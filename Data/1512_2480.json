[ 
    {
        "id": 2480,
        "name": "find-subarrays-with-equal-sum",
        "difficulty": "Easy",
        "link": "https://leetcode.com/problems/find-subarrays-with-equal-sum/",
        "task_description": "Given a **0-indexed** integer array `nums`, determine whether there exist **two** subarrays of length `2` with **equal** sum. Note that the two subarrays must begin at **different** indices. Return `true`_ if these subarrays exist, and _`false`_ otherwise._ A subarray is a contiguous non-empty sequence of elements within an array. **Example 1:** ``` **Input:** nums = [4,2,4] **Output:** true **Explanation:** The subarrays with elements [4,2] and [2,4] have the same sum of 6. ``` **Example 2:** ``` **Input:** nums = [1,2,3,4,5] **Output:** false **Explanation:** No two subarrays of size 2 have the same sum. ``` **Example 3:** ``` **Input:** nums = [0,0,0] **Output:** true **Explanation:** The subarrays [nums[0],nums[1]] and [nums[1],nums[2]] have the same sum of 0. Note that even though the subarrays have the same content, the two subarrays are considered different because they are in different positions in the original array. ``` **Constraints:** `2 <= nums.length <= 1000` `-109 <= nums[i] <= 109`",
        "test_case": [
            {
                "label": "Example 1",
                "input": "nums = [4,2,4]",
                "output": "true Explanation: The subarrays with elements [4,2] and [2,4] have the same sum of 6."
            },
            {
                "label": "Example 2",
                "input": "nums = [1,2,3,4,5]",
                "output": "false Explanation: No two subarrays of size 2 have the same sum."
            },
            {
                "label": "Example 3",
                "input": "nums = [0,0,0]",
                "output": "true Explanation: The subarrays [nums[0],nums[1]] and [nums[1],nums[2]] have the same sum of 0. \nNote that even though the subarrays have the same content, the two subarrays are considered different because they are in different positions in the original array."
            }
        ],
        "elixir_template": "defmodule Solution do\n  @spec find_subarrays(nums :: [integer]) :: boolean\n  def find_subarrays(nums) do\n    \n  end\nend",
        "erlang_template": "-spec find_subarrays(Nums :: [integer()]) -> boolean().\nfind_subarrays(Nums) ->\n  .",
        "scala_template": "object Solution {\n    def findSubarrays(nums: Array[Int]): Boolean = {\n        \n    }\n}"
    },
    {
        "id": 2479,
        "name": "meeting-rooms-iii",
        "difficulty": "Hard",
        "link": "https://leetcode.com/problems/meeting-rooms-iii/",
        "task_description": "You are given an integer `n`. There are `n` rooms numbered from `0` to `n - 1`. You are given a 2D integer array `meetings` where `meetings[i] = [starti, endi]` means that a meeting will be held during the **half-closed** time interval `[starti, endi)`. All the values of `starti` are **unique**. Meetings are allocated to rooms in the following manner: Each meeting will take place in the unused room with the **lowest** number. If there are no available rooms, the meeting will be delayed until a room becomes free. The delayed meeting should have the **same** duration as the original meeting. When a room becomes unused, meetings that have an earlier original **start** time should be given the room. Return_ the **number** of the room that held the most meetings. _If there are multiple rooms, return_ the room with the **lowest** number._ A **half-closed interval** `[a, b)` is the interval between `a` and `b` **including** `a` and **not including** `b`. **Example 1:** ``` **Input:** n = 2, meetings = [[0,10],[1,5],[2,7],[3,4]] **Output:** 0 **Explanation:** - At time 0, both rooms are not being used. The first meeting starts in room 0. - At time 1, only room 1 is not being used. The second meeting starts in room 1. - At time 2, both rooms are being used. The third meeting is delayed. - At time 3, both rooms are being used. The fourth meeting is delayed. - At time 5, the meeting in room 1 finishes. The third meeting starts in room 1 for the time period [5,10). - At time 10, the meetings in both rooms finish. The fourth meeting starts in room 0 for the time period [10,11). Both rooms 0 and 1 held 2 meetings, so we return 0. ``` **Example 2:** ``` **Input:** n = 3, meetings = [[1,20],[2,10],[3,5],[4,9],[6,8]] **Output:** 1 **Explanation:** - At time 1, all three rooms are not being used. The first meeting starts in room 0. - At time 2, rooms 1 and 2 are not being used. The second meeting starts in room 1. - At time 3, only room 2 is not being used. The third meeting starts in room 2. - At time 4, all three rooms are being used. The fourth meeting is delayed. - At time 5, the meeting in room 2 finishes. The fourth meeting starts in room 2 for the time period [5,10). - At time 6, all three rooms are being used. The fifth meeting is delayed. - At time 10, the meetings in rooms 1 and 2 finish. The fifth meeting starts in room 1 for the time period [10,12). Room 0 held 1 meeting while rooms 1 and 2 each held 2 meetings, so we return 1. ``` **Constraints:** `1 <= n <= 100` `1 <= meetings.length <= 105` `meetings[i].length == 2` `0 <= starti < endi <= 5 * 105` All the values of `starti` are **unique**.",
        "test_case": [
            {
                "label": "Example 1",
                "input": "n = 2, meetings = [[0,10],[1,5],[2,7],[3,4]]",
                "output": "0 Explanation: - At time 0, both rooms are not being used. The first meeting starts in room 0.\n- At time 1, only room 1 is not being used. The second meeting starts in room 1.\n- At time 2, both rooms are being used. The third meeting is delayed.\n- At time 3, both rooms are being used. The fourth meeting is delayed.\n- At time 5, the meeting in room 1 finishes. The third meeting starts in room 1 for the time period [5,10).\n- At time 10, the meetings in both rooms finish. The fourth meeting starts in room 0 for the time period [10,11).\nBoth rooms 0 and 1 held 2 meetings, so we return 0."
            },
            {
                "label": "Example 2",
                "input": "n = 3, meetings = [[1,20],[2,10],[3,5],[4,9],[6,8]]",
                "output": "1 Explanation: - At time 1, all three rooms are not being used. The first meeting starts in room 0.\n- At time 2, rooms 1 and 2 are not being used. The second meeting starts in room 1.\n- At time 3, only room 2 is not being used. The third meeting starts in room 2.\n- At time 4, all three rooms are being used. The fourth meeting is delayed.\n- At time 5, the meeting in room 2 finishes. The fourth meeting starts in room 2 for the time period [5,10).\n- At time 6, all three rooms are being used. The fifth meeting is delayed.\n- At time 10, the meetings in rooms 1 and 2 finish. The fifth meeting starts in room 1 for the time period [10,12).\nRoom 0 held 1 meeting while rooms 1 and 2 each held 2 meetings, so we return 1."
            }
        ],
        "elixir_template": "defmodule Solution do\n  @spec most_booked(n :: integer, meetings :: [[integer]]) :: integer\n  def most_booked(n, meetings) do\n    \n  end\nend",
        "erlang_template": "-spec most_booked(N :: integer(), Meetings :: [[integer()]]) -> integer().\nmost_booked(N, Meetings) ->\n  .",
        "scala_template": "object Solution {\n    def mostBooked(n: Int, meetings: Array[Array[Int]]): Int = {\n        \n    }\n}"
    },
    {
        "id": 2478,
        "name": "longest-nice-subarray",
        "difficulty": "Medium",
        "link": "https://leetcode.com/problems/longest-nice-subarray/",
        "task_description": "You are given an array `nums` consisting of **positive** integers. We call a subarray of `nums` **nice** if the bitwise **AND** of every pair of elements that are in **different** positions in the subarray is equal to `0`. Return _the length of the **longest** nice subarray_. A **subarray** is a **contiguous** part of an array. **Note** that subarrays of length `1` are always considered nice. **Example 1:** ``` **Input:** nums = [1,3,8,48,10] **Output:** 3 **Explanation:** The longest nice subarray is [3,8,48]. This subarray satisfies the conditions: - 3 AND 8 = 0. - 3 AND 48 = 0. - 8 AND 48 = 0. It can be proven that no longer nice subarray can be obtained, so we return 3. ``` **Example 2:** ``` **Input:** nums = [3,1,5,11,13] **Output:** 1 **Explanation:** The length of the longest nice subarray is 1. Any subarray of length 1 can be chosen. ``` **Constraints:** `1 <= nums.length <= 105` `1 <= nums[i] <= 109`",
        "test_case": [
            {
                "label": "Example 1",
                "input": "nums = [1,3,8,48,10]",
                "output": "3 Explanation: The longest nice subarray is [3,8,48]. This subarray satisfies the conditions:\n- 3 AND 8 = 0.\n- 3 AND 48 = 0.\n- 8 AND 48 = 0.\nIt can be proven that no longer nice subarray can be obtained, so we return 3."
            },
            {
                "label": "Example 2",
                "input": "nums = [3,1,5,11,13]",
                "output": "1 Explanation: The length of the longest nice subarray is 1. Any subarray of length 1 can be chosen."
            }
        ],
        "elixir_template": "defmodule Solution do\n  @spec longest_nice_subarray(nums :: [integer]) :: integer\n  def longest_nice_subarray(nums) do\n    \n  end\nend",
        "erlang_template": "-spec longest_nice_subarray(Nums :: [integer()]) -> integer().\nlongest_nice_subarray(Nums) ->\n  .",
        "scala_template": "object Solution {\n    def longestNiceSubarray(nums: Array[Int]): Int = {\n        \n    }\n}"
    },
    {
        "id": 2477,
        "name": "number-of-ways-to-reach-a-position-after-exactly-k-steps",
        "difficulty": "Medium",
        "link": "https://leetcode.com/problems/number-of-ways-to-reach-a-position-after-exactly-k-steps/",
        "task_description": "You are given two **positive** integers `startPos` and `endPos`. Initially, you are standing at position `startPos` on an **infinite** number line. With one step, you can move either one position to the left, or one position to the right. Given a positive integer `k`, return _the number of **different** ways to reach the position _`endPos`_ starting from _`startPos`_, such that you perform **exactly** _`k`_ steps_. Since the answer may be very large, return it **modulo** `109 + 7`. Two ways are considered different if the order of the steps made is not exactly the same. **Note** that the number line includes negative integers. **Example 1:** ``` **Input:** startPos = 1, endPos = 2, k = 3 **Output:** 3 **Explanation:** We can reach position 2 from 1 in exactly 3 steps in three ways: - 1 -> 2 -> 3 -> 2. - 1 -> 2 -> 1 -> 2. - 1 -> 0 -> 1 -> 2. It can be proven that no other way is possible, so we return 3. ``` **Example 2:** ``` **Input:** startPos = 2, endPos = 5, k = 10 **Output:** 0 **Explanation:** It is impossible to reach position 5 from position 2 in exactly 10 steps. ``` **Constraints:** `1 <= startPos, endPos, k <= 1000`",
        "test_case": [
            {
                "label": "Example 1",
                "input": "startPos = 1, endPos = 2, k = 3",
                "output": "3 Explanation: We can reach position 2 from 1 in exactly 3 steps in three ways:\n- 1 -> 2 -> 3 -> 2.\n- 1 -> 2 -> 1 -> 2.\n- 1 -> 0 -> 1 -> 2.\nIt can be proven that no other way is possible, so we return 3."
            },
            {
                "label": "Example 2",
                "input": "startPos = 2, endPos = 5, k = 10",
                "output": "0 Explanation: It is impossible to reach position 5 from position 2 in exactly 10 steps."
            }
        ],
        "elixir_template": "defmodule Solution do\n  @spec number_of_ways(start_pos :: integer, end_pos :: integer, k :: integer) :: integer\n  def number_of_ways(start_pos, end_pos, k) do\n    \n  end\nend",
        "erlang_template": "-spec number_of_ways(StartPos :: integer(), EndPos :: integer(), K :: integer()) -> integer().\nnumber_of_ways(StartPos, EndPos, K) ->\n  .",
        "scala_template": "object Solution {\n    def numberOfWays(startPos: Int, endPos: Int, k: Int): Int = {\n        \n    }\n}"
    },
    {
        "id": 2476,
        "name": "check-distances-between-same-letters",
        "difficulty": "Easy",
        "link": "https://leetcode.com/problems/check-distances-between-same-letters/",
        "task_description": "You are given a **0-indexed** string `s` consisting of only lowercase English letters, where each letter in `s` appears **exactly** **twice**. You are also given a **0-indexed** integer array `distance` of length `26`. Each letter in the alphabet is numbered from `0` to `25` (i.e. `'a' -> 0`, `'b' -> 1`, `'c' -> 2`, ... , `'z' -> 25`). In a **well-spaced** string, the number of letters between the two occurrences of the `ith` letter is `distance[i]`. If the `ith` letter does not appear in `s`, then `distance[i]` can be **ignored**. Return `true`_ if _`s`_ is a **well-spaced** string, otherwise return _`false`. **Example 1:** ``` **Input:** s = \"abaccb\", distance = [1,3,0,5,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0] **Output:** true **Explanation:** - 'a' appears at indices 0 and 2 so it satisfies distance[0] = 1. - 'b' appears at indices 1 and 5 so it satisfies distance[1] = 3. - 'c' appears at indices 3 and 4 so it satisfies distance[2] = 0. Note that distance[3] = 5, but since 'd' does not appear in s, it can be ignored. Return true because s is a well-spaced string. ``` **Example 2:** ``` **Input:** s = \"aa\", distance = [1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0] **Output:** false **Explanation:** - 'a' appears at indices 0 and 1 so there are zero letters between them. Because distance[0] = 1, s is not a well-spaced string. ``` **Constraints:** `2 <= s.length <= 52` `s` consists only of lowercase English letters. Each letter appears in `s` exactly twice. `distance.length == 26` `0 <= distance[i] <= 50`",
        "test_case": [
            {
                "label": "Example 1",
                "input": "s = \"abaccb\", distance = [1,3,0,5,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]",
                "output": "true Explanation: - 'a' appears at indices 0 and 2 so it satisfies distance[0] = 1.\n- 'b' appears at indices 1 and 5 so it satisfies distance[1] = 3.\n- 'c' appears at indices 3 and 4 so it satisfies distance[2] = 0.\nNote that distance[3] = 5, but since 'd' does not appear in s, it can be ignored.\nReturn true because s is a well-spaced string."
            },
            {
                "label": "Example 2",
                "input": "s = \"aa\", distance = [1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]",
                "output": "false Explanation: - 'a' appears at indices 0 and 1 so there are zero letters between them.\nBecause distance[0] = 1, s is not a well-spaced string."
            }
        ],
        "elixir_template": "defmodule Solution do\n  @spec check_distances(s :: String.t, distance :: [integer]) :: boolean\n  def check_distances(s, distance) do\n    \n  end\nend",
        "erlang_template": "-spec check_distances(S :: unicode:unicode_binary(), Distance :: [integer()]) -> boolean().\ncheck_distances(S, Distance) ->\n  .",
        "scala_template": "object Solution {\n    def checkDistances(s: String, distance: Array[Int]): Boolean = {\n        \n    }\n}"
    },
    {
        "id": 2475,
        "name": "largest-palindromic-number",
        "difficulty": "Medium",
        "link": "https://leetcode.com/problems/largest-palindromic-number/",
        "task_description": "You are given a string `num` consisting of digits only. Return _the **largest palindromic** integer (in the form of a string) that can be formed using digits taken from _`num`. It should not contain **leading zeroes**. **Notes:** You do **not** need to use all the digits of `num`, but you must use **at least** one digit. The digits can be reordered. **Example 1:** ``` **Input:** num = \"444947137\" **Output:** \"7449447\" **Explanation:** Use the digits \"4449477\" from \"**44494****7**13**7**\" to form the palindromic integer \"7449447\". It can be shown that \"7449447\" is the largest palindromic integer that can be formed. ``` **Example 2:** ``` **Input:** num = \"00009\" **Output:** \"9\" **Explanation:** It can be shown that \"9\" is the largest palindromic integer that can be formed. Note that the integer returned should not contain leading zeroes. ``` **Constraints:** `1 <= num.length <= 105` `num` consists of digits.",
        "test_case": [
            {
                "label": "Example 1",
                "input": "num = \"444947137\"",
                "output": "\"7449447\" Explanation: Use the digits \"4449477\" from \" 44494 7 13 7 \" to form the palindromic integer \"7449447\".\nIt can be shown that \"7449447\" is the largest palindromic integer that can be formed."
            },
            {
                "label": "Example 2",
                "input": "num = \"00009\"",
                "output": "\"9\" Explanation: It can be shown that \"9\" is the largest palindromic integer that can be formed.\nNote that the integer returned should not contain leading zeroes."
            }
        ],
        "elixir_template": "defmodule Solution do\n  @spec largest_palindromic(num :: String.t) :: String.t\n  def largest_palindromic(num) do\n    \n  end\nend",
        "erlang_template": "-spec largest_palindromic(Num :: unicode:unicode_binary()) -> unicode:unicode_binary().\nlargest_palindromic(Num) ->\n  .",
        "scala_template": "object Solution {\n    def largestPalindromic(num: String): String = {\n        \n    }\n}"
    },
    {
        "id": 2473,
        "name": "max-sum-of-a-pair-with-equal-sum-of-digits",
        "difficulty": "Medium",
        "link": "https://leetcode.com/problems/max-sum-of-a-pair-with-equal-sum-of-digits/",
        "task_description": "You are given a **0-indexed** array `nums` consisting of **positive** integers. You can choose two indices `i` and `j`, such that `i != j`, and the sum of digits of the number `nums[i]` is equal to that of `nums[j]`. Return _the **maximum** value of _`nums[i] + nums[j]`_ that you can obtain over all possible indices _`i`_ and _`j`_ that satisfy the conditions._ **Example 1:** ``` **Input:** nums = [18,43,36,13,7] **Output:** 54 **Explanation:** The pairs (i, j) that satisfy the conditions are: - (0, 2), both numbers have a sum of digits equal to 9, and their sum is 18 + 36 = 54. - (1, 4), both numbers have a sum of digits equal to 7, and their sum is 43 + 7 = 50. So the maximum sum that we can obtain is 54. ``` **Example 2:** ``` **Input:** nums = [10,12,19,14] **Output:** -1 **Explanation:** There are no two numbers that satisfy the conditions, so we return -1. ``` **Constraints:** `1 <= nums.length <= 105` `1 <= nums[i] <= 109`",
        "test_case": [
            {
                "label": "Example 1",
                "input": "nums = [18,43,36,13,7]",
                "output": "54 Explanation: The pairs (i, j) that satisfy the conditions are:\n- (0, 2), both numbers have a sum of digits equal to 9, and their sum is 18 + 36 = 54.\n- (1, 4), both numbers have a sum of digits equal to 7, and their sum is 43 + 7 = 50.\nSo the maximum sum that we can obtain is 54."
            },
            {
                "label": "Example 2",
                "input": "nums = [10,12,19,14]",
                "output": "-1 Explanation: There are no two numbers that satisfy the conditions, so we return -1."
            }
        ],
        "elixir_template": "defmodule Solution do\n  @spec maximum_sum(nums :: [integer]) :: integer\n  def maximum_sum(nums) do\n    \n  end\nend",
        "erlang_template": "-spec maximum_sum(Nums :: [integer()]) -> integer().\nmaximum_sum(Nums) ->\n  .",
        "scala_template": "object Solution {\n    def maximumSum(nums: Array[Int]): Int = {\n        \n    }\n}"
    },
    {
        "id": 2472,
        "name": "build-a-matrix-with-conditions",
        "difficulty": "Hard",
        "link": "https://leetcode.com/problems/build-a-matrix-with-conditions/",
        "task_description": "You are given a **positive** integer `k`. You are also given: a 2D integer array `rowConditions` of size `n` where `rowConditions[i] = [abovei, belowi]`, and a 2D integer array `colConditions` of size `m` where `colConditions[i] = [lefti, righti]`. The two arrays contain integers from `1` to `k`. You have to build a `k x k` matrix that contains each of the numbers from `1` to `k` **exactly once**. The remaining cells should have the value `0`. The matrix should also satisfy the following conditions: The number `abovei` should appear in a **row** that is strictly **above** the row at which the number `belowi` appears for all `i` from `0` to `n - 1`. The number `lefti` should appear in a **column** that is strictly **left** of the column at which the number `righti` appears for all `i` from `0` to `m - 1`. Return _**any** matrix that satisfies the conditions_. If no answer exists, return an empty matrix. **Example 1:** ``` **Input:** k = 3, rowConditions = [[1,2],[3,2]], colConditions = [[2,1],[3,2]] **Output:** [[3,0,0],[0,0,1],[0,2,0]] **Explanation:** The diagram above shows a valid example of a matrix that satisfies all the conditions. The row conditions are the following: - Number 1 is in row 1, and number 2 is in row 2, so 1 is above 2 in the matrix. - Number 3 is in row 0, and number 2 is in row 2, so 3 is above 2 in the matrix. The column conditions are the following: - Number 2 is in column 1, and number 1 is in column 2, so 2 is left of 1 in the matrix. - Number 3 is in column 0, and number 2 is in column 1, so 3 is left of 2 in the matrix. Note that there may be multiple correct answers. ``` **Example 2:** ``` **Input:** k = 3, rowConditions = [[1,2],[2,3],[3,1],[2,3]], colConditions = [[2,1]] **Output:** [] **Explanation:** From the first two conditions, 3 has to be below 1 but the third conditions needs 3 to be above 1 to be satisfied. No matrix can satisfy all the conditions, so we return the empty matrix. ``` **Constraints:** `2 <= k <= 400` `1 <= rowConditions.length, colConditions.length <= 104` `rowConditions[i].length == colConditions[i].length == 2` `1 <= abovei, belowi, lefti, righti <= k` `abovei != belowi` `lefti != righti`",
        "test_case": [
            {
                "label": "Example 1",
                "input": "k = 3, rowConditions = [[1,2],[3,2]], colConditions = [[2,1],[3,2]]",
                "output": "[[3,0,0],[0,0,1],[0,2,0]] Explanation: The diagram above shows a valid example of a matrix that satisfies all the conditions.\nThe row conditions are the following:\n- Number 1 is in row 1 , and number 2 is in row 2 , so 1 is above 2 in the matrix.\n- Number 3 is in row 0 , and number 2 is in row 2 , so 3 is above 2 in the matrix.\nThe column conditions are the following:\n- Number 2 is in column 1 , and number 1 is in column 2 , so 2 is left of 1 in the matrix.\n- Number 3 is in column 0 , and number 2 is in column 1 , so 3 is left of 2 in the matrix.\nNote that there may be multiple correct answers."
            },
            {
                "label": "Example 2",
                "input": "k = 3, rowConditions = [[1,2],[2,3],[3,1],[2,3]], colConditions = [[2,1]]",
                "output": "[] Explanation: From the first two conditions, 3 has to be below 1 but the third conditions needs 3 to be above 1 to be satisfied.\nNo matrix can satisfy all the conditions, so we return the empty matrix."
            }
        ],
        "elixir_template": "defmodule Solution do\n  @spec build_matrix(k :: integer, row_conditions :: [[integer]], col_conditions :: [[integer]]) :: [[integer]]\n  def build_matrix(k, row_conditions, col_conditions) do\n    \n  end\nend",
        "erlang_template": "-spec build_matrix(K :: integer(), RowConditions :: [[integer()]], ColConditions :: [[integer()]]) -> [[integer()]].\nbuild_matrix(K, RowConditions, ColConditions) ->\n  .",
        "scala_template": "object Solution {\n    def buildMatrix(k: Int, rowConditions: Array[Array[Int]], colConditions: Array[Array[Int]]): Array[Array[Int]] = {\n        \n    }\n}"
    },
    {
        "id": 2471,
        "name": "minimum-amount-of-time-to-collect-garbage",
        "difficulty": "Medium",
        "link": "https://leetcode.com/problems/minimum-amount-of-time-to-collect-garbage/",
        "task_description": "You are given a **0-indexed** array of strings `garbage` where `garbage[i]` represents the assortment of garbage at the `ith` house. `garbage[i]` consists only of the characters `'M'`, `'P'` and `'G'` representing one unit of metal, paper and glass garbage respectively. Picking up **one** unit of any type of garbage takes `1` minute. You are also given a **0-indexed** integer array `travel` where `travel[i]` is the number of minutes needed to go from house `i` to house `i + 1`. There are three garbage trucks in the city, each responsible for picking up one type of garbage. Each garbage truck starts at house `0` and must visit each house **in order**; however, they do **not** need to visit every house. Only **one** garbage truck may be used at any given moment. While one truck is driving or picking up garbage, the other two trucks **cannot** do anything. Return_ the **minimum** number of minutes needed to pick up all the garbage._ **Example 1:** ``` **Input:** garbage = [\"G\",\"P\",\"GP\",\"GG\"], travel = [2,4,3] **Output:** 21 **Explanation:** The paper garbage truck: 1. Travels from house 0 to house 1 2. Collects the paper garbage at house 1 3. Travels from house 1 to house 2 4. Collects the paper garbage at house 2 Altogether, it takes 8 minutes to pick up all the paper garbage. The glass garbage truck: 1. Collects the glass garbage at house 0 2. Travels from house 0 to house 1 3. Travels from house 1 to house 2 4. Collects the glass garbage at house 2 5. Travels from house 2 to house 3 6. Collects the glass garbage at house 3 Altogether, it takes 13 minutes to pick up all the glass garbage. Since there is no metal garbage, we do not need to consider the metal garbage truck. Therefore, it takes a total of 8 + 13 = 21 minutes to collect all the garbage. ``` **Example 2:** ``` **Input:** garbage = [\"MMM\",\"PGM\",\"GP\"], travel = [3,10] **Output:** 37 **Explanation:** The metal garbage truck takes 7 minutes to pick up all the metal garbage. The paper garbage truck takes 15 minutes to pick up all the paper garbage. The glass garbage truck takes 15 minutes to pick up all the glass garbage. It takes a total of 7 + 15 + 15 = 37 minutes to collect all the garbage. ``` **Constraints:** `2 <= garbage.length <= 105` `garbage[i]` consists of only the letters `'M'`, `'P'`, and `'G'`. `1 <= garbage[i].length <= 10` `travel.length == garbage.length - 1` `1 <= travel[i] <= 100`",
        "test_case": [
            {
                "label": "Example 1",
                "input": "garbage = [\"G\",\"P\",\"GP\",\"GG\"], travel = [2,4,3]",
                "output": "21 Explanation: The paper garbage truck:\n1. Travels from house 0 to house 1\n2. Collects the paper garbage at house 1\n3. Travels from house 1 to house 2\n4. Collects the paper garbage at house 2\nAltogether, it takes 8 minutes to pick up all the paper garbage.\nThe glass garbage truck:\n1. Collects the glass garbage at house 0\n2. Travels from house 0 to house 1\n3. Travels from house 1 to house 2\n4. Collects the glass garbage at house 2\n5. Travels from house 2 to house 3\n6. Collects the glass garbage at house 3\nAltogether, it takes 13 minutes to pick up all the glass garbage.\nSince there is no metal garbage, we do not need to consider the metal garbage truck.\nTherefore, it takes a total of 8 + 13 = 21 minutes to collect all the garbage."
            },
            {
                "label": "Example 2",
                "input": "garbage = [\"MMM\",\"PGM\",\"GP\"], travel = [3,10]",
                "output": "37 Explanation: The metal garbage truck takes 7 minutes to pick up all the metal garbage.\nThe paper garbage truck takes 15 minutes to pick up all the paper garbage.\nThe glass garbage truck takes 15 minutes to pick up all the glass garbage.\nIt takes a total of 7 + 15 + 15 = 37 minutes to collect all the garbage."
            }
        ],
        "elixir_template": "defmodule Solution do\n  @spec garbage_collection(garbage :: [String.t], travel :: [integer]) :: integer\n  def garbage_collection(garbage, travel) do\n    \n  end\nend",
        "erlang_template": "-spec garbage_collection(Garbage :: [unicode:unicode_binary()], Travel :: [integer()]) -> integer().\ngarbage_collection(Garbage, Travel) ->\n  .",
        "scala_template": "object Solution {\n    def garbageCollection(garbage: Array[String], travel: Array[Int]): Int = {\n        \n    }\n}"
    },
    {
        "id": 2470,
        "name": "removing-stars-from-a-string",
        "difficulty": "Medium",
        "link": "https://leetcode.com/problems/removing-stars-from-a-string/",
        "task_description": "You are given a string `s`, which contains stars `*`. In one operation, you can: Choose a star in `s`. Remove the closest **non-star** character to its **left**, as well as remove the star itself. Return _the string after **all** stars have been removed_. **Note:** The input will be generated such that the operation is always possible. It can be shown that the resulting string will always be unique. **Example 1:** ``` **Input:** s = \"leet**cod*e\" **Output:** \"lecoe\" **Explanation:** Performing the removals from left to right: - The closest character to the 1st star is 't' in \"lee**t****cod*e\". s becomes \"lee*cod*e\". - The closest character to the 2nd star is 'e' in \"le**e***cod*e\". s becomes \"lecod*e\". - The closest character to the 3rd star is 'd' in \"leco**d***e\". s becomes \"lecoe\". There are no more stars, so we return \"lecoe\". ``` **Example 2:** ``` **Input:** s = \"erase*****\" **Output:** \"\" **Explanation:** The entire string is removed, so we return an empty string. ``` **Constraints:** `1 <= s.length <= 105` `s` consists of lowercase English letters and stars `*`. The operation above can be performed on `s`.",
        "test_case": [
            {
                "label": "Example 1",
                "input": "s = \"leet**cod*e\"",
                "output": "\"lecoe\" Explanation: Performing the removals from left to right:\n- The closest character to the 1 st star is 't' in \"lee t **cod*e\". s becomes \"lee*cod*e\".\n- The closest character to the 2 nd star is 'e' in \"le e *cod*e\". s becomes \"lecod*e\".\n- The closest character to the 3 rd star is 'd' in \"leco d *e\". s becomes \"lecoe\".\nThere are no more stars, so we return \"lecoe\"."
            },
            {
                "label": "Example 2",
                "input": "s = \"erase*****\"",
                "output": "\"\" Explanation: The entire string is removed, so we return an empty string."
            }
        ],
        "elixir_template": "defmodule Solution do\n  @spec remove_stars(s :: String.t) :: String.t\n  def remove_stars(s) do\n    \n  end\nend",
        "erlang_template": "-spec remove_stars(S :: unicode:unicode_binary()) -> unicode:unicode_binary().\nremove_stars(S) ->\n  .",
        "scala_template": "object Solution {\n    def removeStars(s: String): String = {\n        \n    }\n}"
    },
    {
        "id": 2469,
        "name": "longest-subsequence-with-limited-sum",
        "difficulty": "Easy",
        "link": "https://leetcode.com/problems/longest-subsequence-with-limited-sum/",
        "task_description": "You are given an integer array `nums` of length `n`, and an integer array `queries` of length `m`. Return _an array _`answer`_ of length _`m`_ where _`answer[i]`_ is the **maximum** size of a **subsequence** that you can take from _`nums`_ such that the **sum** of its elements is less than or equal to _`queries[i]`. A **subsequence** is an array that can be derived from another array by deleting some or no elements without changing the order of the remaining elements. **Example 1:** ``` **Input:** nums = [4,5,2,1], queries = [3,10,21] **Output:** [2,3,4] **Explanation:** We answer the queries as follows: - The subsequence [2,1] has a sum less than or equal to 3. It can be proven that 2 is the maximum size of such a subsequence, so answer[0] = 2. - The subsequence [4,5,1] has a sum less than or equal to 10. It can be proven that 3 is the maximum size of such a subsequence, so answer[1] = 3. - The subsequence [4,5,2,1] has a sum less than or equal to 21. It can be proven that 4 is the maximum size of such a subsequence, so answer[2] = 4. ``` **Example 2:** ``` **Input:** nums = [2,3,4,5], queries = [1] **Output:** [0] **Explanation:** The empty subsequence is the only subsequence that has a sum less than or equal to 1, so answer[0] = 0. ``` **Constraints:** `n == nums.length` `m == queries.length` `1 <= n, m <= 1000` `1 <= nums[i], queries[i] <= 106`",
        "test_case": [
            {
                "label": "Example 1",
                "input": "nums = [4,5,2,1], queries = [3,10,21]",
                "output": "[2,3,4] Explanation: We answer the queries as follows:\n- The subsequence [2,1] has a sum less than or equal to 3. It can be proven that 2 is the maximum size of such a subsequence, so answer[0] = 2.\n- The subsequence [4,5,1] has a sum less than or equal to 10. It can be proven that 3 is the maximum size of such a subsequence, so answer[1] = 3.\n- The subsequence [4,5,2,1] has a sum less than or equal to 21. It can be proven that 4 is the maximum size of such a subsequence, so answer[2] = 4."
            },
            {
                "label": "Example 2",
                "input": "nums = [2,3,4,5], queries = [1]",
                "output": "[0] Explanation: The empty subsequence is the only subsequence that has a sum less than or equal to 1, so answer[0] = 0. Constraints: n == nums.length m == queries.length 1 <= n, m <= 1000 1 <= nums[i], queries[i] <= 10 6"
            }
        ],
        "elixir_template": "defmodule Solution do\n  @spec answer_queries(nums :: [integer], queries :: [integer]) :: [integer]\n  def answer_queries(nums, queries) do\n    \n  end\nend",
        "erlang_template": "-spec answer_queries(Nums :: [integer()], Queries :: [integer()]) -> [integer()].\nanswer_queries(Nums, Queries) ->\n  .",
        "scala_template": "object Solution {\n    def answerQueries(nums: Array[Int], queries: Array[Int]): Array[Int] = {\n        \n    }\n}"
    },
    {
        "id": 2466,
        "name": "maximum-segment-sum-after-removals",
        "difficulty": "Hard",
        "link": "https://leetcode.com/problems/maximum-segment-sum-after-removals/",
        "task_description": "You are given two **0-indexed** integer arrays `nums` and `removeQueries`, both of length `n`. For the `ith` query, the element in `nums` at the index `removeQueries[i]` is removed, splitting `nums` into different segments. A **segment** is a contiguous sequence of **positive** integers in `nums`. A **segment sum** is the sum of every element in a segment. Return_ an integer array _`answer`_, of length _`n`_, where _`answer[i]`_ is the **maximum** segment sum after applying the _`ith` _removal._ **Note:** The same index will **not** be removed more than once. **Example 1:** ``` **Input:** nums = [1,2,5,6,1], removeQueries = [0,3,2,4,1] **Output:** [14,7,2,2,0] **Explanation:** Using 0 to indicate a removed element, the answer is as follows: Query 1: Remove the 0th element, nums becomes [0,2,5,6,1] and the maximum segment sum is 14 for segment [2,5,6,1]. Query 2: Remove the 3rd element, nums becomes [0,2,5,0,1] and the maximum segment sum is 7 for segment [2,5]. Query 3: Remove the 2nd element, nums becomes [0,2,0,0,1] and the maximum segment sum is 2 for segment [2]. Query 4: Remove the 4th element, nums becomes [0,2,0,0,0] and the maximum segment sum is 2 for segment [2]. Query 5: Remove the 1st element, nums becomes [0,0,0,0,0] and the maximum segment sum is 0, since there are no segments. Finally, we return [14,7,2,2,0]. ``` **Example 2:** ``` **Input:** nums = [3,2,11,1], removeQueries = [3,2,1,0] **Output:** [16,5,3,0] **Explanation:** Using 0 to indicate a removed element, the answer is as follows: Query 1: Remove the 3rd element, nums becomes [3,2,11,0] and the maximum segment sum is 16 for segment [3,2,11]. Query 2: Remove the 2nd element, nums becomes [3,2,0,0] and the maximum segment sum is 5 for segment [3,2]. Query 3: Remove the 1st element, nums becomes [3,0,0,0] and the maximum segment sum is 3 for segment [3]. Query 4: Remove the 0th element, nums becomes [0,0,0,0] and the maximum segment sum is 0, since there are no segments. Finally, we return [16,5,3,0]. ``` **Constraints:** `n == nums.length == removeQueries.length` `1 <= n <= 105` `1 <= nums[i] <= 109` `0 <= removeQueries[i] < n` All the values of `removeQueries` are **unique**.",
        "test_case": [
            {
                "label": "Example 1",
                "input": "nums = [1,2,5,6,1], removeQueries = [0,3,2,4,1]",
                "output": "[14,7,2,2,0] Explanation: Using 0 to indicate a removed element, the answer is as follows:\nQuery 1: Remove the 0th element, nums becomes [0,2,5,6,1] and the maximum segment sum is 14 for segment [2,5,6,1].\nQuery 2: Remove the 3rd element, nums becomes [0,2,5,0,1] and the maximum segment sum is 7 for segment [2,5].\nQuery 3: Remove the 2nd element, nums becomes [0,2,0,0,1] and the maximum segment sum is 2 for segment [2]. \nQuery 4: Remove the 4th element, nums becomes [0,2,0,0,0] and the maximum segment sum is 2 for segment [2]. \nQuery 5: Remove the 1st element, nums becomes [0,0,0,0,0] and the maximum segment sum is 0, since there are no segments.\nFinally, we return [14,7,2,2,0]."
            },
            {
                "label": "Example 2",
                "input": "nums = [3,2,11,1], removeQueries = [3,2,1,0]",
                "output": "[16,5,3,0] Explanation: Using 0 to indicate a removed element, the answer is as follows:\nQuery 1: Remove the 3rd element, nums becomes [3,2,11,0] and the maximum segment sum is 16 for segment [3,2,11].\nQuery 2: Remove the 2nd element, nums becomes [3,2,0,0] and the maximum segment sum is 5 for segment [3,2].\nQuery 3: Remove the 1st element, nums becomes [3,0,0,0] and the maximum segment sum is 3 for segment [3].\nQuery 4: Remove the 0th element, nums becomes [0,0,0,0] and the maximum segment sum is 0, since there are no segments.\nFinally, we return [16,5,3,0]. Constraints: n == nums.length == removeQueries.length 1 <= n <= 10 5 1 <= nums[i] <= 10 9 0 <= removeQueries[i] < n All the values of removeQueries are unique ."
            }
        ],
        "elixir_template": "defmodule Solution do\n  @spec maximum_segment_sum(nums :: [integer], remove_queries :: [integer]) :: [integer]\n  def maximum_segment_sum(nums, remove_queries) do\n    \n  end\nend",
        "erlang_template": "-spec maximum_segment_sum(Nums :: [integer()], RemoveQueries :: [integer()]) -> [integer()].\nmaximum_segment_sum(Nums, RemoveQueries) ->\n  .",
        "scala_template": "object Solution {\n    def maximumSegmentSum(nums: Array[Int], removeQueries: Array[Int]): Array[Long] = {\n        \n    }\n}"
    },
    {
        "id": 2465,
        "name": "shifting-letters-ii",
        "difficulty": "Medium",
        "link": "https://leetcode.com/problems/shifting-letters-ii/",
        "task_description": "You are given a string `s` of lowercase English letters and a 2D integer array `shifts` where `shifts[i] = [starti, endi, directioni]`. For every `i`, **shift** the characters in `s` from the index `starti` to the index `endi` (**inclusive**) forward if `directioni = 1`, or shift the characters backward if `directioni = 0`. Shifting a character **forward** means replacing it with the **next** letter in the alphabet (wrapping around so that `'z'` becomes `'a'`). Similarly, shifting a character **backward** means replacing it with the **previous** letter in the alphabet (wrapping around so that `'a'` becomes `'z'`). Return _the final string after all such shifts to _`s`_ are applied_. **Example 1:** ``` **Input:** s = \"abc\", shifts = [[0,1,0],[1,2,1],[0,2,1]] **Output:** \"ace\" **Explanation:** Firstly, shift the characters from index 0 to index 1 backward. Now s = \"zac\". Secondly, shift the characters from index 1 to index 2 forward. Now s = \"zbd\". Finally, shift the characters from index 0 to index 2 forward. Now s = \"ace\". ``` **Example 2:** ``` **Input:** s = \"dztz\", shifts = [[0,0,0],[1,1,1]] **Output:** \"catz\" **Explanation:** Firstly, shift the characters from index 0 to index 0 backward. Now s = \"cztz\". Finally, shift the characters from index 1 to index 1 forward. Now s = \"catz\". ``` **Constraints:** `1 <= s.length, shifts.length <= 5 * 104` `shifts[i].length == 3` `0 <= starti <= endi < s.length` `0 <= directioni <= 1` `s` consists of lowercase English letters.",
        "test_case": [
            {
                "label": "Example 1",
                "input": "s = \"abc\", shifts = [[0,1,0],[1,2,1],[0,2,1]]",
                "output": "\"ace\" Explanation: Firstly, shift the characters from index 0 to index 1 backward. Now s = \"zac\".\nSecondly, shift the characters from index 1 to index 2 forward. Now s = \"zbd\".\nFinally, shift the characters from index 0 to index 2 forward. Now s = \"ace\"."
            },
            {
                "label": "Example 2",
                "input": "s = \"dztz\", shifts = [[0,0,0],[1,1,1]]",
                "output": "\"catz\" Explanation: Firstly, shift the characters from index 0 to index 0 backward. Now s = \"cztz\".\nFinally, shift the characters from index 1 to index 1 forward. Now s = \"catz\"."
            }
        ],
        "elixir_template": "defmodule Solution do\n  @spec shifting_letters(s :: String.t, shifts :: [[integer]]) :: String.t\n  def shifting_letters(s, shifts) do\n    \n  end\nend",
        "erlang_template": "-spec shifting_letters(S :: unicode:unicode_binary(), Shifts :: [[integer()]]) -> unicode:unicode_binary().\nshifting_letters(S, Shifts) ->\n  .",
        "scala_template": "object Solution {\n    def shiftingLetters(s: String, shifts: Array[Array[Int]]): String = {\n        \n    }\n}"
    },
    {
        "id": 2464,
        "name": "time-needed-to-rearrange-a-binary-string",
        "difficulty": "Medium",
        "link": "https://leetcode.com/problems/time-needed-to-rearrange-a-binary-string/",
        "task_description": "You are given a binary string `s`. In one second, **all** occurrences of `\"01\"` are **simultaneously** replaced with `\"10\"`. This process **repeats** until no occurrences of `\"01\"` exist. Return_ the number of seconds needed to complete this process._ **Example 1:** ``` **Input:** s = \"0110101\" **Output:** 4 **Explanation:** After one second, s becomes \"1011010\". After another second, s becomes \"1101100\". After the third second, s becomes \"1110100\". After the fourth second, s becomes \"1111000\". No occurrence of \"01\" exists any longer, and the process needed 4 seconds to complete, so we return 4. ``` **Example 2:** ``` **Input:** s = \"11100\" **Output:** 0 **Explanation:** No occurrence of \"01\" exists in s, and the processes needed 0 seconds to complete, so we return 0. ``` **Constraints:** `1 <= s.length <= 1000` `s[i]` is either `'0'` or `'1'`. **Follow up:** Can you solve this problem in O(n) time complexity?",
        "test_case": [
            {
                "label": "Example 1",
                "input": "s = \"0110101\"",
                "output": "4 Explanation: After one second, s becomes \"1011010\".\nAfter another second, s becomes \"1101100\".\nAfter the third second, s becomes \"1110100\".\nAfter the fourth second, s becomes \"1111000\".\nNo occurrence of \"01\" exists any longer, and the process needed 4 seconds to complete,\nso we return 4."
            },
            {
                "label": "Example 2",
                "input": "s = \"11100\"",
                "output": "0 Explanation: No occurrence of \"01\" exists in s, and the processes needed 0 seconds to complete,\nso we return 0."
            }
        ],
        "elixir_template": "defmodule Solution do\n  @spec seconds_to_remove_occurrences(s :: String.t) :: integer\n  def seconds_to_remove_occurrences(s) do\n    \n  end\nend",
        "erlang_template": "-spec seconds_to_remove_occurrences(S :: unicode:unicode_binary()) -> integer().\nseconds_to_remove_occurrences(S) ->\n  .",
        "scala_template": "object Solution {\n    def secondsToRemoveOccurrences(s: String): Int = {\n        \n    }\n}"
    },
    {
        "id": 2463,
        "name": "minimum-recolors-to-get-k-consecutive-black-blocks",
        "difficulty": "Easy",
        "link": "https://leetcode.com/problems/minimum-recolors-to-get-k-consecutive-black-blocks/",
        "task_description": "You are given a **0-indexed** string `blocks` of length `n`, where `blocks[i]` is either `'W'` or `'B'`, representing the color of the `ith` block. The characters `'W'` and `'B'` denote the colors white and black, respectively. You are also given an integer `k`, which is the desired number of **consecutive** black blocks. In one operation, you can **recolor** a white block such that it becomes a black block. Return_ the **minimum** number of operations needed such that there is at least **one** occurrence of _`k`_ consecutive black blocks._ **Example 1:** ``` **Input:** blocks = \"WBBWWBBWBW\", k = 7 **Output:** 3 **Explanation:** One way to achieve 7 consecutive black blocks is to recolor the 0th, 3rd, and 4th blocks so that blocks = \"BBBBBBBWBW\". It can be shown that there is no way to achieve 7 consecutive black blocks in less than 3 operations. Therefore, we return 3. ``` **Example 2:** ``` **Input:** blocks = \"WBWBBBW\", k = 2 **Output:** 0 **Explanation:** No changes need to be made, since 2 consecutive black blocks already exist. Therefore, we return 0. ``` **Constraints:** `n == blocks.length` `1 <= n <= 100` `blocks[i]` is either `'W'` or `'B'`. `1 <= k <= n`",
        "test_case": [
            {
                "label": "Example 1",
                "input": "blocks = \"WBBWWBBWBW\", k = 7",
                "output": "3 Explanation: One way to achieve 7 consecutive black blocks is to recolor the 0th, 3rd, and 4th blocks\nso that blocks = \"BBBBBBBWBW\". \nIt can be shown that there is no way to achieve 7 consecutive black blocks in less than 3 operations.\nTherefore, we return 3."
            },
            {
                "label": "Example 2",
                "input": "blocks = \"WBWBBBW\", k = 2",
                "output": "0 Explanation: No changes need to be made, since 2 consecutive black blocks already exist.\nTherefore, we return 0. Constraints: n == blocks.length 1 <= n <= 100 blocks[i] is either 'W' or 'B' . 1 <= k <= n"
            }
        ],
        "elixir_template": "defmodule Solution do\n  @spec minimum_recolors(blocks :: String.t, k :: integer) :: integer\n  def minimum_recolors(blocks, k) do\n    \n  end\nend",
        "erlang_template": "-spec minimum_recolors(Blocks :: unicode:unicode_binary(), K :: integer()) -> integer().\nminimum_recolors(Blocks, K) ->\n  .",
        "scala_template": "object Solution {\n    def minimumRecolors(blocks: String, k: Int): Int = {\n        \n    }\n}"
    },
    {
        "id": 2462,
        "name": "find-the-k-sum-of-an-array",
        "difficulty": "Hard",
        "link": "https://leetcode.com/problems/find-the-k-sum-of-an-array/",
        "task_description": "You are given an integer array `nums` and a **positive** integer `k`. You can choose any **subsequence** of the array and sum all of its elements together. We define the **K-Sum** of the array as the `kth` **largest** subsequence sum that can be obtained (**not** necessarily distinct). Return _the K-Sum of the array_. A **subsequence** is an array that can be derived from another array by deleting some or no elements without changing the order of the remaining elements. **Note** that the empty subsequence is considered to have a sum of `0`. **Example 1:** ``` **Input:** nums = [2,4,-2], k = 5 **Output:** 2 **Explanation:** All the possible subsequence sums that we can obtain are the following sorted in decreasing order: - 6, 4, 4, 2, 2, 0, 0, -2. The 5-Sum of the array is 2. ``` **Example 2:** ``` **Input:** nums = [1,-2,3,4,-10,12], k = 16 **Output:** 10 **Explanation:** The 16-Sum of the array is 10. ``` **Constraints:** `n == nums.length` `1 <= n <= 105` `-109 <= nums[i] <= 109` `1 <= k <= min(2000, 2n)`",
        "test_case": [
            {
                "label": "Example 1",
                "input": "nums = [2,4,-2], k = 5",
                "output": "2 Explanation: All the possible subsequence sums that we can obtain are the following sorted in decreasing order:\n- 6, 4, 4, 2, 2 , 0, 0, -2.\nThe 5-Sum of the array is 2."
            },
            {
                "label": "Example 2",
                "input": "nums = [1,-2,3,4,-10,12], k = 16",
                "output": "10 Explanation: The 16-Sum of the array is 10. Constraints: n == nums.length 1 <= n <= 10 5 -10 9 <= nums[i] <= 10 9 1 <= k <= min(2000, 2 n )"
            }
        ],
        "elixir_template": "defmodule Solution do\n  @spec k_sum(nums :: [integer], k :: integer) :: integer\n  def k_sum(nums, k) do\n    \n  end\nend",
        "erlang_template": "-spec k_sum(Nums :: [integer()], K :: integer()) -> integer().\nk_sum(Nums, K) ->\n  .",
        "scala_template": "object Solution {\n    def kSum(nums: Array[Int], k: Int): Long = {\n        \n    }\n}"
    },
    {
        "id": 2461,
        "name": "amount-of-time-for-binary-tree-to-be-infected",
        "difficulty": "Medium",
        "link": "https://leetcode.com/problems/amount-of-time-for-binary-tree-to-be-infected/",
        "task_description": "You are given the `root` of a binary tree with **unique** values, and an integer `start`. At minute `0`, an **infection** starts from the node with value `start`. Each minute, a node becomes infected if: The node is currently uninfected. The node is adjacent to an infected node. Return _the number of minutes needed for the entire tree to be infected._ **Example 1:** ``` **Input:** root = [1,5,3,null,4,10,6,9,2], start = 3 **Output:** 4 **Explanation:** The following nodes are infected during: - Minute 0: Node 3 - Minute 1: Nodes 1, 10 and 6 - Minute 2: Node 5 - Minute 3: Node 4 - Minute 4: Nodes 9 and 2 It takes 4 minutes for the whole tree to be infected so we return 4. ``` **Example 2:** ``` **Input:** root = [1], start = 1 **Output:** 0 **Explanation:** At minute 0, the only node in the tree is infected so we return 0. ``` **Constraints:** The number of nodes in the tree is in the range `[1, 105]`. `1 <= Node.val <= 105` Each node has a **unique** value. A node with a value of `start` exists in the tree.",
        "test_case": [
            {
                "label": "Example 1",
                "input": "root = [1,5,3,null,4,10,6,9,2], start = 3",
                "output": "4 Explanation: The following nodes are infected during:\n- Minute 0: Node 3\n- Minute 1: Nodes 1, 10 and 6\n- Minute 2: Node 5\n- Minute 3: Node 4\n- Minute 4: Nodes 9 and 2\nIt takes 4 minutes for the whole tree to be infected so we return 4."
            },
            {
                "label": "Example 2",
                "input": "root = [1], start = 1",
                "output": "0 Explanation: At minute 0, the only node in the tree is infected so we return 0. Constraints: The number of nodes in the tree is in the range [1, 10 5 ] . 1 <= Node.val <= 10 5 Each node has a unique value. A node with a value of start exists in the tree."
            }
        ],
        "elixir_template": "# Definition for a binary tree node.\n#\n# defmodule TreeNode do\n#   @type t :: %__MODULE__{\n#           val: integer,\n#           left: TreeNode.t() | nil,\n#           right: TreeNode.t() | nil\n#         }\n#   defstruct val: 0, left: nil, right: nil\n# end\n\ndefmodule Solution do\n  @spec amount_of_time(root :: TreeNode.t | nil, start :: integer) :: integer\n  def amount_of_time(root, start) do\n    \n  end\nend",
        "erlang_template": "%% Definition for a binary tree node.\n%%\n%% -record(tree_node, {val = 0 :: integer(),\n%%                     left = null  :: 'null' | #tree_node{},\n%%                     right = null :: 'null' | #tree_node{}}).\n\n-spec amount_of_time(Root :: #tree_node{} | null, Start :: integer()) -> integer().\namount_of_time(Root, Start) ->\n  .",
        "scala_template": "/**\n * Definition for a binary tree node.\n * class TreeNode(_value: Int = 0, _left: TreeNode = null, _right: TreeNode = null) {\n *   var value: Int = _value\n *   var left: TreeNode = _left\n *   var right: TreeNode = _right\n * }\n */\nobject Solution {\n    def amountOfTime(root: TreeNode, start: Int): Int = {\n        \n    }\n}"
    },
    {
        "id": 2459,
        "name": "minimum-hours-of-training-to-win-a-competition",
        "difficulty": "Easy",
        "link": "https://leetcode.com/problems/minimum-hours-of-training-to-win-a-competition/",
        "task_description": "You are entering a competition, and are given two **positive** integers `initialEnergy` and `initialExperience` denoting your initial energy and initial experience respectively. You are also given two **0-indexed** integer arrays `energy` and `experience`, both of length `n`. You will face `n` opponents **in order**. The energy and experience of the `ith` opponent is denoted by `energy[i]` and `experience[i]` respectively. When you face an opponent, you need to have both **strictly** greater experience and energy to defeat them and move to the next opponent if available. Defeating the `ith` opponent **increases** your experience by `experience[i]`, but **decreases** your energy by `energy[i]`. Before starting the competition, you can train for some number of hours. After each hour of training, you can **either** choose to increase your initial experience by one, or increase your initial energy by one. Return _the **minimum** number of training hours required to defeat all _`n`_ opponents_. **Example 1:** ``` **Input:** initialEnergy = 5, initialExperience = 3, energy = [1,4,3,2], experience = [2,6,3,1] **Output:** 8 **Explanation:** You can increase your energy to 11 after 6 hours of training, and your experience to 5 after 2 hours of training. You face the opponents in the following order: - You have more energy and experience than the 0th opponent so you win. Your energy becomes 11 - 1 = 10, and your experience becomes 5 + 2 = 7. - You have more energy and experience than the 1st opponent so you win. Your energy becomes 10 - 4 = 6, and your experience becomes 7 + 6 = 13. - You have more energy and experience than the 2nd opponent so you win. Your energy becomes 6 - 3 = 3, and your experience becomes 13 + 3 = 16. - You have more energy and experience than the 3rd opponent so you win. Your energy becomes 3 - 2 = 1, and your experience becomes 16 + 1 = 17. You did a total of 6 + 2 = 8 hours of training before the competition, so we return 8. It can be proven that no smaller answer exists. ``` **Example 2:** ``` **Input:** initialEnergy = 2, initialExperience = 4, energy = [1], experience = [3] **Output:** 0 **Explanation:** You do not need any additional energy or experience to win the competition, so we return 0. ``` **Constraints:** `n == energy.length == experience.length` `1 <= n <= 100` `1 <= initialEnergy, initialExperience, energy[i], experience[i] <= 100`",
        "test_case": [
            {
                "label": "Example 1",
                "input": "initialEnergy = 5, initialExperience = 3, energy = [1,4,3,2], experience = [2,6,3,1]",
                "output": "8 Explanation: You can increase your energy to 11 after 6 hours of training, and your experience to 5 after 2 hours of training.\nYou face the opponents in the following order:\n- You have more energy and experience than the 0 th opponent so you win.\n  Your energy becomes 11 - 1 = 10, and your experience becomes 5 + 2 = 7.\n- You have more energy and experience than the 1 st opponent so you win.\n  Your energy becomes 10 - 4 = 6, and your experience becomes 7 + 6 = 13.\n- You have more energy and experience than the 2 nd opponent so you win.\n  Your energy becomes 6 - 3 = 3, and your experience becomes 13 + 3 = 16.\n- You have more energy and experience than the 3 rd opponent so you win.\n  Your energy becomes 3 - 2 = 1, and your experience becomes 16 + 1 = 17.\nYou did a total of 6 + 2 = 8 hours of training before the competition, so we return 8.\nIt can be proven that no smaller answer exists."
            },
            {
                "label": "Example 2",
                "input": "initialEnergy = 2, initialExperience = 4, energy = [1], experience = [3]",
                "output": "0 Explanation: You do not need any additional energy or experience to win the competition, so we return 0. Constraints: n == energy.length == experience.length 1 <= n <= 100 1 <= initialEnergy, initialExperience, energy[i], experience[i] <= 100"
            }
        ],
        "elixir_template": "defmodule Solution do\n  @spec min_number_of_hours(initial_energy :: integer, initial_experience :: integer, energy :: [integer], experience :: [integer]) :: integer\n  def min_number_of_hours(initial_energy, initial_experience, energy, experience) do\n    \n  end\nend",
        "erlang_template": "-spec min_number_of_hours(InitialEnergy :: integer(), InitialExperience :: integer(), Energy :: [integer()], Experience :: [integer()]) -> integer().\nmin_number_of_hours(InitialEnergy, InitialExperience, Energy, Experience) ->\n  .",
        "scala_template": "object Solution {\n    def minNumberOfHours(initialEnergy: Int, initialExperience: Int, energy: Array[Int], experience: Array[Int]): Int = {\n        \n    }\n}"
    },
    {
        "id": 2457,
        "name": "count-special-integers",
        "difficulty": "Hard",
        "link": "https://leetcode.com/problems/count-special-integers/",
        "task_description": "We call a positive integer **special** if all of its digits are **distinct**. Given a **positive** integer `n`, return _the number of special integers that belong to the interval _`[1, n]`. **Example 1:** ``` **Input:** n = 20 **Output:** 19 **Explanation:** All the integers from 1 to 20, except 11, are special. Thus, there are 19 special integers. ``` **Example 2:** ``` **Input:** n = 5 **Output:** 5 **Explanation:** All the integers from 1 to 5 are special. ``` **Example 3:** ``` **Input:** n = 135 **Output:** 110 **Explanation:** There are 110 integers from 1 to 135 that are special. Some of the integers that are not special are: 22, 114, and 131. ``` **Constraints:** `1 <= n <= 2 * 109`",
        "test_case": [
            {
                "label": "Example 1",
                "input": "n = 20",
                "output": "19 Explanation: All the integers from 1 to 20, except 11, are special. Thus, there are 19 special integers."
            },
            {
                "label": "Example 2",
                "input": "n = 5",
                "output": "5 Explanation: All the integers from 1 to 5 are special."
            },
            {
                "label": "Example 3",
                "input": "n = 135",
                "output": "110 Explanation: There are 110 integers from 1 to 135 that are special.\nSome of the integers that are not special are: 22, 114, and 131."
            }
        ],
        "elixir_template": "defmodule Solution do\n  @spec count_special_numbers(n :: integer) :: integer\n  def count_special_numbers(n) do\n    \n  end\nend",
        "erlang_template": "-spec count_special_numbers(N :: integer()) -> integer().\ncount_special_numbers(N) ->\n  .",
        "scala_template": "object Solution {\n    def countSpecialNumbers(n: Int): Int = {\n        \n    }\n}"
    },
    {
        "id": 2456,
        "name": "construct-smallest-number-from-di-string",
        "difficulty": "Medium",
        "link": "https://leetcode.com/problems/construct-smallest-number-from-di-string/",
        "task_description": "You are given a **0-indexed** string `pattern` of length `n` consisting of the characters `'I'` meaning **increasing** and `'D'` meaning **decreasing**. A **0-indexed** string `num` of length `n + 1` is created using the following conditions: `num` consists of the digits `'1'` to `'9'`, where each digit is used **at most** once. If `pattern[i] == 'I'`, then `num[i] < num[i + 1]`. If `pattern[i] == 'D'`, then `num[i] > num[i + 1]`. Return _the lexicographically **smallest** possible string _`num`_ that meets the conditions._ **Example 1:** ``` **Input:** pattern = \"IIIDIDDD\" **Output:** \"123549876\" **Explanation: **At indices 0, 1, 2, and 4 we must have that num[i] < num[i+1]. At indices 3, 5, 6, and 7 we must have that num[i] > num[i+1]. Some possible values of num are \"245639871\", \"135749862\", and \"123849765\". It can be proven that \"123549876\" is the smallest possible num that meets the conditions. Note that \"123414321\" is not possible because the digit '1' is used more than once. ``` **Example 2:** ``` **Input:** pattern = \"DDD\" **Output:** \"4321\" **Explanation:** Some possible values of num are \"9876\", \"7321\", and \"8742\". It can be proven that \"4321\" is the smallest possible num that meets the conditions. ``` **Constraints:** `1 <= pattern.length <= 8` `pattern` consists of only the letters `'I'` and `'D'`.",
        "test_case": [
            {
                "label": "Example 1",
                "input": "pattern = \"IIIDIDDD\"",
                "output": "\"123549876\" Explanation: At indices 0, 1, 2, and 4 we must have that num[i] < num[i+1].\nAt indices 3, 5, 6, and 7 we must have that num[i] > num[i+1].\nSome possible values of num are \"245639871\", \"135749862\", and \"123849765\".\nIt can be proven that \"123549876\" is the smallest possible num that meets the conditions.\nNote that \"123414321\" is not possible because the digit '1' is used more than once."
            },
            {
                "label": "Example 2",
                "input": "pattern = \"DDD\"",
                "output": "\"4321\" Explanation: Some possible values of num are \"9876\", \"7321\", and \"8742\".\nIt can be proven that \"4321\" is the smallest possible num that meets the conditions."
            }
        ],
        "elixir_template": "defmodule Solution do\n  @spec smallest_number(pattern :: String.t) :: String.t\n  def smallest_number(pattern) do\n    \n  end\nend",
        "erlang_template": "-spec smallest_number(Pattern :: unicode:unicode_binary()) -> unicode:unicode_binary().\nsmallest_number(Pattern) ->\n  .",
        "scala_template": "object Solution {\n    def smallestNumber(pattern: String): String = {\n        \n    }\n}"
    },
    {
        "id": 2455,
        "name": "node-with-highest-edge-score",
        "difficulty": "Medium",
        "link": "https://leetcode.com/problems/node-with-highest-edge-score/",
        "task_description": "You are given a directed graph with `n` nodes labeled from `0` to `n - 1`, where each node has **exactly one** outgoing edge. The graph is represented by a given **0-indexed** integer array `edges` of length `n`, where `edges[i]` indicates that there is a **directed** edge from node `i` to node `edges[i]`. The **edge score** of a node `i` is defined as the sum of the **labels** of all the nodes that have an edge pointing to `i`. Return _the node with the highest **edge score**_. If multiple nodes have the same **edge score**, return the node with the **smallest** index. **Example 1:** ``` **Input:** edges = [1,0,0,0,0,7,7,5] **Output:** 7 **Explanation:** - The nodes 1, 2, 3 and 4 have an edge pointing to node 0. The edge score of node 0 is 1 + 2 + 3 + 4 = 10. - The node 0 has an edge pointing to node 1. The edge score of node 1 is 0. - The node 7 has an edge pointing to node 5. The edge score of node 5 is 7. - The nodes 5 and 6 have an edge pointing to node 7. The edge score of node 7 is 5 + 6 = 11. Node 7 has the highest edge score so return 7. ``` **Example 2:** ``` **Input:** edges = [2,0,0,2] **Output:** 0 **Explanation:** - The nodes 1 and 2 have an edge pointing to node 0. The edge score of node 0 is 1 + 2 = 3. - The nodes 0 and 3 have an edge pointing to node 2. The edge score of node 2 is 0 + 3 = 3. Nodes 0 and 2 both have an edge score of 3. Since node 0 has a smaller index, we return 0. ``` **Constraints:** `n == edges.length` `2 <= n <= 105` `0 <= edges[i] < n` `edges[i] != i`",
        "test_case": [
            {
                "label": "Example 1",
                "input": "edges = [1,0,0,0,0,7,7,5]",
                "output": "7 Explanation: - The nodes 1, 2, 3 and 4 have an edge pointing to node 0. The edge score of node 0 is 1 + 2 + 3 + 4 = 10.\n- The node 0 has an edge pointing to node 1. The edge score of node 1 is 0.\n- The node 7 has an edge pointing to node 5. The edge score of node 5 is 7.\n- The nodes 5 and 6 have an edge pointing to node 7. The edge score of node 7 is 5 + 6 = 11.\nNode 7 has the highest edge score so return 7."
            },
            {
                "label": "Example 2",
                "input": "edges = [2,0,0,2]",
                "output": "0 Explanation: - The nodes 1 and 2 have an edge pointing to node 0. The edge score of node 0 is 1 + 2 = 3.\n- The nodes 0 and 3 have an edge pointing to node 2. The edge score of node 2 is 0 + 3 = 3.\nNodes 0 and 2 both have an edge score of 3. Since node 0 has a smaller index, we return 0. Constraints: n == edges.length 2 <= n <= 10 5 0 <= edges[i] < n edges[i] != i"
            }
        ],
        "elixir_template": "defmodule Solution do\n  @spec edge_score(edges :: [integer]) :: integer\n  def edge_score(edges) do\n    \n  end\nend",
        "erlang_template": "-spec edge_score(Edges :: [integer()]) -> integer().\nedge_score(Edges) ->\n  .",
        "scala_template": "object Solution {\n    def edgeScore(edges: Array[Int]): Int = {\n        \n    }\n}"
    },
    {
        "id": 2454,
        "name": "largest-local-values-in-a-matrix",
        "difficulty": "Easy",
        "link": "https://leetcode.com/problems/largest-local-values-in-a-matrix/",
        "task_description": "You are given an `n x n` integer matrix `grid`. Generate an integer matrix `maxLocal` of size `(n - 2) x (n - 2)` such that: `maxLocal[i][j]` is equal to the **largest** value of the `3 x 3` matrix in `grid` centered around row `i + 1` and column `j + 1`. In other words, we want to find the largest value in every contiguous `3 x 3` matrix in `grid`. Return _the generated matrix_. **Example 1:** ``` **Input:** grid = [[9,9,8,1],[5,6,2,6],[8,2,6,4],[6,2,2,2]] **Output:** [[9,9],[8,6]] **Explanation:** The diagram above shows the original matrix and the generated matrix. Notice that each value in the generated matrix corresponds to the largest value of a contiguous 3 x 3 matrix in grid. ``` **Example 2:** ``` **Input:** grid = [[1,1,1,1,1],[1,1,1,1,1],[1,1,2,1,1],[1,1,1,1,1],[1,1,1,1,1]] **Output:** [[2,2,2],[2,2,2],[2,2,2]] **Explanation:** Notice that the 2 is contained within every contiguous 3 x 3 matrix in grid. ``` **Constraints:** `n == grid.length == grid[i].length` `3 <= n <= 100` `1 <= grid[i][j] <= 100`",
        "test_case": [
            {
                "label": "Example 1",
                "input": "grid = [[9,9,8,1],[5,6,2,6],[8,2,6,4],[6,2,2,2]]",
                "output": "[[9,9],[8,6]] Explanation: The diagram above shows the original matrix and the generated matrix.\nNotice that each value in the generated matrix corresponds to the largest value of a contiguous 3 x 3 matrix in grid."
            },
            {
                "label": "Example 2",
                "input": "grid = [[1,1,1,1,1],[1,1,1,1,1],[1,1,2,1,1],[1,1,1,1,1],[1,1,1,1,1]]",
                "output": "[[2,2,2],[2,2,2],[2,2,2]] Explanation: Notice that the 2 is contained within every contiguous 3 x 3 matrix in grid. Constraints: n == grid.length == grid[i].length 3 <= n <= 100 1 <= grid[i][j] <= 100"
            }
        ],
        "elixir_template": "defmodule Solution do\n  @spec largest_local(grid :: [[integer]]) :: [[integer]]\n  def largest_local(grid) do\n    \n  end\nend",
        "erlang_template": "-spec largest_local(Grid :: [[integer()]]) -> [[integer()]].\nlargest_local(Grid) ->\n  .",
        "scala_template": "object Solution {\n    def largestLocal(grid: Array[Array[Int]]): Array[Array[Int]] = {\n        \n    }\n}"
    },
    {
        "id": 2450,
        "name": "minimum-replacements-to-sort-the-array",
        "difficulty": "Hard",
        "link": "https://leetcode.com/problems/minimum-replacements-to-sort-the-array/",
        "task_description": "You are given a **0-indexed** integer array `nums`. In one operation you can replace any element of the array with **any two** elements that **sum** to it. For example, consider `nums = [5,6,7]`. In one operation, we can replace `nums[1]` with `2` and `4` and convert `nums` to `[5,2,4,7]`. Return _the minimum number of operations to make an array that is sorted in **non-decreasing** order_. **Example 1:** ``` **Input:** nums = [3,9,3] **Output:** 2 **Explanation:** Here are the steps to sort the array in non-decreasing order: - From [3,9,3], replace the 9 with 3 and 6 so the array becomes [3,3,6,3] - From [3,3,6,3], replace the 6 with 3 and 3 so the array becomes [3,3,3,3,3] There are 2 steps to sort the array in non-decreasing order. Therefore, we return 2. ``` **Example 2:** ``` **Input:** nums = [1,2,3,4,5] **Output:** 0 **Explanation:** The array is already in non-decreasing order. Therefore, we return 0. ``` **Constraints:** `1 <= nums.length <= 105` `1 <= nums[i] <= 109`",
        "test_case": [
            {
                "label": "Example 1",
                "input": "nums = [3,9,3]",
                "output": "2 Explanation: Here are the steps to sort the array in non-decreasing order:\n- From [3,9,3], replace the 9 with 3 and 6 so the array becomes [3,3,6,3]\n- From [3,3,6,3], replace the 6 with 3 and 3 so the array becomes [3,3,3,3,3]\nThere are 2 steps to sort the array in non-decreasing order. Therefore, we return 2."
            },
            {
                "label": "Example 2",
                "input": "nums = [1,2,3,4,5]",
                "output": "0 Explanation: The array is already in non-decreasing order. Therefore, we return 0."
            }
        ],
        "elixir_template": "defmodule Solution do\n  @spec minimum_replacement(nums :: [integer]) :: integer\n  def minimum_replacement(nums) do\n    \n  end\nend",
        "erlang_template": "-spec minimum_replacement(Nums :: [integer()]) -> integer().\nminimum_replacement(Nums) ->\n  .",
        "scala_template": "object Solution {\n    def minimumReplacement(nums: Array[Int]): Long = {\n        \n    }\n}"
    },
    {
        "id": 2449,
        "name": "maximum-number-of-robots-within-budget",
        "difficulty": "Hard",
        "link": "https://leetcode.com/problems/maximum-number-of-robots-within-budget/",
        "task_description": "You have `n` robots. You are given two **0-indexed** integer arrays, `chargeTimes` and `runningCosts`, both of length `n`. The `ith` robot costs `chargeTimes[i]` units to charge and costs `runningCosts[i]` units to run. You are also given an integer `budget`. The **total cost** of running `k` chosen robots is equal to `max(chargeTimes) + k * sum(runningCosts)`, where `max(chargeTimes)` is the largest charge cost among the `k` robots and `sum(runningCosts)` is the sum of running costs among the `k` robots. Return_ the **maximum** number of **consecutive** robots you can run such that the total cost **does not** exceed _`budget`. **Example 1:** ``` **Input:** chargeTimes = [3,6,1,3,4], runningCosts = [2,1,3,4,5], budget = 25 **Output:** 3 **Explanation:** It is possible to run all individual and consecutive pairs of robots within budget. To obtain answer 3, consider the first 3 robots. The total cost will be max(3,6,1) + 3 * sum(2,1,3) = 6 + 3 * 6 = 24 which is less than 25. It can be shown that it is not possible to run more than 3 consecutive robots within budget, so we return 3. ``` **Example 2:** ``` **Input:** chargeTimes = [11,12,19], runningCosts = [10,8,7], budget = 19 **Output:** 0 **Explanation:** No robot can be run that does not exceed the budget, so we return 0. ``` **Constraints:** `chargeTimes.length == runningCosts.length == n` `1 <= n <= 5 * 104` `1 <= chargeTimes[i], runningCosts[i] <= 105` `1 <= budget <= 1015`",
        "test_case": [
            {
                "label": "Example 1",
                "input": "chargeTimes = [3,6,1,3,4], runningCosts = [2,1,3,4,5], budget = 25",
                "output": "3 Explanation: It is possible to run all individual and consecutive pairs of robots within budget.\nTo obtain answer 3, consider the first 3 robots. The total cost will be max(3,6,1) + 3 * sum(2,1,3) = 6 + 3 * 6 = 24 which is less than 25.\nIt can be shown that it is not possible to run more than 3 consecutive robots within budget, so we return 3."
            },
            {
                "label": "Example 2",
                "input": "chargeTimes = [11,12,19], runningCosts = [10,8,7], budget = 19",
                "output": "0 Explanation: No robot can be run that does not exceed the budget, so we return 0. Constraints: chargeTimes.length == runningCosts.length == n 1 <= n <= 5 * 10 4 1 <= chargeTimes[i], runningCosts[i] <= 10 5 1 <= budget <= 10 15"
            }
        ],
        "elixir_template": "defmodule Solution do\n  @spec maximum_robots(charge_times :: [integer], running_costs :: [integer], budget :: integer) :: integer\n  def maximum_robots(charge_times, running_costs, budget) do\n    \n  end\nend",
        "erlang_template": "-spec maximum_robots(ChargeTimes :: [integer()], RunningCosts :: [integer()], Budget :: integer()) -> integer().\nmaximum_robots(ChargeTimes, RunningCosts, Budget) ->\n  .",
        "scala_template": "object Solution {\n    def maximumRobots(chargeTimes: Array[Int], runningCosts: Array[Int], budget: Long): Int = {\n        \n    }\n}"
    },
    {
        "id": 2448,
        "name": "count-number-of-bad-pairs",
        "difficulty": "Medium",
        "link": "https://leetcode.com/problems/count-number-of-bad-pairs/",
        "task_description": "You are given a **0-indexed** integer array `nums`. A pair of indices `(i, j)` is a **bad pair** if `i < j` and `j - i != nums[j] - nums[i]`. Return_ the total number of **bad pairs** in _`nums`. **Example 1:** ``` **Input:** nums = [4,1,3,3] **Output:** 5 **Explanation:** The pair (0, 1) is a bad pair since 1 - 0 != 1 - 4. The pair (0, 2) is a bad pair since 2 - 0 != 3 - 4, 2 != -1. The pair (0, 3) is a bad pair since 3 - 0 != 3 - 4, 3 != -1. The pair (1, 2) is a bad pair since 2 - 1 != 3 - 1, 1 != 2. The pair (2, 3) is a bad pair since 3 - 2 != 3 - 3, 1 != 0. There are a total of 5 bad pairs, so we return 5. ``` **Example 2:** ``` **Input:** nums = [1,2,3,4,5] **Output:** 0 **Explanation:** There are no bad pairs. ``` **Constraints:** `1 <= nums.length <= 105` `1 <= nums[i] <= 109`",
        "test_case": [
            {
                "label": "Example 1",
                "input": "nums = [4,1,3,3]",
                "output": "5 Explanation: The pair (0, 1) is a bad pair since 1 - 0 != 1 - 4.\nThe pair (0, 2) is a bad pair since 2 - 0 != 3 - 4, 2 != -1.\nThe pair (0, 3) is a bad pair since 3 - 0 != 3 - 4, 3 != -1.\nThe pair (1, 2) is a bad pair since 2 - 1 != 3 - 1, 1 != 2.\nThe pair (2, 3) is a bad pair since 3 - 2 != 3 - 3, 1 != 0.\nThere are a total of 5 bad pairs, so we return 5."
            },
            {
                "label": "Example 2",
                "input": "nums = [1,2,3,4,5]",
                "output": "0 Explanation: There are no bad pairs."
            }
        ],
        "elixir_template": "defmodule Solution do\n  @spec count_bad_pairs(nums :: [integer]) :: integer\n  def count_bad_pairs(nums) do\n    \n  end\nend",
        "erlang_template": "-spec count_bad_pairs(Nums :: [integer()]) -> integer().\ncount_bad_pairs(Nums) ->\n  .",
        "scala_template": "object Solution {\n    def countBadPairs(nums: Array[Int]): Long = {\n        \n    }\n}"
    },
    {
        "id": 2447,
        "name": "merge-similar-items",
        "difficulty": "Easy",
        "link": "https://leetcode.com/problems/merge-similar-items/",
        "task_description": "You are given two 2D integer arrays, `items1` and `items2`, representing two sets of items. Each array `items` has the following properties: `items[i] = [valuei, weighti]` where `valuei` represents the **value** and `weighti` represents the **weight **of the `ith` item. The value of each item in `items` is **unique**. Return _a 2D integer array_ `ret` _where_ `ret[i] = [valuei, weighti]`_,_ _with_ `weighti` _being the **sum of weights** of all items with value_ `valuei`. **Note:** `ret` should be returned in **ascending** order by value. **Example 1:** ``` **Input:** items1 = [[1,1],[4,5],[3,8]], items2 = [[3,1],[1,5]] **Output:** [[1,6],[3,9],[4,5]] **Explanation:** The item with value = 1 occurs in items1 with weight = 1 and in items2 with weight = 5, total weight = 1 + 5 = 6. The item with value = 3 occurs in items1 with weight = 8 and in items2 with weight = 1, total weight = 8 + 1 = 9. The item with value = 4 occurs in items1 with weight = 5, total weight = 5. Therefore, we return [[1,6],[3,9],[4,5]]. ``` **Example 2:** ``` **Input:** items1 = [[1,1],[3,2],[2,3]], items2 = [[2,1],[3,2],[1,3]] **Output:** [[1,4],[2,4],[3,4]] **Explanation:** The item with value = 1 occurs in items1 with weight = 1 and in items2 with weight = 3, total weight = 1 + 3 = 4. The item with value = 2 occurs in items1 with weight = 3 and in items2 with weight = 1, total weight = 3 + 1 = 4. The item with value = 3 occurs in items1 with weight = 2 and in items2 with weight = 2, total weight = 2 + 2 = 4. Therefore, we return [[1,4],[2,4],[3,4]]. ``` **Example 3:** ``` **Input:** items1 = [[1,3],[2,2]], items2 = [[7,1],[2,2],[1,4]] **Output:** [[1,7],[2,4],[7,1]] **Explanation: **The item with value = 1 occurs in items1 with weight = 3 and in items2 with weight = 4, total weight = 3 + 4 = 7. The item with value = 2 occurs in items1 with weight = 2 and in items2 with weight = 2, total weight = 2 + 2 = 4. The item with value = 7 occurs in items2 with weight = 1, total weight = 1. Therefore, we return [[1,7],[2,4],[7,1]]. ``` **Constraints:** `1 <= items1.length, items2.length <= 1000` `items1[i].length == items2[i].length == 2` `1 <= valuei, weighti <= 1000` Each `valuei` in `items1` is **unique**. Each `valuei` in `items2` is **unique**.",
        "test_case": [
            {
                "label": "Example 1",
                "input": "items1 = [[1,1],[4,5],[3,8]], items2 = [[3,1],[1,5]]",
                "output": "[[1,6],[3,9],[4,5]] Explanation: The item with value = 1 occurs in items1 with weight = 1 and in items2 with weight = 5, total weight = 1 + 5 = 6.\nThe item with value = 3 occurs in items1 with weight = 8 and in items2 with weight = 1, total weight = 8 + 1 = 9.\nThe item with value = 4 occurs in items1 with weight = 5, total weight = 5.  \nTherefore, we return [[1,6],[3,9],[4,5]]."
            },
            {
                "label": "Example 2",
                "input": "items1 = [[1,1],[3,2],[2,3]], items2 = [[2,1],[3,2],[1,3]]",
                "output": "[[1,4],[2,4],[3,4]] Explanation: The item with value = 1 occurs in items1 with weight = 1 and in items2 with weight = 3, total weight = 1 + 3 = 4.\nThe item with value = 2 occurs in items1 with weight = 3 and in items2 with weight = 1, total weight = 3 + 1 = 4.\nThe item with value = 3 occurs in items1 with weight = 2 and in items2 with weight = 2, total weight = 2 + 2 = 4.\nTherefore, we return [[1,4],[2,4],[3,4]]."
            },
            {
                "label": "Example 3",
                "input": "items1 = [[1,3],[2,2]], items2 = [[7,1],[2,2],[1,4]]",
                "output": "[[1,7],[2,4],[7,1]] Explanation: The item with value = 1 occurs in items1 with weight = 3 and in items2 with weight = 4, total weight = 3 + 4 = 7. \nThe item with value = 2 occurs in items1 with weight = 2 and in items2 with weight = 2, total weight = 2 + 2 = 4. \nThe item with value = 7 occurs in items2 with weight = 1, total weight = 1.\nTherefore, we return [[1,7],[2,4],[7,1]]."
            }
        ],
        "elixir_template": "defmodule Solution do\n  @spec merge_similar_items(items1 :: [[integer]], items2 :: [[integer]]) :: [[integer]]\n  def merge_similar_items(items1, items2) do\n    \n  end\nend",
        "erlang_template": "-spec merge_similar_items(Items1 :: [[integer()]], Items2 :: [[integer()]]) -> [[integer()]].\nmerge_similar_items(Items1, Items2) ->\n  .",
        "scala_template": "object Solution {\n    def mergeSimilarItems(items1: Array[Array[Int]], items2: Array[Array[Int]]): List[List[Int]] = {\n        \n    }\n}"
    },
    {
        "id": 2445,
        "name": "reachable-nodes-with-restrictions",
        "difficulty": "Medium",
        "link": "https://leetcode.com/problems/reachable-nodes-with-restrictions/",
        "task_description": "There is an undirected tree with `n` nodes labeled from `0` to `n - 1` and `n - 1` edges. You are given a 2D integer array `edges` of length `n - 1` where `edges[i] = [ai, bi]` indicates that there is an edge between nodes `ai` and `bi` in the tree. You are also given an integer array `restricted` which represents **restricted** nodes. Return _the **maximum** number of nodes you can reach from node _`0`_ without visiting a restricted node._ Note that node `0` will **not** be a restricted node. **Example 1:** ``` **Input:** n = 7, edges = [[0,1],[1,2],[3,1],[4,0],[0,5],[5,6]], restricted = [4,5] **Output:** 4 **Explanation:** The diagram above shows the tree. We have that [0,1,2,3] are the only nodes that can be reached from node 0 without visiting a restricted node. ``` **Example 2:** ``` **Input:** n = 7, edges = [[0,1],[0,2],[0,5],[0,4],[3,2],[6,5]], restricted = [4,2,1] **Output:** 3 **Explanation:** The diagram above shows the tree. We have that [0,5,6] are the only nodes that can be reached from node 0 without visiting a restricted node. ``` **Constraints:** `2 <= n <= 105` `edges.length == n - 1` `edges[i].length == 2` `0 <= ai, bi < n` `ai != bi` `edges` represents a valid tree. `1 <= restricted.length < n` `1 <= restricted[i] < n` All the values of `restricted` are **unique**.",
        "test_case": [
            {
                "label": "Example 1",
                "input": "n = 7, edges = [[0,1],[1,2],[3,1],[4,0],[0,5],[5,6]], restricted = [4,5]",
                "output": "4 Explanation: The diagram above shows the tree.\nWe have that [0,1,2,3] are the only nodes that can be reached from node 0 without visiting a restricted node."
            },
            {
                "label": "Example 2",
                "input": "n = 7, edges = [[0,1],[0,2],[0,5],[0,4],[3,2],[6,5]], restricted = [4,2,1]",
                "output": "3 Explanation: The diagram above shows the tree.\nWe have that [0,5,6] are the only nodes that can be reached from node 0 without visiting a restricted node."
            }
        ],
        "elixir_template": "defmodule Solution do\n  @spec reachable_nodes(n :: integer, edges :: [[integer]], restricted :: [integer]) :: integer\n  def reachable_nodes(n, edges, restricted) do\n    \n  end\nend",
        "erlang_template": "-spec reachable_nodes(N :: integer(), Edges :: [[integer()]], Restricted :: [integer()]) -> integer().\nreachable_nodes(N, Edges, Restricted) ->\n  .",
        "scala_template": "object Solution {\n    def reachableNodes(n: Int, edges: Array[Array[Int]], restricted: Array[Int]): Int = {\n        \n    }\n}"
    },
    {
        "id": 2444,
        "name": "longest-ideal-subsequence",
        "difficulty": "Medium",
        "link": "https://leetcode.com/problems/longest-ideal-subsequence/",
        "task_description": "You are given a string `s` consisting of lowercase letters and an integer `k`. We call a string `t` **ideal** if the following conditions are satisfied: `t` is a **subsequence** of the string `s`. The absolute difference in the alphabet order of every two **adjacent** letters in `t` is less than or equal to `k`. Return _the length of the **longest** ideal string_. A **subsequence** is a string that can be derived from another string by deleting some or no characters without changing the order of the remaining characters. **Note** that the alphabet order is not cyclic. For example, the absolute difference in the alphabet order of `'a'` and `'z'` is `25`, not `1`. **Example 1:** ``` **Input:** s = \"acfgbd\", k = 2 **Output:** 4 **Explanation:** The longest ideal string is \"acbd\". The length of this string is 4, so 4 is returned. Note that \"acfgbd\" is not ideal because 'c' and 'f' have a difference of 3 in alphabet order. ``` **Example 2:** ``` **Input:** s = \"abcd\", k = 3 **Output:** 4 **Explanation:** The longest ideal string is \"abcd\". The length of this string is 4, so 4 is returned. ``` **Constraints:** `1 <= s.length <= 105` `0 <= k <= 25` `s` consists of lowercase English letters.",
        "test_case": [
            {
                "label": "Example 1",
                "input": "s = \"acfgbd\", k = 2",
                "output": "4 Explanation: The longest ideal string is \"acbd\". The length of this string is 4, so 4 is returned.\nNote that \"acfgbd\" is not ideal because 'c' and 'f' have a difference of 3 in alphabet order."
            },
            {
                "label": "Example 2",
                "input": "s = \"abcd\", k = 3",
                "output": "4 Explanation: The longest ideal string is \"abcd\". The length of this string is 4, so 4 is returned."
            }
        ],
        "elixir_template": "defmodule Solution do\n  @spec longest_ideal_string(s :: String.t, k :: integer) :: integer\n  def longest_ideal_string(s, k) do\n    \n  end\nend",
        "erlang_template": "-spec longest_ideal_string(S :: unicode:unicode_binary(), K :: integer()) -> integer().\nlongest_ideal_string(S, K) ->\n  .",
        "scala_template": "object Solution {\n    def longestIdealString(s: String, k: Int): Int = {\n        \n    }\n}"
    },
    {
        "id": 2443,
        "name": "check-if-there-is-a-valid-partition-for-the-array",
        "difficulty": "Medium",
        "link": "https://leetcode.com/problems/check-if-there-is-a-valid-partition-for-the-array/",
        "task_description": "You are given a **0-indexed** integer array `nums`. You have to partition the array into one or more **contiguous** subarrays. We call a partition of the array **valid** if each of the obtained subarrays satisfies **one** of the following conditions: The subarray consists of **exactly** `2,` equal elements. For example, the subarray `[2,2]` is good. The subarray consists of **exactly** `3,` equal elements. For example, the subarray `[4,4,4]` is good. The subarray consists of **exactly** `3` consecutive increasing elements, that is, the difference between adjacent elements is `1`. For example, the subarray `[3,4,5]` is good, but the subarray `[1,3,5]` is not. Return `true`_ if the array has **at least** one valid partition_. Otherwise, return `false`. **Example 1:** ``` **Input:** nums = [4,4,4,5,6] **Output:** true **Explanation:** The array can be partitioned into the subarrays [4,4] and [4,5,6]. This partition is valid, so we return true. ``` **Example 2:** ``` **Input:** nums = [1,1,1,2] **Output:** false **Explanation:** There is no valid partition for this array. ``` **Constraints:** `2 <= nums.length <= 105` `1 <= nums[i] <= 106`",
        "test_case": [
            {
                "label": "Example 1",
                "input": "nums = [4,4,4,5,6]",
                "output": "true Explanation: The array can be partitioned into the subarrays [4,4] and [4,5,6].\nThis partition is valid, so we return true."
            },
            {
                "label": "Example 2",
                "input": "nums = [1,1,1,2]",
                "output": "false Explanation: There is no valid partition for this array."
            }
        ],
        "elixir_template": "defmodule Solution do\n  @spec valid_partition(nums :: [integer]) :: boolean\n  def valid_partition(nums) do\n    \n  end\nend",
        "erlang_template": "-spec valid_partition(Nums :: [integer()]) -> boolean().\nvalid_partition(Nums) ->\n  .",
        "scala_template": "object Solution {\n    def validPartition(nums: Array[Int]): Boolean = {\n        \n    }\n}"
    },
    {
        "id": 2442,
        "name": "number-of-arithmetic-triplets",
        "difficulty": "Easy",
        "link": "https://leetcode.com/problems/number-of-arithmetic-triplets/",
        "task_description": "You are given a **0-indexed**, **strictly increasing** integer array `nums` and a positive integer `diff`. A triplet `(i, j, k)` is an **arithmetic triplet** if the following conditions are met: `i < j < k`, `nums[j] - nums[i] == diff`, and `nums[k] - nums[j] == diff`. Return _the number of unique **arithmetic triplets**._ **Example 1:** ``` **Input:** nums = [0,1,4,6,7,10], diff = 3 **Output:** 2 **Explanation:** (1, 2, 4) is an arithmetic triplet because both 7 - 4 == 3 and 4 - 1 == 3. (2, 4, 5) is an arithmetic triplet because both 10 - 7 == 3 and 7 - 4 == 3. ``` **Example 2:** ``` **Input:** nums = [4,5,6,7,8,9], diff = 2 **Output:** 2 **Explanation:** (0, 2, 4) is an arithmetic triplet because both 8 - 6 == 2 and 6 - 4 == 2. (1, 3, 5) is an arithmetic triplet because both 9 - 7 == 2 and 7 - 5 == 2. ``` **Constraints:** `3 <= nums.length <= 200` `0 <= nums[i] <= 200` `1 <= diff <= 50` `nums` is **strictly** increasing.",
        "test_case": [
            {
                "label": "Example 1",
                "input": "nums = [0,1,4,6,7,10], diff = 3",
                "output": "2 Explanation: (1, 2, 4) is an arithmetic triplet because both 7 - 4 == 3 and 4 - 1 == 3.\n(2, 4, 5) is an arithmetic triplet because both 10 - 7 == 3 and 7 - 4 == 3."
            },
            {
                "label": "Example 2",
                "input": "nums = [4,5,6,7,8,9], diff = 2",
                "output": "2 Explanation: (0, 2, 4) is an arithmetic triplet because both 8 - 6 == 2 and 6 - 4 == 2.\n(1, 3, 5) is an arithmetic triplet because both 9 - 7 == 2 and 7 - 5 == 2."
            }
        ],
        "elixir_template": "defmodule Solution do\n  @spec arithmetic_triplets(nums :: [integer], diff :: integer) :: integer\n  def arithmetic_triplets(nums, diff) do\n    \n  end\nend",
        "erlang_template": "-spec arithmetic_triplets(Nums :: [integer()], Diff :: integer()) -> integer().\narithmetic_triplets(Nums, Diff) ->\n  .",
        "scala_template": "object Solution {\n    def arithmeticTriplets(nums: Array[Int], diff: Int): Int = {\n        \n    }\n}"
    },
    {
        "id": 2439,
        "name": "longest-cycle-in-a-graph",
        "difficulty": "Hard",
        "link": "https://leetcode.com/problems/longest-cycle-in-a-graph/",
        "task_description": "You are given a **directed** graph of `n` nodes numbered from `0` to `n - 1`, where each node has **at most one** outgoing edge. The graph is represented with a given **0-indexed** array `edges` of size `n`, indicating that there is a directed edge from node `i` to node `edges[i]`. If there is no outgoing edge from node `i`, then `edges[i] == -1`. Return _the length of the **longest** cycle in the graph_. If no cycle exists, return `-1`. A cycle is a path that starts and ends at the **same** node. **Example 1:** ``` **Input:** edges = [3,3,4,2,3] **Output:** 3 **Explanation:** The longest cycle in the graph is the cycle: 2 -> 4 -> 3 -> 2. The length of this cycle is 3, so 3 is returned. ``` **Example 2:** ``` **Input:** edges = [2,-1,3,1] **Output:** -1 **Explanation:** There are no cycles in this graph. ``` **Constraints:** `n == edges.length` `2 <= n <= 105` `-1 <= edges[i] < n` `edges[i] != i`",
        "test_case": [
            {
                "label": "Example 1",
                "input": "edges = [3,3,4,2,3]",
                "output": "3 Explanation: The longest cycle in the graph is the cycle: 2 -> 4 -> 3 -> 2.\nThe length of this cycle is 3, so 3 is returned."
            },
            {
                "label": "Example 2",
                "input": "edges = [2,-1,3,1]",
                "output": "-1 Explanation: There are no cycles in this graph. Constraints: n == edges.length 2 <= n <= 10 5 -1 <= edges[i] < n edges[i] != i"
            }
        ],
        "elixir_template": "defmodule Solution do\n  @spec longest_cycle(edges :: [integer]) :: integer\n  def longest_cycle(edges) do\n    \n  end\nend",
        "erlang_template": "-spec longest_cycle(Edges :: [integer()]) -> integer().\nlongest_cycle(Edges) ->\n  .",
        "scala_template": "object Solution {\n    def longestCycle(edges: Array[Int]): Int = {\n        \n    }\n}"
    },
    {
        "id": 2438,
        "name": "find-closest-node-to-given-two-nodes",
        "difficulty": "Medium",
        "link": "https://leetcode.com/problems/find-closest-node-to-given-two-nodes/",
        "task_description": "You are given a **directed** graph of `n` nodes numbered from `0` to `n - 1`, where each node has **at most one** outgoing edge. The graph is represented with a given **0-indexed** array `edges` of size `n`, indicating that there is a directed edge from node `i` to node `edges[i]`. If there is no outgoing edge from `i`, then `edges[i] == -1`. You are also given two integers `node1` and `node2`. Return _the **index** of the node that can be reached from both _`node1`_ and _`node2`_, such that the **maximum** between the distance from _`node1`_ to that node, and from _`node2`_ to that node is **minimized**_. If there are multiple answers, return the node with the **smallest** index, and if no possible answer exists, return `-1`. Note that `edges` may contain cycles. **Example 1:** ``` **Input:** edges = [2,2,3,-1], node1 = 0, node2 = 1 **Output:** 2 **Explanation:** The distance from node 0 to node 2 is 1, and the distance from node 1 to node 2 is 1. The maximum of those two distances is 1. It can be proven that we cannot get a node with a smaller maximum distance than 1, so we return node 2. ``` **Example 2:** ``` **Input:** edges = [1,2,-1], node1 = 0, node2 = 2 **Output:** 2 **Explanation:** The distance from node 0 to node 2 is 2, and the distance from node 2 to itself is 0. The maximum of those two distances is 2. It can be proven that we cannot get a node with a smaller maximum distance than 2, so we return node 2. ``` **Constraints:** `n == edges.length` `2 <= n <= 105` `-1 <= edges[i] < n` `edges[i] != i` `0 <= node1, node2 < n`",
        "test_case": [
            {
                "label": "Example 1",
                "input": "edges = [2,2,3,-1], node1 = 0, node2 = 1",
                "output": "2 Explanation: The distance from node 0 to node 2 is 1, and the distance from node 1 to node 2 is 1.\nThe maximum of those two distances is 1. It can be proven that we cannot get a node with a smaller maximum distance than 1, so we return node 2."
            },
            {
                "label": "Example 2",
                "input": "edges = [1,2,-1], node1 = 0, node2 = 2",
                "output": "2 Explanation: The distance from node 0 to node 2 is 2, and the distance from node 2 to itself is 0.\nThe maximum of those two distances is 2. It can be proven that we cannot get a node with a smaller maximum distance than 2, so we return node 2. Constraints: n == edges.length 2 <= n <= 10 5 -1 <= edges[i] < n edges[i] != i 0 <= node1, node2 < n"
            }
        ],
        "elixir_template": "defmodule Solution do\n  @spec closest_meeting_node(edges :: [integer], node1 :: integer, node2 :: integer) :: integer\n  def closest_meeting_node(edges, node1, node2) do\n    \n  end\nend",
        "erlang_template": "-spec closest_meeting_node(Edges :: [integer()], Node1 :: integer(), Node2 :: integer()) -> integer().\nclosest_meeting_node(Edges, Node1, Node2) ->\n  .",
        "scala_template": "object Solution {\n    def closestMeetingNode(edges: Array[Int], node1: Int, node2: Int): Int = {\n        \n    }\n}"
    },
    {
        "id": 2437,
        "name": "maximum-number-of-groups-entering-a-competition",
        "difficulty": "Medium",
        "link": "https://leetcode.com/problems/maximum-number-of-groups-entering-a-competition/",
        "task_description": "You are given a positive integer array `grades` which represents the grades of students in a university. You would like to enter **all** these students into a competition in **ordered** non-empty groups, such that the ordering meets the following conditions: The sum of the grades of students in the `ith` group is **less than** the sum of the grades of students in the `(i + 1)th` group, for all groups (except the last). The total number of students in the `ith` group is **less than** the total number of students in the `(i + 1)th` group, for all groups (except the last). Return _the **maximum** number of groups that can be formed_. **Example 1:** ``` **Input:** grades = [10,6,12,7,3,5] **Output:** 3 **Explanation:** The following is a possible way to form 3 groups of students: - 1st group has the students with grades = [12]. Sum of grades: 12. Student count: 1 - 2nd group has the students with grades = [6,7]. Sum of grades: 6 + 7 = 13. Student count: 2 - 3rd group has the students with grades = [10,3,5]. Sum of grades: 10 + 3 + 5 = 18. Student count: 3 It can be shown that it is not possible to form more than 3 groups. ``` **Example 2:** ``` **Input:** grades = [8,8] **Output:** 1 **Explanation:** We can only form 1 group, since forming 2 groups would lead to an equal number of students in both groups. ``` **Constraints:** `1 <= grades.length <= 105` `1 <= grades[i] <= 105`",
        "test_case": [
            {
                "label": "Example 1",
                "input": "grades = [10,6,12,7,3,5]",
                "output": "3 Explanation: The following is a possible way to form 3 groups of students:\n- 1 st group has the students with grades = [12]. Sum of grades: 12. Student count: 1\n- 2 nd group has the students with grades = [6,7]. Sum of grades: 6 + 7 = 13. Student count: 2\n- 3 rd group has the students with grades = [10,3,5]. Sum of grades: 10 + 3 + 5 = 18. Student count: 3\nIt can be shown that it is not possible to form more than 3 groups."
            },
            {
                "label": "Example 2",
                "input": "grades = [8,8]",
                "output": "1 Explanation: We can only form 1 group, since forming 2 groups would lead to an equal number of students in both groups."
            }
        ],
        "elixir_template": "defmodule Solution do\n  @spec maximum_groups(grades :: [integer]) :: integer\n  def maximum_groups(grades) do\n    \n  end\nend",
        "erlang_template": "-spec maximum_groups(Grades :: [integer()]) -> integer().\nmaximum_groups(Grades) ->\n  .",
        "scala_template": "object Solution {\n    def maximumGroups(grades: Array[Int]): Int = {\n        \n    }\n}"
    },
    {
        "id": 2436,
        "name": "make-array-zero-by-subtracting-equal-amounts",
        "difficulty": "Easy",
        "link": "https://leetcode.com/problems/make-array-zero-by-subtracting-equal-amounts/",
        "task_description": "You are given a non-negative integer array `nums`. In one operation, you must: Choose a positive integer `x` such that `x` is less than or equal to the **smallest non-zero** element in `nums`. Subtract `x` from every **positive** element in `nums`. Return _the **minimum** number of operations to make every element in _`nums`_ equal to _`0`. **Example 1:** ``` **Input:** nums = [1,5,0,3,5] **Output:** 3 **Explanation:** In the first operation, choose x = 1. Now, nums = [0,4,0,2,4]. In the second operation, choose x = 2. Now, nums = [0,2,0,0,2]. In the third operation, choose x = 2. Now, nums = [0,0,0,0,0]. ``` **Example 2:** ``` **Input:** nums = [0] **Output:** 0 **Explanation:** Each element in nums is already 0 so no operations are needed. ``` **Constraints:** `1 <= nums.length <= 100` `0 <= nums[i] <= 100`",
        "test_case": [
            {
                "label": "Example 1",
                "input": "nums = [1,5,0,3,5]",
                "output": "3 Explanation: In the first operation, choose x = 1. Now, nums = [0,4,0,2,4].\nIn the second operation, choose x = 2. Now, nums = [0,2,0,0,2].\nIn the third operation, choose x = 2. Now, nums = [0,0,0,0,0]."
            },
            {
                "label": "Example 2",
                "input": "nums = [0]",
                "output": "0 Explanation: Each element in nums is already 0 so no operations are needed."
            }
        ],
        "elixir_template": "defmodule Solution do\n  @spec minimum_operations(nums :: [integer]) :: integer\n  def minimum_operations(nums) do\n    \n  end\nend",
        "erlang_template": "-spec minimum_operations(Nums :: [integer()]) -> integer().\nminimum_operations(Nums) ->\n  .",
        "scala_template": "object Solution {\n    def minimumOperations(nums: Array[Int]): Int = {\n        \n    }\n}"
    },
    {
        "id": 2435,
        "name": "shortest-impossible-sequence-of-rolls",
        "difficulty": "Hard",
        "link": "https://leetcode.com/problems/shortest-impossible-sequence-of-rolls/",
        "task_description": "You are given an integer array `rolls` of length `n` and an integer `k`. You roll a `k` sided dice numbered from `1` to `k`, `n` times, where the result of the `ith` roll is `rolls[i]`. Return_ the length of the **shortest** sequence of rolls so that there's no such subsequence in _`rolls`. A **sequence of rolls** of length `len` is the result of rolling a `k` sided dice `len` times. **Example 1:** ``` **Input:** rolls = [4,2,1,2,3,3,2,4,1], k = 4 **Output:** 3 **Explanation:** Every sequence of rolls of length 1, [1], [2], [3], [4], can be taken from rolls. Every sequence of rolls of length 2, [1, 1], [1, 2], ..., [4, 4], can be taken from rolls. The sequence [1, 4, 2] cannot be taken from rolls, so we return 3. Note that there are other sequences that cannot be taken from rolls. ``` **Example 2:** ``` **Input:** rolls = [1,1,2,2], k = 2 **Output:** 2 **Explanation:** Every sequence of rolls of length 1, [1], [2], can be taken from rolls. The sequence [2, 1] cannot be taken from rolls, so we return 2. Note that there are other sequences that cannot be taken from rolls but [2, 1] is the shortest. ``` **Example 3:** ``` **Input:** rolls = [1,1,3,2,2,2,3,3], k = 4 **Output:** 1 **Explanation:** The sequence [4] cannot be taken from rolls, so we return 1. Note that there are other sequences that cannot be taken from rolls but [4] is the shortest. ``` **Constraints:** `n == rolls.length` `1 <= n <= 105` `1 <= rolls[i] <= k <= 105`",
        "test_case": [
            {
                "label": "Example 1",
                "input": "rolls = [4,2,1,2,3,3,2,4,1], k = 4",
                "output": "3 Explanation: Every sequence of rolls of length 1, [1], [2], [3], [4], can be taken from rolls.\nEvery sequence of rolls of length 2, [1, 1], [1, 2], ..., [4, 4], can be taken from rolls.\nThe sequence [1, 4, 2] cannot be taken from rolls, so we return 3.\nNote that there are other sequences that cannot be taken from rolls."
            },
            {
                "label": "Example 2",
                "input": "rolls = [1,1,2,2], k = 2",
                "output": "2 Explanation: Every sequence of rolls of length 1, [1], [2], can be taken from rolls.\nThe sequence [2, 1] cannot be taken from rolls, so we return 2.\nNote that there are other sequences that cannot be taken from rolls but [2, 1] is the shortest."
            },
            {
                "label": "Example 3",
                "input": "rolls = [1,1,3,2,2,2,3,3], k = 4",
                "output": "1 Explanation: The sequence [4] cannot be taken from rolls, so we return 1.\nNote that there are other sequences that cannot be taken from rolls but [4] is the shortest. Constraints: n == rolls.length 1 <= n <= 10 5 1 <= rolls[i] <= k <= 10 5"
            }
        ],
        "elixir_template": "defmodule Solution do\n  @spec shortest_sequence(rolls :: [integer], k :: integer) :: integer\n  def shortest_sequence(rolls, k) do\n    \n  end\nend",
        "erlang_template": "-spec shortest_sequence(Rolls :: [integer()], K :: integer()) -> integer().\nshortest_sequence(Rolls, K) ->\n  .",
        "scala_template": "object Solution {\n    def shortestSequence(rolls: Array[Int], k: Int): Int = {\n        \n    }\n}"
    },
    {
        "id": 2434,
        "name": "design-a-number-container-system",
        "difficulty": "Medium",
        "link": "https://leetcode.com/problems/design-a-number-container-system/",
        "task_description": "Design a number container system that can do the following: **Insert **or **Replace** a number at the given index in the system. **Return **the smallest index for the given number in the system. Implement the `NumberContainers` class: `NumberContainers()` Initializes the number container system. `void change(int index, int number)` Fills the container at `index` with the `number`. If there is already a number at that `index`, replace it. `int find(int number)` Returns the smallest index for the given `number`, or `-1` if there is no index that is filled by `number` in the system. **Example 1:** ``` **Input** [\"NumberContainers\", \"find\", \"change\", \"change\", \"change\", \"change\", \"find\", \"change\", \"find\"] [[], [10], [2, 10], [1, 10], [3, 10], [5, 10], [10], [1, 20], [10]] **Output** [null, -1, null, null, null, null, 1, null, 2] **Explanation** NumberContainers nc = new NumberContainers(); nc.find(10); // There is no index that is filled with number 10. Therefore, we return -1. nc.change(2, 10); // Your container at index 2 will be filled with number 10. nc.change(1, 10); // Your container at index 1 will be filled with number 10. nc.change(3, 10); // Your container at index 3 will be filled with number 10. nc.change(5, 10); // Your container at index 5 will be filled with number 10. nc.find(10); // Number 10 is at the indices 1, 2, 3, and 5. Since the smallest index that is filled with 10 is 1, we return 1. nc.change(1, 20); // Your container at index 1 will be filled with number 20. Note that index 1 was filled with 10 and then replaced with 20. nc.find(10); // Number 10 is at the indices 2, 3, and 5. The smallest index that is filled with 10 is 2. Therefore, we return 2. ``` **Constraints:** `1 <= index, number <= 109` At most `105` calls will be made **in total** to `change` and `find`.",
        "test_case": [],
        "elixir_template": "defmodule NumberContainers do\n  @spec init_() :: any\n  def init_() do\n    \n  end\n\n  @spec change(index :: integer, number :: integer) :: any\n  def change(index, number) do\n    \n  end\n\n  @spec find(number :: integer) :: integer\n  def find(number) do\n    \n  end\nend\n\n# Your functions will be called as such:\n# NumberContainers.init_()\n# NumberContainers.change(index, number)\n# param_2 = NumberContainers.find(number)\n\n# NumberContainers.init_ will be called before every test case, in which you can do some necessary initializations.",
        "erlang_template": "-spec number_containers_init_() -> any().\nnumber_containers_init_() ->\n  .\n\n-spec number_containers_change(Index :: integer(), Number :: integer()) -> any().\nnumber_containers_change(Index, Number) ->\n  .\n\n-spec number_containers_find(Number :: integer()) -> integer().\nnumber_containers_find(Number) ->\n  .\n\n\n%% Your functions will be called as such:\n%% number_containers_init_(),\n%% number_containers_change(Index, Number),\n%% Param_2 = number_containers_find(Number),\n\n%% number_containers_init_ will be called before every test case, in which you can do some necessary initializations.",
        "scala_template": "class NumberContainers() {\n\n    def change(index: Int, number: Int): Unit = {\n        \n    }\n\n    def find(number: Int): Int = {\n        \n    }\n\n}\n\n/**\n * Your NumberContainers object will be instantiated and called as such:\n * val obj = new NumberContainers()\n * obj.change(index,number)\n * val param_2 = obj.find(number)\n */"
    },
    {
        "id": 2433,
        "name": "best-poker-hand",
        "difficulty": "Easy",
        "link": "https://leetcode.com/problems/best-poker-hand/",
        "task_description": "You are given an integer array `ranks` and a character array `suits`. You have `5` cards where the `ith` card has a rank of `ranks[i]` and a suit of `suits[i]`. The following are the types of **poker hands** you can make from best to worst: `\"Flush\"`: Five cards of the same suit. `\"Three of a Kind\"`: Three cards of the same rank. `\"Pair\"`: Two cards of the same rank. `\"High Card\"`: Any single card. Return _a string representing the **best** type of **poker hand** you can make with the given cards._ **Note** that the return values are **case-sensitive**. **Example 1:** ``` **Input:** ranks = [13,2,3,1,9], suits = [\"a\",\"a\",\"a\",\"a\",\"a\"] **Output:** \"Flush\" **Explanation:** The hand with all the cards consists of 5 cards with the same suit, so we have a \"Flush\". ``` **Example 2:** ``` **Input:** ranks = [4,4,2,4,4], suits = [\"d\",\"a\",\"a\",\"b\",\"c\"] **Output:** \"Three of a Kind\" **Explanation:** The hand with the first, second, and fourth card consists of 3 cards with the same rank, so we have a \"Three of a Kind\". Note that we could also make a \"Pair\" hand but \"Three of a Kind\" is a better hand. Also note that other cards could be used to make the \"Three of a Kind\" hand. ``` **Example 3:** ``` **Input:** ranks = [10,10,2,12,9], suits = [\"a\",\"b\",\"c\",\"a\",\"d\"] **Output:** \"Pair\" **Explanation:** The hand with the first and second card consists of 2 cards with the same rank, so we have a \"Pair\". Note that we cannot make a \"Flush\" or a \"Three of a Kind\". ``` **Constraints:** `ranks.length == suits.length == 5` `1 <= ranks[i] <= 13` `'a' <= suits[i] <= 'd'` No two cards have the same rank and suit.",
        "test_case": [
            {
                "label": "Example 1",
                "input": "ranks = [13,2,3,1,9], suits = [\"a\",\"a\",\"a\",\"a\",\"a\"]",
                "output": "\"Flush\" Explanation: The hand with all the cards consists of 5 cards with the same suit, so we have a \"Flush\"."
            },
            {
                "label": "Example 2",
                "input": "ranks = [4,4,2,4,4], suits = [\"d\",\"a\",\"a\",\"b\",\"c\"]",
                "output": "\"Three of a Kind\" Explanation: The hand with the first, second, and fourth card consists of 3 cards with the same rank, so we have a \"Three of a Kind\".\nNote that we could also make a \"Pair\" hand but \"Three of a Kind\" is a better hand.\nAlso note that other cards could be used to make the \"Three of a Kind\" hand."
            },
            {
                "label": "Example 3",
                "input": "ranks = [10,10,2,12,9], suits = [\"a\",\"b\",\"c\",\"a\",\"d\"]",
                "output": "\"Pair\" Explanation: The hand with the first and second card consists of 2 cards with the same rank, so we have a \"Pair\".\nNote that we cannot make a \"Flush\" or a \"Three of a Kind\". Constraints: ranks.length == suits.length == 5 1 <= ranks[i] <= 13 'a' <= suits[i] <= 'd' No two cards have the same rank and suit."
            }
        ],
        "elixir_template": "defmodule Solution do\n  @spec best_hand(ranks :: [integer], suits :: [char]) :: String.t\n  def best_hand(ranks, suits) do\n    \n  end\nend",
        "erlang_template": "-spec best_hand(Ranks :: [integer()], Suits :: [char()]) -> unicode:unicode_binary().\nbest_hand(Ranks, Suits) ->\n  .",
        "scala_template": "object Solution {\n    def bestHand(ranks: Array[Int], suits: Array[Char]): String = {\n        \n    }\n}"
    },
    {
        "id": 2432,
        "name": "number-of-zero-filled-subarrays",
        "difficulty": "Medium",
        "link": "https://leetcode.com/problems/number-of-zero-filled-subarrays/",
        "task_description": "Given an integer array `nums`, return _the number of **subarrays** filled with _`0`. A **subarray** is a contiguous non-empty sequence of elements within an array. **Example 1:** ``` **Input:** nums = [1,3,0,0,2,0,0,4] **Output:** 6 **Explanation:** There are 4 occurrences of [0] as a subarray. There are 2 occurrences of [0,0] as a subarray. There is no occurrence of a subarray with a size more than 2 filled with 0. Therefore, we return 6. ``` **Example 2:** ``` **Input:** nums = [0,0,0,2,0,0] **Output:** 9 **Explanation: **There are 5 occurrences of [0] as a subarray. There are 3 occurrences of [0,0] as a subarray. There is 1 occurrence of [0,0,0] as a subarray. There is no occurrence of a subarray with a size more than 3 filled with 0. Therefore, we return 9. ``` **Example 3:** ``` **Input:** nums = [2,10,2019] **Output:** 0 **Explanation:** There is no subarray filled with 0. Therefore, we return 0. ``` **Constraints:** `1 <= nums.length <= 105` `-109 <= nums[i] <= 109`",
        "test_case": [
            {
                "label": "Example 1",
                "input": "nums = [1,3,0,0,2,0,0,4]",
                "output": "6 Explanation: There are 4 occurrences of [0] as a subarray.\nThere are 2 occurrences of [0,0] as a subarray.\nThere is no occurrence of a subarray with a size more than 2 filled with 0. Therefore, we return 6."
            },
            {
                "label": "Example 2",
                "input": "nums = [0,0,0,2,0,0]",
                "output": "9 Explanation: There are 5 occurrences of [0] as a subarray.\nThere are 3 occurrences of [0,0] as a subarray.\nThere is 1 occurrence of [0,0,0] as a subarray.\nThere is no occurrence of a subarray with a size more than 3 filled with 0. Therefore, we return 9."
            },
            {
                "label": "Example 3",
                "input": "nums = [2,10,2019]",
                "output": "0 Explanation: There is no subarray filled with 0. Therefore, we return 0."
            }
        ],
        "elixir_template": "defmodule Solution do\n  @spec zero_filled_subarray(nums :: [integer]) :: integer\n  def zero_filled_subarray(nums) do\n    \n  end\nend",
        "erlang_template": "-spec zero_filled_subarray(Nums :: [integer()]) -> integer().\nzero_filled_subarray(Nums) ->\n  .",
        "scala_template": "object Solution {\n    def zeroFilledSubarray(nums: Array[Int]): Long = {\n        \n    }\n}"
    },
    {
        "id": 2430,
        "name": "number-of-excellent-pairs",
        "difficulty": "Hard",
        "link": "https://leetcode.com/problems/number-of-excellent-pairs/",
        "task_description": "You are given a **0-indexed** positive integer array `nums` and a positive integer `k`. A pair of numbers `(num1, num2)` is called **excellent** if the following conditions are satisfied: **Both** the numbers `num1` and `num2` exist in the array `nums`. The sum of the number of set bits in `num1 OR num2` and `num1 AND num2` is greater than or equal to `k`, where `OR` is the bitwise **OR** operation and `AND` is the bitwise **AND** operation. Return _the number of **distinct** excellent pairs_. Two pairs `(a, b)` and `(c, d)` are considered distinct if either `a != c` or `b != d`. For example, `(1, 2)` and `(2, 1)` are distinct. **Note** that a pair `(num1, num2)` such that `num1 == num2` can also be excellent if you have at least **one** occurrence of `num1` in the array. **Example 1:** ``` **Input:** nums = [1,2,3,1], k = 3 **Output:** 5 **Explanation:** The excellent pairs are the following: - (3, 3). (3 AND 3) and (3 OR 3) are both equal to (11) in binary. The total number of set bits is 2 + 2 = 4, which is greater than or equal to k = 3. - (2, 3) and (3, 2). (2 AND 3) is equal to (10) in binary, and (2 OR 3) is equal to (11) in binary. The total number of set bits is 1 + 2 = 3. - (1, 3) and (3, 1). (1 AND 3) is equal to (01) in binary, and (1 OR 3) is equal to (11) in binary. The total number of set bits is 1 + 2 = 3. So the number of excellent pairs is 5. ``` **Example 2:** ``` **Input:** nums = [5,1,1], k = 10 **Output:** 0 **Explanation:** There are no excellent pairs for this array. ``` **Constraints:** `1 <= nums.length <= 105` `1 <= nums[i] <= 109` `1 <= k <= 60`",
        "test_case": [
            {
                "label": "Example 1",
                "input": "nums = [1,2,3,1], k = 3",
                "output": "5 Explanation: The excellent pairs are the following:\n- (3, 3). (3 AND 3) and (3 OR 3) are both equal to (11) in binary. The total number of set bits is 2 + 2 = 4, which is greater than or equal to k = 3.\n- (2, 3) and (3, 2). (2 AND 3) is equal to (10) in binary, and (2 OR 3) is equal to (11) in binary. The total number of set bits is 1 + 2 = 3.\n- (1, 3) and (3, 1). (1 AND 3) is equal to (01) in binary, and (1 OR 3) is equal to (11) in binary. The total number of set bits is 1 + 2 = 3.\nSo the number of excellent pairs is 5."
            },
            {
                "label": "Example 2",
                "input": "nums = [5,1,1], k = 10",
                "output": "0 Explanation: There are no excellent pairs for this array."
            }
        ],
        "elixir_template": "defmodule Solution do\n  @spec count_excellent_pairs(nums :: [integer], k :: integer) :: integer\n  def count_excellent_pairs(nums, k) do\n    \n  end\nend",
        "erlang_template": "-spec count_excellent_pairs(Nums :: [integer()], K :: integer()) -> integer().\ncount_excellent_pairs(Nums, K) ->\n  .",
        "scala_template": "object Solution {\n    def countExcellentPairs(nums: Array[Int], k: Int): Long = {\n        \n    }\n}"
    },
    {
        "id": 2429,
        "name": "design-a-food-rating-system",
        "difficulty": "Medium",
        "link": "https://leetcode.com/problems/design-a-food-rating-system/",
        "task_description": "Design a food rating system that can do the following: **Modify** the rating of a food item listed in the system. Return the highest-rated food item for a type of cuisine in the system. Implement the `FoodRatings` class: `FoodRatings(String[] foods, String[] cuisines, int[] ratings)` Initializes the system. The food items are described by `foods`, `cuisines` and `ratings`, all of which have a length of `n`. `foods[i]` is the name of the `ith` food, `cuisines[i]` is the type of cuisine of the `ith` food, and `ratings[i]` is the initial rating of the `ith` food. `void changeRating(String food, int newRating)` Changes the rating of the food item with the name `food`. `String highestRated(String cuisine)` Returns the name of the food item that has the highest rating for the given type of `cuisine`. If there is a tie, return the item with the **lexicographically smaller** name. Note that a string `x` is lexicographically smaller than string `y` if `x` comes before `y` in dictionary order, that is, either `x` is a prefix of `y`, or if `i` is the first position such that `x[i] != y[i]`, then `x[i]` comes before `y[i]` in alphabetic order. **Example 1:** ``` **Input** [\"FoodRatings\", \"highestRated\", \"highestRated\", \"changeRating\", \"highestRated\", \"changeRating\", \"highestRated\"] [[[\"kimchi\", \"miso\", \"sushi\", \"moussaka\", \"ramen\", \"bulgogi\"], [\"korean\", \"japanese\", \"japanese\", \"greek\", \"japanese\", \"korean\"], [9, 12, 8, 15, 14, 7]], [\"korean\"], [\"japanese\"], [\"sushi\", 16], [\"japanese\"], [\"ramen\", 16], [\"japanese\"]] **Output** [null, \"kimchi\", \"ramen\", null, \"sushi\", null, \"ramen\"] **Explanation** FoodRatings foodRatings = new FoodRatings([\"kimchi\", \"miso\", \"sushi\", \"moussaka\", \"ramen\", \"bulgogi\"], [\"korean\", \"japanese\", \"japanese\", \"greek\", \"japanese\", \"korean\"], [9, 12, 8, 15, 14, 7]); foodRatings.highestRated(\"korean\"); // return \"kimchi\" // \"kimchi\" is the highest rated korean food with a rating of 9. foodRatings.highestRated(\"japanese\"); // return \"ramen\" // \"ramen\" is the highest rated japanese food with a rating of 14. foodRatings.changeRating(\"sushi\", 16); // \"sushi\" now has a rating of 16. foodRatings.highestRated(\"japanese\"); // return \"sushi\" // \"sushi\" is the highest rated japanese food with a rating of 16. foodRatings.changeRating(\"ramen\", 16); // \"ramen\" now has a rating of 16. foodRatings.highestRated(\"japanese\"); // return \"ramen\" // Both \"sushi\" and \"ramen\" have a rating of 16. // However, \"ramen\" is lexicographically smaller than \"sushi\". ``` **Constraints:** `1 <= n <= 2 * 104` `n == foods.length == cuisines.length == ratings.length` `1 <= foods[i].length, cuisines[i].length <= 10` `foods[i]`, `cuisines[i]` consist of lowercase English letters. `1 <= ratings[i] <= 108` All the strings in `foods` are **distinct**. `food` will be the name of a food item in the system across all calls to `changeRating`. `cuisine` will be a type of cuisine of **at least one** food item in the system across all calls to `highestRated`. At most `2 * 104` calls **in total** will be made to `changeRating` and `highestRated`.",
        "test_case": [],
        "elixir_template": "defmodule FoodRatings do\n  @spec init_(foods :: [String.t], cuisines :: [String.t], ratings :: [integer]) :: any\n  def init_(foods, cuisines, ratings) do\n    \n  end\n\n  @spec change_rating(food :: String.t, new_rating :: integer) :: any\n  def change_rating(food, new_rating) do\n    \n  end\n\n  @spec highest_rated(cuisine :: String.t) :: String.t\n  def highest_rated(cuisine) do\n    \n  end\nend\n\n# Your functions will be called as such:\n# FoodRatings.init_(foods, cuisines, ratings)\n# FoodRatings.change_rating(food, new_rating)\n# param_2 = FoodRatings.highest_rated(cuisine)\n\n# FoodRatings.init_ will be called before every test case, in which you can do some necessary initializations.",
        "erlang_template": "-spec food_ratings_init_(Foods :: [unicode:unicode_binary()], Cuisines :: [unicode:unicode_binary()], Ratings :: [integer()]) -> any().\nfood_ratings_init_(Foods, Cuisines, Ratings) ->\n  .\n\n-spec food_ratings_change_rating(Food :: unicode:unicode_binary(), NewRating :: integer()) -> any().\nfood_ratings_change_rating(Food, NewRating) ->\n  .\n\n-spec food_ratings_highest_rated(Cuisine :: unicode:unicode_binary()) -> unicode:unicode_binary().\nfood_ratings_highest_rated(Cuisine) ->\n  .\n\n\n%% Your functions will be called as such:\n%% food_ratings_init_(Foods, Cuisines, Ratings),\n%% food_ratings_change_rating(Food, NewRating),\n%% Param_2 = food_ratings_highest_rated(Cuisine),\n\n%% food_ratings_init_ will be called before every test case, in which you can do some necessary initializations.",
        "scala_template": "class FoodRatings(_foods: Array[String], _cuisines: Array[String], _ratings: Array[Int]) {\n\n    def changeRating(food: String, newRating: Int): Unit = {\n        \n    }\n\n    def highestRated(cuisine: String): String = {\n        \n    }\n\n}\n\n/**\n * Your FoodRatings object will be instantiated and called as such:\n * val obj = new FoodRatings(foods, cuisines, ratings)\n * obj.changeRating(food,newRating)\n * val param_2 = obj.highestRated(cuisine)\n */"
    },
    {
        "id": 2428,
        "name": "equal-row-and-column-pairs",
        "difficulty": "Medium",
        "link": "https://leetcode.com/problems/equal-row-and-column-pairs/",
        "task_description": "Given a **0-indexed** `n x n` integer matrix `grid`, _return the number of pairs _`(ri, cj)`_ such that row _`ri`_ and column _`cj`_ are equal_. A row and column pair is considered equal if they contain the same elements in the same order (i.e., an equal array). **Example 1:** ``` **Input:** grid = [[3,2,1],[1,7,6],[2,7,7]] **Output:** 1 **Explanation:** There is 1 equal row and column pair: - (Row 2, Column 1): [2,7,7] ``` **Example 2:** ``` **Input:** grid = [[3,1,2,2],[1,4,4,5],[2,4,2,2],[2,4,2,2]] **Output:** 3 **Explanation:** There are 3 equal row and column pairs: - (Row 0, Column 0): [3,1,2,2] - (Row 2, Column 2): [2,4,2,2] - (Row 3, Column 2): [2,4,2,2] ``` **Constraints:** `n == grid.length == grid[i].length` `1 <= n <= 200` `1 <= grid[i][j] <= 105`",
        "test_case": [
            {
                "label": "Example 1",
                "input": "grid = [[3,2,1],[1,7,6],[2,7,7]]",
                "output": "1 Explanation: There is 1 equal row and column pair:\n- (Row 2, Column 1): [2,7,7]"
            },
            {
                "label": "Example 2",
                "input": "grid = [[3,1,2,2],[1,4,4,5],[2,4,2,2],[2,4,2,2]]",
                "output": "3 Explanation: There are 3 equal row and column pairs:\n- (Row 0, Column 0): [3,1,2,2]\n- (Row 2, Column 2): [2,4,2,2]\n- (Row 3, Column 2): [2,4,2,2] Constraints: n == grid.length == grid[i].length 1 <= n <= 200 1 <= grid[i][j] <= 10 5"
            }
        ],
        "elixir_template": "defmodule Solution do\n  @spec equal_pairs(grid :: [[integer]]) :: integer\n  def equal_pairs(grid) do\n    \n  end\nend",
        "erlang_template": "-spec equal_pairs(Grid :: [[integer()]]) -> integer().\nequal_pairs(Grid) ->\n  .",
        "scala_template": "object Solution {\n    def equalPairs(grid: Array[Array[Int]]): Int = {\n        \n    }\n}"
    },
    {
        "id": 2427,
        "name": "first-letter-to-appear-twice",
        "difficulty": "Easy",
        "link": "https://leetcode.com/problems/first-letter-to-appear-twice/",
        "task_description": "Given a string `s` consisting of lowercase English letters, return _the first letter to appear **twice**_. **Note**: A letter `a` appears twice before another letter `b` if the **second** occurrence of `a` is before the **second** occurrence of `b`. `s` will contain at least one letter that appears twice. **Example 1:** ``` **Input:** s = \"abccbaacz\" **Output:** \"c\" **Explanation:** The letter 'a' appears on the indexes 0, 5 and 6. The letter 'b' appears on the indexes 1 and 4. The letter 'c' appears on the indexes 2, 3 and 7. The letter 'z' appears on the index 8. The letter 'c' is the first letter to appear twice, because out of all the letters the index of its second occurrence is the smallest. ``` **Example 2:** ``` **Input:** s = \"abcdd\" **Output:** \"d\" **Explanation:** The only letter that appears twice is 'd' so we return 'd'. ``` **Constraints:** `2 <= s.length <= 100` `s` consists of lowercase English letters. `s` has at least one repeated letter.",
        "test_case": [
            {
                "label": "Example 1",
                "input": "s = \"abccbaacz\"",
                "output": "\"c\" Explanation: The letter 'a' appears on the indexes 0, 5 and 6.\nThe letter 'b' appears on the indexes 1 and 4.\nThe letter 'c' appears on the indexes 2, 3 and 7.\nThe letter 'z' appears on the index 8.\nThe letter 'c' is the first letter to appear twice, because out of all the letters the index of its second occurrence is the smallest."
            },
            {
                "label": "Example 2",
                "input": "s = \"abcdd\"",
                "output": "\"d\" Explanation: The only letter that appears twice is 'd' so we return 'd'."
            }
        ],
        "elixir_template": "defmodule Solution do\n  @spec repeated_character(s :: String.t) :: char\n  def repeated_character(s) do\n    \n  end\nend",
        "erlang_template": "-spec repeated_character(S :: unicode:unicode_binary()) -> char().\nrepeated_character(S) ->\n  .",
        "scala_template": "object Solution {\n    def repeatedCharacter(s: String): Char = {\n        \n    }\n}"
    },
    {
        "id": 2423,
        "name": "minimum-deletions-to-make-array-divisible",
        "difficulty": "Hard",
        "link": "https://leetcode.com/problems/minimum-deletions-to-make-array-divisible/",
        "task_description": "You are given two positive integer arrays `nums` and `numsDivide`. You can delete any number of elements from `nums`. Return _the **minimum** number of deletions such that the **smallest** element in _`nums`_ **divides** all the elements of _`numsDivide`. If this is not possible, return `-1`. Note that an integer `x` divides `y` if `y % x == 0`. **Example 1:** ``` **Input:** nums = [2,3,2,4,3], numsDivide = [9,6,9,3,15] **Output:** 2 **Explanation:** The smallest element in [2,3,2,4,3] is 2, which does not divide all the elements of numsDivide. We use 2 deletions to delete the elements in nums that are equal to 2 which makes nums = [3,4,3]. The smallest element in [3,4,3] is 3, which divides all the elements of numsDivide. It can be shown that 2 is the minimum number of deletions needed. ``` **Example 2:** ``` **Input:** nums = [4,3,6], numsDivide = [8,2,6,10] **Output:** -1 **Explanation:** We want the smallest element in nums to divide all the elements of numsDivide. There is no way to delete elements from nums to allow this. ``` **Constraints:** `1 <= nums.length, numsDivide.length <= 105` `1 <= nums[i], numsDivide[i] <= 109`",
        "test_case": [
            {
                "label": "Example 1",
                "input": "nums = [2,3,2,4,3], numsDivide = [9,6,9,3,15]",
                "output": "2 Explanation: The smallest element in [2,3,2,4,3] is 2, which does not divide all the elements of numsDivide.\nWe use 2 deletions to delete the elements in nums that are equal to 2 which makes nums = [3,4,3].\nThe smallest element in [3,4,3] is 3, which divides all the elements of numsDivide.\nIt can be shown that 2 is the minimum number of deletions needed."
            },
            {
                "label": "Example 2",
                "input": "nums = [4,3,6], numsDivide = [8,2,6,10]",
                "output": "-1 Explanation: We want the smallest element in nums to divide all the elements of numsDivide.\nThere is no way to delete elements from nums to allow this."
            }
        ],
        "elixir_template": "defmodule Solution do\n  @spec min_operations(nums :: [integer], nums_divide :: [integer]) :: integer\n  def min_operations(nums, nums_divide) do\n    \n  end\nend",
        "erlang_template": "-spec min_operations(Nums :: [integer()], NumsDivide :: [integer()]) -> integer().\nmin_operations(Nums, NumsDivide) ->\n  .",
        "scala_template": "object Solution {\n    def minOperations(nums: Array[Int], numsDivide: Array[Int]): Int = {\n        \n    }\n}"
    },
    {
        "id": 2422,
        "name": "query-kth-smallest-trimmed-number",
        "difficulty": "Medium",
        "link": "https://leetcode.com/problems/query-kth-smallest-trimmed-number/",
        "task_description": "You are given a **0-indexed** array of strings `nums`, where each string is of **equal length** and consists of only digits. You are also given a **0-indexed** 2D integer array `queries` where `queries[i] = [ki, trimi]`. For each `queries[i]`, you need to: **Trim** each number in `nums` to its **rightmost** `trimi` digits. Determine the **index** of the `kith` smallest trimmed number in `nums`. If two trimmed numbers are equal, the number with the **lower** index is considered to be smaller. Reset each number in `nums` to its original length. Return _an array _`answer`_ of the same length as _`queries`,_ where _`answer[i]`_ is the answer to the _`ith`_ query._ **Note**: To trim to the rightmost `x` digits means to keep removing the leftmost digit, until only `x` digits remain. Strings in `nums` may contain leading zeros. **Example 1:** ``` **Input:** nums = [\"102\",\"473\",\"251\",\"814\"], queries = [[1,1],[2,3],[4,2],[1,2]] **Output:** [2,2,1,0] **Explanation:** 1. After trimming to the last digit, nums = [\"2\",\"3\",\"1\",\"4\"]. The smallest number is 1 at index 2. 2. Trimmed to the last 3 digits, nums is unchanged. The 2nd smallest number is 251 at index 2. 3. Trimmed to the last 2 digits, nums = [\"02\",\"73\",\"51\",\"14\"]. The 4th smallest number is 73. 4. Trimmed to the last 2 digits, the smallest number is 2 at index 0. Note that the trimmed number \"02\" is evaluated as 2. ``` **Example 2:** ``` **Input:** nums = [\"24\",\"37\",\"96\",\"04\"], queries = [[2,1],[2,2]] **Output:** [3,0] **Explanation:** 1. Trimmed to the last digit, nums = [\"4\",\"7\",\"6\",\"4\"]. The 2nd smallest number is 4 at index 3. There are two occurrences of 4, but the one at index 0 is considered smaller than the one at index 3. 2. Trimmed to the last 2 digits, nums is unchanged. The 2nd smallest number is 24. ``` **Constraints:** `1 <= nums.length <= 100` `1 <= nums[i].length <= 100` `nums[i]` consists of only digits. All `nums[i].length` are **equal**. `1 <= queries.length <= 100` `queries[i].length == 2` `1 <= ki <= nums.length` `1 <= trimi <= nums[i].length` **Follow up:** Could you use the **Radix Sort Algorithm** to solve this problem? What will be the complexity of that solution?",
        "test_case": [
            {
                "label": "Example 1",
                "input": "nums = [\"102\",\"473\",\"251\",\"814\"], queries = [[1,1],[2,3],[4,2],[1,2]]",
                "output": "[2,2,1,0] Explanation: 1. After trimming to the last digit, nums = [\"2\",\"3\",\"1\",\"4\"]. The smallest number is 1 at index 2.\n2. Trimmed to the last 3 digits, nums is unchanged. The 2 nd smallest number is 251 at index 2.\n3. Trimmed to the last 2 digits, nums = [\"02\",\"73\",\"51\",\"14\"]. The 4 th smallest number is 73.\n4. Trimmed to the last 2 digits, the smallest number is 2 at index 0.\n   Note that the trimmed number \"02\" is evaluated as 2."
            },
            {
                "label": "Example 2",
                "input": "nums = [\"24\",\"37\",\"96\",\"04\"], queries = [[2,1],[2,2]]",
                "output": "[3,0] Explanation: 1. Trimmed to the last digit, nums = [\"4\",\"7\",\"6\",\"4\"]. The 2 nd smallest number is 4 at index 3.\n   There are two occurrences of 4, but the one at index 0 is considered smaller than the one at index 3.\n2. Trimmed to the last 2 digits, nums is unchanged. The 2 nd smallest number is 24."
            }
        ],
        "elixir_template": "defmodule Solution do\n  @spec smallest_trimmed_numbers(nums :: [String.t], queries :: [[integer]]) :: [integer]\n  def smallest_trimmed_numbers(nums, queries) do\n    \n  end\nend",
        "erlang_template": "-spec smallest_trimmed_numbers(Nums :: [unicode:unicode_binary()], Queries :: [[integer()]]) -> [integer()].\nsmallest_trimmed_numbers(Nums, Queries) ->\n  .",
        "scala_template": "object Solution {\n    def smallestTrimmedNumbers(nums: Array[String], queries: Array[Array[Int]]): Array[Int] = {\n        \n    }\n}"
    },
    {
        "id": 2421,
        "name": "maximum-number-of-pairs-in-array",
        "difficulty": "Easy",
        "link": "https://leetcode.com/problems/maximum-number-of-pairs-in-array/",
        "task_description": "You are given a **0-indexed** integer array `nums`. In one operation, you may do the following: Choose **two** integers in `nums` that are **equal**. Remove both integers from `nums`, forming a **pair**. The operation is done on `nums` as many times as possible. Return _a **0-indexed** integer array _`answer`_ of size _`2`_ where _`answer[0]`_ is the number of pairs that are formed and _`answer[1]`_ is the number of leftover integers in _`nums`_ after doing the operation as many times as possible_. **Example 1:** ``` **Input:** nums = [1,3,2,1,3,2,2] **Output:** [3,1] **Explanation:** Form a pair with nums[0] and nums[3] and remove them from nums. Now, nums = [3,2,3,2,2]. Form a pair with nums[0] and nums[2] and remove them from nums. Now, nums = [2,2,2]. Form a pair with nums[0] and nums[1] and remove them from nums. Now, nums = [2]. No more pairs can be formed. A total of 3 pairs have been formed, and there is 1 number leftover in nums. ``` **Example 2:** ``` **Input:** nums = [1,1] **Output:** [1,0] **Explanation:** Form a pair with nums[0] and nums[1] and remove them from nums. Now, nums = []. No more pairs can be formed. A total of 1 pair has been formed, and there are 0 numbers leftover in nums. ``` **Example 3:** ``` **Input:** nums = [0] **Output:** [0,1] **Explanation:** No pairs can be formed, and there is 1 number leftover in nums. ``` **Constraints:** `1 <= nums.length <= 100` `0 <= nums[i] <= 100`",
        "test_case": [
            {
                "label": "Example 1",
                "input": "nums = [1,3,2,1,3,2,2]",
                "output": "[3,1] Explanation: Form a pair with nums[0] and nums[3] and remove them from nums. Now, nums = [3,2,3,2,2].\nForm a pair with nums[0] and nums[2] and remove them from nums. Now, nums = [2,2,2].\nForm a pair with nums[0] and nums[1] and remove them from nums. Now, nums = [2].\nNo more pairs can be formed. A total of 3 pairs have been formed, and there is 1 number leftover in nums."
            },
            {
                "label": "Example 2",
                "input": "nums = [1,1]",
                "output": "[1,0] Explanation: Form a pair with nums[0] and nums[1] and remove them from nums. Now, nums = [].\nNo more pairs can be formed. A total of 1 pair has been formed, and there are 0 numbers leftover in nums."
            },
            {
                "label": "Example 3",
                "input": "nums = [0]",
                "output": "[0,1] Explanation: No pairs can be formed, and there is 1 number leftover in nums."
            }
        ],
        "elixir_template": "defmodule Solution do\n  @spec number_of_pairs(nums :: [integer]) :: [integer]\n  def number_of_pairs(nums) do\n    \n  end\nend",
        "erlang_template": "-spec number_of_pairs(Nums :: [integer()]) -> [integer()].\nnumber_of_pairs(Nums) ->\n  .",
        "scala_template": "object Solution {\n    def numberOfPairs(nums: Array[Int]): Array[Int] = {\n        \n    }\n}"
    },
    {
        "id": 2419,
        "name": "subarray-with-elements-greater-than-varying-threshold",
        "difficulty": "Hard",
        "link": "https://leetcode.com/problems/subarray-with-elements-greater-than-varying-threshold/",
        "task_description": "You are given an integer array `nums` and an integer `threshold`. Find any subarray of `nums` of length `k` such that **every** element in the subarray is **greater** than `threshold / k`. Return_ the **size** of **any** such subarray_. If there is no such subarray, return `-1`. A **subarray** is a contiguous non-empty sequence of elements within an array. **Example 1:** ``` **Input:** nums = [1,3,4,3,1], threshold = 6 **Output:** 3 **Explanation:** The subarray [3,4,3] has a size of 3, and every element is greater than 6 / 3 = 2. Note that this is the only valid subarray. ``` **Example 2:** ``` **Input:** nums = [6,5,6,5,8], threshold = 7 **Output:** 1 **Explanation:** The subarray [8] has a size of 1, and 8 > 7 / 1 = 7. So 1 is returned. Note that the subarray [6,5] has a size of 2, and every element is greater than 7 / 2 = 3.5. Similarly, the subarrays [6,5,6], [6,5,6,5], [6,5,6,5,8] also satisfy the given conditions. Therefore, 2, 3, 4, or 5 may also be returned. ``` **Constraints:** `1 <= nums.length <= 105` `1 <= nums[i], threshold <= 109`",
        "test_case": [
            {
                "label": "Example 1",
                "input": "nums = [1,3,4,3,1], threshold = 6",
                "output": "3 Explanation: The subarray [3,4,3] has a size of 3, and every element is greater than 6 / 3 = 2.\nNote that this is the only valid subarray."
            },
            {
                "label": "Example 2",
                "input": "nums = [6,5,6,5,8], threshold = 7",
                "output": "1 Explanation: The subarray [8] has a size of 1, and 8 > 7 / 1 = 7. So 1 is returned.\nNote that the subarray [6,5] has a size of 2, and every element is greater than 7 / 2 = 3.5. \nSimilarly, the subarrays [6,5,6], [6,5,6,5], [6,5,6,5,8] also satisfy the given conditions.\nTherefore, 2, 3, 4, or 5 may also be returned."
            }
        ],
        "elixir_template": "defmodule Solution do\n  @spec valid_subarray_size(nums :: [integer], threshold :: integer) :: integer\n  def valid_subarray_size(nums, threshold) do\n    \n  end\nend",
        "erlang_template": "-spec valid_subarray_size(Nums :: [integer()], Threshold :: integer()) -> integer().\nvalid_subarray_size(Nums, Threshold) ->\n  .",
        "scala_template": "object Solution {\n    def validSubarraySize(nums: Array[Int], threshold: Int): Int = {\n        \n    }\n}"
    },
    {
        "id": 2418,
        "name": "minimum-sum-of-squared-difference",
        "difficulty": "Medium",
        "link": "https://leetcode.com/problems/minimum-sum-of-squared-difference/",
        "task_description": "You are given two positive **0-indexed** integer arrays `nums1` and `nums2`, both of length `n`. The **sum of squared difference** of arrays `nums1` and `nums2` is defined as the **sum** of `(nums1[i] - nums2[i])2` for each `0 <= i < n`. You are also given two positive integers `k1` and `k2`. You can modify any of the elements of `nums1` by `+1` or `-1` at most `k1` times. Similarly, you can modify any of the elements of `nums2` by `+1` or `-1` at most `k2` times. Return _the minimum **sum of squared difference** after modifying array _`nums1`_ at most _`k1`_ times and modifying array _`nums2`_ at most _`k2`_ times_. **Note**: You are allowed to modify the array elements to become **negative** integers. **Example 1:** ``` **Input:** nums1 = [1,2,3,4], nums2 = [2,10,20,19], k1 = 0, k2 = 0 **Output:** 579 **Explanation:** The elements in nums1 and nums2 cannot be modified because k1 = 0 and k2 = 0. The sum of square difference will be: (1 - 2)2 + (2 - 10)2 + (3 - 20)2 + (4 - 19)2 = 579. ``` **Example 2:** ``` **Input:** nums1 = [1,4,10,12], nums2 = [5,8,6,9], k1 = 1, k2 = 1 **Output:** 43 **Explanation:** One way to obtain the minimum sum of square difference is: - Increase nums1[0] once. - Increase nums2[2] once. The minimum of the sum of square difference will be: (2 - 5)2 + (4 - 8)2 + (10 - 7)2 + (12 - 9)2 = 43. Note that, there are other ways to obtain the minimum of the sum of square difference, but there is no way to obtain a sum smaller than 43. ``` **Constraints:** `n == nums1.length == nums2.length` `1 <= n <= 105` `0 <= nums1[i], nums2[i] <= 105` `0 <= k1, k2 <= 109`",
        "test_case": [
            {
                "label": "Example 1",
                "input": "nums1 = [1,2,3,4], nums2 = [2,10,20,19], k1 = 0, k2 = 0",
                "output": "579 Explanation: The elements in nums1 and nums2 cannot be modified because k1 = 0 and k2 = 0. \nThe sum of square difference will be: (1 - 2) 2 + (2 - 10) 2 + (3 - 20) 2 + (4 - 19) 2 = 579."
            },
            {
                "label": "Example 2",
                "input": "nums1 = [1,4,10,12], nums2 = [5,8,6,9], k1 = 1, k2 = 1",
                "output": "43 Explanation: One way to obtain the minimum sum of square difference is: \n- Increase nums1[0] once.\n- Increase nums2[2] once.\nThe minimum of the sum of square difference will be: \n(2 - 5) 2 + (4 - 8) 2 + (10 - 7) 2 + (12 - 9) 2 = 43.\nNote that, there are other ways to obtain the minimum of the sum of square difference, but there is no way to obtain a sum smaller than 43. Constraints: n == nums1.length == nums2.length 1 <= n <= 10 5 0 <= nums1[i], nums2[i] <= 10 5 0 <= k1, k2 <= 10 9"
            }
        ],
        "elixir_template": "defmodule Solution do\n  @spec min_sum_square_diff(nums1 :: [integer], nums2 :: [integer], k1 :: integer, k2 :: integer) :: integer\n  def min_sum_square_diff(nums1, nums2, k1, k2) do\n    \n  end\nend",
        "erlang_template": "-spec min_sum_square_diff(Nums1 :: [integer()], Nums2 :: [integer()], K1 :: integer(), K2 :: integer()) -> integer().\nmin_sum_square_diff(Nums1, Nums2, K1, K2) ->\n  .",
        "scala_template": "object Solution {\n    def minSumSquareDiff(nums1: Array[Int], nums2: Array[Int], k1: Int, k2: Int): Long = {\n        \n    }\n}"
    },
    {
        "id": 2417,
        "name": "the-latest-time-to-catch-a-bus",
        "difficulty": "Medium",
        "link": "https://leetcode.com/problems/the-latest-time-to-catch-a-bus/",
        "task_description": "You are given a **0-indexed** integer array `buses` of length `n`, where `buses[i]` represents the departure time of the `ith` bus. You are also given a **0-indexed** integer array `passengers` of length `m`, where `passengers[j]` represents the arrival time of the `jth` passenger. All bus departure times are unique. All passenger arrival times are unique. You are given an integer `capacity`, which represents the **maximum** number of passengers that can get on each bus. When a passenger arrives, they will wait in line for the next available bus. You can get on a bus that departs at `x` minutes if you arrive at `y` minutes where `y <= x`, and the bus is not full. Passengers with the **earliest** arrival times get on the bus first. More formally when a bus arrives, either: If `capacity` or fewer passengers are waiting for a bus, they will **all** get on the bus, or The `capacity` passengers with the **earliest** arrival times will get on the bus. Return _the latest time you may arrive at the bus station to catch a bus_. You **cannot** arrive at the same time as another passenger. **Note: **The arrays `buses` and `passengers` are not necessarily sorted. **Example 1:** ``` **Input:** buses = [10,20], passengers = [2,17,18,19], capacity = 2 **Output:** 16 **Explanation:** Suppose you arrive at time 16. At time 10, the first bus departs with the 0th passenger. At time 20, the second bus departs with you and the 1st passenger. Note that you may not arrive at the same time as another passenger, which is why you must arrive before the 1st passenger to catch the bus. ``` **Example 2:** ``` **Input:** buses = [20,30,10], passengers = [19,13,26,4,25,11,21], capacity = 2 **Output:** 20 **Explanation:** Suppose you arrive at time 20. At time 10, the first bus departs with the 3rd passenger. At time 20, the second bus departs with the 5th and 1st passengers. At time 30, the third bus departs with the 0th passenger and you. Notice if you had arrived any later, then the 6th passenger would have taken your seat on the third bus. ``` **Constraints:** `n == buses.length` `m == passengers.length` `1 <= n, m, capacity <= 105` `2 <= buses[i], passengers[i] <= 109` Each element in `buses` is **unique**. Each element in `passengers` is **unique**.",
        "test_case": [
            {
                "label": "Example 1",
                "input": "buses = [10,20], passengers = [2,17,18,19], capacity = 2",
                "output": "16 Explanation: Suppose you arrive at time 16.\nAt time 10, the first bus departs with the 0 th passenger. \nAt time 20, the second bus departs with you and the 1 st passenger.\nNote that you may not arrive at the same time as another passenger, which is why you must arrive before the 1 st passenger to catch the bus."
            },
            {
                "label": "Example 2",
                "input": "buses = [20,30,10], passengers = [19,13,26,4,25,11,21], capacity = 2",
                "output": "20 Explanation: Suppose you arrive at time 20.\nAt time 10, the first bus departs with the 3 rd passenger. \nAt time 20, the second bus departs with the 5 th and 1 st passengers.\nAt time 30, the third bus departs with the 0 th passenger and you.\nNotice if you had arrived any later, then the 6 th passenger would have taken your seat on the third bus. Constraints: n == buses.length m == passengers.length 1 <= n, m, capacity <= 10 5 2 <= buses[i], passengers[i] <= 10 9 Each element in buses is unique . Each element in passengers is unique ."
            }
        ],
        "elixir_template": "defmodule Solution do\n  @spec latest_time_catch_the_bus(buses :: [integer], passengers :: [integer], capacity :: integer) :: integer\n  def latest_time_catch_the_bus(buses, passengers, capacity) do\n    \n  end\nend",
        "erlang_template": "-spec latest_time_catch_the_bus(Buses :: [integer()], Passengers :: [integer()], Capacity :: integer()) -> integer().\nlatest_time_catch_the_bus(Buses, Passengers, Capacity) ->\n  .",
        "scala_template": "object Solution {\n    def latestTimeCatchTheBus(buses: Array[Int], passengers: Array[Int], capacity: Int): Int = {\n        \n    }\n}"
    },
    {
        "id": 2416,
        "name": "evaluate-boolean-binary-tree",
        "difficulty": "Easy",
        "link": "https://leetcode.com/problems/evaluate-boolean-binary-tree/",
        "task_description": "You are given the `root` of a **full binary tree** with the following properties: **Leaf nodes** have either the value `0` or `1`, where `0` represents `False` and `1` represents `True`. **Non-leaf nodes** have either the value `2` or `3`, where `2` represents the boolean `OR` and `3` represents the boolean `AND`. The **evaluation** of a node is as follows: If the node is a leaf node, the evaluation is the **value** of the node, i.e. `True` or `False`. Otherwise, **evaluate** the node's two children and **apply** the boolean operation of its value with the children's evaluations. Return_ the boolean result of **evaluating** the _`root`_ node._ A **full binary tree** is a binary tree where each node has either `0` or `2` children. A **leaf node** is a node that has zero children. **Example 1:** ``` **Input:** root = [2,1,3,null,null,0,1] **Output:** true **Explanation:** The above diagram illustrates the evaluation process. The AND node evaluates to False AND True = False. The OR node evaluates to True OR False = True. The root node evaluates to True, so we return true. ``` **Example 2:** ``` **Input:** root = [0] **Output:** false **Explanation:** The root node is a leaf node and it evaluates to false, so we return false. ``` **Constraints:** The number of nodes in the tree is in the range `[1, 1000]`. `0 <= Node.val <= 3` Every node has either `0` or `2` children. Leaf nodes have a value of `0` or `1`. Non-leaf nodes have a value of `2` or `3`.",
        "test_case": [
            {
                "label": "Example 1",
                "input": "root = [2,1,3,null,null,0,1]",
                "output": "true Explanation: The above diagram illustrates the evaluation process.\nThe AND node evaluates to False AND True = False.\nThe OR node evaluates to True OR False = True.\nThe root node evaluates to True, so we return true."
            },
            {
                "label": "Example 2",
                "input": "root = [0]",
                "output": "false Explanation: The root node is a leaf node and it evaluates to false, so we return false. Constraints: The number of nodes in the tree is in the range [1, 1000] . 0 <= Node.val <= 3 Every node has either 0 or 2 children. Leaf nodes have a value of 0 or 1 . Non-leaf nodes have a value of 2 or 3 ."
            }
        ],
        "elixir_template": "# Definition for a binary tree node.\n#\n# defmodule TreeNode do\n#   @type t :: %__MODULE__{\n#           val: integer,\n#           left: TreeNode.t() | nil,\n#           right: TreeNode.t() | nil\n#         }\n#   defstruct val: 0, left: nil, right: nil\n# end\n\ndefmodule Solution do\n  @spec evaluate_tree(root :: TreeNode.t | nil) :: boolean\n  def evaluate_tree(root) do\n    \n  end\nend",
        "erlang_template": "%% Definition for a binary tree node.\n%%\n%% -record(tree_node, {val = 0 :: integer(),\n%%                     left = null  :: 'null' | #tree_node{},\n%%                     right = null :: 'null' | #tree_node{}}).\n\n-spec evaluate_tree(Root :: #tree_node{} | null) -> boolean().\nevaluate_tree(Root) ->\n  .",
        "scala_template": "/**\n * Definition for a binary tree node.\n * class TreeNode(_value: Int = 0, _left: TreeNode = null, _right: TreeNode = null) {\n *   var value: Int = _value\n *   var left: TreeNode = _left\n *   var right: TreeNode = _right\n * }\n */\nobject Solution {\n    def evaluateTree(root: TreeNode): Boolean = {\n        \n    }\n}"
    },
    {
        "id": 2415,
        "name": "count-the-number-of-ideal-arrays",
        "difficulty": "Hard",
        "link": "https://leetcode.com/problems/count-the-number-of-ideal-arrays/",
        "task_description": "You are given two integers `n` and `maxValue`, which are used to describe an **ideal** array. A **0-indexed** integer array `arr` of length `n` is considered **ideal** if the following conditions hold: Every `arr[i]` is a value from `1` to `maxValue`, for `0 <= i < n`. Every `arr[i]` is divisible by `arr[i - 1]`, for `0 < i < n`. Return _the number of **distinct** ideal arrays of length _`n`. Since the answer may be very large, return it modulo `109 + 7`. **Example 1:** ``` **Input:** n = 2, maxValue = 5 **Output:** 10 **Explanation:** The following are the possible ideal arrays: - Arrays starting with the value 1 (5 arrays): [1,1], [1,2], [1,3], [1,4], [1,5] - Arrays starting with the value 2 (2 arrays): [2,2], [2,4] - Arrays starting with the value 3 (1 array): [3,3] - Arrays starting with the value 4 (1 array): [4,4] - Arrays starting with the value 5 (1 array): [5,5] There are a total of 5 + 2 + 1 + 1 + 1 = 10 distinct ideal arrays. ``` **Example 2:** ``` **Input:** n = 5, maxValue = 3 **Output:** 11 **Explanation:** The following are the possible ideal arrays: - Arrays starting with the value 1 (9 arrays): - With no other distinct values (1 array): [1,1,1,1,1] - With 2nd distinct value 2 (4 arrays): [1,1,1,1,2], [1,1,1,2,2], [1,1,2,2,2], [1,2,2,2,2] - With 2nd distinct value 3 (4 arrays): [1,1,1,1,3], [1,1,1,3,3], [1,1,3,3,3], [1,3,3,3,3] - Arrays starting with the value 2 (1 array): [2,2,2,2,2] - Arrays starting with the value 3 (1 array): [3,3,3,3,3] There are a total of 9 + 1 + 1 = 11 distinct ideal arrays. ``` **Constraints:** `2 <= n <= 104` `1 <= maxValue <= 104`",
        "test_case": [
            {
                "label": "Example 1",
                "input": "n = 2, maxValue = 5",
                "output": "10 Explanation: The following are the possible ideal arrays:\n- Arrays starting with the value 1 (5 arrays): [1,1], [1,2], [1,3], [1,4], [1,5]\n- Arrays starting with the value 2 (2 arrays): [2,2], [2,4]\n- Arrays starting with the value 3 (1 array): [3,3]\n- Arrays starting with the value 4 (1 array): [4,4]\n- Arrays starting with the value 5 (1 array): [5,5]\nThere are a total of 5 + 2 + 1 + 1 + 1 = 10 distinct ideal arrays."
            },
            {
                "label": "Example 2",
                "input": "n = 5, maxValue = 3",
                "output": "11 Explanation: The following are the possible ideal arrays:\n- Arrays starting with the value 1 (9 arrays): \n   - With no other distinct values (1 array): [1,1,1,1,1] \n   - With 2 nd distinct value 2 (4 arrays): [1,1,1,1,2], [1,1,1,2,2], [1,1,2,2,2], [1,2,2,2,2]\n   - With 2 nd distinct value 3 (4 arrays): [1,1,1,1,3], [1,1,1,3,3], [1,1,3,3,3], [1,3,3,3,3]\n- Arrays starting with the value 2 (1 array): [2,2,2,2,2]\n- Arrays starting with the value 3 (1 array): [3,3,3,3,3]\nThere are a total of 9 + 1 + 1 = 11 distinct ideal arrays."
            }
        ],
        "elixir_template": "defmodule Solution do\n  @spec ideal_arrays(n :: integer, max_value :: integer) :: integer\n  def ideal_arrays(n, max_value) do\n    \n  end\nend",
        "erlang_template": "-spec ideal_arrays(N :: integer(), MaxValue :: integer()) -> integer().\nideal_arrays(N, MaxValue) ->\n  .",
        "scala_template": "object Solution {\n    def idealArrays(n: Int, maxValue: Int): Int = {\n        \n    }\n}"
    },
    {
        "id": 2414,
        "name": "move-pieces-to-obtain-a-string",
        "difficulty": "Medium",
        "link": "https://leetcode.com/problems/move-pieces-to-obtain-a-string/",
        "task_description": "You are given two strings `start` and `target`, both of length `n`. Each string consists **only** of the characters `'L'`, `'R'`, and `'_'` where: The characters `'L'` and `'R'` represent pieces, where a piece `'L'` can move to the **left** only if there is a **blank** space directly to its left, and a piece `'R'` can move to the **right** only if there is a **blank** space directly to its right. The character `'_'` represents a blank space that can be occupied by **any** of the `'L'` or `'R'` pieces. Return `true` _if it is possible to obtain the string_ `target`_ by moving the pieces of the string _`start`_ **any** number of times_. Otherwise, return `false`. **Example 1:** ``` **Input:** start = \"_L__R__R_\", target = \"L______RR\" **Output:** true **Explanation:** We can obtain the string target from start by doing the following moves: - Move the first piece one step to the left, start becomes equal to \"**L**___R__R_\". - Move the last piece one step to the right, start becomes equal to \"L___R___**R**\". - Move the second piece three steps to the right, start becomes equal to \"L______**R**R\". Since it is possible to get the string target from start, we return true. ``` **Example 2:** ``` **Input:** start = \"R_L_\", target = \"__LR\" **Output:** false **Explanation:** The 'R' piece in the string start can move one step to the right to obtain \"_**R**L_\". After that, no pieces can move anymore, so it is impossible to obtain the string target from start. ``` **Example 3:** ``` **Input:** start = \"_R\", target = \"R_\" **Output:** false **Explanation:** The piece in the string start can move only to the right, so it is impossible to obtain the string target from start. ``` **Constraints:** `n == start.length == target.length` `1 <= n <= 105` `start` and `target` consist of the characters `'L'`, `'R'`, and `'_'`.",
        "test_case": [
            {
                "label": "Example 1",
                "input": "start = \"_L__R__R_\", target = \"L______RR\"",
                "output": "true Explanation: We can obtain the string target from start by doing the following moves:\n- Move the first piece one step to the left, start becomes equal to \" L ___R__R_\".\n- Move the last piece one step to the right, start becomes equal to \"L___R___ R \".\n- Move the second piece three steps to the right, start becomes equal to \"L______ R R\".\nSince it is possible to get the string target from start, we return true."
            },
            {
                "label": "Example 2",
                "input": "start = \"R_L_\", target = \"__LR\"",
                "output": "false Explanation: The 'R' piece in the string start can move one step to the right to obtain \"_ R L_\".\nAfter that, no pieces can move anymore, so it is impossible to obtain the string target from start."
            },
            {
                "label": "Example 3",
                "input": "start = \"_R\", target = \"R_\"",
                "output": "false Explanation: The piece in the string start can move only to the right, so it is impossible to obtain the string target from start. Constraints: n == start.length == target.length 1 <= n <= 10 5 start and target consist of the characters 'L' , 'R' , and '_' ."
            }
        ],
        "elixir_template": "defmodule Solution do\n  @spec can_change(start :: String.t, target :: String.t) :: boolean\n  def can_change(start, target) do\n    \n  end\nend",
        "erlang_template": "-spec can_change(Start :: unicode:unicode_binary(), Target :: unicode:unicode_binary()) -> boolean().\ncan_change(Start, Target) ->\n  .",
        "scala_template": "object Solution {\n    def canChange(start: String, target: String): Boolean = {\n        \n    }\n}"
    },
    {
        "id": 2413,
        "name": "smallest-number-in-infinite-set",
        "difficulty": "Medium",
        "link": "https://leetcode.com/problems/smallest-number-in-infinite-set/",
        "task_description": "You have a set which contains all positive integers `[1, 2, 3, 4, 5, ...]`. Implement the `SmallestInfiniteSet` class: `SmallestInfiniteSet()` Initializes the **SmallestInfiniteSet** object to contain **all** positive integers. `int popSmallest()` **Removes** and returns the smallest integer contained in the infinite set. `void addBack(int num)` **Adds** a positive integer `num` back into the infinite set, if it is **not** already in the infinite set. **Example 1:** ``` **Input** [\"SmallestInfiniteSet\", \"addBack\", \"popSmallest\", \"popSmallest\", \"popSmallest\", \"addBack\", \"popSmallest\", \"popSmallest\", \"popSmallest\"] [[], [2], [], [], [], [1], [], [], []] **Output** [null, null, 1, 2, 3, null, 1, 4, 5] **Explanation** SmallestInfiniteSet smallestInfiniteSet = new SmallestInfiniteSet(); smallestInfiniteSet.addBack(2); // 2 is already in the set, so no change is made. smallestInfiniteSet.popSmallest(); // return 1, since 1 is the smallest number, and remove it from the set. smallestInfiniteSet.popSmallest(); // return 2, and remove it from the set. smallestInfiniteSet.popSmallest(); // return 3, and remove it from the set. smallestInfiniteSet.addBack(1); // 1 is added back to the set. smallestInfiniteSet.popSmallest(); // return 1, since 1 was added back to the set and // is the smallest number, and remove it from the set. smallestInfiniteSet.popSmallest(); // return 4, and remove it from the set. smallestInfiniteSet.popSmallest(); // return 5, and remove it from the set. ``` **Constraints:** `1 <= num <= 1000` At most `1000` calls will be made **in total** to `popSmallest` and `addBack`.",
        "test_case": [],
        "elixir_template": "defmodule SmallestInfiniteSet do\n  @spec init_() :: any\n  def init_() do\n    \n  end\n\n  @spec pop_smallest() :: integer\n  def pop_smallest() do\n    \n  end\n\n  @spec add_back(num :: integer) :: any\n  def add_back(num) do\n    \n  end\nend\n\n# Your functions will be called as such:\n# SmallestInfiniteSet.init_()\n# param_1 = SmallestInfiniteSet.pop_smallest()\n# SmallestInfiniteSet.add_back(num)\n\n# SmallestInfiniteSet.init_ will be called before every test case, in which you can do some necessary initializations.",
        "erlang_template": "-spec smallest_infinite_set_init_() -> any().\nsmallest_infinite_set_init_() ->\n  .\n\n-spec smallest_infinite_set_pop_smallest() -> integer().\nsmallest_infinite_set_pop_smallest() ->\n  .\n\n-spec smallest_infinite_set_add_back(Num :: integer()) -> any().\nsmallest_infinite_set_add_back(Num) ->\n  .\n\n\n%% Your functions will be called as such:\n%% smallest_infinite_set_init_(),\n%% Param_1 = smallest_infinite_set_pop_smallest(),\n%% smallest_infinite_set_add_back(Num),\n\n%% smallest_infinite_set_init_ will be called before every test case, in which you can do some necessary initializations.",
        "scala_template": "class SmallestInfiniteSet() {\n\n    def popSmallest(): Int = {\n        \n    }\n\n    def addBack(num: Int): Unit = {\n        \n    }\n\n}\n\n/**\n * Your SmallestInfiniteSet object will be instantiated and called as such:\n * val obj = new SmallestInfiniteSet()\n * val param_1 = obj.popSmallest()\n * obj.addBack(num)\n */"
    },
    {
        "id": 2412,
        "name": "minimum-amount-of-time-to-fill-cups",
        "difficulty": "Easy",
        "link": "https://leetcode.com/problems/minimum-amount-of-time-to-fill-cups/",
        "task_description": "You have a water dispenser that can dispense cold, warm, and hot water. Every second, you can either fill up `2` cups with **different** types of water, or `1` cup of any type of water. You are given a **0-indexed** integer array `amount` of length `3` where `amount[0]`, `amount[1]`, and `amount[2]` denote the number of cold, warm, and hot water cups you need to fill respectively. Return _the **minimum** number of seconds needed to fill up all the cups_. **Example 1:** ``` **Input:** amount = [1,4,2] **Output:** 4 **Explanation:** One way to fill up the cups is: Second 1: Fill up a cold cup and a warm cup. Second 2: Fill up a warm cup and a hot cup. Second 3: Fill up a warm cup and a hot cup. Second 4: Fill up a warm cup. It can be proven that 4 is the minimum number of seconds needed. ``` **Example 2:** ``` **Input:** amount = [5,4,4] **Output:** 7 **Explanation:** One way to fill up the cups is: Second 1: Fill up a cold cup, and a hot cup. Second 2: Fill up a cold cup, and a warm cup. Second 3: Fill up a cold cup, and a warm cup. Second 4: Fill up a warm cup, and a hot cup. Second 5: Fill up a cold cup, and a hot cup. Second 6: Fill up a cold cup, and a warm cup. Second 7: Fill up a hot cup. ``` **Example 3:** ``` **Input:** amount = [5,0,0] **Output:** 5 **Explanation:** Every second, we fill up a cold cup. ``` **Constraints:** `amount.length == 3` `0 <= amount[i] <= 100`",
        "test_case": [
            {
                "label": "Example 1",
                "input": "amount = [1,4,2]",
                "output": "4 Explanation: One way to fill up the cups is:\nSecond 1: Fill up a cold cup and a warm cup.\nSecond 2: Fill up a warm cup and a hot cup.\nSecond 3: Fill up a warm cup and a hot cup.\nSecond 4: Fill up a warm cup.\nIt can be proven that 4 is the minimum number of seconds needed."
            },
            {
                "label": "Example 2",
                "input": "amount = [5,4,4]",
                "output": "7 Explanation: One way to fill up the cups is:\nSecond 1: Fill up a cold cup, and a hot cup.\nSecond 2: Fill up a cold cup, and a warm cup.\nSecond 3: Fill up a cold cup, and a warm cup.\nSecond 4: Fill up a warm cup, and a hot cup.\nSecond 5: Fill up a cold cup, and a hot cup.\nSecond 6: Fill up a cold cup, and a warm cup.\nSecond 7: Fill up a hot cup."
            },
            {
                "label": "Example 3",
                "input": "amount = [5,0,0]",
                "output": "5 Explanation: Every second, we fill up a cold cup. Constraints: amount.length == 3 0 <= amount[i] <= 100"
            }
        ],
        "elixir_template": "defmodule Solution do\n  @spec fill_cups(amount :: [integer]) :: integer\n  def fill_cups(amount) do\n    \n  end\nend",
        "erlang_template": "-spec fill_cups(Amount :: [integer()]) -> integer().\nfill_cups(Amount) ->\n  .",
        "scala_template": "object Solution {\n    def fillCups(amount: Array[Int]): Int = {\n        \n    }\n}"
    },
    {
        "id": 2411,
        "name": "spiral-matrix-iv",
        "difficulty": "Medium",
        "link": "https://leetcode.com/problems/spiral-matrix-iv/",
        "task_description": "You are given two integers `m` and `n`, which represent the dimensions of a matrix. You are also given the `head` of a linked list of integers. Generate an `m x n` matrix that contains the integers in the linked list presented in **spiral** order **(clockwise)**, starting from the **top-left** of the matrix. If there are remaining empty spaces, fill them with `-1`. Return _the generated matrix_. **Example 1:** ``` **Input:** m = 3, n = 5, head = [3,0,2,6,8,1,7,9,4,2,5,5,0] **Output:** [[3,0,2,6,8],[5,0,-1,-1,1],[5,2,4,9,7]] **Explanation:** The diagram above shows how the values are printed in the matrix. Note that the remaining spaces in the matrix are filled with -1. ``` **Example 2:** ``` **Input:** m = 1, n = 4, head = [0,1,2] **Output:** [[0,1,2,-1]] **Explanation:** The diagram above shows how the values are printed from left to right in the matrix. The last space in the matrix is set to -1. ``` **Constraints:** `1 <= m, n <= 105` `1 <= m * n <= 105` The number of nodes in the list is in the range `[1, m * n]`. `0 <= Node.val <= 1000`",
        "test_case": [
            {
                "label": "Example 1",
                "input": "m = 3, n = 5, head = [3,0,2,6,8,1,7,9,4,2,5,5,0]",
                "output": "[[3,0,2,6,8],[5,0,-1,-1,1],[5,2,4,9,7]] Explanation: The diagram above shows how the values are printed in the matrix.\nNote that the remaining spaces in the matrix are filled with -1."
            },
            {
                "label": "Example 2",
                "input": "m = 1, n = 4, head = [0,1,2]",
                "output": "[[0,1,2,-1]] Explanation: The diagram above shows how the values are printed from left to right in the matrix.\nThe last space in the matrix is set to -1."
            }
        ],
        "elixir_template": "# Definition for singly-linked list.\n#\n# defmodule ListNode do\n#   @type t :: %__MODULE__{\n#           val: integer,\n#           next: ListNode.t() | nil\n#         }\n#   defstruct val: 0, next: nil\n# end\n\ndefmodule Solution do\n  @spec spiral_matrix(m :: integer, n :: integer, head :: ListNode.t | nil) :: [[integer]]\n  def spiral_matrix(m, n, head) do\n    \n  end\nend",
        "erlang_template": "%% Definition for singly-linked list.\n%%\n%% -record(list_node, {val = 0 :: integer(),\n%%                     next = null :: 'null' | #list_node{}}).\n\n-spec spiral_matrix(M :: integer(), N :: integer(), Head :: #list_node{} | null) -> [[integer()]].\nspiral_matrix(M, N, Head) ->\n  .",
        "scala_template": "/**\n * Definition for singly-linked list.\n * class ListNode(_x: Int = 0, _next: ListNode = null) {\n *   var next: ListNode = _next\n *   var x: Int = _x\n * }\n */\nobject Solution {\n    def spiralMatrix(m: Int, n: Int, head: ListNode): Array[Array[Int]] = {\n        \n    }\n}"
    },
    {
        "id": 2409,
        "name": "number-of-increasing-paths-in-a-grid",
        "difficulty": "Hard",
        "link": "https://leetcode.com/problems/number-of-increasing-paths-in-a-grid/",
        "task_description": "You are given an `m x n` integer matrix `grid`, where you can move from a cell to any adjacent cell in all `4` directions. Return _the number of **strictly** **increasing** paths in the grid such that you can start from **any** cell and end at **any** cell. _Since the answer may be very large, return it **modulo** `109 + 7`. Two paths are considered different if they do not have exactly the same sequence of visited cells. **Example 1:** ``` **Input:** grid = [[1,1],[3,4]] **Output:** 8 **Explanation:** The strictly increasing paths are: - Paths with length 1: [1], [1], [3], [4]. - Paths with length 2: [1 -> 3], [1 -> 4], [3 -> 4]. - Paths with length 3: [1 -> 3 -> 4]. The total number of paths is 4 + 3 + 1 = 8. ``` **Example 2:** ``` **Input:** grid = [[1],[2]] **Output:** 3 **Explanation:** The strictly increasing paths are: - Paths with length 1: [1], [2]. - Paths with length 2: [1 -> 2]. The total number of paths is 2 + 1 = 3. ``` **Constraints:** `m == grid.length` `n == grid[i].length` `1 <= m, n <= 1000` `1 <= m * n <= 105` `1 <= grid[i][j] <= 105`",
        "test_case": [
            {
                "label": "Example 1",
                "input": "grid = [[1,1],[3,4]]",
                "output": "8 Explanation: The strictly increasing paths are:\n- Paths with length 1: [1], [1], [3], [4].\n- Paths with length 2: [1 -> 3], [1 -> 4], [3 -> 4].\n- Paths with length 3: [1 -> 3 -> 4].\nThe total number of paths is 4 + 3 + 1 = 8."
            },
            {
                "label": "Example 2",
                "input": "grid = [[1],[2]]",
                "output": "3 Explanation: The strictly increasing paths are:\n- Paths with length 1: [1], [2].\n- Paths with length 2: [1 -> 2].\nThe total number of paths is 2 + 1 = 3. Constraints: m == grid.length n == grid[i].length 1 <= m, n <= 1000 1 <= m * n <= 10 5 1 <= grid[i][j] <= 10 5"
            }
        ],
        "elixir_template": "defmodule Solution do\n  @spec count_paths(grid :: [[integer]]) :: integer\n  def count_paths(grid) do\n    \n  end\nend",
        "erlang_template": "-spec count_paths(Grid :: [[integer()]]) -> integer().\ncount_paths(Grid) ->\n  .",
        "scala_template": "object Solution {\n    def countPaths(grid: Array[Array[Int]]): Int = {\n        \n    }\n}"
    },
    {
        "id": 2408,
        "name": "number-of-people-aware-of-a-secret",
        "difficulty": "Medium",
        "link": "https://leetcode.com/problems/number-of-people-aware-of-a-secret/",
        "task_description": "On day `1`, one person discovers a secret. You are given an integer `delay`, which means that each person will **share** the secret with a new person **every day**, starting from `delay` days after discovering the secret. You are also given an integer `forget`, which means that each person will **forget** the secret `forget` days after discovering it. A person **cannot** share the secret on the same day they forgot it, or on any day afterwards. Given an integer `n`, return_ the number of people who know the secret at the end of day _`n`. Since the answer may be very large, return it **modulo** `109 + 7`. **Example 1:** ``` **Input:** n = 6, delay = 2, forget = 4 **Output:** 5 **Explanation:** Day 1: Suppose the first person is named A. (1 person) Day 2: A is the only person who knows the secret. (1 person) Day 3: A shares the secret with a new person, B. (2 people) Day 4: A shares the secret with a new person, C. (3 people) Day 5: A forgets the secret, and B shares the secret with a new person, D. (3 people) Day 6: B shares the secret with E, and C shares the secret with F. (5 people) ``` **Example 2:** ``` **Input:** n = 4, delay = 1, forget = 3 **Output:** 6 **Explanation:** Day 1: The first person is named A. (1 person) Day 2: A shares the secret with B. (2 people) Day 3: A and B share the secret with 2 new people, C and D. (4 people) Day 4: A forgets the secret. B, C, and D share the secret with 3 new people. (6 people) ``` **Constraints:** `2 <= n <= 1000` `1 <= delay < forget <= n`",
        "test_case": [
            {
                "label": "Example 1",
                "input": "n = 6, delay = 2, forget = 4",
                "output": "5 Explanation: Day 1: Suppose the first person is named A. (1 person)\nDay 2: A is the only person who knows the secret. (1 person)\nDay 3: A shares the secret with a new person, B. (2 people)\nDay 4: A shares the secret with a new person, C. (3 people)\nDay 5: A forgets the secret, and B shares the secret with a new person, D. (3 people)\nDay 6: B shares the secret with E, and C shares the secret with F. (5 people)"
            },
            {
                "label": "Example 2",
                "input": "n = 4, delay = 1, forget = 3",
                "output": "6 Explanation: Day 1: The first person is named A. (1 person)\nDay 2: A shares the secret with B. (2 people)\nDay 3: A and B share the secret with 2 new people, C and D. (4 people)\nDay 4: A forgets the secret. B, C, and D share the secret with 3 new people. (6 people)"
            }
        ],
        "elixir_template": "defmodule Solution do\n  @spec people_aware_of_secret(n :: integer, delay :: integer, forget :: integer) :: integer\n  def people_aware_of_secret(n, delay, forget) do\n    \n  end\nend",
        "erlang_template": "-spec people_aware_of_secret(N :: integer(), Delay :: integer(), Forget :: integer()) -> integer().\npeople_aware_of_secret(N, Delay, Forget) ->\n  .",
        "scala_template": "object Solution {\n    def peopleAwareOfSecret(n: Int, delay: Int, forget: Int): Int = {\n        \n    }\n}"
    },
    {
        "id": 2406,
        "name": "decode-the-message",
        "difficulty": "Easy",
        "link": "https://leetcode.com/problems/decode-the-message/",
        "task_description": "You are given the strings `key` and `message`, which represent a cipher key and a secret message, respectively. The steps to decode `message` are as follows: Use the **first** appearance of all 26 lowercase English letters in `key` as the **order** of the substitution table. Align the substitution table with the regular English alphabet. Each letter in `message` is then **substituted** using the table. Spaces `' '` are transformed to themselves. For example, given `key = \"**hap**p**y** **bo**y\"` (actual key would have **at least one** instance of each letter in the alphabet), we have the partial substitution table of (`'h' -> 'a'`, `'a' -> 'b'`, `'p' -> 'c'`, `'y' -> 'd'`, `'b' -> 'e'`, `'o' -> 'f'`). Return _the decoded message_. **Example 1:** ``` **Input:** key = \"the quick brown fox jumps over the lazy dog\", message = \"vkbs bs t suepuv\" **Output:** \"this is a secret\" **Explanation:** The diagram above shows the substitution table. It is obtained by taking the first appearance of each letter in \"**the** **quick** **brown** **f**o**x** **j**u**mps** o**v**er the **lazy** **d**o**g**\". ``` **Example 2:** ``` **Input:** key = \"eljuxhpwnyrdgtqkviszcfmabo\", message = \"zwx hnfx lqantp mnoeius ycgk vcnjrdb\" **Output:** \"the five boxing wizards jump quickly\" **Explanation:** The diagram above shows the substitution table. It is obtained by taking the first appearance of each letter in \"**eljuxhpwnyrdgtqkviszcfmabo**\". ``` **Constraints:** `26 <= key.length <= 2000` `key` consists of lowercase English letters and `' '`. `key` contains every letter in the English alphabet (`'a'` to `'z'`) **at least once**. `1 <= message.length <= 2000` `message` consists of lowercase English letters and `' '`.",
        "test_case": [
            {
                "label": "Example 1",
                "input": "key = \"the quick brown fox jumps over the lazy dog\", message = \"vkbs bs t suepuv\"",
                "output": "\"this is a secret\" Explanation: The diagram above shows the substitution table.\nIt is obtained by taking the first appearance of each letter in \" the quick brown f o x j u mps o v er the lazy d o g \"."
            },
            {
                "label": "Example 2",
                "input": "key = \"eljuxhpwnyrdgtqkviszcfmabo\", message = \"zwx hnfx lqantp mnoeius ycgk vcnjrdb\"",
                "output": "\"the five boxing wizards jump quickly\" Explanation: The diagram above shows the substitution table.\nIt is obtained by taking the first appearance of each letter in \" eljuxhpwnyrdgtqkviszcfmabo \"."
            }
        ],
        "elixir_template": "defmodule Solution do\n  @spec decode_message(key :: String.t, message :: String.t) :: String.t\n  def decode_message(key, message) do\n    \n  end\nend",
        "erlang_template": "-spec decode_message(Key :: unicode:unicode_binary(), Message :: unicode:unicode_binary()) -> unicode:unicode_binary().\ndecode_message(Key, Message) ->\n  .",
        "scala_template": "object Solution {\n    def decodeMessage(key: String, message: String): String = {\n        \n    }\n}"
    },
    {
        "id": 2404,
        "name": "number-of-distinct-roll-sequences",
        "difficulty": "Hard",
        "link": "https://leetcode.com/problems/number-of-distinct-roll-sequences/",
        "task_description": "You are given an integer `n`. You roll a fair 6-sided dice `n` times. Determine the total number of **distinct** sequences of rolls possible such that the following conditions are satisfied: The **greatest common divisor** of any **adjacent** values in the sequence is equal to `1`. There is **at least** a gap of `2` rolls between **equal** valued rolls. More formally, if the value of the `ith` roll is **equal** to the value of the `jth` roll, then `abs(i - j) > 2`. Return _the** total number** of distinct sequences possible_. Since the answer may be very large, return it **modulo** `109 + 7`. Two sequences are considered distinct if at least one element is different. **Example 1:** ``` **Input:** n = 4 **Output:** 184 **Explanation:** Some of the possible sequences are (1, 2, 3, 4), (6, 1, 2, 3), (1, 2, 3, 1), etc. Some invalid sequences are (1, 2, 1, 3), (1, 2, 3, 6). (1, 2, 1, 3) is invalid since the first and third roll have an equal value and abs(1 - 3) = 2 (i and j are 1-indexed). (1, 2, 3, 6) is invalid since the greatest common divisor of 3 and 6 = 3. There are a total of 184 distinct sequences possible, so we return 184. ``` **Example 2:** ``` **Input:** n = 2 **Output:** 22 **Explanation:** Some of the possible sequences are (1, 2), (2, 1), (3, 2). Some invalid sequences are (3, 6), (2, 4) since the greatest common divisor is not equal to 1. There are a total of 22 distinct sequences possible, so we return 22. ``` **Constraints:** `1 <= n <= 104`",
        "test_case": [
            {
                "label": "Example 1",
                "input": "n = 4",
                "output": "184 Explanation: Some of the possible sequences are (1, 2, 3, 4), (6, 1, 2, 3), (1, 2, 3, 1), etc.\nSome invalid sequences are (1, 2, 1, 3), (1, 2, 3, 6).\n(1, 2, 1, 3) is invalid since the first and third roll have an equal value and abs(1 - 3) = 2 (i and j are 1-indexed).\n(1, 2, 3, 6) is invalid since the greatest common divisor of 3 and 6 = 3.\nThere are a total of 184 distinct sequences possible, so we return 184."
            },
            {
                "label": "Example 2",
                "input": "n = 2",
                "output": "22 Explanation: Some of the possible sequences are (1, 2), (2, 1), (3, 2).\nSome invalid sequences are (3, 6), (2, 4) since the greatest common divisor is not equal to 1.\nThere are a total of 22 distinct sequences possible, so we return 22."
            }
        ],
        "elixir_template": "defmodule Solution do\n  @spec distinct_sequences(n :: integer) :: integer\n  def distinct_sequences(n) do\n    \n  end\nend",
        "erlang_template": "-spec distinct_sequences(N :: integer()) -> integer().\ndistinct_sequences(N) ->\n  .",
        "scala_template": "object Solution {\n    def distinctSequences(n: Int): Int = {\n        \n    }\n}"
    },
    {
        "id": 2403,
        "name": "count-unreachable-pairs-of-nodes-in-an-undirected-graph",
        "difficulty": "Medium",
        "link": "https://leetcode.com/problems/count-unreachable-pairs-of-nodes-in-an-undirected-graph/",
        "task_description": "You are given an integer `n`. There is an **undirected** graph with `n` nodes, numbered from `0` to `n - 1`. You are given a 2D integer array `edges` where `edges[i] = [ai, bi]` denotes that there exists an **undirected** edge connecting nodes `ai` and `bi`. Return _the **number of pairs** of different nodes that are **unreachable** from each other_. **Example 1:** ``` **Input:** n = 3, edges = [[0,1],[0,2],[1,2]] **Output:** 0 **Explanation:** There are no pairs of nodes that are unreachable from each other. Therefore, we return 0. ``` **Example 2:** ``` **Input:** n = 7, edges = [[0,2],[0,5],[2,4],[1,6],[5,4]] **Output:** 14 **Explanation:** There are 14 pairs of nodes that are unreachable from each other: [[0,1],[0,3],[0,6],[1,2],[1,3],[1,4],[1,5],[2,3],[2,6],[3,4],[3,5],[3,6],[4,6],[5,6]]. Therefore, we return 14. ``` **Constraints:** `1 <= n <= 105` `0 <= edges.length <= 2 * 105` `edges[i].length == 2` `0 <= ai, bi < n` `ai != bi` There are no repeated edges.",
        "test_case": [
            {
                "label": "Example 1",
                "input": "n = 3, edges = [[0,1],[0,2],[1,2]]",
                "output": "0 Explanation: There are no pairs of nodes that are unreachable from each other. Therefore, we return 0."
            },
            {
                "label": "Example 2",
                "input": "n = 7, edges = [[0,2],[0,5],[2,4],[1,6],[5,4]]",
                "output": "14 Explanation: There are 14 pairs of nodes that are unreachable from each other:\n[[0,1],[0,3],[0,6],[1,2],[1,3],[1,4],[1,5],[2,3],[2,6],[3,4],[3,5],[3,6],[4,6],[5,6]].\nTherefore, we return 14."
            }
        ],
        "elixir_template": "defmodule Solution do\n  @spec count_pairs(n :: integer, edges :: [[integer]]) :: integer\n  def count_pairs(n, edges) do\n    \n  end\nend",
        "erlang_template": "-spec count_pairs(N :: integer(), Edges :: [[integer()]]) -> integer().\ncount_pairs(N, Edges) ->\n  .",
        "scala_template": "object Solution {\n    def countPairs(n: Int, edges: Array[Array[Int]]): Long = {\n        \n    }\n}"
    },
    {
        "id": 2402,
        "name": "maximum-xor-after-operations",
        "difficulty": "Medium",
        "link": "https://leetcode.com/problems/maximum-xor-after-operations/",
        "task_description": "You are given a **0-indexed** integer array `nums`. In one operation, select **any** non-negative integer `x` and an index `i`, then **update** `nums[i]` to be equal to `nums[i] AND (nums[i] XOR x)`. Note that `AND` is the bitwise AND operation and `XOR` is the bitwise XOR operation. Return _the **maximum** possible bitwise XOR of all elements of _`nums`_ after applying the operation **any number** of times_. **Example 1:** ``` **Input:** nums = [3,2,4,6] **Output:** 7 **Explanation:** Apply the operation with x = 4 and i = 3, num[3] = 6 AND (6 XOR 4) = 6 AND 2 = 2. Now, nums = [3, 2, 4, 2] and the bitwise XOR of all the elements = 3 XOR 2 XOR 4 XOR 2 = 7. It can be shown that 7 is the maximum possible bitwise XOR. Note that other operations may be used to achieve a bitwise XOR of 7. ``` **Example 2:** ``` **Input:** nums = [1,2,3,9,2] **Output:** 11 **Explanation:** Apply the operation zero times. The bitwise XOR of all the elements = 1 XOR 2 XOR 3 XOR 9 XOR 2 = 11. It can be shown that 11 is the maximum possible bitwise XOR. ``` **Constraints:** `1 <= nums.length <= 105` `0 <= nums[i] <= 108`",
        "test_case": [
            {
                "label": "Example 1",
                "input": "nums = [3,2,4,6]",
                "output": "7 Explanation: Apply the operation with x = 4 and i = 3, num[3] = 6 AND (6 XOR 4) = 6 AND 2 = 2.\nNow, nums = [3, 2, 4, 2] and the bitwise XOR of all the elements = 3 XOR 2 XOR 4 XOR 2 = 7.\nIt can be shown that 7 is the maximum possible bitwise XOR.\nNote that other operations may be used to achieve a bitwise XOR of 7."
            },
            {
                "label": "Example 2",
                "input": "nums = [1,2,3,9,2]",
                "output": "11 Explanation: Apply the operation zero times.\nThe bitwise XOR of all the elements = 1 XOR 2 XOR 3 XOR 9 XOR 2 = 11.\nIt can be shown that 11 is the maximum possible bitwise XOR."
            }
        ],
        "elixir_template": "defmodule Solution do\n  @spec maximum_xor(nums :: [integer]) :: integer\n  def maximum_xor(nums) do\n    \n  end\nend",
        "erlang_template": "-spec maximum_xor(Nums :: [integer()]) -> integer().\nmaximum_xor(Nums) ->\n  .",
        "scala_template": "object Solution {\n    def maximumXOR(nums: Array[Int]): Int = {\n        \n    }\n}"
    },
    {
        "id": 2401,
        "name": "count-asterisks",
        "difficulty": "Easy",
        "link": "https://leetcode.com/problems/count-asterisks/",
        "task_description": "You are given a string `s`, where every **two** consecutive vertical bars `'|'` are grouped into a **pair**. In other words, the 1st and 2nd `'|'` make a pair, the 3rd and 4th `'|'` make a pair, and so forth. Return _the number of _`'*'`_ in _`s`_, **excluding** the _`'*'`_ between each pair of _`'|'`. **Note** that each `'|'` will belong to **exactly** one pair. **Example 1:** ``` **Input:** s = \"l|*e*et|c**o|*de|\" **Output:** 2 **Explanation:** The considered characters are underlined: \"l|*e*et|c**o|*de|\". The characters between the first and second '|' are excluded from the answer. Also, the characters between the third and fourth '|' are excluded from the answer. There are 2 asterisks considered. Therefore, we return 2. ``` **Example 2:** ``` **Input:** s = \"iamprogrammer\" **Output:** 0 **Explanation:** In this example, there are no asterisks in s. Therefore, we return 0. ``` **Example 3:** ``` **Input:** s = \"yo|uar|e**|b|e***au|tifu|l\" **Output:** 5 **Explanation:** The considered characters are underlined: \"yo|uar|e**|b|e***au|tifu|l\". There are 5 asterisks considered. Therefore, we return 5. ``` **Constraints:** `1 <= s.length <= 1000` `s` consists of lowercase English letters, vertical bars `'|'`, and asterisks `'*'`. `s` contains an **even** number of vertical bars `'|'`.",
        "test_case": [
            {
                "label": "Example 1",
                "input": "s = \"l|*e*et|c**o|*de|\"",
                "output": "2 Explanation: The considered characters are underlined: \" l |*e*et| c**o |*de|\".\nThe characters between the first and second '|' are excluded from the answer.\nAlso, the characters between the third and fourth '|' are excluded from the answer.\nThere are 2 asterisks considered. Therefore, we return 2."
            },
            {
                "label": "Example 2",
                "input": "s = \"iamprogrammer\"",
                "output": "0 Explanation: In this example, there are no asterisks in s. Therefore, we return 0."
            },
            {
                "label": "Example 3",
                "input": "s = \"yo|uar|e**|b|e***au|tifu|l\"",
                "output": "5 Explanation: The considered characters are underlined: \" yo |uar| e** |b| e***au |tifu| l \". There are 5 asterisks considered. Therefore, we return 5."
            }
        ],
        "elixir_template": "defmodule Solution do\n  @spec count_asterisks(s :: String.t) :: integer\n  def count_asterisks(s) do\n    \n  end\nend",
        "erlang_template": "-spec count_asterisks(S :: unicode:unicode_binary()) -> integer().\ncount_asterisks(S) ->\n  .",
        "scala_template": "object Solution {\n    def countAsterisks(s: String): Int = {\n        \n    }\n}"
    },
    {
        "id": 2400,
        "name": "minimum-score-after-removals-on-a-tree",
        "difficulty": "Hard",
        "link": "https://leetcode.com/problems/minimum-score-after-removals-on-a-tree/",
        "task_description": "There is an undirected connected tree with `n` nodes labeled from `0` to `n - 1` and `n - 1` edges. You are given a **0-indexed** integer array `nums` of length `n` where `nums[i]` represents the value of the `ith` node. You are also given a 2D integer array `edges` of length `n - 1` where `edges[i] = [ai, bi]` indicates that there is an edge between nodes `ai` and `bi` in the tree. Remove two **distinct** edges of the tree to form three connected components. For a pair of removed edges, the following steps are defined: Get the XOR of all the values of the nodes for **each** of the three components respectively. The **difference** between the **largest** XOR value and the **smallest** XOR value is the **score** of the pair. For example, say the three components have the node values: `[4,5,7]`, `[1,9]`, and `[3,3,3]`. The three XOR values are `4 ^ 5 ^ 7 = **6**`, `1 ^ 9 = **8**`, and `3 ^ 3 ^ 3 = **3**`. The largest XOR value is `8` and the smallest XOR value is `3`. The score is then `8 - 3 = 5`. Return _the **minimum** score of any possible pair of edge removals on the given tree_. **Example 1:** ``` **Input:** nums = [1,5,5,4,11], edges = [[0,1],[1,2],[1,3],[3,4]] **Output:** 9 **Explanation:** The diagram above shows a way to make a pair of removals. - The 1st component has nodes [1,3,4] with values [5,4,11]. Its XOR value is 5 ^ 4 ^ 11 = 10. - The 2nd component has node [0] with value [1]. Its XOR value is 1 = 1. - The 3rd component has node [2] with value [5]. Its XOR value is 5 = 5. The score is the difference between the largest and smallest XOR value which is 10 - 1 = 9. It can be shown that no other pair of removals will obtain a smaller score than 9. ``` **Example 2:** ``` **Input:** nums = [5,5,2,4,4,2], edges = [[0,1],[1,2],[5,2],[4,3],[1,3]] **Output:** 0 **Explanation:** The diagram above shows a way to make a pair of removals. - The 1st component has nodes [3,4] with values [4,4]. Its XOR value is 4 ^ 4 = 0. - The 2nd component has nodes [1,0] with values [5,5]. Its XOR value is 5 ^ 5 = 0. - The 3rd component has nodes [2,5] with values [2,2]. Its XOR value is 2 ^ 2 = 0. The score is the difference between the largest and smallest XOR value which is 0 - 0 = 0. We cannot obtain a smaller score than 0. ``` **Constraints:** `n == nums.length` `3 <= n <= 1000` `1 <= nums[i] <= 108` `edges.length == n - 1` `edges[i].length == 2` `0 <= ai, bi < n` `ai != bi` `edges` represents a valid tree.",
        "test_case": [
            {
                "label": "Example 1",
                "input": "nums = [1,5,5,4,11], edges = [[0,1],[1,2],[1,3],[3,4]]",
                "output": "9 Explanation: The diagram above shows a way to make a pair of removals.\n- The 1 st component has nodes [1,3,4] with values [5,4,11]. Its XOR value is 5 ^ 4 ^ 11 = 10.\n- The 2 nd component has node [0] with value [1]. Its XOR value is 1 = 1.\n- The 3 rd component has node [2] with value [5]. Its XOR value is 5 = 5.\nThe score is the difference between the largest and smallest XOR value which is 10 - 1 = 9.\nIt can be shown that no other pair of removals will obtain a smaller score than 9."
            },
            {
                "label": "Example 2",
                "input": "nums = [5,5,2,4,4,2], edges = [[0,1],[1,2],[5,2],[4,3],[1,3]]",
                "output": "0 Explanation: The diagram above shows a way to make a pair of removals.\n- The 1 st component has nodes [3,4] with values [4,4]. Its XOR value is 4 ^ 4 = 0.\n- The 2 nd component has nodes [1,0] with values [5,5]. Its XOR value is 5 ^ 5 = 0.\n- The 3 rd component has nodes [2,5] with values [2,2]. Its XOR value is 2 ^ 2 = 0.\nThe score is the difference between the largest and smallest XOR value which is 0 - 0 = 0.\nWe cannot obtain a smaller score than 0. Constraints: n == nums.length 3 <= n <= 1000 1 <= nums[i] <= 10 8 edges.length == n - 1 edges[i].length == 2 0 <= a i , b i < n a i != b i edges represents a valid tree."
            }
        ],
        "elixir_template": "defmodule Solution do\n  @spec minimum_score(nums :: [integer], edges :: [[integer]]) :: integer\n  def minimum_score(nums, edges) do\n    \n  end\nend",
        "erlang_template": "-spec minimum_score(Nums :: [integer()], Edges :: [[integer()]]) -> integer().\nminimum_score(Nums, Edges) ->\n  .",
        "scala_template": "object Solution {\n    def minimumScore(nums: Array[Int], edges: Array[Array[Int]]): Int = {\n        \n    }\n}"
    },
    {
        "id": 2398,
        "name": "check-if-matrix-is-x-matrix",
        "difficulty": "Easy",
        "link": "https://leetcode.com/problems/check-if-matrix-is-x-matrix/",
        "task_description": "A square matrix is said to be an **X-Matrix** if **both** of the following conditions hold: All the elements in the diagonals of the matrix are **non-zero**. All other elements are 0. Given a 2D integer array `grid` of size `n x n` representing a square matrix, return `true`_ if _`grid`_ is an X-Matrix_. Otherwise, return `false`. **Example 1:** ``` **Input:** grid = [[2,0,0,1],[0,3,1,0],[0,5,2,0],[4,0,0,2]] **Output:** true **Explanation:** Refer to the diagram above. An X-Matrix should have the green elements (diagonals) be non-zero and the red elements be 0. Thus, grid is an X-Matrix. ``` **Example 2:** ``` **Input:** grid = [[5,7,0],[0,3,1],[0,5,0]] **Output:** false **Explanation:** Refer to the diagram above. An X-Matrix should have the green elements (diagonals) be non-zero and the red elements be 0. Thus, grid is not an X-Matrix. ``` **Constraints:** `n == grid.length == grid[i].length` `3 <= n <= 100` `0 <= grid[i][j] <= 105`",
        "test_case": [
            {
                "label": "Example 1",
                "input": "grid = [[2,0,0,1],[0,3,1,0],[0,5,2,0],[4,0,0,2]]",
                "output": "true Explanation: Refer to the diagram above. \nAn X-Matrix should have the green elements (diagonals) be non-zero and the red elements be 0.\nThus, grid is an X-Matrix."
            },
            {
                "label": "Example 2",
                "input": "grid = [[5,7,0],[0,3,1],[0,5,0]]",
                "output": "false Explanation: Refer to the diagram above.\nAn X-Matrix should have the green elements (diagonals) be non-zero and the red elements be 0.\nThus, grid is not an X-Matrix. Constraints: n == grid.length == grid[i].length 3 <= n <= 100 0 <= grid[i][j] <= 10 5"
            }
        ],
        "elixir_template": "defmodule Solution do\n  @spec check_x_matrix(grid :: [[integer]]) :: boolean\n  def check_x_matrix(grid) do\n    \n  end\nend",
        "erlang_template": "-spec check_x_matrix(Grid :: [[integer()]]) -> boolean().\ncheck_x_matrix(Grid) ->\n  .",
        "scala_template": "object Solution {\n    def checkXMatrix(grid: Array[Array[Int]]): Boolean = {\n        \n    }\n}"
    },
    {
        "id": 2397,
        "name": "count-number-of-ways-to-place-houses",
        "difficulty": "Medium",
        "link": "https://leetcode.com/problems/count-number-of-ways-to-place-houses/",
        "task_description": "There is a street with `n * 2` **plots**, where there are `n` plots on each side of the street. The plots on each side are numbered from `1` to `n`. On each plot, a house can be placed. Return _the number of ways houses can be placed such that no two houses are adjacent to each other on the same side of the street_. Since the answer may be very large, return it **modulo** `109 + 7`. Note that if a house is placed on the `ith` plot on one side of the street, a house can also be placed on the `ith` plot on the other side of the street. **Example 1:** ``` **Input:** n = 1 **Output:** 4 **Explanation:** Possible arrangements: 1. All plots are empty. 2. A house is placed on one side of the street. 3. A house is placed on the other side of the street. 4. Two houses are placed, one on each side of the street. ``` **Example 2:** ``` **Input:** n = 2 **Output:** 9 **Explanation:** The 9 possible arrangements are shown in the diagram above. ``` **Constraints:** `1 <= n <= 104`",
        "test_case": [
            {
                "label": "Example 1",
                "input": "n = 1",
                "output": "4 Explanation: Possible arrangements:\n1. All plots are empty.\n2. A house is placed on one side of the street.\n3. A house is placed on the other side of the street.\n4. Two houses are placed, one on each side of the street."
            },
            {
                "label": "Example 2",
                "input": "n = 2",
                "output": "9 Explanation: The 9 possible arrangements are shown in the diagram above."
            }
        ],
        "elixir_template": "defmodule Solution do\n  @spec count_house_placements(n :: integer) :: integer\n  def count_house_placements(n) do\n    \n  end\nend",
        "erlang_template": "-spec count_house_placements(N :: integer()) -> integer().\ncount_house_placements(N) ->\n  .",
        "scala_template": "object Solution {\n    def countHousePlacements(n: Int): Int = {\n        \n    }\n}"
    },
    {
        "id": 2395,
        "name": "longest-binary-subsequence-less-than-or-equal-to-k",
        "difficulty": "Medium",
        "link": "https://leetcode.com/problems/longest-binary-subsequence-less-than-or-equal-to-k/",
        "task_description": "You are given a binary string `s` and a positive integer `k`. Return _the length of the **longest** subsequence of _`s`_ that makes up a **binary** number less than or equal to_ `k`. Note: The subsequence can contain **leading zeroes**. The empty string is considered to be equal to `0`. A **subsequence** is a string that can be derived from another string by deleting some or no characters without changing the order of the remaining characters. **Example 1:** ``` **Input:** s = \"1001010\", k = 5 **Output:** 5 **Explanation:** The longest subsequence of s that makes up a binary number less than or equal to 5 is \"00010\", as this number is equal to 2 in decimal. Note that \"00100\" and \"00101\" are also possible, which are equal to 4 and 5 in decimal, respectively. The length of this subsequence is 5, so 5 is returned. ``` **Example 2:** ``` **Input:** s = \"00101001\", k = 1 **Output:** 6 **Explanation:** \"000001\" is the longest subsequence of s that makes up a binary number less than or equal to 1, as this number is equal to 1 in decimal. The length of this subsequence is 6, so 6 is returned. ``` **Constraints:** `1 <= s.length <= 1000` `s[i]` is either `'0'` or `'1'`. `1 <= k <= 109`",
        "test_case": [
            {
                "label": "Example 1",
                "input": "s = \"1001010\", k = 5",
                "output": "5 Explanation: The longest subsequence of s that makes up a binary number less than or equal to 5 is \"00010\", as this number is equal to 2 in decimal.\nNote that \"00100\" and \"00101\" are also possible, which are equal to 4 and 5 in decimal, respectively.\nThe length of this subsequence is 5, so 5 is returned."
            },
            {
                "label": "Example 2",
                "input": "s = \"00101001\", k = 1",
                "output": "6 Explanation: \"000001\" is the longest subsequence of s that makes up a binary number less than or equal to 1, as this number is equal to 1 in decimal.\nThe length of this subsequence is 6, so 6 is returned."
            }
        ],
        "elixir_template": "defmodule Solution do\n  @spec longest_subsequence(s :: String.t, k :: integer) :: integer\n  def longest_subsequence(s, k) do\n    \n  end\nend",
        "erlang_template": "-spec longest_subsequence(S :: unicode:unicode_binary(), K :: integer()) -> integer().\nlongest_subsequence(S, K) ->\n  .",
        "scala_template": "object Solution {\n    def longestSubsequence(s: String, k: Int): Int = {\n        \n    }\n}"
    },
    {
        "id": 2394,
        "name": "count-subarrays-with-score-less-than-k",
        "difficulty": "Hard",
        "link": "https://leetcode.com/problems/count-subarrays-with-score-less-than-k/",
        "task_description": "The **score** of an array is defined as the **product** of its sum and its length. For example, the score of `[1, 2, 3, 4, 5]` is `(1 + 2 + 3 + 4 + 5) * 5 = 75`. Given a positive integer array `nums` and an integer `k`, return _the **number of non-empty subarrays** of_ `nums` _whose score is **strictly less** than_ `k`. A **subarray** is a contiguous sequence of elements within an array. **Example 1:** ``` **Input:** nums = [2,1,4,3,5], k = 10 **Output:** 6 **Explanation:** The 6 subarrays having scores less than 10 are: - [2] with score 2 * 1 = 2. - [1] with score 1 * 1 = 1. - [4] with score 4 * 1 = 4. - [3] with score 3 * 1 = 3. - [5] with score 5 * 1 = 5. - [2,1] with score (2 + 1) * 2 = 6. Note that subarrays such as [1,4] and [4,3,5] are not considered because their scores are 10 and 36 respectively, while we need scores strictly less than 10. ``` **Example 2:** ``` **Input:** nums = [1,1,1], k = 5 **Output:** 5 **Explanation:** Every subarray except [1,1,1] has a score less than 5. [1,1,1] has a score (1 + 1 + 1) * 3 = 9, which is greater than 5. Thus, there are 5 subarrays having scores less than 5. ``` **Constraints:** `1 <= nums.length <= 105` `1 <= nums[i] <= 105` `1 <= k <= 1015`",
        "test_case": [
            {
                "label": "Example 1",
                "input": "nums = [2,1,4,3,5], k = 10",
                "output": "6 Explanation: The 6 subarrays having scores less than 10 are:\n- [2] with score 2 * 1 = 2.\n- [1] with score 1 * 1 = 1.\n- [4] with score 4 * 1 = 4.\n- [3] with score 3 * 1 = 3. \n- [5] with score 5 * 1 = 5.\n- [2,1] with score (2 + 1) * 2 = 6.\nNote that subarrays such as [1,4] and [4,3,5] are not considered because their scores are 10 and 36 respectively, while we need scores strictly less than 10."
            },
            {
                "label": "Example 2",
                "input": "nums = [1,1,1], k = 5",
                "output": "5 Explanation: Every subarray except [1,1,1] has a score less than 5.\n[1,1,1] has a score (1 + 1 + 1) * 3 = 9, which is greater than 5.\nThus, there are 5 subarrays having scores less than 5."
            }
        ],
        "elixir_template": "defmodule Solution do\n  @spec count_subarrays(nums :: [integer], k :: integer) :: integer\n  def count_subarrays(nums, k) do\n    \n  end\nend",
        "erlang_template": "-spec count_subarrays(Nums :: [integer()], K :: integer()) -> integer().\ncount_subarrays(Nums, K) ->\n  .",
        "scala_template": "object Solution {\n    def countSubarrays(nums: Array[Int], k: Long): Long = {\n        \n    }\n}"
    },
    {
        "id": 2393,
        "name": "match-substring-after-replacement",
        "difficulty": "Hard",
        "link": "https://leetcode.com/problems/match-substring-after-replacement/",
        "task_description": "You are given two strings `s` and `sub`. You are also given a 2D character array `mappings` where `mappings[i] = [oldi, newi]` indicates that you may perform the following operation **any** number of times: **Replace** a character `oldi` of `sub` with `newi`. Each character in `sub` **cannot** be replaced more than once. Return `true`_ if it is possible to make _`sub`_ a substring of _`s`_ by replacing zero or more characters according to _`mappings`. Otherwise, return `false`. A **substring** is a contiguous non-empty sequence of characters within a string. **Example 1:** ``` **Input:** s = \"fool3e7bar\", sub = \"leet\", mappings = [[\"e\",\"3\"],[\"t\",\"7\"],[\"t\",\"8\"]] **Output:** true **Explanation:** Replace the first 'e' in sub with '3' and 't' in sub with '7'. Now sub = \"l3e7\" is a substring of s, so we return true. ``` **Example 2:** ``` **Input:** s = \"fooleetbar\", sub = \"f00l\", mappings = [[\"o\",\"0\"]] **Output:** false **Explanation:** The string \"f00l\" is not a substring of s and no replacements can be made. Note that we cannot replace '0' with 'o'. ``` **Example 3:** ``` **Input:** s = \"Fool33tbaR\", sub = \"leetd\", mappings = [[\"e\",\"3\"],[\"t\",\"7\"],[\"t\",\"8\"],[\"d\",\"b\"],[\"p\",\"b\"]] **Output:** true **Explanation:** Replace the first and second 'e' in sub with '3' and 'd' in sub with 'b'. Now sub = \"l33tb\" is a substring of s, so we return true. ``` **Constraints:** `1 <= sub.length <= s.length <= 5000` `0 <= mappings.length <= 1000` `mappings[i].length == 2` `oldi != newi` `s` and `sub` consist of uppercase and lowercase English letters and digits. `oldi` and `newi` are either uppercase or lowercase English letters or digits.",
        "test_case": [
            {
                "label": "Example 1",
                "input": "s = \"fool3e7bar\", sub = \"leet\", mappings = [[\"e\",\"3\"],[\"t\",\"7\"],[\"t\",\"8\"]]",
                "output": "true Explanation: Replace the first 'e' in sub with '3' and 't' in sub with '7'.\nNow sub = \"l3e7\" is a substring of s, so we return true."
            },
            {
                "label": "Example 2",
                "input": "s = \"fooleetbar\", sub = \"f00l\", mappings = [[\"o\",\"0\"]]",
                "output": "false Explanation: The string \"f00l\" is not a substring of s and no replacements can be made.\nNote that we cannot replace '0' with 'o'."
            },
            {
                "label": "Example 3",
                "input": "s = \"Fool33tbaR\", sub = \"leetd\", mappings = [[\"e\",\"3\"],[\"t\",\"7\"],[\"t\",\"8\"],[\"d\",\"b\"],[\"p\",\"b\"]]",
                "output": "true Explanation: Replace the first and second 'e' in sub with '3' and 'd' in sub with 'b'.\nNow sub = \"l33tb\" is a substring of s, so we return true."
            }
        ],
        "elixir_template": "defmodule Solution do\n  @spec match_replacement(s :: String.t, sub :: String.t, mappings :: [[char]]) :: boolean\n  def match_replacement(s, sub, mappings) do\n    \n  end\nend",
        "erlang_template": "-spec match_replacement(S :: unicode:unicode_binary(), Sub :: unicode:unicode_binary(), Mappings :: [[char()]]) -> boolean().\nmatch_replacement(S, Sub, Mappings) ->\n  .",
        "scala_template": "object Solution {\n    def matchReplacement(s: String, sub: String, mappings: Array[Array[Char]]): Boolean = {\n        \n    }\n}"
    },
    {
        "id": 2392,
        "name": "successful-pairs-of-spells-and-potions",
        "difficulty": "Medium",
        "link": "https://leetcode.com/problems/successful-pairs-of-spells-and-potions/",
        "task_description": "You are given two positive integer arrays `spells` and `potions`, of length `n` and `m` respectively, where `spells[i]` represents the strength of the `ith` spell and `potions[j]` represents the strength of the `jth` potion. You are also given an integer `success`. A spell and potion pair is considered **successful** if the **product** of their strengths is **at least** `success`. Return _an integer array _`pairs`_ of length _`n`_ where _`pairs[i]`_ is the number of **potions** that will form a successful pair with the _`ith`_ spell._ **Example 1:** ``` **Input:** spells = [5,1,3], potions = [1,2,3,4,5], success = 7 **Output:** [4,0,3] **Explanation:** - 0th spell: 5 * [1,2,3,4,5] = [5,**10**,**15**,**20**,**25**]. 4 pairs are successful. - 1st spell: 1 * [1,2,3,4,5] = [1,2,3,4,5]. 0 pairs are successful. - 2nd spell: 3 * [1,2,3,4,5] = [3,6,**9**,**12**,**15**]. 3 pairs are successful. Thus, [4,0,3] is returned. ``` **Example 2:** ``` **Input:** spells = [3,1,2], potions = [8,5,8], success = 16 **Output:** [2,0,2] **Explanation:** - 0th spell: 3 * [8,5,8] = [**24**,15,**24**]. 2 pairs are successful. - 1st spell: 1 * [8,5,8] = [8,5,8]. 0 pairs are successful. - 2nd spell: 2 * [8,5,8] = [**16**,10,**16**]. 2 pairs are successful. Thus, [2,0,2] is returned. ``` **Constraints:** `n == spells.length` `m == potions.length` `1 <= n, m <= 105` `1 <= spells[i], potions[i] <= 105` `1 <= success <= 1010`",
        "test_case": [
            {
                "label": "Example 1",
                "input": "spells = [5,1,3], potions = [1,2,3,4,5], success = 7",
                "output": "[4,0,3] Explanation: - 0 th spell: 5 * [1,2,3,4,5] = [5, 10 , 15 , 20 , 25 ]. 4 pairs are successful.\n- 1 st spell: 1 * [1,2,3,4,5] = [1,2,3,4,5]. 0 pairs are successful.\n- 2 nd spell: 3 * [1,2,3,4,5] = [3,6, 9 , 12 , 15 ]. 3 pairs are successful.\nThus, [4,0,3] is returned."
            },
            {
                "label": "Example 2",
                "input": "spells = [3,1,2], potions = [8,5,8], success = 16",
                "output": "[2,0,2] Explanation: - 0 th spell: 3 * [8,5,8] = [ 24 ,15, 24 ]. 2 pairs are successful.\n- 1 st spell: 1 * [8,5,8] = [8,5,8]. 0 pairs are successful. \n- 2 nd spell: 2 * [8,5,8] = [ 16 ,10, 16 ]. 2 pairs are successful. \nThus, [2,0,2] is returned. Constraints: n == spells.length m == potions.length 1 <= n, m <= 10 5 1 <= spells[i], potions[i] <= 10 5 1 <= success <= 10 10"
            }
        ],
        "elixir_template": "defmodule Solution do\n  @spec successful_pairs(spells :: [integer], potions :: [integer], success :: integer) :: [integer]\n  def successful_pairs(spells, potions, success) do\n    \n  end\nend",
        "erlang_template": "-spec successful_pairs(Spells :: [integer()], Potions :: [integer()], Success :: integer()) -> [integer()].\nsuccessful_pairs(Spells, Potions, Success) ->\n  .",
        "scala_template": "object Solution {\n    def successfulPairs(spells: Array[Int], potions: Array[Int], success: Long): Array[Int] = {\n        \n    }\n}"
    },
    {
        "id": 2391,
        "name": "strong-password-checker-ii",
        "difficulty": "Easy",
        "link": "https://leetcode.com/problems/strong-password-checker-ii/",
        "task_description": "A password is said to be **strong** if it satisfies all the following criteria: It has at least `8` characters. It contains at least **one lowercase** letter. It contains at least **one uppercase** letter. It contains at least **one digit**. It contains at least **one special character**. The special characters are the characters in the following string: `\"!@#$%^&*()-+\"`. It does **not** contain `2` of the same character in adjacent positions (i.e., `\"aab\"` violates this condition, but `\"aba\"` does not). Given a string `password`, return `true`_ if it is a **strong** password_. Otherwise, return `false`. **Example 1:** ``` **Input:** password = \"IloveLe3tcode!\" **Output:** true **Explanation:** The password meets all the requirements. Therefore, we return true. ``` **Example 2:** ``` **Input:** password = \"Me+You--IsMyDream\" **Output:** false **Explanation:** The password does not contain a digit and also contains 2 of the same character in adjacent positions. Therefore, we return false. ``` **Example 3:** ``` **Input:** password = \"1aB!\" **Output:** false **Explanation:** The password does not meet the length requirement. Therefore, we return false. ``` **Constraints:** `1 <= password.length <= 100` `password` consists of letters, digits, and special characters: `\"!@#$%^&*()-+\"`.",
        "test_case": [
            {
                "label": "Example 1",
                "input": "password = \"IloveLe3tcode!\"",
                "output": "true Explanation: The password meets all the requirements. Therefore, we return true."
            },
            {
                "label": "Example 2",
                "input": "password = \"Me+You--IsMyDream\"",
                "output": "false Explanation: The password does not contain a digit and also contains 2 of the same character in adjacent positions. Therefore, we return false."
            },
            {
                "label": "Example 3",
                "input": "password = \"1aB!\"",
                "output": "false Explanation: The password does not meet the length requirement. Therefore, we return false."
            }
        ],
        "elixir_template": "defmodule Solution do\n  @spec strong_password_checker_ii(password :: String.t) :: boolean\n  def strong_password_checker_ii(password) do\n    \n  end\nend",
        "erlang_template": "-spec strong_password_checker_ii(Password :: unicode:unicode_binary()) -> boolean().\nstrong_password_checker_ii(Password) ->\n  .",
        "scala_template": "object Solution {\n    def strongPasswordCheckerII(password: String): Boolean = {\n        \n    }\n}"
    },
    {
        "id": 2390,
        "name": "naming-a-company",
        "difficulty": "Hard",
        "link": "https://leetcode.com/problems/naming-a-company/",
        "task_description": "You are given an array of strings `ideas` that represents a list of names to be used in the process of naming a company. The process of naming a company is as follows: Choose 2 **distinct** names from `ideas`, call them `ideaA` and `ideaB`. Swap the first letters of `ideaA` and `ideaB` with each other. If **both** of the new names are not found in the original `ideas`, then the name `ideaA ideaB` (the **concatenation** of `ideaA` and `ideaB`, separated by a space) is a valid company name. Otherwise, it is not a valid name. Return _the number of **distinct** valid names for the company_. **Example 1:** ``` **Input:** ideas = [\"coffee\",\"donuts\",\"time\",\"toffee\"] **Output:** 6 **Explanation:** The following selections are valid: - (\"coffee\", \"donuts\"): The company name created is \"doffee conuts\". - (\"donuts\", \"coffee\"): The company name created is \"conuts doffee\". - (\"donuts\", \"time\"): The company name created is \"tonuts dime\". - (\"donuts\", \"toffee\"): The company name created is \"tonuts doffee\". - (\"time\", \"donuts\"): The company name created is \"dime tonuts\". - (\"toffee\", \"donuts\"): The company name created is \"doffee tonuts\". Therefore, there are a total of 6 distinct company names. The following are some examples of invalid selections: - (\"coffee\", \"time\"): The name \"toffee\" formed after swapping already exists in the original array. - (\"time\", \"toffee\"): Both names are still the same after swapping and exist in the original array. - (\"coffee\", \"toffee\"): Both names formed after swapping already exist in the original array. ``` **Example 2:** ``` **Input:** ideas = [\"lack\",\"back\"] **Output:** 0 **Explanation:** There are no valid selections. Therefore, 0 is returned. ``` **Constraints:** `2 <= ideas.length <= 5 * 104` `1 <= ideas[i].length <= 10` `ideas[i]` consists of lowercase English letters. All the strings in `ideas` are **unique**.",
        "test_case": [
            {
                "label": "Example 1",
                "input": "ideas = [\"coffee\",\"donuts\",\"time\",\"toffee\"]",
                "output": "6 Explanation: The following selections are valid:\n- (\"coffee\", \"donuts\"): The company name created is \"doffee conuts\".\n- (\"donuts\", \"coffee\"): The company name created is \"conuts doffee\".\n- (\"donuts\", \"time\"): The company name created is \"tonuts dime\".\n- (\"donuts\", \"toffee\"): The company name created is \"tonuts doffee\".\n- (\"time\", \"donuts\"): The company name created is \"dime tonuts\".\n- (\"toffee\", \"donuts\"): The company name created is \"doffee tonuts\".\nTherefore, there are a total of 6 distinct company names.\n\nThe following are some examples of invalid selections:\n- (\"coffee\", \"time\"): The name \"toffee\" formed after swapping already exists in the original array.\n- (\"time\", \"toffee\"): Both names are still the same after swapping and exist in the original array.\n- (\"coffee\", \"toffee\"): Both names formed after swapping already exist in the original array."
            },
            {
                "label": "Example 2",
                "input": "ideas = [\"lack\",\"back\"]",
                "output": "0 Explanation: There are no valid selections. Therefore, 0 is returned."
            }
        ],
        "elixir_template": "defmodule Solution do\n  @spec distinct_names(ideas :: [String.t]) :: integer\n  def distinct_names(ideas) do\n    \n  end\nend",
        "erlang_template": "-spec distinct_names(Ideas :: [unicode:unicode_binary()]) -> integer().\ndistinct_names(Ideas) ->\n  .",
        "scala_template": "object Solution {\n    def distinctNames(ideas: Array[String]): Long = {\n        \n    }\n}"
    },
    {
        "id": 2389,
        "name": "design-a-text-editor",
        "difficulty": "Hard",
        "link": "https://leetcode.com/problems/design-a-text-editor/",
        "task_description": "Design a text editor with a cursor that can do the following: **Add** text to where the cursor is. **Delete** text from where the cursor is (simulating the backspace key). **Move** the cursor either left or right. When deleting text, only characters to the left of the cursor will be deleted. The cursor will also remain within the actual text and cannot be moved beyond it. More formally, we have that `0 <= cursor.position <= currentText.length` always holds. Implement the `TextEditor` class: `TextEditor()` Initializes the object with empty text. `void addText(string text)` Appends `text` to where the cursor is. The cursor ends to the right of `text`. `int deleteText(int k)` Deletes `k` characters to the left of the cursor. Returns the number of characters actually deleted. `string cursorLeft(int k)` Moves the cursor to the left `k` times. Returns the last `min(10, len)` characters to the left of the cursor, where `len` is the number of characters to the left of the cursor. `string cursorRight(int k)` Moves the cursor to the right `k` times. Returns the last `min(10, len)` characters to the left of the cursor, where `len` is the number of characters to the left of the cursor. **Example 1:** ``` **Input** [\"TextEditor\", \"addText\", \"deleteText\", \"addText\", \"cursorRight\", \"cursorLeft\", \"deleteText\", \"cursorLeft\", \"cursorRight\"] [[], [\"leetcode\"], [4], [\"practice\"], [3], [8], [10], [2], [6]] **Output** [null, null, 4, null, \"etpractice\", \"leet\", 4, \"\", \"practi\"] **Explanation** TextEditor textEditor = new TextEditor(); // The current text is \"|\". (The '|' character represents the cursor) textEditor.addText(\"leetcode\"); // The current text is \"leetcode|\". textEditor.deleteText(4); // return 4 // The current text is \"leet|\". // 4 characters were deleted. textEditor.addText(\"practice\"); // The current text is \"leetpractice|\". textEditor.cursorRight(3); // return \"etpractice\" // The current text is \"leetpractice|\". // The cursor cannot be moved beyond the actual text and thus did not move. // \"etpractice\" is the last 10 characters to the left of the cursor. textEditor.cursorLeft(8); // return \"leet\" // The current text is \"leet|practice\". // \"leet\" is the last min(10, 4) = 4 characters to the left of the cursor. textEditor.deleteText(10); // return 4 // The current text is \"|practice\". // Only 4 characters were deleted. textEditor.cursorLeft(2); // return \"\" // The current text is \"|practice\". // The cursor cannot be moved beyond the actual text and thus did not move. // \"\" is the last min(10, 0) = 0 characters to the left of the cursor. textEditor.cursorRight(6); // return \"practi\" // The current text is \"practi|ce\". // \"practi\" is the last min(10, 6) = 6 characters to the left of the cursor. ``` **Constraints:** `1 <= text.length, k <= 40` `text` consists of lowercase English letters. At most `2 * 104` calls **in total** will be made to `addText`, `deleteText`, `cursorLeft` and `cursorRight`. **Follow-up:** Could you find a solution with time complexity of `O(k)` per call?",
        "test_case": [],
        "elixir_template": "defmodule TextEditor do\n  @spec init_() :: any\n  def init_() do\n    \n  end\n\n  @spec add_text(text :: String.t) :: any\n  def add_text(text) do\n    \n  end\n\n  @spec delete_text(k :: integer) :: integer\n  def delete_text(k) do\n    \n  end\n\n  @spec cursor_left(k :: integer) :: String.t\n  def cursor_left(k) do\n    \n  end\n\n  @spec cursor_right(k :: integer) :: String.t\n  def cursor_right(k) do\n    \n  end\nend\n\n# Your functions will be called as such:\n# TextEditor.init_()\n# TextEditor.add_text(text)\n# param_2 = TextEditor.delete_text(k)\n# param_3 = TextEditor.cursor_left(k)\n# param_4 = TextEditor.cursor_right(k)\n\n# TextEditor.init_ will be called before every test case, in which you can do some necessary initializations.",
        "erlang_template": "-spec text_editor_init_() -> any().\ntext_editor_init_() ->\n  .\n\n-spec text_editor_add_text(Text :: unicode:unicode_binary()) -> any().\ntext_editor_add_text(Text) ->\n  .\n\n-spec text_editor_delete_text(K :: integer()) -> integer().\ntext_editor_delete_text(K) ->\n  .\n\n-spec text_editor_cursor_left(K :: integer()) -> unicode:unicode_binary().\ntext_editor_cursor_left(K) ->\n  .\n\n-spec text_editor_cursor_right(K :: integer()) -> unicode:unicode_binary().\ntext_editor_cursor_right(K) ->\n  .\n\n\n%% Your functions will be called as such:\n%% text_editor_init_(),\n%% text_editor_add_text(Text),\n%% Param_2 = text_editor_delete_text(K),\n%% Param_3 = text_editor_cursor_left(K),\n%% Param_4 = text_editor_cursor_right(K),\n\n%% text_editor_init_ will be called before every test case, in which you can do some necessary initializations.",
        "scala_template": "class TextEditor() {\n\n    def addText(text: String): Unit = {\n        \n    }\n\n    def deleteText(k: Int): Int = {\n        \n    }\n\n    def cursorLeft(k: Int): String = {\n        \n    }\n\n    def cursorRight(k: Int): String = {\n        \n    }\n\n}\n\n/**\n * Your TextEditor object will be instantiated and called as such:\n * val obj = new TextEditor()\n * obj.addText(text)\n * val param_2 = obj.deleteText(k)\n * val param_3 = obj.cursorLeft(k)\n * val param_4 = obj.cursorRight(k)\n */"
    },
    {
        "id": 2388,
        "name": "replace-elements-in-an-array",
        "difficulty": "Medium",
        "link": "https://leetcode.com/problems/replace-elements-in-an-array/",
        "task_description": "You are given a **0-indexed** array `nums` that consists of `n` **distinct** positive integers. Apply `m` operations to this array, where in the `ith` operation you replace the number `operations[i][0]` with `operations[i][1]`. It is guaranteed that in the `ith` operation: `operations[i][0]` **exists** in `nums`. `operations[i][1]` does **not** exist in `nums`. Return _the array obtained after applying all the operations_. **Example 1:** ``` **Input:** nums = [1,2,4,6], operations = [[1,3],[4,7],[6,1]] **Output:** [3,2,7,1] **Explanation:** We perform the following operations on nums: - Replace the number 1 with 3. nums becomes [**3**,2,4,6]. - Replace the number 4 with 7. nums becomes [3,2,**7**,6]. - Replace the number 6 with 1. nums becomes [3,2,7,**1**]. We return the final array [3,2,7,1]. ``` **Example 2:** ``` **Input:** nums = [1,2], operations = [[1,3],[2,1],[3,2]] **Output:** [2,1] **Explanation:** We perform the following operations to nums: - Replace the number 1 with 3. nums becomes [**3**,2]. - Replace the number 2 with 1. nums becomes [3,**1**]. - Replace the number 3 with 2. nums becomes [**2**,1]. We return the array [2,1]. ``` **Constraints:** `n == nums.length` `m == operations.length` `1 <= n, m <= 105` All the values of `nums` are **distinct**. `operations[i].length == 2` `1 <= nums[i], operations[i][0], operations[i][1] <= 106` `operations[i][0]` will exist in `nums` when applying the `ith` operation. `operations[i][1]` will not exist in `nums` when applying the `ith` operation.",
        "test_case": [
            {
                "label": "Example 1",
                "input": "nums = [1,2,4,6], operations = [[1,3],[4,7],[6,1]]",
                "output": "[3,2,7,1] Explanation: We perform the following operations on nums:\n- Replace the number 1 with 3. nums becomes [ 3 ,2,4,6].\n- Replace the number 4 with 7. nums becomes [3,2, 7 ,6].\n- Replace the number 6 with 1. nums becomes [3,2,7, 1 ].\nWe return the final array [3,2,7,1]."
            },
            {
                "label": "Example 2",
                "input": "nums = [1,2], operations = [[1,3],[2,1],[3,2]]",
                "output": "[2,1] Explanation: We perform the following operations to nums:\n- Replace the number 1 with 3. nums becomes [ 3 ,2].\n- Replace the number 2 with 1. nums becomes [3, 1 ].\n- Replace the number 3 with 2. nums becomes [ 2 ,1].\nWe return the array [2,1]. Constraints: n == nums.length m == operations.length 1 <= n, m <= 10 5 All the values of nums are distinct . operations[i].length == 2 1 <= nums[i], operations[i][0], operations[i][1] <= 10 6 operations[i][0] will exist in nums when applying the i th operation. operations[i][1] will not exist in nums when applying the i th operation."
            }
        ],
        "elixir_template": "defmodule Solution do\n  @spec array_change(nums :: [integer], operations :: [[integer]]) :: [integer]\n  def array_change(nums, operations) do\n    \n  end\nend",
        "erlang_template": "-spec array_change(Nums :: [integer()], Operations :: [[integer()]]) -> [integer()].\narray_change(Nums, Operations) ->\n  .",
        "scala_template": "object Solution {\n    def arrayChange(nums: Array[Int], operations: Array[Array[Int]]): Array[Int] = {\n        \n    }\n}"
    },
    {
        "id": 2387,
        "name": "partition-array-such-that-maximum-difference-is-k",
        "difficulty": "Medium",
        "link": "https://leetcode.com/problems/partition-array-such-that-maximum-difference-is-k/",
        "task_description": "You are given an integer array `nums` and an integer `k`. You may partition `nums` into one or more **subsequences** such that each element in `nums` appears in **exactly** one of the subsequences. Return _the **minimum **number of subsequences needed such that the difference between the maximum and minimum values in each subsequence is **at most** _`k`_._ A **subsequence** is a sequence that can be derived from another sequence by deleting some or no elements without changing the order of the remaining elements. **Example 1:** ``` **Input:** nums = [3,6,1,2,5], k = 2 **Output:** 2 **Explanation:** We can partition nums into the two subsequences [3,1,2] and [6,5]. The difference between the maximum and minimum value in the first subsequence is 3 - 1 = 2. The difference between the maximum and minimum value in the second subsequence is 6 - 5 = 1. Since two subsequences were created, we return 2. It can be shown that 2 is the minimum number of subsequences needed. ``` **Example 2:** ``` **Input:** nums = [1,2,3], k = 1 **Output:** 2 **Explanation:** We can partition nums into the two subsequences [1,2] and [3]. The difference between the maximum and minimum value in the first subsequence is 2 - 1 = 1. The difference between the maximum and minimum value in the second subsequence is 3 - 3 = 0. Since two subsequences were created, we return 2. Note that another optimal solution is to partition nums into the two subsequences [1] and [2,3]. ``` **Example 3:** ``` **Input:** nums = [2,2,4,5], k = 0 **Output:** 3 **Explanation:** We can partition nums into the three subsequences [2,2], [4], and [5]. The difference between the maximum and minimum value in the first subsequences is 2 - 2 = 0. The difference between the maximum and minimum value in the second subsequences is 4 - 4 = 0. The difference between the maximum and minimum value in the third subsequences is 5 - 5 = 0. Since three subsequences were created, we return 3. It can be shown that 3 is the minimum number of subsequences needed. ``` **Constraints:** `1 <= nums.length <= 105` `0 <= nums[i] <= 105` `0 <= k <= 105`",
        "test_case": [
            {
                "label": "Example 1",
                "input": "nums = [3,6,1,2,5], k = 2",
                "output": "2 Explanation: We can partition nums into the two subsequences [3,1,2] and [6,5].\nThe difference between the maximum and minimum value in the first subsequence is 3 - 1 = 2.\nThe difference between the maximum and minimum value in the second subsequence is 6 - 5 = 1.\nSince two subsequences were created, we return 2. It can be shown that 2 is the minimum number of subsequences needed."
            },
            {
                "label": "Example 2",
                "input": "nums = [1,2,3], k = 1",
                "output": "2 Explanation: We can partition nums into the two subsequences [1,2] and [3].\nThe difference between the maximum and minimum value in the first subsequence is 2 - 1 = 1.\nThe difference between the maximum and minimum value in the second subsequence is 3 - 3 = 0.\nSince two subsequences were created, we return 2. Note that another optimal solution is to partition nums into the two subsequences [1] and [2,3]."
            },
            {
                "label": "Example 3",
                "input": "nums = [2,2,4,5], k = 0",
                "output": "3 Explanation: We can partition nums into the three subsequences [2,2], [4], and [5].\nThe difference between the maximum and minimum value in the first subsequences is 2 - 2 = 0.\nThe difference between the maximum and minimum value in the second subsequences is 4 - 4 = 0.\nThe difference between the maximum and minimum value in the third subsequences is 5 - 5 = 0.\nSince three subsequences were created, we return 3. It can be shown that 3 is the minimum number of subsequences needed."
            }
        ],
        "elixir_template": "defmodule Solution do\n  @spec partition_array(nums :: [integer], k :: integer) :: integer\n  def partition_array(nums, k) do\n    \n  end\nend",
        "erlang_template": "-spec partition_array(Nums :: [integer()], K :: integer()) -> integer().\npartition_array(Nums, K) ->\n  .",
        "scala_template": "object Solution {\n    def partitionArray(nums: Array[Int], k: Int): Int = {\n        \n    }\n}"
    },
    {
        "id": 2386,
        "name": "min-max-game",
        "difficulty": "Easy",
        "link": "https://leetcode.com/problems/min-max-game/",
        "task_description": "You are given a **0-indexed** integer array `nums` whose length is a power of `2`. Apply the following algorithm on `nums`: Let `n` be the length of `nums`. If `n == 1`, **end** the process. Otherwise, **create** a new **0-indexed** integer array `newNums` of length `n / 2`. For every **even** index `i` where `0 <= i < n / 2`, **assign** the value of `newNums[i]` as `min(nums[2 * i], nums[2 * i + 1])`. For every **odd** index `i` where `0 <= i < n / 2`, **assign** the value of `newNums[i]` as `max(nums[2 * i], nums[2 * i + 1])`. **Replace** the array `nums` with `newNums`. **Repeat** the entire process starting from step 1. Return _the last number that remains in _`nums`_ after applying the algorithm._ **Example 1:** ``` **Input:** nums = [1,3,5,2,4,8,2,2] **Output:** 1 **Explanation:** The following arrays are the results of applying the algorithm repeatedly. First: nums = [1,5,4,2] Second: nums = [1,4] Third: nums = [1] 1 is the last remaining number, so we return 1. ``` **Example 2:** ``` **Input:** nums = [3] **Output:** 3 **Explanation:** 3 is already the last remaining number, so we return 3. ``` **Constraints:** `1 <= nums.length <= 1024` `1 <= nums[i] <= 109` `nums.length` is a power of `2`.",
        "test_case": [
            {
                "label": "Example 1",
                "input": "nums = [1,3,5,2,4,8,2,2]",
                "output": "1 Explanation: The following arrays are the results of applying the algorithm repeatedly.\nFirst: nums = [1,5,4,2]\nSecond: nums = [1,4]\nThird: nums = [1]\n1 is the last remaining number, so we return 1."
            },
            {
                "label": "Example 2",
                "input": "nums = [3]",
                "output": "3 Explanation: 3 is already the last remaining number, so we return 3."
            }
        ],
        "elixir_template": "defmodule Solution do\n  @spec min_max_game(nums :: [integer]) :: integer\n  def min_max_game(nums) do\n    \n  end\nend",
        "erlang_template": "-spec min_max_game(Nums :: [integer()]) -> integer().\nmin_max_game(Nums) ->\n  .",
        "scala_template": "object Solution {\n    def minMaxGame(nums: Array[Int]): Int = {\n        \n    }\n}"
    },
    {
        "id": 2384,
        "name": "root-equals-sum-of-children",
        "difficulty": "Easy",
        "link": "https://leetcode.com/problems/root-equals-sum-of-children/",
        "task_description": "You are given the `root` of a **binary tree** that consists of exactly `3` nodes: the root, its left child, and its right child. Return `true` _if the value of the root is equal to the **sum** of the values of its two children, or _`false`_ otherwise_. **Example 1:** ``` **Input:** root = [10,4,6] **Output:** true **Explanation:** The values of the root, its left child, and its right child are 10, 4, and 6, respectively. 10 is equal to 4 + 6, so we return true. ``` **Example 2:** ``` **Input:** root = [5,3,1] **Output:** false **Explanation:** The values of the root, its left child, and its right child are 5, 3, and 1, respectively. 5 is not equal to 3 + 1, so we return false. ``` **Constraints:** The tree consists only of the root, its left child, and its right child. `-100 <= Node.val <= 100`",
        "test_case": [
            {
                "label": "Example 1",
                "input": "root = [10,4,6]",
                "output": "true Explanation: The values of the root, its left child, and its right child are 10, 4, and 6, respectively.\n10 is equal to 4 + 6, so we return true."
            },
            {
                "label": "Example 2",
                "input": "root = [5,3,1]",
                "output": "false Explanation: The values of the root, its left child, and its right child are 5, 3, and 1, respectively.\n5 is not equal to 3 + 1, so we return false. Constraints: The tree consists only of the root, its left child, and its right child. -100 <= Node.val <= 100"
            }
        ],
        "elixir_template": "# Definition for a binary tree node.\n#\n# defmodule TreeNode do\n#   @type t :: %__MODULE__{\n#           val: integer,\n#           left: TreeNode.t() | nil,\n#           right: TreeNode.t() | nil\n#         }\n#   defstruct val: 0, left: nil, right: nil\n# end\n\ndefmodule Solution do\n  @spec check_tree(root :: TreeNode.t | nil) :: boolean\n  def check_tree(root) do\n    \n  end\nend",
        "erlang_template": "%% Definition for a binary tree node.\n%%\n%% -record(tree_node, {val = 0 :: integer(),\n%%                     left = null  :: 'null' | #tree_node{},\n%%                     right = null :: 'null' | #tree_node{}}).\n\n-spec check_tree(Root :: #tree_node{} | null) -> boolean().\ncheck_tree(Root) ->\n  .",
        "scala_template": "/**\n * Definition for a binary tree node.\n * class TreeNode(_value: Int = 0, _left: TreeNode = null, _right: TreeNode = null) {\n *   var value: Int = _value\n *   var left: TreeNode = _left\n *   var right: TreeNode = _right\n * }\n */\nobject Solution {\n    def checkTree(root: TreeNode): Boolean = {\n        \n    }\n}"
    },
    {
        "id": 2383,
        "name": "add-two-integers",
        "difficulty": "Easy",
        "link": "https://leetcode.com/problems/add-two-integers/",
        "task_description": "Given two integers `num1` and `num2`, return _the **sum** of the two integers_. **Example 1:** ``` **Input:** num1 = 12, num2 = 5 **Output:** 17 **Explanation:** num1 is 12, num2 is 5, and their sum is 12 + 5 = 17, so 17 is returned. ``` **Example 2:** ``` **Input:** num1 = -10, num2 = 4 **Output:** -6 **Explanation:** num1 + num2 = -6, so -6 is returned. ``` **Constraints:** `-100 <= num1, num2 <= 100`",
        "test_case": [
            {
                "label": "Example 1",
                "input": "num1 = 12, num2 = 5",
                "output": "17 Explanation: num1 is 12, num2 is 5, and their sum is 12 + 5 = 17, so 17 is returned."
            },
            {
                "label": "Example 2",
                "input": "num1 = -10, num2 = 4",
                "output": "-6 Explanation: num1 + num2 = -6, so -6 is returned. Constraints: -100 <= num1, num2 <= 100"
            }
        ],
        "elixir_template": "defmodule Solution do\n  @spec sum(num1 :: integer, num2 :: integer) :: integer\n  def sum(num1, num2) do\n    \n  end\nend",
        "erlang_template": "-spec sum(Num1 :: integer(), Num2 :: integer()) -> integer().\nsum(Num1, Num2) ->\n  .",
        "scala_template": "object Solution {\n    def sum(num1: Int, num2: Int): Int = {\n        \n    }\n}"
    },
    {
        "id": 2380,
        "name": "booking-concert-tickets-in-groups",
        "difficulty": "Hard",
        "link": "https://leetcode.com/problems/booking-concert-tickets-in-groups/",
        "task_description": "A concert hall has `n` rows numbered from `0` to `n - 1`, each with `m` seats, numbered from `0` to `m - 1`. You need to design a ticketing system that can allocate seats in the following cases: If a group of `k` spectators can sit **together** in a row. If **every** member of a group of `k` spectators can get a seat. They may or **may not** sit together. Note that the spectators are very picky. Hence: They will book seats only if each member of their group can get a seat with row number **less than or equal** to `maxRow`. `maxRow` can **vary** from group to group. In case there are multiple rows to choose from, the row with the **smallest** number is chosen. If there are multiple seats to choose in the same row, the seat with the **smallest** number is chosen. Implement the `BookMyShow` class: `BookMyShow(int n, int m)` Initializes the object with `n` as number of rows and `m` as number of seats per row. `int[] gather(int k, int maxRow)` Returns an array of length `2` denoting the row and seat number (respectively) of the **first seat** being allocated to the `k` members of the group, who must sit **together**. In other words, it returns the smallest possible `r` and `c` such that all `[c, c + k - 1]` seats are valid and empty in row `r`, and `r <= maxRow`. Returns `[]` in case it is **not possible** to allocate seats to the group. `boolean scatter(int k, int maxRow)` Returns `true` if all `k` members of the group can be allocated seats in rows `0` to `maxRow`, who may or **may not** sit together. If the seats can be allocated, it allocates `k` seats to the group with the **smallest** row numbers, and the smallest possible seat numbers in each row. Otherwise, returns `false`. **Example 1:** ``` **Input** [\"BookMyShow\", \"gather\", \"gather\", \"scatter\", \"scatter\"] [[2, 5], [4, 0], [2, 0], [5, 1], [5, 1]] **Output** [null, [0, 0], [], true, false] **Explanation** BookMyShow bms = new BookMyShow(2, 5); // There are 2 rows with 5 seats each bms.gather(4, 0); // return [0, 0] // The group books seats [0, 3] of row 0. bms.gather(2, 0); // return [] // There is only 1 seat left in row 0, // so it is not possible to book 2 consecutive seats. bms.scatter(5, 1); // return True // The group books seat 4 of row 0 and seats [0, 3] of row 1. bms.scatter(5, 1); // return False // There is only one seat left in the hall. ``` **Constraints:** `1 <= n <= 5 * 104` `1 <= m, k <= 109` `0 <= maxRow <= n - 1` At most `5 * 104` calls **in total** will be made to `gather` and `scatter`.",
        "test_case": [],
        "elixir_template": "defmodule BookMyShow do\n  @spec init_(n :: integer, m :: integer) :: any\n  def init_(n, m) do\n    \n  end\n\n  @spec gather(k :: integer, max_row :: integer) :: [integer]\n  def gather(k, max_row) do\n    \n  end\n\n  @spec scatter(k :: integer, max_row :: integer) :: boolean\n  def scatter(k, max_row) do\n    \n  end\nend\n\n# Your functions will be called as such:\n# BookMyShow.init_(n, m)\n# param_1 = BookMyShow.gather(k, max_row)\n# param_2 = BookMyShow.scatter(k, max_row)\n\n# BookMyShow.init_ will be called before every test case, in which you can do some necessary initializations.",
        "erlang_template": "-spec book_my_show_init_(N :: integer(), M :: integer()) -> any().\nbook_my_show_init_(N, M) ->\n  .\n\n-spec book_my_show_gather(K :: integer(), MaxRow :: integer()) -> [integer()].\nbook_my_show_gather(K, MaxRow) ->\n  .\n\n-spec book_my_show_scatter(K :: integer(), MaxRow :: integer()) -> boolean().\nbook_my_show_scatter(K, MaxRow) ->\n  .\n\n\n%% Your functions will be called as such:\n%% book_my_show_init_(N, M),\n%% Param_1 = book_my_show_gather(K, MaxRow),\n%% Param_2 = book_my_show_scatter(K, MaxRow),\n\n%% book_my_show_init_ will be called before every test case, in which you can do some necessary initializations.",
        "scala_template": "class BookMyShow(_n: Int, _m: Int) {\n\n    def gather(k: Int, maxRow: Int): Array[Int] = {\n        \n    }\n\n    def scatter(k: Int, maxRow: Int): Boolean = {\n        \n    }\n\n}\n\n/**\n * Your BookMyShow object will be instantiated and called as such:\n * val obj = new BookMyShow(n, m)\n * val param_1 = obj.gather(k,maxRow)\n * val param_2 = obj.scatter(k,maxRow)\n */"
    },
    {
        "id": 2379,
        "name": "maximum-total-importance-of-roads",
        "difficulty": "Medium",
        "link": "https://leetcode.com/problems/maximum-total-importance-of-roads/",
        "task_description": "You are given an integer `n` denoting the number of cities in a country. The cities are numbered from `0` to `n - 1`. You are also given a 2D integer array `roads` where `roads[i] = [ai, bi]` denotes that there exists a **bidirectional** road connecting cities `ai` and `bi`. You need to assign each city with an integer value from `1` to `n`, where each value can only be used **once**. The **importance** of a road is then defined as the **sum** of the values of the two cities it connects. Return _the **maximum total importance** of all roads possible after assigning the values optimally._ **Example 1:** ``` **Input:** n = 5, roads = [[0,1],[1,2],[2,3],[0,2],[1,3],[2,4]] **Output:** 43 **Explanation:** The figure above shows the country and the assigned values of [2,4,5,3,1]. - The road (0,1) has an importance of 2 + 4 = 6. - The road (1,2) has an importance of 4 + 5 = 9. - The road (2,3) has an importance of 5 + 3 = 8. - The road (0,2) has an importance of 2 + 5 = 7. - The road (1,3) has an importance of 4 + 3 = 7. - The road (2,4) has an importance of 5 + 1 = 6. The total importance of all roads is 6 + 9 + 8 + 7 + 7 + 6 = 43. It can be shown that we cannot obtain a greater total importance than 43. ``` **Example 2:** ``` **Input:** n = 5, roads = [[0,3],[2,4],[1,3]] **Output:** 20 **Explanation:** The figure above shows the country and the assigned values of [4,3,2,5,1]. - The road (0,3) has an importance of 4 + 5 = 9. - The road (2,4) has an importance of 2 + 1 = 3. - The road (1,3) has an importance of 3 + 5 = 8. The total importance of all roads is 9 + 3 + 8 = 20. It can be shown that we cannot obtain a greater total importance than 20. ``` **Constraints:** `2 <= n <= 5 * 104` `1 <= roads.length <= 5 * 104` `roads[i].length == 2` `0 <= ai, bi <= n - 1` `ai != bi` There are no duplicate roads.",
        "test_case": [
            {
                "label": "Example 1",
                "input": "n = 5, roads = [[0,1],[1,2],[2,3],[0,2],[1,3],[2,4]]",
                "output": "43 Explanation: The figure above shows the country and the assigned values of [2,4,5,3,1].\n- The road (0,1) has an importance of 2 + 4 = 6.\n- The road (1,2) has an importance of 4 + 5 = 9.\n- The road (2,3) has an importance of 5 + 3 = 8.\n- The road (0,2) has an importance of 2 + 5 = 7.\n- The road (1,3) has an importance of 4 + 3 = 7.\n- The road (2,4) has an importance of 5 + 1 = 6.\nThe total importance of all roads is 6 + 9 + 8 + 7 + 7 + 6 = 43.\nIt can be shown that we cannot obtain a greater total importance than 43."
            },
            {
                "label": "Example 2",
                "input": "n = 5, roads = [[0,3],[2,4],[1,3]]",
                "output": "20 Explanation: The figure above shows the country and the assigned values of [4,3,2,5,1].\n- The road (0,3) has an importance of 4 + 5 = 9.\n- The road (2,4) has an importance of 2 + 1 = 3.\n- The road (1,3) has an importance of 3 + 5 = 8.\nThe total importance of all roads is 9 + 3 + 8 = 20.\nIt can be shown that we cannot obtain a greater total importance than 20."
            }
        ],
        "elixir_template": "defmodule Solution do\n  @spec maximum_importance(n :: integer, roads :: [[integer]]) :: integer\n  def maximum_importance(n, roads) do\n    \n  end\nend",
        "erlang_template": "-spec maximum_importance(N :: integer(), Roads :: [[integer()]]) -> integer().\nmaximum_importance(N, Roads) ->\n  .",
        "scala_template": "object Solution {\n    def maximumImportance(n: Int, roads: Array[Array[Int]]): Long = {\n        \n    }\n}"
    },
    {
        "id": 2378,
        "name": "sender-with-largest-word-count",
        "difficulty": "Medium",
        "link": "https://leetcode.com/problems/sender-with-largest-word-count/",
        "task_description": "You have a chat log of `n` messages. You are given two string arrays `messages` and `senders` where `messages[i]` is a **message** sent by `senders[i]`. A **message** is list of **words** that are separated by a single space with no leading or trailing spaces. The **word count** of a sender is the total number of **words** sent by the sender. Note that a sender may send more than one message. Return _the sender with the **largest** word count_. If there is more than one sender with the largest word count, return _the one with the **lexicographically largest** name_. **Note:** Uppercase letters come before lowercase letters in lexicographical order. `\"Alice\"` and `\"alice\"` are distinct. **Example 1:** ``` **Input:** messages = [\"Hello userTwooo\",\"Hi userThree\",\"Wonderful day Alice\",\"Nice day userThree\"], senders = [\"Alice\",\"userTwo\",\"userThree\",\"Alice\"] **Output:** \"Alice\" **Explanation:** Alice sends a total of 2 + 3 = 5 words. userTwo sends a total of 2 words. userThree sends a total of 3 words. Since Alice has the largest word count, we return \"Alice\". ``` **Example 2:** ``` **Input:** messages = [\"How is leetcode for everyone\",\"Leetcode is useful for practice\"], senders = [\"Bob\",\"Charlie\"] **Output:** \"Charlie\" **Explanation:** Bob sends a total of 5 words. Charlie sends a total of 5 words. Since there is a tie for the largest word count, we return the sender with the lexicographically larger name, Charlie. ``` **Constraints:** `n == messages.length == senders.length` `1 <= n <= 104` `1 <= messages[i].length <= 100` `1 <= senders[i].length <= 10` `messages[i]` consists of uppercase and lowercase English letters and `' '`. All the words in `messages[i]` are separated by **a single space**. `messages[i]` does not have leading or trailing spaces. `senders[i]` consists of uppercase and lowercase English letters only.",
        "test_case": [
            {
                "label": "Example 1",
                "input": "messages = [\"Hello userTwooo\",\"Hi userThree\",\"Wonderful day Alice\",\"Nice day userThree\"], senders = [\"Alice\",\"userTwo\",\"userThree\",\"Alice\"]",
                "output": "\"Alice\" Explanation: Alice sends a total of 2 + 3 = 5 words.\nuserTwo sends a total of 2 words.\nuserThree sends a total of 3 words.\nSince Alice has the largest word count, we return \"Alice\"."
            },
            {
                "label": "Example 2",
                "input": "messages = [\"How is leetcode for everyone\",\"Leetcode is useful for practice\"], senders = [\"Bob\",\"Charlie\"]",
                "output": "\"Charlie\" Explanation: Bob sends a total of 5 words.\nCharlie sends a total of 5 words.\nSince there is a tie for the largest word count, we return the sender with the lexicographically larger name, Charlie. Constraints: n == messages.length == senders.length 1 <= n <= 10 4 1 <= messages[i].length <= 100 1 <= senders[i].length <= 10 messages[i] consists of uppercase and lowercase English letters and ' ' . All the words in messages[i] are separated by a single space . messages[i] does not have leading or trailing spaces. senders[i] consists of uppercase and lowercase English letters only."
            }
        ],
        "elixir_template": "defmodule Solution do\n  @spec largest_word_count(messages :: [String.t], senders :: [String.t]) :: String.t\n  def largest_word_count(messages, senders) do\n    \n  end\nend",
        "erlang_template": "-spec largest_word_count(Messages :: [unicode:unicode_binary()], Senders :: [unicode:unicode_binary()]) -> unicode:unicode_binary().\nlargest_word_count(Messages, Senders) ->\n  .",
        "scala_template": "object Solution {\n    def largestWordCount(messages: Array[String], senders: Array[String]): String = {\n        \n    }\n}"
    },
    {
        "id": 2377,
        "name": "check-if-number-has-equal-digit-count-and-digit-value",
        "difficulty": "Easy",
        "link": "https://leetcode.com/problems/check-if-number-has-equal-digit-count-and-digit-value/",
        "task_description": "You are given a **0-indexed** string `num` of length `n` consisting of digits. Return `true` _if for **every** index _`i`_ in the range _`0 <= i < n`_, the digit _`i`_ occurs _`num[i]`_ times in _`num`_, otherwise return _`false`. **Example 1:** ``` **Input:** num = \"1210\" **Output:** true **Explanation:** num[0] = '1'. The digit 0 occurs once in num. num[1] = '2'. The digit 1 occurs twice in num. num[2] = '1'. The digit 2 occurs once in num. num[3] = '0'. The digit 3 occurs zero times in num. The condition holds true for every index in \"1210\", so return true. ``` **Example 2:** ``` **Input:** num = \"030\" **Output:** false **Explanation:** num[0] = '0'. The digit 0 should occur zero times, but actually occurs twice in num. num[1] = '3'. The digit 1 should occur three times, but actually occurs zero times in num. num[2] = '0'. The digit 2 occurs zero times in num. The indices 0 and 1 both violate the condition, so return false. ``` **Constraints:** `n == num.length` `1 <= n <= 10` `num` consists of digits.",
        "test_case": [
            {
                "label": "Example 1",
                "input": "num = \"1210\"",
                "output": "true Explanation: num[0] = '1'. The digit 0 occurs once in num.\nnum[1] = '2'. The digit 1 occurs twice in num.\nnum[2] = '1'. The digit 2 occurs once in num.\nnum[3] = '0'. The digit 3 occurs zero times in num.\nThe condition holds true for every index in \"1210\", so return true."
            },
            {
                "label": "Example 2",
                "input": "num = \"030\"",
                "output": "false Explanation: num[0] = '0'. The digit 0 should occur zero times, but actually occurs twice in num.\nnum[1] = '3'. The digit 1 should occur three times, but actually occurs zero times in num.\nnum[2] = '0'. The digit 2 occurs zero times in num.\nThe indices 0 and 1 both violate the condition, so return false. Constraints: n == num.length 1 <= n <= 10 num consists of digits."
            }
        ],
        "elixir_template": "defmodule Solution do\n  @spec digit_count(num :: String.t) :: boolean\n  def digit_count(num) do\n    \n  end\nend",
        "erlang_template": "-spec digit_count(Num :: unicode:unicode_binary()) -> boolean().\ndigit_count(Num) ->\n  .",
        "scala_template": "object Solution {\n    def digitCount(num: String): Boolean = {\n        \n    }\n}"
    },
    {
        "id": 2375,
        "name": "minimum-obstacle-removal-to-reach-corner",
        "difficulty": "Hard",
        "link": "https://leetcode.com/problems/minimum-obstacle-removal-to-reach-corner/",
        "task_description": "You are given a **0-indexed** 2D integer array `grid` of size `m x n`. Each cell has one of two values: `0` represents an **empty** cell, `1` represents an **obstacle** that may be removed. You can move up, down, left, or right from and to an empty cell. Return _the **minimum** number of **obstacles** to **remove** so you can move from the upper left corner _`(0, 0)`_ to the lower right corner _`(m - 1, n - 1)`. **Example 1:** ``` **Input:** grid = [[0,1,1],[1,1,0],[1,1,0]] **Output:** 2 **Explanation:** We can remove the obstacles at (0, 1) and (0, 2) to create a path from (0, 0) to (2, 2). It can be shown that we need to remove at least 2 obstacles, so we return 2. Note that there may be other ways to remove 2 obstacles to create a path. ``` **Example 2:** ``` **Input:** grid = [[0,1,0,0,0],[0,1,0,1,0],[0,0,0,1,0]] **Output:** 0 **Explanation:** We can move from (0, 0) to (2, 4) without removing any obstacles, so we return 0. ``` **Constraints:** `m == grid.length` `n == grid[i].length` `1 <= m, n <= 105` `2 <= m * n <= 105` `grid[i][j]` is either `0` **or** `1`. `grid[0][0] == grid[m - 1][n - 1] == 0`",
        "test_case": [
            {
                "label": "Example 1",
                "input": "grid = [[0,1,1],[1,1,0],[1,1,0]]",
                "output": "2 Explanation: We can remove the obstacles at (0, 1) and (0, 2) to create a path from (0, 0) to (2, 2).\nIt can be shown that we need to remove at least 2 obstacles, so we return 2.\nNote that there may be other ways to remove 2 obstacles to create a path."
            },
            {
                "label": "Example 2",
                "input": "grid = [[0,1,0,0,0],[0,1,0,1,0],[0,0,0,1,0]]",
                "output": "0 Explanation: We can move from (0, 0) to (2, 4) without removing any obstacles, so we return 0. Constraints: m == grid.length n == grid[i].length 1 <= m, n <= 10 5 2 <= m * n <= 10 5 grid[i][j] is either 0 or 1 . grid[0][0] == grid[m - 1][n - 1] == 0"
            }
        ],
        "elixir_template": "defmodule Solution do\n  @spec minimum_obstacles(grid :: [[integer]]) :: integer\n  def minimum_obstacles(grid) do\n    \n  end\nend",
        "erlang_template": "-spec minimum_obstacles(Grid :: [[integer()]]) -> integer().\nminimum_obstacles(Grid) ->\n  .",
        "scala_template": "object Solution {\n    def minimumObstacles(grid: Array[Array[Int]]): Int = {\n        \n    }\n}"
    },
    {
        "id": 2374,
        "name": "steps-to-make-array-non-decreasing",
        "difficulty": "Medium",
        "link": "https://leetcode.com/problems/steps-to-make-array-non-decreasing/",
        "task_description": "You are given a **0-indexed** integer array `nums`. In one step, **remove** all elements `nums[i]` where `nums[i - 1] > nums[i]` for all `0 < i < nums.length`. Return _the number of steps performed until _`nums`_ becomes a **non-decreasing** array_. **Example 1:** ``` **Input:** nums = [5,3,4,4,7,3,6,11,8,5,11] **Output:** 3 **Explanation:** The following are the steps performed: - Step 1: [5,**3**,4,4,7,**3**,6,11,**8**,**5**,11] becomes [5,4,4,7,6,11,11] - Step 2: [5,**4**,4,7,**6**,11,11] becomes [5,4,7,11,11] - Step 3: [5,**4**,7,11,11] becomes [5,7,11,11] [5,7,11,11] is a non-decreasing array. Therefore, we return 3. ``` **Example 2:** ``` **Input:** nums = [4,5,7,7,13] **Output:** 0 **Explanation:** nums is already a non-decreasing array. Therefore, we return 0. ``` **Constraints:** `1 <= nums.length <= 105` `1 <= nums[i] <= 109`",
        "test_case": [
            {
                "label": "Example 1",
                "input": "nums = [5,3,4,4,7,3,6,11,8,5,11]",
                "output": "3 Explanation: The following are the steps performed:\n- Step 1: [5, 3 ,4,4,7, 3 ,6,11, 8 , 5 ,11] becomes [5,4,4,7,6,11,11]\n- Step 2: [5, 4 ,4,7, 6 ,11,11] becomes [5,4,7,11,11]\n- Step 3: [5, 4 ,7,11,11] becomes [5,7,11,11]\n[5,7,11,11] is a non-decreasing array. Therefore, we return 3."
            },
            {
                "label": "Example 2",
                "input": "nums = [4,5,7,7,13]",
                "output": "0 Explanation: nums is already a non-decreasing array. Therefore, we return 0."
            }
        ],
        "elixir_template": "defmodule Solution do\n  @spec total_steps(nums :: [integer]) :: integer\n  def total_steps(nums) do\n    \n  end\nend",
        "erlang_template": "-spec total_steps(Nums :: [integer()]) -> integer().\ntotal_steps(Nums) ->\n  .",
        "scala_template": "object Solution {\n    def totalSteps(nums: Array[Int]): Int = {\n        \n    }\n}"
    },
    {
        "id": 2373,
        "name": "apply-discount-to-prices",
        "difficulty": "Medium",
        "link": "https://leetcode.com/problems/apply-discount-to-prices/",
        "task_description": "A **sentence** is a string of single-space separated words where each word can contain digits, lowercase letters, and the dollar sign `'$'`. A word represents a **price** if it is a sequence of digits preceded by a dollar sign. For example, `\"$100\"`, `\"$23\"`, and `\"$6\"` represent prices while `\"100\"`, `\"$\"`, and `\"$1e5\"` do not. You are given a string `sentence` representing a sentence and an integer `discount`. For each word representing a price, apply a discount of `discount%` on the price and **update** the word in the sentence. All updated prices should be represented with **exactly two** decimal places. Return _a string representing the modified sentence_. Note that all prices will contain **at most** `10` digits. **Example 1:** ``` **Input:** sentence = \"there are $1 $2 and 5$ candies in the shop\", discount = 50 **Output:** \"there are $0.50 $1.00 and 5$ candies in the shop\" **Explanation:** The words which represent prices are \"$1\" and \"$2\". - A 50% discount on \"$1\" yields \"$0.50\", so \"$1\" is replaced by \"$0.50\". - A 50% discount on \"$2\" yields \"$1\". Since we need to have exactly 2 decimal places after a price, we replace \"$2\" with \"$1.00\". ``` **Example 2:** ``` **Input:** sentence = \"1 2 $3 4 $5 $6 7 8$ $9 $10$\", discount = 100 **Output:** \"1 2 $0.00 4 $0.00 $0.00 7 8$ $0.00 $10$\" **Explanation:** Applying a 100% discount on any price will result in 0. The words representing prices are \"$3\", \"$5\", \"$6\", and \"$9\". Each of them is replaced by \"$0.00\". ``` **Constraints:** `1 <= sentence.length <= 105` `sentence` consists of lowercase English letters, digits, `' '`, and `'$'`. `sentence` does not have leading or trailing spaces. All words in `sentence` are separated by a single space. All prices will be **positive** numbers without leading zeros. All prices will have **at most** `10` digits. `0 <= discount <= 100`",
        "test_case": [
            {
                "label": "Example 1",
                "input": "sentence = \"there are $1 $2 and 5$ candies in the shop\", discount = 50",
                "output": "\"there are $0.50 $1.00 and 5$ candies in the shop\" Explanation: The words which represent prices are \"$1\" and \"$2\". \n- A 50% discount on \"$1\" yields \"$0.50\", so \"$1\" is replaced by \"$0.50\".\n- A 50% discount on \"$2\" yields \"$1\". Since we need to have exactly 2 decimal places after a price, we replace \"$2\" with \"$1.00\"."
            },
            {
                "label": "Example 2",
                "input": "sentence = \"1 2 $3 4 $5 $6 7 8$ $9 $10$\", discount = 100",
                "output": "\"1 2 $0.00 4 $0.00 $0.00 7 8$ $0.00 $10$\" Explanation: Applying a 100% discount on any price will result in 0.\nThe words representing prices are \"$3\", \"$5\", \"$6\", and \"$9\".\nEach of them is replaced by \"$0.00\"."
            }
        ],
        "elixir_template": "defmodule Solution do\n  @spec discount_prices(sentence :: String.t, discount :: integer) :: String.t\n  def discount_prices(sentence, discount) do\n    \n  end\nend",
        "erlang_template": "-spec discount_prices(Sentence :: unicode:unicode_binary(), Discount :: integer()) -> unicode:unicode_binary().\ndiscount_prices(Sentence, Discount) ->\n  .",
        "scala_template": "object Solution {\n    def discountPrices(sentence: String, discount: Int): String = {\n        \n    }\n}"
    },
    {
        "id": 2372,
        "name": "rearrange-characters-to-make-target-string",
        "difficulty": "Easy",
        "link": "https://leetcode.com/problems/rearrange-characters-to-make-target-string/",
        "task_description": "You are given two **0-indexed** strings `s` and `target`. You can take some letters from `s` and rearrange them to form new strings. Return_ the **maximum** number of copies of _`target`_ that can be formed by taking letters from _`s`_ and rearranging them._ **Example 1:** ``` **Input:** s = \"ilovecodingonleetcode\", target = \"code\" **Output:** 2 **Explanation:** For the first copy of \"code\", take the letters at indices 4, 5, 6, and 7. For the second copy of \"code\", take the letters at indices 17, 18, 19, and 20. The strings that are formed are \"ecod\" and \"code\" which can both be rearranged into \"code\". We can make at most two copies of \"code\", so we return 2. ``` **Example 2:** ``` **Input:** s = \"abcba\", target = \"abc\" **Output:** 1 **Explanation:** We can make one copy of \"abc\" by taking the letters at indices 0, 1, and 2. We can make at most one copy of \"abc\", so we return 1. Note that while there is an extra 'a' and 'b' at indices 3 and 4, we cannot reuse the letter 'c' at index 2, so we cannot make a second copy of \"abc\". ``` **Example 3:** ``` **Input:** s = \"abbaccaddaeea\", target = \"aaaaa\" **Output:** 1 **Explanation:** We can make one copy of \"aaaaa\" by taking the letters at indices 0, 3, 6, 9, and 12. We can make at most one copy of \"aaaaa\", so we return 1. ``` **Constraints:** `1 <= s.length <= 100` `1 <= target.length <= 10` `s` and `target` consist of lowercase English letters. **Note:** This question is the same as 1189: Maximum Number of Balloons.",
        "test_case": [
            {
                "label": "Example 1",
                "input": "s = \"ilovecodingonleetcode\", target = \"code\"",
                "output": "2 Explanation: For the first copy of \"code\", take the letters at indices 4, 5, 6, and 7.\nFor the second copy of \"code\", take the letters at indices 17, 18, 19, and 20.\nThe strings that are formed are \"ecod\" and \"code\" which can both be rearranged into \"code\".\nWe can make at most two copies of \"code\", so we return 2."
            },
            {
                "label": "Example 2",
                "input": "s = \"abcba\", target = \"abc\"",
                "output": "1 Explanation: We can make one copy of \"abc\" by taking the letters at indices 0, 1, and 2.\nWe can make at most one copy of \"abc\", so we return 1.\nNote that while there is an extra 'a' and 'b' at indices 3 and 4, we cannot reuse the letter 'c' at index 2, so we cannot make a second copy of \"abc\"."
            },
            {
                "label": "Example 3",
                "input": "s = \"abbaccaddaeea\", target = \"aaaaa\"",
                "output": "1 Explanation: We can make one copy of \"aaaaa\" by taking the letters at indices 0, 3, 6, 9, and 12.\nWe can make at most one copy of \"aaaaa\", so we return 1."
            }
        ],
        "elixir_template": "defmodule Solution do\n  @spec rearrange_characters(s :: String.t, target :: String.t) :: integer\n  def rearrange_characters(s, target) do\n    \n  end\nend",
        "erlang_template": "-spec rearrange_characters(S :: unicode:unicode_binary(), Target :: unicode:unicode_binary()) -> integer().\nrearrange_characters(S, Target) ->\n  .",
        "scala_template": "object Solution {\n    def rearrangeCharacters(s: String, target: String): Int = {\n        \n    }\n}"
    },
    {
        "id": 2368,
        "name": "sum-of-total-strength-of-wizards",
        "difficulty": "Hard",
        "link": "https://leetcode.com/problems/sum-of-total-strength-of-wizards/",
        "task_description": "As the ruler of a kingdom, you have an army of wizards at your command. You are given a **0-indexed** integer array `strength`, where `strength[i]` denotes the strength of the `ith` wizard. For a **contiguous** group of wizards (i.e. the wizards' strengths form a **subarray** of `strength`), the **total strength** is defined as the **product** of the following two values: The strength of the **weakest** wizard in the group. The **total** of all the individual strengths of the wizards in the group. Return _the **sum** of the total strengths of **all** contiguous groups of wizards_. Since the answer may be very large, return it **modulo** `109 + 7`. A **subarray** is a contiguous **non-empty** sequence of elements within an array. **Example 1:** ``` **Input:** strength = [1,3,1,2] **Output:** 44 **Explanation:** The following are all the contiguous groups of wizards: - [1] from [**1**,3,1,2] has a total strength of min([1]) * sum([1]) = 1 * 1 = 1 - [3] from [1,**3**,1,2] has a total strength of min([3]) * sum([3]) = 3 * 3 = 9 - [1] from [1,3,**1**,2] has a total strength of min([1]) * sum([1]) = 1 * 1 = 1 - [2] from [1,3,1,**2**] has a total strength of min([2]) * sum([2]) = 2 * 2 = 4 - [1,3] from [**1,3**,1,2] has a total strength of min([1,3]) * sum([1,3]) = 1 * 4 = 4 - [3,1] from [1,**3,1**,2] has a total strength of min([3,1]) * sum([3,1]) = 1 * 4 = 4 - [1,2] from [1,3,**1,2**] has a total strength of min([1,2]) * sum([1,2]) = 1 * 3 = 3 - [1,3,1] from [**1,3,1**,2] has a total strength of min([1,3,1]) * sum([1,3,1]) = 1 * 5 = 5 - [3,1,2] from [1,**3,1,2**] has a total strength of min([3,1,2]) * sum([3,1,2]) = 1 * 6 = 6 - [1,3,1,2] from [**1,3,1,2**] has a total strength of min([1,3,1,2]) * sum([1,3,1,2]) = 1 * 7 = 7 The sum of all the total strengths is 1 + 9 + 1 + 4 + 4 + 4 + 3 + 5 + 6 + 7 = 44. ``` **Example 2:** ``` **Input:** strength = [5,4,6] **Output:** 213 **Explanation:** The following are all the contiguous groups of wizards: - [5] from [**5**,4,6] has a total strength of min([5]) * sum([5]) = 5 * 5 = 25 - [4] from [5,**4**,6] has a total strength of min([4]) * sum([4]) = 4 * 4 = 16 - [6] from [5,4,**6**] has a total strength of min([6]) * sum([6]) = 6 * 6 = 36 - [5,4] from [**5,4**,6] has a total strength of min([5,4]) * sum([5,4]) = 4 * 9 = 36 - [4,6] from [5,**4,6**] has a total strength of min([4,6]) * sum([4,6]) = 4 * 10 = 40 - [5,4,6] from [**5,4,6**] has a total strength of min([5,4,6]) * sum([5,4,6]) = 4 * 15 = 60 The sum of all the total strengths is 25 + 16 + 36 + 36 + 40 + 60 = 213. ``` **Constraints:** `1 <= strength.length <= 105` `1 <= strength[i] <= 109`",
        "test_case": [
            {
                "label": "Example 1",
                "input": "strength = [1,3,1,2]",
                "output": "44 Explanation: The following are all the contiguous groups of wizards:\n- [1] from [ 1 ,3,1,2] has a total strength of min([1]) * sum([1]) = 1 * 1 = 1\n- [3] from [1, 3 ,1,2] has a total strength of min([3]) * sum([3]) = 3 * 3 = 9\n- [1] from [1,3, 1 ,2] has a total strength of min([1]) * sum([1]) = 1 * 1 = 1\n- [2] from [1,3,1, 2 ] has a total strength of min([2]) * sum([2]) = 2 * 2 = 4\n- [1,3] from [ 1,3 ,1,2] has a total strength of min([1,3]) * sum([1,3]) = 1 * 4 = 4\n- [3,1] from [1, 3,1 ,2] has a total strength of min([3,1]) * sum([3,1]) = 1 * 4 = 4\n- [1,2] from [1,3, 1,2 ] has a total strength of min([1,2]) * sum([1,2]) = 1 * 3 = 3\n- [1,3,1] from [ 1,3,1 ,2] has a total strength of min([1,3,1]) * sum([1,3,1]) = 1 * 5 = 5\n- [3,1,2] from [1, 3,1,2 ] has a total strength of min([3,1,2]) * sum([3,1,2]) = 1 * 6 = 6\n- [1,3,1,2] from [ 1,3,1,2 ] has a total strength of min([1,3,1,2]) * sum([1,3,1,2]) = 1 * 7 = 7\nThe sum of all the total strengths is 1 + 9 + 1 + 4 + 4 + 4 + 3 + 5 + 6 + 7 = 44."
            },
            {
                "label": "Example 2",
                "input": "strength = [5,4,6]",
                "output": "213 Explanation: The following are all the contiguous groups of wizards: \n- [5] from [ 5 ,4,6] has a total strength of min([5]) * sum([5]) = 5 * 5 = 25\n- [4] from [5, 4 ,6] has a total strength of min([4]) * sum([4]) = 4 * 4 = 16\n- [6] from [5,4, 6 ] has a total strength of min([6]) * sum([6]) = 6 * 6 = 36\n- [5,4] from [ 5,4 ,6] has a total strength of min([5,4]) * sum([5,4]) = 4 * 9 = 36\n- [4,6] from [5, 4,6 ] has a total strength of min([4,6]) * sum([4,6]) = 4 * 10 = 40\n- [5,4,6] from [ 5,4,6 ] has a total strength of min([5,4,6]) * sum([5,4,6]) = 4 * 15 = 60\nThe sum of all the total strengths is 25 + 16 + 36 + 36 + 40 + 60 = 213."
            }
        ],
        "elixir_template": "defmodule Solution do\n  @spec total_strength(strength :: [integer]) :: integer\n  def total_strength(strength) do\n    \n  end\nend",
        "erlang_template": "-spec total_strength(Strength :: [integer()]) -> integer().\ntotal_strength(Strength) ->\n  .",
        "scala_template": "object Solution {\n    def totalStrength(strength: Array[Int]): Int = {\n        \n    }\n}"
    },
    {
        "id": 2367,
        "name": "minimum-lines-to-represent-a-line-chart",
        "difficulty": "Medium",
        "link": "https://leetcode.com/problems/minimum-lines-to-represent-a-line-chart/",
        "task_description": "You are given a 2D integer array `stockPrices` where `stockPrices[i] = [dayi, pricei]` indicates the price of the stock on day `dayi` is `pricei`. A **line chart** is created from the array by plotting the points on an XY plane with the X-axis representing the day and the Y-axis representing the price and connecting adjacent points. One such example is shown below: Return _the **minimum number of lines** needed to represent the line chart_. **Example 1:** ``` **Input:** stockPrices = [[1,7],[2,6],[3,5],[4,4],[5,4],[6,3],[7,2],[8,1]] **Output:** 3 **Explanation:** The diagram above represents the input, with the X-axis representing the day and Y-axis representing the price. The following 3 lines can be drawn to represent the line chart: - Line 1 (in red) from (1,7) to (4,4) passing through (1,7), (2,6), (3,5), and (4,4). - Line 2 (in blue) from (4,4) to (5,4). - Line 3 (in green) from (5,4) to (8,1) passing through (5,4), (6,3), (7,2), and (8,1). It can be shown that it is not possible to represent the line chart using less than 3 lines. ``` **Example 2:** ``` **Input:** stockPrices = [[3,4],[1,2],[7,8],[2,3]] **Output:** 1 **Explanation:** As shown in the diagram above, the line chart can be represented with a single line. ``` **Constraints:** `1 <= stockPrices.length <= 105` `stockPrices[i].length == 2` `1 <= dayi, pricei <= 109` All `dayi` are **distinct**.",
        "test_case": [
            {
                "label": "Example 1",
                "input": "stockPrices = [[1,7],[2,6],[3,5],[4,4],[5,4],[6,3],[7,2],[8,1]]",
                "output": "3 Explanation: The diagram above represents the input, with the X-axis representing the day and Y-axis representing the price.\nThe following 3 lines can be drawn to represent the line chart:\n- Line 1 (in red) from (1,7) to (4,4) passing through (1,7), (2,6), (3,5), and (4,4).\n- Line 2 (in blue) from (4,4) to (5,4).\n- Line 3 (in green) from (5,4) to (8,1) passing through (5,4), (6,3), (7,2), and (8,1).\nIt can be shown that it is not possible to represent the line chart using less than 3 lines."
            },
            {
                "label": "Example 2",
                "input": "stockPrices = [[3,4],[1,2],[7,8],[2,3]]",
                "output": "1 Explanation: As shown in the diagram above, the line chart can be represented with a single line."
            }
        ],
        "elixir_template": "defmodule Solution do\n  @spec minimum_lines(stock_prices :: [[integer]]) :: integer\n  def minimum_lines(stock_prices) do\n    \n  end\nend",
        "erlang_template": "-spec minimum_lines(StockPrices :: [[integer()]]) -> integer().\nminimum_lines(StockPrices) ->\n  .",
        "scala_template": "object Solution {\n    def minimumLines(stockPrices: Array[Array[Int]]): Int = {\n        \n    }\n}"
    },
    {
        "id": 2366,
        "name": "maximum-bags-with-full-capacity-of-rocks",
        "difficulty": "Medium",
        "link": "https://leetcode.com/problems/maximum-bags-with-full-capacity-of-rocks/",
        "task_description": "You have `n` bags numbered from `0` to `n - 1`. You are given two **0-indexed** integer arrays `capacity` and `rocks`. The `ith` bag can hold a maximum of `capacity[i]` rocks and currently contains `rocks[i]` rocks. You are also given an integer `additionalRocks`, the number of additional rocks you can place in **any** of the bags. Return_ the **maximum** number of bags that could have full capacity after placing the additional rocks in some bags._ **Example 1:** ``` **Input:** capacity = [2,3,4,5], rocks = [1,2,4,4], additionalRocks = 2 **Output:** 3 **Explanation:** Place 1 rock in bag 0 and 1 rock in bag 1. The number of rocks in each bag are now [2,3,4,4]. Bags 0, 1, and 2 have full capacity. There are 3 bags at full capacity, so we return 3. It can be shown that it is not possible to have more than 3 bags at full capacity. Note that there may be other ways of placing the rocks that result in an answer of 3. ``` **Example 2:** ``` **Input:** capacity = [10,2,2], rocks = [2,2,0], additionalRocks = 100 **Output:** 3 **Explanation:** Place 8 rocks in bag 0 and 2 rocks in bag 2. The number of rocks in each bag are now [10,2,2]. Bags 0, 1, and 2 have full capacity. There are 3 bags at full capacity, so we return 3. It can be shown that it is not possible to have more than 3 bags at full capacity. Note that we did not use all of the additional rocks. ``` **Constraints:** `n == capacity.length == rocks.length` `1 <= n <= 5 * 104` `1 <= capacity[i] <= 109` `0 <= rocks[i] <= capacity[i]` `1 <= additionalRocks <= 109`",
        "test_case": [
            {
                "label": "Example 1",
                "input": "capacity = [2,3,4,5], rocks = [1,2,4,4], additionalRocks = 2",
                "output": "3 Explanation: Place 1 rock in bag 0 and 1 rock in bag 1.\nThe number of rocks in each bag are now [2,3,4,4].\nBags 0, 1, and 2 have full capacity.\nThere are 3 bags at full capacity, so we return 3.\nIt can be shown that it is not possible to have more than 3 bags at full capacity.\nNote that there may be other ways of placing the rocks that result in an answer of 3."
            },
            {
                "label": "Example 2",
                "input": "capacity = [10,2,2], rocks = [2,2,0], additionalRocks = 100",
                "output": "3 Explanation: Place 8 rocks in bag 0 and 2 rocks in bag 2.\nThe number of rocks in each bag are now [10,2,2].\nBags 0, 1, and 2 have full capacity.\nThere are 3 bags at full capacity, so we return 3.\nIt can be shown that it is not possible to have more than 3 bags at full capacity.\nNote that we did not use all of the additional rocks. Constraints: n == capacity.length == rocks.length 1 <= n <= 5 * 10 4 1 <= capacity[i] <= 10 9 0 <= rocks[i] <= capacity[i] 1 <= additionalRocks <= 10 9"
            }
        ],
        "elixir_template": "defmodule Solution do\n  @spec maximum_bags(capacity :: [integer], rocks :: [integer], additional_rocks :: integer) :: integer\n  def maximum_bags(capacity, rocks, additional_rocks) do\n    \n  end\nend",
        "erlang_template": "-spec maximum_bags(Capacity :: [integer()], Rocks :: [integer()], AdditionalRocks :: integer()) -> integer().\nmaximum_bags(Capacity, Rocks, AdditionalRocks) ->\n  .",
        "scala_template": "object Solution {\n    def maximumBags(capacity: Array[Int], rocks: Array[Int], additionalRocks: Int): Int = {\n        \n    }\n}"
    },
    {
        "id": 2365,
        "name": "percentage-of-letter-in-string",
        "difficulty": "Easy",
        "link": "https://leetcode.com/problems/percentage-of-letter-in-string/",
        "task_description": "Given a string `s` and a character `letter`, return_ the **percentage** of characters in _`s`_ that equal _`letter`_ **rounded down** to the nearest whole percent._ **Example 1:** ``` **Input:** s = \"foobar\", letter = \"o\" **Output:** 33 **Explanation:** The percentage of characters in s that equal the letter 'o' is 2 / 6 * 100% = 33% when rounded down, so we return 33. ``` **Example 2:** ``` **Input:** s = \"jjjj\", letter = \"k\" **Output:** 0 **Explanation:** The percentage of characters in s that equal the letter 'k' is 0%, so we return 0. ``` **Constraints:** `1 <= s.length <= 100` `s` consists of lowercase English letters. `letter` is a lowercase English letter.",
        "test_case": [
            {
                "label": "Example 1",
                "input": "s = \"foobar\", letter = \"o\"",
                "output": "33 Explanation: The percentage of characters in s that equal the letter 'o' is 2 / 6 * 100% = 33% when rounded down, so we return 33."
            },
            {
                "label": "Example 2",
                "input": "s = \"jjjj\", letter = \"k\"",
                "output": "0 Explanation: The percentage of characters in s that equal the letter 'k' is 0%, so we return 0."
            }
        ],
        "elixir_template": "defmodule Solution do\n  @spec percentage_letter(s :: String.t, letter :: char) :: integer\n  def percentage_letter(s, letter) do\n    \n  end\nend",
        "erlang_template": "-spec percentage_letter(S :: unicode:unicode_binary(), Letter :: char()) -> integer().\npercentage_letter(S, Letter) ->\n  .",
        "scala_template": "object Solution {\n    def percentageLetter(s: String, letter: Char): Int = {\n        \n    }\n}"
    },
    {
        "id": 2364,
        "name": "longest-path-with-different-adjacent-characters",
        "difficulty": "Hard",
        "link": "https://leetcode.com/problems/longest-path-with-different-adjacent-characters/",
        "task_description": "You are given a **tree** (i.e. a connected, undirected graph that has no cycles) **rooted** at node `0` consisting of `n` nodes numbered from `0` to `n - 1`. The tree is represented by a **0-indexed** array `parent` of size `n`, where `parent[i]` is the parent of node `i`. Since node `0` is the root, `parent[0] == -1`. You are also given a string `s` of length `n`, where `s[i]` is the character assigned to node `i`. Return _the length of the **longest path** in the tree such that no pair of **adjacent** nodes on the path have the same character assigned to them._ **Example 1:** ``` **Input:** parent = [-1,0,0,1,1,2], s = \"abacbe\" **Output:** 3 **Explanation:** The longest path where each two adjacent nodes have different characters in the tree is the path: 0 -> 1 -> 3. The length of this path is 3, so 3 is returned. It can be proven that there is no longer path that satisfies the conditions. ``` **Example 2:** ``` **Input:** parent = [-1,0,0,0], s = \"aabc\" **Output:** 3 **Explanation:** The longest path where each two adjacent nodes have different characters is the path: 2 -> 0 -> 3. The length of this path is 3, so 3 is returned. ``` **Constraints:** `n == parent.length == s.length` `1 <= n <= 105` `0 <= parent[i] <= n - 1` for all `i >= 1` `parent[0] == -1` `parent` represents a valid tree. `s` consists of only lowercase English letters.",
        "test_case": [
            {
                "label": "Example 1",
                "input": "parent = [-1,0,0,1,1,2], s = \"abacbe\"",
                "output": "3 Explanation: The longest path where each two adjacent nodes have different characters in the tree is the path: 0 -> 1 -> 3. The length of this path is 3, so 3 is returned.\nIt can be proven that there is no longer path that satisfies the conditions."
            },
            {
                "label": "Example 2",
                "input": "parent = [-1,0,0,0], s = \"aabc\"",
                "output": "3 Explanation: The longest path where each two adjacent nodes have different characters is the path: 2 -> 0 -> 3. The length of this path is 3, so 3 is returned. Constraints: n == parent.length == s.length 1 <= n <= 10 5 0 <= parent[i] <= n - 1 for all i >= 1 parent[0] == -1 parent represents a valid tree. s consists of only lowercase English letters."
            }
        ],
        "elixir_template": "defmodule Solution do\n  @spec longest_path(parent :: [integer], s :: String.t) :: integer\n  def longest_path(parent, s) do\n    \n  end\nend",
        "erlang_template": "-spec longest_path(Parent :: [integer()], S :: unicode:unicode_binary()) -> integer().\nlongest_path(Parent, S) ->\n  .",
        "scala_template": "object Solution {\n    def longestPath(parent: Array[Int], s: String): Int = {\n        \n    }\n}"
    },
    {
        "id": 2363,
        "name": "maximum-trailing-zeros-in-a-cornered-path",
        "difficulty": "Medium",
        "link": "https://leetcode.com/problems/maximum-trailing-zeros-in-a-cornered-path/",
        "task_description": "You are given a 2D integer array `grid` of size `m x n`, where each cell contains a positive integer. A **cornered path** is defined as a set of adjacent cells with **at most** one turn. More specifically, the path should exclusively move either **horizontally** or **vertically** up to the turn (if there is one), without returning to a previously visited cell. After the turn, the path will then move exclusively in the **alternate** direction: move vertically if it moved horizontally, and vice versa, also without returning to a previously visited cell. The **product** of a path is defined as the product of all the values in the path. Return _the **maximum** number of **trailing zeros** in the product of a cornered path found in _`grid`. Note: **Horizontal** movement means moving in either the left or right direction. **Vertical** movement means moving in either the up or down direction. **Example 1:** ``` **Input:** grid = [[23,17,15,3,20],[8,1,20,27,11],[9,4,6,2,21],[40,9,1,10,6],[22,7,4,5,3]] **Output:** 3 **Explanation:** The grid on the left shows a valid cornered path. It has a product of 15 * 20 * 6 * 1 * 10 = 18000 which has 3 trailing zeros. It can be shown that this is the maximum trailing zeros in the product of a cornered path. The grid in the middle is not a cornered path as it has more than one turn. The grid on the right is not a cornered path as it requires a return to a previously visited cell. ``` **Example 2:** ``` **Input:** grid = [[4,3,2],[7,6,1],[8,8,8]] **Output:** 0 **Explanation:** The grid is shown in the figure above. There are no cornered paths in the grid that result in a product with a trailing zero. ``` **Constraints:** `m == grid.length` `n == grid[i].length` `1 <= m, n <= 105` `1 <= m * n <= 105` `1 <= grid[i][j] <= 1000`",
        "test_case": [
            {
                "label": "Example 1",
                "input": "grid = [[23,17,15,3,20],[8,1,20,27,11],[9,4,6,2,21],[40,9,1,10,6],[22,7,4,5,3]]",
                "output": "3 Explanation: The grid on the left shows a valid cornered path.\nIt has a product of 15 * 20 * 6 * 1 * 10 = 18000 which has 3 trailing zeros.\nIt can be shown that this is the maximum trailing zeros in the product of a cornered path.\n\nThe grid in the middle is not a cornered path as it has more than one turn.\nThe grid on the right is not a cornered path as it requires a return to a previously visited cell."
            },
            {
                "label": "Example 2",
                "input": "grid = [[4,3,2],[7,6,1],[8,8,8]]",
                "output": "0 Explanation: The grid is shown in the figure above.\nThere are no cornered paths in the grid that result in a product with a trailing zero. Constraints: m == grid.length n == grid[i].length 1 <= m, n <= 10 5 1 <= m * n <= 10 5 1 <= grid[i][j] <= 1000"
            }
        ],
        "elixir_template": "defmodule Solution do\n  @spec max_trailing_zeros(grid :: [[integer]]) :: integer\n  def max_trailing_zeros(grid) do\n    \n  end\nend",
        "erlang_template": "-spec max_trailing_zeros(Grid :: [[integer()]]) -> integer().\nmax_trailing_zeros(Grid) ->\n  .",
        "scala_template": "object Solution {\n    def maxTrailingZeros(grid: Array[Array[Int]]): Int = {\n        \n    }\n}"
    },
    {
        "id": 2362,
        "name": "minimum-rounds-to-complete-all-tasks",
        "difficulty": "Medium",
        "link": "https://leetcode.com/problems/minimum-rounds-to-complete-all-tasks/",
        "task_description": "You are given a **0-indexed** integer array `tasks`, where `tasks[i]` represents the difficulty level of a task. In each round, you can complete either 2 or 3 tasks of the **same difficulty level**. Return _the **minimum** rounds required to complete all the tasks, or _`-1`_ if it is not possible to complete all the tasks._ **Example 1:** ``` **Input:** tasks = [2,2,3,3,2,4,4,4,4,4] **Output:** 4 **Explanation:** To complete all the tasks, a possible plan is: - In the first round, you complete 3 tasks of difficulty level 2. - In the second round, you complete 2 tasks of difficulty level 3. - In the third round, you complete 3 tasks of difficulty level 4. - In the fourth round, you complete 2 tasks of difficulty level 4. It can be shown that all the tasks cannot be completed in fewer than 4 rounds, so the answer is 4. ``` **Example 2:** ``` **Input:** tasks = [2,3,3] **Output:** -1 **Explanation:** There is only 1 task of difficulty level 2, but in each round, you can only complete either 2 or 3 tasks of the same difficulty level. Hence, you cannot complete all the tasks, and the answer is -1. ``` **Constraints:** `1 <= tasks.length <= 105` `1 <= tasks[i] <= 109` **Note:** This question is the same as 2870: Minimum Number of Operations to Make Array Empty.",
        "test_case": [
            {
                "label": "Example 1",
                "input": "tasks = [2,2,3,3,2,4,4,4,4,4]",
                "output": "4 Explanation: To complete all the tasks, a possible plan is:\n- In the first round, you complete 3 tasks of difficulty level 2. \n- In the second round, you complete 2 tasks of difficulty level 3. \n- In the third round, you complete 3 tasks of difficulty level 4. \n- In the fourth round, you complete 2 tasks of difficulty level 4.  \nIt can be shown that all the tasks cannot be completed in fewer than 4 rounds, so the answer is 4."
            },
            {
                "label": "Example 2",
                "input": "tasks = [2,3,3]",
                "output": "-1 Explanation: There is only 1 task of difficulty level 2, but in each round, you can only complete either 2 or 3 tasks of the same difficulty level. Hence, you cannot complete all the tasks, and the answer is -1."
            }
        ],
        "elixir_template": "defmodule Solution do\n  @spec minimum_rounds(tasks :: [integer]) :: integer\n  def minimum_rounds(tasks) do\n    \n  end\nend",
        "erlang_template": "-spec minimum_rounds(Tasks :: [integer()]) -> integer().\nminimum_rounds(Tasks) ->\n  .",
        "scala_template": "object Solution {\n    def minimumRounds(tasks: Array[Int]): Int = {\n        \n    }\n}"
    },
    {
        "id": 2361,
        "name": "calculate-digit-sum-of-a-string",
        "difficulty": "Easy",
        "link": "https://leetcode.com/problems/calculate-digit-sum-of-a-string/",
        "task_description": "You are given a string `s` consisting of digits and an integer `k`. A **round** can be completed if the length of `s` is greater than `k`. In one round, do the following: **Divide** `s` into **consecutive groups** of size `k` such that the first `k` characters are in the first group, the next `k` characters are in the second group, and so on. **Note** that the size of the last group can be smaller than `k`. **Replace** each group of `s` with a string representing the sum of all its digits. For example, `\"346\"` is replaced with `\"13\"` because `3 + 4 + 6 = 13`. **Merge** consecutive groups together to form a new string. If the length of the string is greater than `k`, repeat from step `1`. Return `s` _after all rounds have been completed_. **Example 1:** ``` **Input:** s = \"11111222223\", k = 3 **Output:** \"135\" **Explanation:** - For the first round, we divide s into groups of size 3: \"111\", \"112\", \"222\", and \"23\". \u200b\u200b\u200b\u200b\u200bThen we calculate the digit sum of each group: 1 + 1 + 1 = 3, 1 + 1 + 2 = 4, 2 + 2 + 2 = 6, and 2 + 3 = 5. So, s becomes \"3\" + \"4\" + \"6\" + \"5\" = \"3465\" after the first round. - For the second round, we divide s into \"346\" and \"5\". Then we calculate the digit sum of each group: 3 + 4 + 6 = 13, 5 = 5. So, s becomes \"13\" + \"5\" = \"135\" after second round. Now, s.length <= k, so we return \"135\" as the answer. ``` **Example 2:** ``` **Input:** s = \"00000000\", k = 3 **Output:** \"000\" **Explanation:** We divide s into \"000\", \"000\", and \"00\". Then we calculate the digit sum of each group: 0 + 0 + 0 = 0, 0 + 0 + 0 = 0, and 0 + 0 = 0. s becomes \"0\" + \"0\" + \"0\" = \"000\", whose length is equal to k, so we return \"000\". ``` **Constraints:** `1 <= s.length <= 100` `2 <= k <= 100` `s` consists of digits only.",
        "test_case": [
            {
                "label": "Example 1",
                "input": "s = \"11111222223\", k = 3",
                "output": "\"135\" Explanation: - For the first round, we divide s into groups of size 3: \"111\", \"112\", \"222\", and \"23\".\n  \u200b\u200b\u200b\u200b\u200bThen we calculate the digit sum of each group: 1 + 1 + 1 = 3, 1 + 1 + 2 = 4, 2 + 2 + 2 = 6, and 2 + 3 = 5. \n\u00a0 So, s becomes \"3\" + \"4\" + \"6\" + \"5\" = \"3465\" after the first round.\n- For the second round, we divide s into \"346\" and \"5\".\n\u00a0 Then we calculate the digit sum of each group: 3 + 4 + 6 = 13, 5 = 5. \n\u00a0 So, s becomes \"13\" + \"5\" = \"135\" after second round. \nNow, s.length <= k, so we return \"135\" as the answer."
            },
            {
                "label": "Example 2",
                "input": "s = \"00000000\", k = 3",
                "output": "\"000\" Explanation: We divide s into \"000\", \"000\", and \"00\".\nThen we calculate the digit sum of each group: 0 + 0 + 0 = 0, 0 + 0 + 0 = 0, and 0 + 0 = 0. \ns becomes \"0\" + \"0\" + \"0\" = \"000\", whose length is equal to k, so we return \"000\"."
            }
        ],
        "elixir_template": "defmodule Solution do\n  @spec digit_sum(s :: String.t, k :: integer) :: String.t\n  def digit_sum(s, k) do\n    \n  end\nend",
        "erlang_template": "-spec digit_sum(S :: unicode:unicode_binary(), K :: integer()) -> unicode:unicode_binary().\ndigit_sum(S, K) ->\n  .",
        "scala_template": "object Solution {\n    def digitSum(s: String, k: Int): String = {\n        \n    }\n}"
    },
    {
        "id": 2360,
        "name": "substring-with-largest-variance",
        "difficulty": "Hard",
        "link": "https://leetcode.com/problems/substring-with-largest-variance/",
        "task_description": "The **variance** of a string is defined as the largest difference between the number of occurrences of **any** `2` characters present in the string. Note the two characters may or may not be the same. Given a string `s` consisting of lowercase English letters only, return _the **largest variance** possible among all **substrings** of_ `s`. A **substring** is a contiguous sequence of characters within a string. **Example 1:** ``` **Input:** s = \"aababbb\" **Output:** 3 **Explanation:** All possible variances along with their respective substrings are listed below: - Variance 0 for substrings \"a\", \"aa\", \"ab\", \"abab\", \"aababb\", \"ba\", \"b\", \"bb\", and \"bbb\". - Variance 1 for substrings \"aab\", \"aba\", \"abb\", \"aabab\", \"ababb\", \"aababbb\", and \"bab\". - Variance 2 for substrings \"aaba\", \"ababbb\", \"abbb\", and \"babb\". - Variance 3 for substring \"babbb\". Since the largest possible variance is 3, we return it. ``` **Example 2:** ``` **Input:** s = \"abcde\" **Output:** 0 **Explanation:** No letter occurs more than once in s, so the variance of every substring is 0. ``` **Constraints:** `1 <= s.length <= 104` `s` consists of lowercase English letters.",
        "test_case": [
            {
                "label": "Example 1",
                "input": "s = \"aababbb\"",
                "output": "3 Explanation: All possible variances along with their respective substrings are listed below:\n- Variance 0 for substrings \"a\", \"aa\", \"ab\", \"abab\", \"aababb\", \"ba\", \"b\", \"bb\", and \"bbb\".\n- Variance 1 for substrings \"aab\", \"aba\", \"abb\", \"aabab\", \"ababb\", \"aababbb\", and \"bab\".\n- Variance 2 for substrings \"aaba\", \"ababbb\", \"abbb\", and \"babb\".\n- Variance 3 for substring \"babbb\".\nSince the largest possible variance is 3, we return it."
            },
            {
                "label": "Example 2",
                "input": "s = \"abcde\"",
                "output": "0 Explanation: No letter occurs more than once in s, so the variance of every substring is 0."
            }
        ],
        "elixir_template": "defmodule Solution do\n  @spec largest_variance(s :: String.t) :: integer\n  def largest_variance(s) do\n    \n  end\nend",
        "erlang_template": "-spec largest_variance(S :: unicode:unicode_binary()) -> integer().\nlargest_variance(S) ->\n  .",
        "scala_template": "object Solution {\n    def largestVariance(s: String): Int = {\n        \n    }\n}"
    },
    {
        "id": 2359,
        "name": "maximum-white-tiles-covered-by-a-carpet",
        "difficulty": "Medium",
        "link": "https://leetcode.com/problems/maximum-white-tiles-covered-by-a-carpet/",
        "task_description": "You are given a 2D integer array `tiles` where `tiles[i] = [li, ri]` represents that every tile `j` in the range `li <= j <= ri` is colored white. You are also given an integer `carpetLen`, the length of a single carpet that can be placed **anywhere**. Return _the **maximum** number of white tiles that can be covered by the carpet_. **Example 1:** ``` **Input:** tiles = [[1,5],[10,11],[12,18],[20,25],[30,32]], carpetLen = 10 **Output:** 9 **Explanation:** Place the carpet starting on tile 10. It covers 9 white tiles, so we return 9. Note that there may be other places where the carpet covers 9 white tiles. It can be shown that the carpet cannot cover more than 9 white tiles. ``` **Example 2:** ``` **Input:** tiles = [[10,11],[1,1]], carpetLen = 2 **Output:** 2 **Explanation:** Place the carpet starting on tile 10. It covers 2 white tiles, so we return 2. ``` **Constraints:** `1 <= tiles.length <= 5 * 104` `tiles[i].length == 2` `1 <= li <= ri <= 109` `1 <= carpetLen <= 109` The `tiles` are **non-overlapping**.",
        "test_case": [
            {
                "label": "Example 1",
                "input": "tiles = [[1,5],[10,11],[12,18],[20,25],[30,32]], carpetLen = 10",
                "output": "9 Explanation: Place the carpet starting on tile 10. \nIt covers 9 white tiles, so we return 9.\nNote that there may be other places where the carpet covers 9 white tiles.\nIt can be shown that the carpet cannot cover more than 9 white tiles."
            },
            {
                "label": "Example 2",
                "input": "tiles = [[10,11],[1,1]], carpetLen = 2",
                "output": "2 Explanation: Place the carpet starting on tile 10. \nIt covers 2 white tiles, so we return 2."
            }
        ],
        "elixir_template": "defmodule Solution do\n  @spec maximum_white_tiles(tiles :: [[integer]], carpet_len :: integer) :: integer\n  def maximum_white_tiles(tiles, carpet_len) do\n    \n  end\nend",
        "erlang_template": "-spec maximum_white_tiles(Tiles :: [[integer()]], CarpetLen :: integer()) -> integer().\nmaximum_white_tiles(Tiles, CarpetLen) ->\n  .",
        "scala_template": "object Solution {\n    def maximumWhiteTiles(tiles: Array[Array[Int]], carpetLen: Int): Int = {\n        \n    }\n}"
    },
    {
        "id": 2358,
        "name": "number-of-ways-to-split-array",
        "difficulty": "Medium",
        "link": "https://leetcode.com/problems/number-of-ways-to-split-array/",
        "task_description": "You are given a **0-indexed** integer array `nums` of length `n`. `nums` contains a **valid split** at index `i` if the following are true: The sum of the first `i + 1` elements is **greater than or equal to** the sum of the last `n - i - 1` elements. There is **at least one** element to the right of `i`. That is, `0 <= i < n - 1`. Return _the number of **valid splits** in_ `nums`. **Example 1:** ``` **Input:** nums = [10,4,-8,7] **Output:** 2 **Explanation:** There are three ways of splitting nums into two non-empty parts: - Split nums at index 0. Then, the first part is [10], and its sum is 10. The second part is [4,-8,7], and its sum is 3. Since 10 >= 3, i = 0 is a valid split. - Split nums at index 1. Then, the first part is [10,4], and its sum is 14. The second part is [-8,7], and its sum is -1. Since 14 >= -1, i = 1 is a valid split. - Split nums at index 2. Then, the first part is [10,4,-8], and its sum is 6. The second part is [7], and its sum is 7. Since 6 < 7, i = 2 is not a valid split. Thus, the number of valid splits in nums is 2. ``` **Example 2:** ``` **Input:** nums = [2,3,1,0] **Output:** 2 **Explanation:** There are two valid splits in nums: - Split nums at index 1. Then, the first part is [2,3], and its sum is 5. The second part is [1,0], and its sum is 1. Since 5 >= 1, i = 1 is a valid split. - Split nums at index 2. Then, the first part is [2,3,1], and its sum is 6. The second part is [0], and its sum is 0. Since 6 >= 0, i = 2 is a valid split. ``` **Constraints:** `2 <= nums.length <= 105` `-105 <= nums[i] <= 105`",
        "test_case": [
            {
                "label": "Example 1",
                "input": "nums = [10,4,-8,7]",
                "output": "2 Explanation: There are three ways of splitting nums into two non-empty parts:\n- Split nums at index 0. Then, the first part is [10], and its sum is 10. The second part is [4,-8,7], and its sum is 3. Since 10 >= 3, i = 0 is a valid split.\n- Split nums at index 1. Then, the first part is [10,4], and its sum is 14. The second part is [-8,7], and its sum is -1. Since 14 >= -1, i = 1 is a valid split.\n- Split nums at index 2. Then, the first part is [10,4,-8], and its sum is 6. The second part is [7], and its sum is 7. Since 6 < 7, i = 2 is not a valid split.\nThus, the number of valid splits in nums is 2."
            },
            {
                "label": "Example 2",
                "input": "nums = [2,3,1,0]",
                "output": "2 Explanation: There are two valid splits in nums:\n- Split nums at index 1. Then, the first part is [2,3], and its sum is 5. The second part is [1,0], and its sum is 1. Since 5 >= 1, i = 1 is a valid split. \n- Split nums at index 2. Then, the first part is [2,3,1], and its sum is 6. The second part is [0], and its sum is 0. Since 6 >= 0, i = 2 is a valid split."
            }
        ],
        "elixir_template": "defmodule Solution do\n  @spec ways_to_split_array(nums :: [integer]) :: integer\n  def ways_to_split_array(nums) do\n    \n  end\nend",
        "erlang_template": "-spec ways_to_split_array(Nums :: [integer()]) -> integer().\nways_to_split_array(Nums) ->\n  .",
        "scala_template": "object Solution {\n    def waysToSplitArray(nums: Array[Int]): Int = {\n        \n    }\n}"
    },
    {
        "id": 2357,
        "name": "count-integers-in-intervals",
        "difficulty": "Hard",
        "link": "https://leetcode.com/problems/count-integers-in-intervals/",
        "task_description": "Given an **empty** set of intervals, implement a data structure that can: **Add** an interval to the set of intervals. **Count** the number of integers that are present in **at least one** interval. Implement the `CountIntervals` class: `CountIntervals()` Initializes the object with an empty set of intervals. `void add(int left, int right)` Adds the interval `[left, right]` to the set of intervals. `int count()` Returns the number of integers that are present in **at least one** interval. **Note** that an interval `[left, right]` denotes all the integers `x` where `left <= x <= right`. **Example 1:** ``` **Input** [\"CountIntervals\", \"add\", \"add\", \"count\", \"add\", \"count\"] [[], [2, 3], [7, 10], [], [5, 8], []] **Output** [null, null, null, 6, null, 8] **Explanation** CountIntervals countIntervals = new CountIntervals(); // initialize the object with an empty set of intervals. countIntervals.add(2, 3); // add [2, 3] to the set of intervals. countIntervals.add(7, 10); // add [7, 10] to the set of intervals. countIntervals.count(); // return 6 // the integers 2 and 3 are present in the interval [2, 3]. // the integers 7, 8, 9, and 10 are present in the interval [7, 10]. countIntervals.add(5, 8); // add [5, 8] to the set of intervals. countIntervals.count(); // return 8 // the integers 2 and 3 are present in the interval [2, 3]. // the integers 5 and 6 are present in the interval [5, 8]. // the integers 7 and 8 are present in the intervals [5, 8] and [7, 10]. // the integers 9 and 10 are present in the interval [7, 10]. ``` **Constraints:** `1 <= left <= right <= 109` At most `105` calls **in total** will be made to `add` and `count`. At least **one** call will be made to `count`.",
        "test_case": [],
        "elixir_template": "defmodule CountIntervals do\n  @spec init_() :: any\n  def init_() do\n    \n  end\n\n  @spec add(left :: integer, right :: integer) :: any\n  def add(left, right) do\n    \n  end\n\n  @spec count() :: integer\n  def count() do\n    \n  end\nend\n\n# Your functions will be called as such:\n# CountIntervals.init_()\n# CountIntervals.add(left, right)\n# param_2 = CountIntervals.count()\n\n# CountIntervals.init_ will be called before every test case, in which you can do some necessary initializations.",
        "erlang_template": "-spec count_intervals_init_() -> any().\ncount_intervals_init_() ->\n  .\n\n-spec count_intervals_add(Left :: integer(), Right :: integer()) -> any().\ncount_intervals_add(Left, Right) ->\n  .\n\n-spec count_intervals_count() -> integer().\ncount_intervals_count() ->\n  .\n\n\n%% Your functions will be called as such:\n%% count_intervals_init_(),\n%% count_intervals_add(Left, Right),\n%% Param_2 = count_intervals_count(),\n\n%% count_intervals_init_ will be called before every test case, in which you can do some necessary initializations.",
        "scala_template": "class CountIntervals() {\n\n    def add(left: Int, right: Int): Unit = {\n        \n    }\n\n    def count(): Int = {\n        \n    }\n\n}\n\n/**\n * Your CountIntervals object will be instantiated and called as such:\n * val obj = new CountIntervals()\n * obj.add(left,right)\n * val param_2 = obj.count()\n */"
    },
    {
        "id": 2356,
        "name": "largest-combination-with-bitwise-and-greater-than-zero",
        "difficulty": "Medium",
        "link": "https://leetcode.com/problems/largest-combination-with-bitwise-and-greater-than-zero/",
        "task_description": "The **bitwise AND** of an array `nums` is the bitwise AND of all integers in `nums`. For example, for `nums = [1, 5, 3]`, the bitwise AND is equal to `1 & 5 & 3 = 1`. Also, for `nums = [7]`, the bitwise AND is `7`. You are given an array of positive integers `candidates`. Compute the **bitwise AND** for all possible **combinations** of elements in the `candidates` array. Return _the size of the **largest** combination of _`candidates`_ with a bitwise AND **greater** than _`0`. **Example 1:** ``` **Input:** candidates = [16,17,71,62,12,24,14] **Output:** 4 **Explanation:** The combination [16,17,62,24] has a bitwise AND of 16 & 17 & 62 & 24 = 16 > 0. The size of the combination is 4. It can be shown that no combination with a size greater than 4 has a bitwise AND greater than 0. Note that more than one combination may have the largest size. For example, the combination [62,12,24,14] has a bitwise AND of 62 & 12 & 24 & 14 = 8 > 0. ``` **Example 2:** ``` **Input:** candidates = [8,8] **Output:** 2 **Explanation:** The largest combination [8,8] has a bitwise AND of 8 & 8 = 8 > 0. The size of the combination is 2, so we return 2. ``` **Constraints:** `1 <= candidates.length <= 105` `1 <= candidates[i] <= 107`",
        "test_case": [
            {
                "label": "Example 1",
                "input": "candidates = [16,17,71,62,12,24,14]",
                "output": "4 Explanation: The combination [16,17,62,24] has a bitwise AND of 16 & 17 & 62 & 24 = 16 > 0.\nThe size of the combination is 4.\nIt can be shown that no combination with a size greater than 4 has a bitwise AND greater than 0.\nNote that more than one combination may have the largest size.\nFor example, the combination [62,12,24,14] has a bitwise AND of 62 & 12 & 24 & 14 = 8 > 0."
            },
            {
                "label": "Example 2",
                "input": "candidates = [8,8]",
                "output": "2 Explanation: The largest combination [8,8] has a bitwise AND of 8 & 8 = 8 > 0.\nThe size of the combination is 2, so we return 2."
            }
        ],
        "elixir_template": "defmodule Solution do\n  @spec largest_combination(candidates :: [integer]) :: integer\n  def largest_combination(candidates) do\n    \n  end\nend",
        "erlang_template": "-spec largest_combination(Candidates :: [integer()]) -> integer().\nlargest_combination(Candidates) ->\n  .",
        "scala_template": "object Solution {\n    def largestCombination(candidates: Array[Int]): Int = {\n        \n    }\n}"
    },
    {
        "id": 2355,
        "name": "maximum-consecutive-floors-without-special-floors",
        "difficulty": "Medium",
        "link": "https://leetcode.com/problems/maximum-consecutive-floors-without-special-floors/",
        "task_description": "Alice manages a company and has rented some floors of a building as office space. Alice has decided some of these floors should be **special floors**, used for relaxation only. You are given two integers `bottom` and `top`, which denote that Alice has rented all the floors from `bottom` to `top` (**inclusive**). You are also given the integer array `special`, where `special[i]` denotes a special floor that Alice has designated for relaxation. Return _the **maximum** number of consecutive floors without a special floor_. **Example 1:** ``` **Input:** bottom = 2, top = 9, special = [4,6] **Output:** 3 **Explanation:** The following are the ranges (inclusive) of consecutive floors without a special floor: - (2, 3) with a total amount of 2 floors. - (5, 5) with a total amount of 1 floor. - (7, 9) with a total amount of 3 floors. Therefore, we return the maximum number which is 3 floors. ``` **Example 2:** ``` **Input:** bottom = 6, top = 8, special = [7,6,8] **Output:** 0 **Explanation:** Every floor rented is a special floor, so we return 0. ``` **Constraints:** `1 <= special.length <= 105` `1 <= bottom <= special[i] <= top <= 109` All the values of `special` are **unique**.",
        "test_case": [
            {
                "label": "Example 1",
                "input": "bottom = 2, top = 9, special = [4,6]",
                "output": "3 Explanation: The following are the ranges (inclusive) of consecutive floors without a special floor:\n- (2, 3) with a total amount of 2 floors.\n- (5, 5) with a total amount of 1 floor.\n- (7, 9) with a total amount of 3 floors.\nTherefore, we return the maximum number which is 3 floors."
            },
            {
                "label": "Example 2",
                "input": "bottom = 6, top = 8, special = [7,6,8]",
                "output": "0 Explanation: Every floor rented is a special floor, so we return 0."
            }
        ],
        "elixir_template": "defmodule Solution do\n  @spec max_consecutive(bottom :: integer, top :: integer, special :: [integer]) :: integer\n  def max_consecutive(bottom, top, special) do\n    \n  end\nend",
        "erlang_template": "-spec max_consecutive(Bottom :: integer(), Top :: integer(), Special :: [integer()]) -> integer().\nmax_consecutive(Bottom, Top, Special) ->\n  .",
        "scala_template": "object Solution {\n    def maxConsecutive(bottom: Int, top: Int, special: Array[Int]): Int = {\n        \n    }\n}"
    },
    {
        "id": 2353,
        "name": "maximum-score-of-a-node-sequence",
        "difficulty": "Hard",
        "link": "https://leetcode.com/problems/maximum-score-of-a-node-sequence/",
        "task_description": "There is an **undirected** graph with `n` nodes, numbered from `0` to `n - 1`. You are given a **0-indexed** integer array `scores` of length `n` where `scores[i]` denotes the score of node `i`. You are also given a 2D integer array `edges` where `edges[i] = [ai, bi]` denotes that there exists an **undirected** edge connecting nodes `ai` and `bi`. A node sequence is valid if it meets the following conditions: There is an edge connecting every pair of **adjacent** nodes in the sequence. No node appears more than once in the sequence. The score of a node sequence is defined as the **sum** of the scores of the nodes in the sequence. Return _the **maximum score** of a valid node sequence with a length of _`4`_. _If no such sequence exists, return_ _`-1`. **Example 1:** ``` **Input:** scores = [5,2,9,8,4], edges = [[0,1],[1,2],[2,3],[0,2],[1,3],[2,4]] **Output:** 24 **Explanation:** The figure above shows the graph and the chosen node sequence [0,1,2,3]. The score of the node sequence is 5 + 2 + 9 + 8 = 24. It can be shown that no other node sequence has a score of more than 24. Note that the sequences [3,1,2,0] and [1,0,2,3] are also valid and have a score of 24. The sequence [0,3,2,4] is not valid since no edge connects nodes 0 and 3. ``` **Example 2:** ``` **Input:** scores = [9,20,6,4,11,12], edges = [[0,3],[5,3],[2,4],[1,3]] **Output:** -1 **Explanation:** The figure above shows the graph. There are no valid node sequences of length 4, so we return -1. ``` **Constraints:** `n == scores.length` `4 <= n <= 5 * 104` `1 <= scores[i] <= 108` `0 <= edges.length <= 5 * 104` `edges[i].length == 2` `0 <= ai, bi <= n - 1` `ai != bi` There are no duplicate edges.",
        "test_case": [
            {
                "label": "Example 1",
                "input": "scores = [5,2,9,8,4], edges = [[0,1],[1,2],[2,3],[0,2],[1,3],[2,4]]",
                "output": "24 Explanation: The figure above shows the graph and the chosen node sequence [0,1,2,3].\nThe score of the node sequence is 5 + 2 + 9 + 8 = 24.\nIt can be shown that no other node sequence has a score of more than 24.\nNote that the sequences [3,1,2,0] and [1,0,2,3] are also valid and have a score of 24.\nThe sequence [0,3,2,4] is not valid since no edge connects nodes 0 and 3."
            },
            {
                "label": "Example 2",
                "input": "scores = [9,20,6,4,11,12], edges = [[0,3],[5,3],[2,4],[1,3]]",
                "output": "-1 Explanation: The figure above shows the graph.\nThere are no valid node sequences of length 4, so we return -1. Constraints: n == scores.length 4 <= n <= 5 * 10 4 1 <= scores[i] <= 10 8 0 <= edges.length <= 5 * 10 4 edges[i].length == 2 0 <= a i , b i <= n - 1 a i != b i There are no duplicate edges."
            }
        ],
        "elixir_template": "defmodule Solution do\n  @spec maximum_score(scores :: [integer], edges :: [[integer]]) :: integer\n  def maximum_score(scores, edges) do\n    \n  end\nend",
        "erlang_template": "-spec maximum_score(Scores :: [integer()], Edges :: [[integer()]]) -> integer().\nmaximum_score(Scores, Edges) ->\n  .",
        "scala_template": "object Solution {\n    def maximumScore(scores: Array[Int], edges: Array[Array[Int]]): Int = {\n        \n    }\n}"
    },
    {
        "id": 2352,
        "name": "design-an-atm-machine",
        "difficulty": "Medium",
        "link": "https://leetcode.com/problems/design-an-atm-machine/",
        "task_description": "There is an ATM machine that stores banknotes of `5` denominations: `20`, `50`, `100`, `200`, and `500` dollars. Initially the ATM is empty. The user can use the machine to deposit or withdraw any amount of money. When withdrawing, the machine prioritizes using banknotes of **larger** values. For example, if you want to withdraw `$300` and there are `2` `$50` banknotes, `1` `$100` banknote, and `1` `$200` banknote, then the machine will use the `$100` and `$200` banknotes. However, if you try to withdraw `$600` and there are `3` `$200` banknotes and `1` `$500` banknote, then the withdraw request will be rejected because the machine will first try to use the `$500` banknote and then be unable to use banknotes to complete the remaining `$100`. Note that the machine is **not** allowed to use the `$200` banknotes instead of the `$500` banknote. Implement the ATM class: `ATM()` Initializes the ATM object. `void deposit(int[] banknotesCount)` Deposits new banknotes in the order `$20`, `$50`, `$100`, `$200`, and `$500`. `int[] withdraw(int amount)` Returns an array of length `5` of the number of banknotes that will be handed to the user in the order `$20`, `$50`, `$100`, `$200`, and `$500`, and update the number of banknotes in the ATM after withdrawing. Returns `[-1]` if it is not possible (do **not** withdraw any banknotes in this case). **Example 1:** ``` **Input** [\"ATM\", \"deposit\", \"withdraw\", \"deposit\", \"withdraw\", \"withdraw\"] [[], [[0,0,1,2,1]], [600], [[0,1,0,1,1]], [600], [550]] **Output** [null, null, [0,0,1,0,1], null, [-1], [0,1,0,0,1]] **Explanation** ATM atm = new ATM(); atm.deposit([0,0,1,2,1]); // Deposits 1 $100 banknote, 2 $200 banknotes, // and 1 $500 banknote. atm.withdraw(600); // Returns [0,0,1,0,1]. The machine uses 1 $100 banknote // and 1 $500 banknote. The banknotes left over in the // machine are [0,0,0,2,0]. atm.deposit([0,1,0,1,1]); // Deposits 1 $50, $200, and $500 banknote. // The banknotes in the machine are now [0,1,0,3,1]. atm.withdraw(600); // Returns [-1]. The machine will try to use a $500 banknote // and then be unable to complete the remaining $100, // so the withdraw request will be rejected. // Since the request is rejected, the number of banknotes // in the machine is not modified. atm.withdraw(550); // Returns [0,1,0,0,1]. The machine uses 1 $50 banknote // and 1 $500 banknote. ``` **Constraints:** `banknotesCount.length == 5` `0 <= banknotesCount[i] <= 109` `1 <= amount <= 109` At most `5000` calls **in total** will be made to `withdraw` and `deposit`. At least **one** call will be made to each function `withdraw` and `deposit`. Sum of `banknotesCount[i]` in all deposits doesn't exceed `109`",
        "test_case": [],
        "elixir_template": "defmodule ATM do\n  @spec init_() :: any\n  def init_() do\n    \n  end\n\n  @spec deposit(banknotes_count :: [integer]) :: any\n  def deposit(banknotes_count) do\n    \n  end\n\n  @spec withdraw(amount :: integer) :: [integer]\n  def withdraw(amount) do\n    \n  end\nend\n\n# Your functions will be called as such:\n# ATM.init_()\n# ATM.deposit(banknotes_count)\n# param_2 = ATM.withdraw(amount)\n\n# ATM.init_ will be called before every test case, in which you can do some necessary initializations.",
        "erlang_template": "-spec atm_init_() -> any().\natm_init_() ->\n  .\n\n-spec atm_deposit(BanknotesCount :: [integer()]) -> any().\natm_deposit(BanknotesCount) ->\n  .\n\n-spec atm_withdraw(Amount :: integer()) -> [integer()].\natm_withdraw(Amount) ->\n  .\n\n\n%% Your functions will be called as such:\n%% atm_init_(),\n%% atm_deposit(BanknotesCount),\n%% Param_2 = atm_withdraw(Amount),\n\n%% atm_init_ will be called before every test case, in which you can do some necessary initializations.",
        "scala_template": "class ATM() {\n\n    def deposit(banknotesCount: Array[Int]): Unit = {\n        \n    }\n\n    def withdraw(amount: Int): Array[Int] = {\n        \n    }\n\n}\n\n/**\n * Your ATM object will be instantiated and called as such:\n * val obj = new ATM()\n * obj.deposit(banknotesCount)\n * val param_2 = obj.withdraw(amount)\n */"
    },
    {
        "id": 2351,
        "name": "number-of-ways-to-buy-pens-and-pencils",
        "difficulty": "Medium",
        "link": "https://leetcode.com/problems/number-of-ways-to-buy-pens-and-pencils/",
        "task_description": "You are given an integer `total` indicating the amount of money you have. You are also given two integers `cost1` and `cost2` indicating the price of a pen and pencil respectively. You can spend **part or all** of your money to buy multiple quantities (or none) of each kind of writing utensil. Return _the **number of distinct ways** you can buy some number of pens and pencils._ **Example 1:** ``` **Input:** total = 20, cost1 = 10, cost2 = 5 **Output:** 9 **Explanation:** The price of a pen is 10 and the price of a pencil is 5. - If you buy 0 pens, you can buy 0, 1, 2, 3, or 4 pencils. - If you buy 1 pen, you can buy 0, 1, or 2 pencils. - If you buy 2 pens, you cannot buy any pencils. The total number of ways to buy pens and pencils is 5 + 3 + 1 = 9. ``` **Example 2:** ``` **Input:** total = 5, cost1 = 10, cost2 = 10 **Output:** 1 **Explanation:** The price of both pens and pencils are 10, which cost more than total, so you cannot buy any writing utensils. Therefore, there is only 1 way: buy 0 pens and 0 pencils. ``` **Constraints:** `1 <= total, cost1, cost2 <= 106`",
        "test_case": [
            {
                "label": "Example 1",
                "input": "total = 20, cost1 = 10, cost2 = 5",
                "output": "9 Explanation: The price of a pen is 10 and the price of a pencil is 5.\n- If you buy 0 pens, you can buy 0, 1, 2, 3, or 4 pencils.\n- If you buy 1 pen, you can buy 0, 1, or 2 pencils.\n- If you buy 2 pens, you cannot buy any pencils.\nThe total number of ways to buy pens and pencils is 5 + 3 + 1 = 9."
            },
            {
                "label": "Example 2",
                "input": "total = 5, cost1 = 10, cost2 = 10",
                "output": "1 Explanation: The price of both pens and pencils are 10, which cost more than total, so you cannot buy any writing utensils. Therefore, there is only 1 way: buy 0 pens and 0 pencils."
            }
        ],
        "elixir_template": "defmodule Solution do\n  @spec ways_to_buy_pens_pencils(total :: integer, cost1 :: integer, cost2 :: integer) :: integer\n  def ways_to_buy_pens_pencils(total, cost1, cost2) do\n    \n  end\nend",
        "erlang_template": "-spec ways_to_buy_pens_pencils(Total :: integer(), Cost1 :: integer(), Cost2 :: integer()) -> integer().\nways_to_buy_pens_pencils(Total, Cost1, Cost2) ->\n  .",
        "scala_template": "object Solution {\n    def waysToBuyPensPencils(total: Int, cost1: Int, cost2: Int): Long = {\n        \n    }\n}"
    },
    {
        "id": 2350,
        "name": "find-closest-number-to-zero",
        "difficulty": "Easy",
        "link": "https://leetcode.com/problems/find-closest-number-to-zero/",
        "task_description": "Given an integer array `nums` of size `n`, return _the number with the value **closest** to _`0`_ in _`nums`. If there are multiple answers, return _the number with the **largest** value_. **Example 1:** ``` **Input:** nums = [-4,-2,1,4,8] **Output:** 1 **Explanation:** The distance from -4 to 0 is |-4| = 4. The distance from -2 to 0 is |-2| = 2. The distance from 1 to 0 is |1| = 1. The distance from 4 to 0 is |4| = 4. The distance from 8 to 0 is |8| = 8. Thus, the closest number to 0 in the array is 1. ``` **Example 2:** ``` **Input:** nums = [2,-1,1] **Output:** 1 **Explanation:** 1 and -1 are both the closest numbers to 0, so 1 being larger is returned. ``` **Constraints:** `1 <= n <= 1000` `-105 <= nums[i] <= 105`",
        "test_case": [
            {
                "label": "Example 1",
                "input": "nums = [-4,-2,1,4,8]",
                "output": "1 Explanation: The distance from -4 to 0 is |-4| = 4.\nThe distance from -2 to 0 is |-2| = 2.\nThe distance from 1 to 0 is |1| = 1.\nThe distance from 4 to 0 is |4| = 4.\nThe distance from 8 to 0 is |8| = 8.\nThus, the closest number to 0 in the array is 1."
            },
            {
                "label": "Example 2",
                "input": "nums = [2,-1,1]",
                "output": "1 Explanation: 1 and -1 are both the closest numbers to 0, so 1 being larger is returned."
            }
        ],
        "elixir_template": "defmodule Solution do\n  @spec find_closest_number(nums :: [integer]) :: integer\n  def find_closest_number(nums) do\n    \n  end\nend",
        "erlang_template": "-spec find_closest_number(Nums :: [integer()]) -> integer().\nfind_closest_number(Nums) ->\n  .",
        "scala_template": "object Solution {\n    def findClosestNumber(nums: Array[Int]): Int = {\n        \n    }\n}"
    },
    {
        "id": 2349,
        "name": "check-if-there-is-a-valid-parentheses-string-path",
        "difficulty": "Hard",
        "link": "https://leetcode.com/problems/check-if-there-is-a-valid-parentheses-string-path/",
        "task_description": "A parentheses string is a **non-empty** string consisting only of `'('` and `')'`. It is **valid** if **any** of the following conditions is **true**: It is `()`. It can be written as `AB` (`A` concatenated with `B`), where `A` and `B` are valid parentheses strings. It can be written as `(A)`, where `A` is a valid parentheses string. You are given an `m x n` matrix of parentheses `grid`. A **valid parentheses string path** in the grid is a path satisfying **all** of the following conditions: The path starts from the upper left cell `(0, 0)`. The path ends at the bottom-right cell `(m - 1, n - 1)`. The path only ever moves **down** or **right**. The resulting parentheses string formed by the path is **valid**. Return `true` _if there exists a **valid parentheses string path** in the grid._ Otherwise, return `false`. **Example 1:** ``` **Input:** grid = [[\"(\",\"(\",\"(\"],[\")\",\"(\",\")\"],[\"(\",\"(\",\")\"],[\"(\",\"(\",\")\"]] **Output:** true **Explanation:** The above diagram shows two possible paths that form valid parentheses strings. The first path shown results in the valid parentheses string \"()(())\". The second path shown results in the valid parentheses string \"((()))\". Note that there may be other valid parentheses string paths. ``` **Example 2:** ``` **Input:** grid = [[\")\",\")\"],[\"(\",\"(\"]] **Output:** false **Explanation:** The two possible paths form the parentheses strings \"))(\" and \")((\". Since neither of them are valid parentheses strings, we return false. ``` **Constraints:** `m == grid.length` `n == grid[i].length` `1 <= m, n <= 100` `grid[i][j]` is either `'('` or `')'`.",
        "test_case": [
            {
                "label": "Example 1",
                "input": "grid = [[\"(\",\"(\",\"(\"],[\")\",\"(\",\")\"],[\"(\",\"(\",\")\"],[\"(\",\"(\",\")\"]]",
                "output": "true Explanation: The above diagram shows two possible paths that form valid parentheses strings.\nThe first path shown results in the valid parentheses string \"()(())\".\nThe second path shown results in the valid parentheses string \"((()))\".\nNote that there may be other valid parentheses string paths."
            },
            {
                "label": "Example 2",
                "input": "grid = [[\")\",\")\"],[\"(\",\"(\"]]",
                "output": "false Explanation: The two possible paths form the parentheses strings \"))(\" and \")((\". Since neither of them are valid parentheses strings, we return false. Constraints: m == grid.length n == grid[i].length 1 <= m, n <= 100 grid[i][j] is either '(' or ')' ."
            }
        ],
        "elixir_template": "defmodule Solution do\n  @spec has_valid_path(grid :: [[char]]) :: boolean\n  def has_valid_path(grid) do\n    \n  end\nend",
        "erlang_template": "-spec has_valid_path(Grid :: [[char()]]) -> boolean().\nhas_valid_path(Grid) ->\n  .",
        "scala_template": "object Solution {\n    def hasValidPath(grid: Array[Array[Char]]): Boolean = {\n        \n    }\n}"
    },
    {
        "id": 2348,
        "name": "count-number-of-texts",
        "difficulty": "Medium",
        "link": "https://leetcode.com/problems/count-number-of-texts/",
        "task_description": "Alice is texting Bob using her phone. The **mapping** of digits to letters is shown in the figure below. In order to **add** a letter, Alice has to **press** the key of the corresponding digit `i` times, where `i` is the position of the letter in the key. For example, to add the letter `'s'`, Alice has to press `'7'` four times. Similarly, to add the letter `'k'`, Alice has to press `'5'` twice. Note that the digits `'0'` and `'1'` do not map to any letters, so Alice **does not** use them. However, due to an error in transmission, Bob did not receive Alice's text message but received a **string of pressed keys** instead. For example, when Alice sent the message `\"bob\"`, Bob received the string `\"2266622\"`. Given a string `pressedKeys` representing the string received by Bob, return _the **total number of possible text messages** Alice could have sent_. Since the answer may be very large, return it **modulo** `109 + 7`. **Example 1:** ``` **Input:** pressedKeys = \"22233\" **Output:** 8 **Explanation:** The possible text messages Alice could have sent are: \"aaadd\", \"abdd\", \"badd\", \"cdd\", \"aaae\", \"abe\", \"bae\", and \"ce\". Since there are 8 possible messages, we return 8. ``` **Example 2:** ``` **Input:** pressedKeys = \"222222222222222222222222222222222222\" **Output:** 82876089 **Explanation:** There are 2082876103 possible text messages Alice could have sent. Since we need to return the answer modulo 109 + 7, we return 2082876103 % (109 + 7) = 82876089. ``` **Constraints:** `1 <= pressedKeys.length <= 105` `pressedKeys` only consists of digits from `'2'` - `'9'`.",
        "test_case": [
            {
                "label": "Example 1",
                "input": "pressedKeys = \"22233\"",
                "output": "8 Explanation: The possible text messages Alice could have sent are:\n\"aaadd\", \"abdd\", \"badd\", \"cdd\", \"aaae\", \"abe\", \"bae\", and \"ce\".\nSince there are 8 possible messages, we return 8."
            },
            {
                "label": "Example 2",
                "input": "pressedKeys = \"222222222222222222222222222222222222\"",
                "output": "82876089 Explanation: There are 2082876103 possible text messages Alice could have sent.\nSince we need to return the answer modulo 10 9 + 7, we return 2082876103 % (10 9 + 7) = 82876089."
            }
        ],
        "elixir_template": "defmodule Solution do\n  @spec count_texts(pressed_keys :: String.t) :: integer\n  def count_texts(pressed_keys) do\n    \n  end\nend",
        "erlang_template": "-spec count_texts(PressedKeys :: unicode:unicode_binary()) -> integer().\ncount_texts(PressedKeys) ->\n  .",
        "scala_template": "object Solution {\n    def countTexts(pressedKeys: String): Int = {\n        \n    }\n}"
    },
    {
        "id": 2347,
        "name": "count-nodes-equal-to-average-of-subtree",
        "difficulty": "Medium",
        "link": "https://leetcode.com/problems/count-nodes-equal-to-average-of-subtree/",
        "task_description": "Given the `root` of a binary tree, return _the number of nodes where the value of the node is equal to the **average** of the values in its **subtree**_. **Note:** The **average** of `n` elements is the **sum** of the `n` elements divided by `n` and **rounded down** to the nearest integer. A **subtree** of `root` is a tree consisting of `root` and all of its descendants. **Example 1:** ``` **Input:** root = [4,8,5,0,1,null,6] **Output:** 5 **Explanation:** For the node with value 4: The average of its subtree is (4 + 8 + 5 + 0 + 1 + 6) / 6 = 24 / 6 = 4. For the node with value 5: The average of its subtree is (5 + 6) / 2 = 11 / 2 = 5. For the node with value 0: The average of its subtree is 0 / 1 = 0. For the node with value 1: The average of its subtree is 1 / 1 = 1. For the node with value 6: The average of its subtree is 6 / 1 = 6. ``` **Example 2:** ``` **Input:** root = [1] **Output:** 1 **Explanation:** For the node with value 1: The average of its subtree is 1 / 1 = 1. ``` **Constraints:** The number of nodes in the tree is in the range `[1, 1000]`. `0 <= Node.val <= 1000`",
        "test_case": [
            {
                "label": "Example 1",
                "input": "root = [4,8,5,0,1,null,6]",
                "output": "5 Explanation: For the node with value 4: The average of its subtree is (4 + 8 + 5 + 0 + 1 + 6) / 6 = 24 / 6 = 4.\nFor the node with value 5: The average of its subtree is (5 + 6) / 2 = 11 / 2 = 5.\nFor the node with value 0: The average of its subtree is 0 / 1 = 0.\nFor the node with value 1: The average of its subtree is 1 / 1 = 1.\nFor the node with value 6: The average of its subtree is 6 / 1 = 6."
            },
            {
                "label": "Example 2",
                "input": "root = [1]",
                "output": "1 Explanation: For the node with value 1: The average of its subtree is 1 / 1 = 1. Constraints: The number of nodes in the tree is in the range [1, 1000] . 0 <= Node.val <= 1000"
            }
        ],
        "elixir_template": "# Definition for a binary tree node.\n#\n# defmodule TreeNode do\n#   @type t :: %__MODULE__{\n#           val: integer,\n#           left: TreeNode.t() | nil,\n#           right: TreeNode.t() | nil\n#         }\n#   defstruct val: 0, left: nil, right: nil\n# end\n\ndefmodule Solution do\n  @spec average_of_subtree(root :: TreeNode.t | nil) :: integer\n  def average_of_subtree(root) do\n    \n  end\nend",
        "erlang_template": "%% Definition for a binary tree node.\n%%\n%% -record(tree_node, {val = 0 :: integer(),\n%%                     left = null  :: 'null' | #tree_node{},\n%%                     right = null :: 'null' | #tree_node{}}).\n\n-spec average_of_subtree(Root :: #tree_node{} | null) -> integer().\naverage_of_subtree(Root) ->\n  .",
        "scala_template": "/**\n * Definition for a binary tree node.\n * class TreeNode(_value: Int = 0, _left: TreeNode = null, _right: TreeNode = null) {\n *   var value: Int = _value\n *   var left: TreeNode = _left\n *   var right: TreeNode = _right\n * }\n */\nobject Solution {\n    def averageOfSubtree(root: TreeNode): Int = {\n        \n    }\n}"
    },
    {
        "id": 2346,
        "name": "largest-3-same-digit-number-in-string",
        "difficulty": "Easy",
        "link": "https://leetcode.com/problems/largest-3-same-digit-number-in-string/",
        "task_description": "You are given a string `num` representing a large integer. An integer is **good** if it meets the following conditions: It is a **substring** of `num` with length `3`. It consists of only one unique digit. Return _the **maximum good **integer as a **string** or an empty string _`\"\"`_ if no such integer exists_. Note: A **substring** is a contiguous sequence of characters within a string. There may be **leading zeroes** in `num` or a good integer. **Example 1:** ``` **Input:** num = \"6**777**133339\" **Output:** \"777\" **Explanation:** There are two distinct good integers: \"777\" and \"333\". \"777\" is the largest, so we return \"777\". ``` **Example 2:** ``` **Input:** num = \"23**000**19\" **Output:** \"000\" **Explanation:** \"000\" is the only good integer. ``` **Example 3:** ``` **Input:** num = \"42352338\" **Output:** \"\" **Explanation:** No substring of length 3 consists of only one unique digit. Therefore, there are no good integers. ``` **Constraints:** `3 <= num.length <= 1000` `num` only consists of digits.",
        "test_case": [
            {
                "label": "Example 1",
                "input": "num = \"6 777 133339\"",
                "output": "\"777\" Explanation: There are two distinct good integers: \"777\" and \"333\".\n\"777\" is the largest, so we return \"777\"."
            },
            {
                "label": "Example 2",
                "input": "num = \"23 000 19\"",
                "output": "\"000\" Explanation: \"000\" is the only good integer."
            },
            {
                "label": "Example 3",
                "input": "num = \"42352338\"",
                "output": "\"\" Explanation: No substring of length 3 consists of only one unique digit. Therefore, there are no good integers."
            }
        ],
        "elixir_template": "defmodule Solution do\n  @spec largest_good_integer(num :: String.t) :: String.t\n  def largest_good_integer(num) do\n    \n  end\nend",
        "erlang_template": "-spec largest_good_integer(Num :: unicode:unicode_binary()) -> unicode:unicode_binary().\nlargest_good_integer(Num) ->\n  .",
        "scala_template": "object Solution {\n    def largestGoodInteger(num: String): String = {\n        \n    }\n}"
    },
    {
        "id": 2345,
        "name": "minimum-number-of-operations-to-convert-time",
        "difficulty": "Easy",
        "link": "https://leetcode.com/problems/minimum-number-of-operations-to-convert-time/",
        "task_description": "You are given two strings `current` and `correct` representing two **24-hour times**. 24-hour times are formatted as `\"HH:MM\"`, where `HH` is between `00` and `23`, and `MM` is between `00` and `59`. The earliest 24-hour time is `00:00`, and the latest is `23:59`. In one operation you can increase the time `current` by `1`, `5`, `15`, or `60` minutes. You can perform this operation **any** number of times. Return _the **minimum number of operations** needed to convert _`current`_ to _`correct`. **Example 1:** ``` **Input:** current = \"02:30\", correct = \"04:35\" **Output:** 3 **Explanation: **We can convert current to correct in 3 operations as follows: - Add 60 minutes to current. current becomes \"03:30\". - Add 60 minutes to current. current becomes \"04:30\". - Add 5 minutes to current. current becomes \"04:35\". It can be proven that it is not possible to convert current to correct in fewer than 3 operations. ``` **Example 2:** ``` **Input:** current = \"11:00\", correct = \"11:01\" **Output:** 1 **Explanation:** We only have to add one minute to current, so the minimum number of operations needed is 1. ``` **Constraints:** `current` and `correct` are in the format `\"HH:MM\"` `current <= correct`",
        "test_case": [
            {
                "label": "Example 1",
                "input": "current = \"02:30\", correct = \"04:35\"",
                "output": "3 Explanation: We can convert current to correct in 3 operations as follows:\n- Add 60 minutes to current. current becomes \"03:30\".\n- Add 60 minutes to current. current becomes \"04:30\".\n- Add 5 minutes to current. current becomes \"04:35\".\nIt can be proven that it is not possible to convert current to correct in fewer than 3 operations."
            },
            {
                "label": "Example 2",
                "input": "current = \"11:00\", correct = \"11:01\"",
                "output": "1 Explanation: We only have to add one minute to current, so the minimum number of operations needed is 1. Constraints: current and correct are in the format \"HH:MM\" current <= correct"
            }
        ],
        "elixir_template": "defmodule Solution do\n  @spec convert_time(current :: String.t, correct :: String.t) :: integer\n  def convert_time(current, correct) do\n    \n  end\nend",
        "erlang_template": "-spec convert_time(Current :: unicode:unicode_binary(), Correct :: unicode:unicode_binary()) -> integer().\nconvert_time(Current, Correct) ->\n  .",
        "scala_template": "object Solution {\n    def convertTime(current: String, correct: String): Int = {\n        \n    }\n}"
    },
    {
        "id": 2344,
        "name": "escape-the-spreading-fire",
        "difficulty": "Hard",
        "link": "https://leetcode.com/problems/escape-the-spreading-fire/",
        "task_description": "You are given a **0-indexed** 2D integer array `grid` of size `m x n` which represents a field. Each cell has one of three values: `0` represents grass, `1` represents fire, `2` represents a wall that you and fire cannot pass through. You are situated in the top-left cell, `(0, 0)`, and you want to travel to the safehouse at the bottom-right cell, `(m - 1, n - 1)`. Every minute, you may move to an **adjacent** grass cell. **After** your move, every fire cell will spread to all **adjacent** cells that are not walls. Return _the **maximum** number of minutes that you can stay in your initial position before moving while still safely reaching the safehouse_. If this is impossible, return `-1`. If you can **always** reach the safehouse regardless of the minutes stayed, return `109`. Note that even if the fire spreads to the safehouse immediately after you have reached it, it will be counted as safely reaching the safehouse. A cell is **adjacent** to another cell if the former is directly north, east, south, or west of the latter (i.e., their sides are touching). **Example 1:** ``` **Input:** grid = [[0,2,0,0,0,0,0],[0,0,0,2,2,1,0],[0,2,0,0,1,2,0],[0,0,2,2,2,0,2],[0,0,0,0,0,0,0]] **Output:** 3 **Explanation:** The figure above shows the scenario where you stay in the initial position for 3 minutes. You will still be able to safely reach the safehouse. Staying for more than 3 minutes will not allow you to safely reach the safehouse. ``` **Example 2:** ``` **Input:** grid = [[0,0,0,0],[0,1,2,0],[0,2,0,0]] **Output:** -1 **Explanation:** The figure above shows the scenario where you immediately move towards the safehouse. Fire will spread to any cell you move towards and it is impossible to safely reach the safehouse. Thus, -1 is returned. ``` **Example 3:** ``` **Input:** grid = [[0,0,0],[2,2,0],[1,2,0]] **Output:** 1000000000 **Explanation:** The figure above shows the initial grid. Notice that the fire is contained by walls and you will always be able to safely reach the safehouse. Thus, 109 is returned. ``` **Constraints:** `m == grid.length` `n == grid[i].length` `2 <= m, n <= 300` `4 <= m * n <= 2 * 104` `grid[i][j]` is either `0`, `1`, or `2`. `grid[0][0] == grid[m - 1][n - 1] == 0`",
        "test_case": [
            {
                "label": "Example 1",
                "input": "grid = [[0,2,0,0,0,0,0],[0,0,0,2,2,1,0],[0,2,0,0,1,2,0],[0,0,2,2,2,0,2],[0,0,0,0,0,0,0]]",
                "output": "3 Explanation: The figure above shows the scenario where you stay in the initial position for 3 minutes.\nYou will still be able to safely reach the safehouse.\nStaying for more than 3 minutes will not allow you to safely reach the safehouse."
            },
            {
                "label": "Example 2",
                "input": "grid = [[0,0,0,0],[0,1,2,0],[0,2,0,0]]",
                "output": "-1 Explanation: The figure above shows the scenario where you immediately move towards the safehouse.\nFire will spread to any cell you move towards and it is impossible to safely reach the safehouse.\nThus, -1 is returned."
            },
            {
                "label": "Example 3",
                "input": "grid = [[0,0,0],[2,2,0],[1,2,0]]",
                "output": "1000000000 Explanation: The figure above shows the initial grid.\nNotice that the fire is contained by walls and you will always be able to safely reach the safehouse.\nThus, 10 9 is returned. Constraints: m == grid.length n == grid[i].length 2 <= m, n <= 300 4 <= m * n <= 2 * 10 4 grid[i][j] is either 0 , 1 , or 2 . grid[0][0] == grid[m - 1][n - 1] == 0"
            }
        ],
        "elixir_template": "defmodule Solution do\n  @spec maximum_minutes(grid :: [[integer]]) :: integer\n  def maximum_minutes(grid) do\n    \n  end\nend",
        "erlang_template": "-spec maximum_minutes(Grid :: [[integer()]]) -> integer().\nmaximum_minutes(Grid) ->\n  .",
        "scala_template": "object Solution {\n    def maximumMinutes(grid: Array[Array[Int]]): Int = {\n        \n    }\n}"
    },
    {
        "id": 2343,
        "name": "count-unguarded-cells-in-the-grid",
        "difficulty": "Medium",
        "link": "https://leetcode.com/problems/count-unguarded-cells-in-the-grid/",
        "task_description": "You are given two integers `m` and `n` representing a **0-indexed** `m x n` grid. You are also given two 2D integer arrays `guards` and `walls` where `guards[i] = [rowi, coli]` and `walls[j] = [rowj, colj]` represent the positions of the `ith` guard and `jth` wall respectively. A guard can see every cell in the four cardinal directions (north, east, south, or west) starting from their position unless **obstructed** by a wall or another guard. A cell is **guarded** if there is **at least** one guard that can see it. Return_ the number of unoccupied cells that are **not** **guarded**._ **Example 1:** ``` **Input:** m = 4, n = 6, guards = [[0,0],[1,1],[2,3]], walls = [[0,1],[2,2],[1,4]] **Output:** 7 **Explanation:** The guarded and unguarded cells are shown in red and green respectively in the above diagram. There are a total of 7 unguarded cells, so we return 7. ``` **Example 2:** ``` **Input:** m = 3, n = 3, guards = [[1,1]], walls = [[0,1],[1,0],[2,1],[1,2]] **Output:** 4 **Explanation:** The unguarded cells are shown in green in the above diagram. There are a total of 4 unguarded cells, so we return 4. ``` **Constraints:** `1 <= m, n <= 105` `2 <= m * n <= 105` `1 <= guards.length, walls.length <= 5 * 104` `2 <= guards.length + walls.length <= m * n` `guards[i].length == walls[j].length == 2` `0 <= rowi, rowj < m` `0 <= coli, colj < n` All the positions in `guards` and `walls` are **unique**.",
        "test_case": [
            {
                "label": "Example 1",
                "input": "m = 4, n = 6, guards = [[0,0],[1,1],[2,3]], walls = [[0,1],[2,2],[1,4]]",
                "output": "7 Explanation: The guarded and unguarded cells are shown in red and green respectively in the above diagram.\nThere are a total of 7 unguarded cells, so we return 7."
            },
            {
                "label": "Example 2",
                "input": "m = 3, n = 3, guards = [[1,1]], walls = [[0,1],[1,0],[2,1],[1,2]]",
                "output": "4 Explanation: The unguarded cells are shown in green in the above diagram.\nThere are a total of 4 unguarded cells, so we return 4."
            }
        ],
        "elixir_template": "defmodule Solution do\n  @spec count_unguarded(m :: integer, n :: integer, guards :: [[integer]], walls :: [[integer]]) :: integer\n  def count_unguarded(m, n, guards, walls) do\n    \n  end\nend",
        "erlang_template": "-spec count_unguarded(M :: integer(), N :: integer(), Guards :: [[integer()]], Walls :: [[integer()]]) -> integer().\ncount_unguarded(M, N, Guards, Walls) ->\n  .",
        "scala_template": "object Solution {\n    def countUnguarded(m: Int, n: Int, guards: Array[Array[Int]], walls: Array[Array[Int]]): Int = {\n        \n    }\n}"
    },
    {
        "id": 2342,
        "name": "minimum-average-difference",
        "difficulty": "Medium",
        "link": "https://leetcode.com/problems/minimum-average-difference/",
        "task_description": "You are given a **0-indexed** integer array `nums` of length `n`. The **average difference** of the index `i` is the **absolute** **difference** between the average of the **first** `i + 1` elements of `nums` and the average of the **last** `n - i - 1` elements. Both averages should be **rounded down** to the nearest integer. Return_ the index with the **minimum average difference**_. If there are multiple such indices, return the **smallest** one. **Note:** The **absolute difference** of two numbers is the absolute value of their difference. The **average** of `n` elements is the **sum** of the `n` elements divided (**integer division**) by `n`. The average of `0` elements is considered to be `0`. **Example 1:** ``` **Input:** nums = [2,5,3,9,5,3] **Output:** 3 **Explanation:** - The average difference of index 0 is: |2 / 1 - (5 + 3 + 9 + 5 + 3) / 5| = |2 / 1 - 25 / 5| = |2 - 5| = 3. - The average difference of index 1 is: |(2 + 5) / 2 - (3 + 9 + 5 + 3) / 4| = |7 / 2 - 20 / 4| = |3 - 5| = 2. - The average difference of index 2 is: |(2 + 5 + 3) / 3 - (9 + 5 + 3) / 3| = |10 / 3 - 17 / 3| = |3 - 5| = 2. - The average difference of index 3 is: |(2 + 5 + 3 + 9) / 4 - (5 + 3) / 2| = |19 / 4 - 8 / 2| = |4 - 4| = 0. - The average difference of index 4 is: |(2 + 5 + 3 + 9 + 5) / 5 - 3 / 1| = |24 / 5 - 3 / 1| = |4 - 3| = 1. - The average difference of index 5 is: |(2 + 5 + 3 + 9 + 5 + 3) / 6 - 0| = |27 / 6 - 0| = |4 - 0| = 4. The average difference of index 3 is the minimum average difference so return 3. ``` **Example 2:** ``` **Input:** nums = [0] **Output:** 0 **Explanation:** The only index is 0 so return 0. The average difference of index 0 is: |0 / 1 - 0| = |0 - 0| = 0. ``` **Constraints:** `1 <= nums.length <= 105` `0 <= nums[i] <= 105`",
        "test_case": [
            {
                "label": "Example 1",
                "input": "nums = [2,5,3,9,5,3]",
                "output": "3 Explanation: - The average difference of index 0 is: |2 / 1 - (5 + 3 + 9 + 5 + 3) / 5| = |2 / 1 - 25 / 5| = |2 - 5| = 3.\n- The average difference of index 1 is: |(2 + 5) / 2 - (3 + 9 + 5 + 3) / 4| = |7 / 2 - 20 / 4| = |3 - 5| = 2.\n- The average difference of index 2 is: |(2 + 5 + 3) / 3 - (9 + 5 + 3) / 3| = |10 / 3 - 17 / 3| = |3 - 5| = 2.\n- The average difference of index 3 is: |(2 + 5 + 3 + 9) / 4 - (5 + 3) / 2| = |19 / 4 - 8 / 2| = |4 - 4| = 0.\n- The average difference of index 4 is: |(2 + 5 + 3 + 9 + 5) / 5 - 3 / 1| = |24 / 5 - 3 / 1| = |4 - 3| = 1.\n- The average difference of index 5 is: |(2 + 5 + 3 + 9 + 5 + 3) / 6 - 0| = |27 / 6 - 0| = |4 - 0| = 4.\nThe average difference of index 3 is the minimum average difference so return 3."
            },
            {
                "label": "Example 2",
                "input": "nums = [0]",
                "output": "0 Explanation: The only index is 0 so return 0.\nThe average difference of index 0 is: |0 / 1 - 0| = |0 - 0| = 0."
            }
        ],
        "elixir_template": "defmodule Solution do\n  @spec minimum_average_difference(nums :: [integer]) :: integer\n  def minimum_average_difference(nums) do\n    \n  end\nend",
        "erlang_template": "-spec minimum_average_difference(Nums :: [integer()]) -> integer().\nminimum_average_difference(Nums) ->\n  .",
        "scala_template": "object Solution {\n    def minimumAverageDifference(nums: Array[Int]): Int = {\n        \n    }\n}"
    },
    {
        "id": 2341,
        "name": "count-prefixes-of-a-given-string",
        "difficulty": "Easy",
        "link": "https://leetcode.com/problems/count-prefixes-of-a-given-string/",
        "task_description": "You are given a string array `words` and a string `s`, where `words[i]` and `s` comprise only of **lowercase English letters**. Return _the **number of strings** in_ `words` _that are a **prefix** of_ `s`. A **prefix** of a string is a substring that occurs at the beginning of the string. A substring is a contiguous sequence of characters within a string. **Example 1:** ``` **Input:** words = [\"a\",\"b\",\"c\",\"ab\",\"bc\",\"abc\"], s = \"abc\" **Output:** 3 **Explanation:** The strings in words which are a prefix of s = \"abc\" are: \"a\", \"ab\", and \"abc\". Thus the number of strings in words which are a prefix of s is 3. ``` **Example 2:** ``` **Input:** words = [\"a\",\"a\"], s = \"aa\" **Output:** 2 **Explanation: **Both of the strings are a prefix of s. Note that the same string can occur multiple times in words, and it should be counted each time. ``` **Constraints:** `1 <= words.length <= 1000` `1 <= words[i].length, s.length <= 10` `words[i]` and `s` consist of lowercase English letters **only**.",
        "test_case": [
            {
                "label": "Example 1",
                "input": "words = [\"a\",\"b\",\"c\",\"ab\",\"bc\",\"abc\"], s = \"abc\"",
                "output": "3 Explanation: The strings in words which are a prefix of s = \"abc\" are:\n\"a\", \"ab\", and \"abc\".\nThus the number of strings in words which are a prefix of s is 3."
            },
            {
                "label": "Example 2",
                "input": "words = [\"a\",\"a\"], s = \"aa\"",
                "output": "2 Explanation: Both of the strings are a prefix of s. \nNote that the same string can occur multiple times in words, and it should be counted each time."
            }
        ],
        "elixir_template": "defmodule Solution do\n  @spec count_prefixes(words :: [String.t], s :: String.t) :: integer\n  def count_prefixes(words, s) do\n    \n  end\nend",
        "erlang_template": "-spec count_prefixes(Words :: [unicode:unicode_binary()], S :: unicode:unicode_binary()) -> integer().\ncount_prefixes(Words, S) ->\n  .",
        "scala_template": "object Solution {\n    def countPrefixes(words: Array[String], s: String): Int = {\n        \n    }\n}"
    },
    {
        "id": 2340,
        "name": "total-appeal-of-a-string",
        "difficulty": "Hard",
        "link": "https://leetcode.com/problems/total-appeal-of-a-string/",
        "task_description": "The appeal of a string is the number of **distinct** characters found in the string. For example, the appeal of `\"abbca\"` is `3` because it has `3` distinct characters: `'a'`, `'b'`, and `'c'`. Given a string `s`, return _the **total appeal of all of its **substrings**.**_ A **substring** is a contiguous sequence of characters within a string. **Example 1:** ``` **Input:** s = \"abbca\" **Output:** 28 **Explanation:** The following are the substrings of \"abbca\": - Substrings of length 1: \"a\", \"b\", \"b\", \"c\", \"a\" have an appeal of 1, 1, 1, 1, and 1 respectively. The sum is 5. - Substrings of length 2: \"ab\", \"bb\", \"bc\", \"ca\" have an appeal of 2, 1, 2, and 2 respectively. The sum is 7. - Substrings of length 3: \"abb\", \"bbc\", \"bca\" have an appeal of 2, 2, and 3 respectively. The sum is 7. - Substrings of length 4: \"abbc\", \"bbca\" have an appeal of 3 and 3 respectively. The sum is 6. - Substrings of length 5: \"abbca\" has an appeal of 3. The sum is 3. The total sum is 5 + 7 + 7 + 6 + 3 = 28. ``` **Example 2:** ``` **Input:** s = \"code\" **Output:** 20 **Explanation:** The following are the substrings of \"code\": - Substrings of length 1: \"c\", \"o\", \"d\", \"e\" have an appeal of 1, 1, 1, and 1 respectively. The sum is 4. - Substrings of length 2: \"co\", \"od\", \"de\" have an appeal of 2, 2, and 2 respectively. The sum is 6. - Substrings of length 3: \"cod\", \"ode\" have an appeal of 3 and 3 respectively. The sum is 6. - Substrings of length 4: \"code\" has an appeal of 4. The sum is 4. The total sum is 4 + 6 + 6 + 4 = 20. ``` **Constraints:** `1 <= s.length <= 105` `s` consists of lowercase English letters.",
        "test_case": [
            {
                "label": "Example 1",
                "input": "s = \"abbca\"",
                "output": "28 Explanation: The following are the substrings of \"abbca\":\n- Substrings of length 1: \"a\", \"b\", \"b\", \"c\", \"a\" have an appeal of 1, 1, 1, 1, and 1 respectively. The sum is 5.\n- Substrings of length 2: \"ab\", \"bb\", \"bc\", \"ca\" have an appeal of 2, 1, 2, and 2 respectively. The sum is 7.\n- Substrings of length 3: \"abb\", \"bbc\", \"bca\" have an appeal of 2, 2, and 3 respectively. The sum is 7.\n- Substrings of length 4: \"abbc\", \"bbca\" have an appeal of 3 and 3 respectively. The sum is 6.\n- Substrings of length 5: \"abbca\" has an appeal of 3. The sum is 3.\nThe total sum is 5 + 7 + 7 + 6 + 3 = 28."
            },
            {
                "label": "Example 2",
                "input": "s = \"code\"",
                "output": "20 Explanation: The following are the substrings of \"code\":\n- Substrings of length 1: \"c\", \"o\", \"d\", \"e\" have an appeal of 1, 1, 1, and 1 respectively. The sum is 4.\n- Substrings of length 2: \"co\", \"od\", \"de\" have an appeal of 2, 2, and 2 respectively. The sum is 6.\n- Substrings of length 3: \"cod\", \"ode\" have an appeal of 3 and 3 respectively. The sum is 6.\n- Substrings of length 4: \"code\" has an appeal of 4. The sum is 4.\nThe total sum is 4 + 6 + 6 + 4 = 20."
            }
        ],
        "elixir_template": "defmodule Solution do\n  @spec appeal_sum(s :: String.t) :: integer\n  def appeal_sum(s) do\n    \n  end\nend",
        "erlang_template": "-spec appeal_sum(S :: unicode:unicode_binary()) -> integer().\nappeal_sum(S) ->\n  .",
        "scala_template": "object Solution {\n    def appealSum(s: String): Long = {\n        \n    }\n}"
    },
    {
        "id": 2339,
        "name": "k-divisible-elements-subarrays",
        "difficulty": "Medium",
        "link": "https://leetcode.com/problems/k-divisible-elements-subarrays/",
        "task_description": "Given an integer array `nums` and two integers `k` and `p`, return _the number of **distinct subarrays,** which have **at most**_ `k` _elements _that are _divisible by_ `p`. Two arrays `nums1` and `nums2` are said to be **distinct** if: They are of **different** lengths, or There exists **at least** one index `i` where `nums1[i] != nums2[i]`. A **subarray** is defined as a **non-empty** contiguous sequence of elements in an array. **Example 1:** ``` **Input:** nums = [**2**,3,3,**2**,**2**], k = 2, p = 2 **Output:** 11 **Explanation:** The elements at indices 0, 3, and 4 are divisible by p = 2. The 11 distinct subarrays which have at most k = 2 elements divisible by 2 are: [2], [2,3], [2,3,3], [2,3,3,2], [3], [3,3], [3,3,2], [3,3,2,2], [3,2], [3,2,2], and [2,2]. Note that the subarrays [2] and [3] occur more than once in nums, but they should each be counted only once. The subarray [2,3,3,2,2] should not be counted because it has 3 elements that are divisible by 2. ``` **Example 2:** ``` **Input:** nums = [1,2,3,4], k = 4, p = 1 **Output:** 10 **Explanation:** All element of nums are divisible by p = 1. Also, every subarray of nums will have at most 4 elements that are divisible by 1. Since all subarrays are distinct, the total number of subarrays satisfying all the constraints is 10. ``` **Constraints:** `1 <= nums.length <= 200` `1 <= nums[i], p <= 200` `1 <= k <= nums.length` **Follow up:** Can you solve this problem in O(n2) time complexity?",
        "test_case": [
            {
                "label": "Example 1",
                "input": "nums = [ 2 ,3,3, 2 , 2 ], k = 2, p = 2",
                "output": "11 Explanation: The elements at indices 0, 3, and 4 are divisible by p = 2.\nThe 11 distinct subarrays which have at most k = 2 elements divisible by 2 are:\n[2], [2,3], [2,3,3], [2,3,3,2], [3], [3,3], [3,3,2], [3,3,2,2], [3,2], [3,2,2], and [2,2].\nNote that the subarrays [2] and [3] occur more than once in nums, but they should each be counted only once.\nThe subarray [2,3,3,2,2] should not be counted because it has 3 elements that are divisible by 2."
            },
            {
                "label": "Example 2",
                "input": "nums = [1,2,3,4], k = 4, p = 1",
                "output": "10 Explanation: All element of nums are divisible by p = 1.\nAlso, every subarray of nums will have at most 4 elements that are divisible by 1.\nSince all subarrays are distinct, the total number of subarrays satisfying all the constraints is 10."
            }
        ],
        "elixir_template": "defmodule Solution do\n  @spec count_distinct(nums :: [integer], k :: integer, p :: integer) :: integer\n  def count_distinct(nums, k, p) do\n    \n  end\nend",
        "erlang_template": "-spec count_distinct(Nums :: [integer()], K :: integer(), P :: integer()) -> integer().\ncount_distinct(Nums, K, P) ->\n  .",
        "scala_template": "object Solution {\n    def countDistinct(nums: Array[Int], k: Int, p: Int): Int = {\n        \n    }\n}"
    },
    {
        "id": 2338,
        "name": "minimum-consecutive-cards-to-pick-up",
        "difficulty": "Medium",
        "link": "https://leetcode.com/problems/minimum-consecutive-cards-to-pick-up/",
        "task_description": "You are given an integer array `cards` where `cards[i]` represents the **value** of the `ith` card. A pair of cards are **matching** if the cards have the **same** value. Return_ the **minimum** number of **consecutive** cards you have to pick up to have a pair of **matching** cards among the picked cards._ If it is impossible to have matching cards, return `-1`. **Example 1:** ``` **Input:** cards = [3,4,2,3,4,7] **Output:** 4 **Explanation:** We can pick up the cards [3,4,2,3] which contain a matching pair of cards with value 3. Note that picking up the cards [4,2,3,4] is also optimal. ``` **Example 2:** ``` **Input:** cards = [1,0,5,3] **Output:** -1 **Explanation:** There is no way to pick up a set of consecutive cards that contain a pair of matching cards. ``` **Constraints:** `1 <= cards.length <= 105` `0 <= cards[i] <= 106`",
        "test_case": [
            {
                "label": "Example 1",
                "input": "cards = [3,4,2,3,4,7]",
                "output": "4 Explanation: We can pick up the cards [3,4,2,3] which contain a matching pair of cards with value 3. Note that picking up the cards [4,2,3,4] is also optimal."
            },
            {
                "label": "Example 2",
                "input": "cards = [1,0,5,3]",
                "output": "-1 Explanation: There is no way to pick up a set of consecutive cards that contain a pair of matching cards."
            }
        ],
        "elixir_template": "defmodule Solution do\n  @spec minimum_card_pickup(cards :: [integer]) :: integer\n  def minimum_card_pickup(cards) do\n    \n  end\nend",
        "erlang_template": "-spec minimum_card_pickup(Cards :: [integer()]) -> integer().\nminimum_card_pickup(Cards) ->\n  .",
        "scala_template": "object Solution {\n    def minimumCardPickup(cards: Array[Int]): Int = {\n        \n    }\n}"
    },
    {
        "id": 2337,
        "name": "remove-digit-from-number-to-maximize-result",
        "difficulty": "Easy",
        "link": "https://leetcode.com/problems/remove-digit-from-number-to-maximize-result/",
        "task_description": "You are given a string `number` representing a **positive integer** and a character `digit`. Return _the resulting string after removing **exactly one occurrence** of _`digit`_ from _`number`_ such that the value of the resulting string in **decimal** form is **maximized**_. The test cases are generated such that `digit` occurs at least once in `number`. **Example 1:** ``` **Input:** number = \"123\", digit = \"3\" **Output:** \"12\" **Explanation:** There is only one '3' in \"123\". After removing '3', the result is \"12\". ``` **Example 2:** ``` **Input:** number = \"1231\", digit = \"1\" **Output:** \"231\" **Explanation:** We can remove the first '1' to get \"231\" or remove the second '1' to get \"123\". Since 231 > 123, we return \"231\". ``` **Example 3:** ``` **Input:** number = \"551\", digit = \"5\" **Output:** \"51\" **Explanation:** We can remove either the first or second '5' from \"551\". Both result in the string \"51\". ``` **Constraints:** `2 <= number.length <= 100` `number` consists of digits from `'1'` to `'9'`. `digit` is a digit from `'1'` to `'9'`. `digit` occurs at least once in `number`.",
        "test_case": [
            {
                "label": "Example 1",
                "input": "number = \"123\", digit = \"3\"",
                "output": "\"12\" Explanation: There is only one '3' in \"123\". After removing '3', the result is \"12\"."
            },
            {
                "label": "Example 2",
                "input": "number = \"1231\", digit = \"1\"",
                "output": "\"231\" Explanation: We can remove the first '1' to get \"231\" or remove the second '1' to get \"123\".\nSince 231 > 123, we return \"231\"."
            },
            {
                "label": "Example 3",
                "input": "number = \"551\", digit = \"5\"",
                "output": "\"51\" Explanation: We can remove either the first or second '5' from \"551\".\nBoth result in the string \"51\"."
            }
        ],
        "elixir_template": "defmodule Solution do\n  @spec remove_digit(number :: String.t, digit :: char) :: String.t\n  def remove_digit(number, digit) do\n    \n  end\nend",
        "erlang_template": "-spec remove_digit(Number :: unicode:unicode_binary(), Digit :: char()) -> unicode:unicode_binary().\nremove_digit(Number, Digit) ->\n  .",
        "scala_template": "object Solution {\n    def removeDigit(number: String, digit: Char): String = {\n        \n    }\n}"
    },
    {
        "id": 2334,
        "name": "number-of-flowers-in-full-bloom",
        "difficulty": "Hard",
        "link": "https://leetcode.com/problems/number-of-flowers-in-full-bloom/",
        "task_description": "You are given a **0-indexed** 2D integer array `flowers`, where `flowers[i] = [starti, endi]` means the `ith` flower will be in **full bloom** from `starti` to `endi` (**inclusive**). You are also given a **0-indexed** integer array `people` of size `n`, where `people[i]` is the time that the `ith` person will arrive to see the flowers. Return _an integer array _`answer`_ of size _`n`_, where _`answer[i]`_ is the **number** of flowers that are in full bloom when the _`ith`_ person arrives._ **Example 1:** ``` **Input:** flowers = [[1,6],[3,7],[9,12],[4,13]], people = [2,3,7,11] **Output:** [1,2,2,2] **Explanation: **The figure above shows the times when the flowers are in full bloom and when the people arrive. For each person, we return the number of flowers in full bloom during their arrival. ``` **Example 2:** ``` **Input:** flowers = [[1,10],[3,3]], people = [3,3,2] **Output:** [2,2,1] **Explanation:** The figure above shows the times when the flowers are in full bloom and when the people arrive. For each person, we return the number of flowers in full bloom during their arrival. ``` **Constraints:** `1 <= flowers.length <= 5 * 104` `flowers[i].length == 2` `1 <= starti <= endi <= 109` `1 <= people.length <= 5 * 104` `1 <= people[i] <= 109`",
        "test_case": [
            {
                "label": "Example 1",
                "input": "flowers = [[1,6],[3,7],[9,12],[4,13]], people = [2,3,7,11]",
                "output": "[1,2,2,2] Explanation: The figure above shows the times when the flowers are in full bloom and when the people arrive.\nFor each person, we return the number of flowers in full bloom during their arrival."
            },
            {
                "label": "Example 2",
                "input": "flowers = [[1,10],[3,3]], people = [3,3,2]",
                "output": "[2,2,1] Explanation: The figure above shows the times when the flowers are in full bloom and when the people arrive.\nFor each person, we return the number of flowers in full bloom during their arrival."
            }
        ],
        "elixir_template": "defmodule Solution do\n  @spec full_bloom_flowers(flowers :: [[integer]], people :: [integer]) :: [integer]\n  def full_bloom_flowers(flowers, people) do\n    \n  end\nend",
        "erlang_template": "-spec full_bloom_flowers(Flowers :: [[integer()]], People :: [integer()]) -> [integer()].\nfull_bloom_flowers(Flowers, People) ->\n  .",
        "scala_template": "object Solution {\n    def fullBloomFlowers(flowers: Array[Array[Int]], people: Array[Int]): Array[Int] = {\n        \n    }\n}"
    },
    {
        "id": 2333,
        "name": "count-number-of-rectangles-containing-each-point",
        "difficulty": "Medium",
        "link": "https://leetcode.com/problems/count-number-of-rectangles-containing-each-point/",
        "task_description": "You are given a 2D integer array `rectangles` where `rectangles[i] = [li, hi]` indicates that `ith` rectangle has a length of `li` and a height of `hi`. You are also given a 2D integer array `points` where `points[j] = [xj, yj]` is a point with coordinates `(xj, yj)`. The `ith` rectangle has its **bottom-left corner** point at the coordinates `(0, 0)` and its **top-right corner** point at `(li, hi)`. Return_ an integer array _`count`_ of length _`points.length`_ where _`count[j]`_ is the number of rectangles that **contain** the _`jth`_ point._ The `ith` rectangle **contains** the `jth` point if `0 <= xj <= li` and `0 <= yj <= hi`. Note that points that lie on the **edges** of a rectangle are also considered to be contained by that rectangle. **Example 1:** ``` **Input:** rectangles = [[1,2],[2,3],[2,5]], points = [[2,1],[1,4]] **Output:** [2,1] **Explanation:** The first rectangle contains no points. The second rectangle contains only the point (2, 1). The third rectangle contains the points (2, 1) and (1, 4). The number of rectangles that contain the point (2, 1) is 2. The number of rectangles that contain the point (1, 4) is 1. Therefore, we return [2, 1]. ``` **Example 2:** ``` **Input:** rectangles = [[1,1],[2,2],[3,3]], points = [[1,3],[1,1]] **Output:** [1,3] **Explanation: **The first rectangle contains only the point (1, 1). The second rectangle contains only the point (1, 1). The third rectangle contains the points (1, 3) and (1, 1). The number of rectangles that contain the point (1, 3) is 1. The number of rectangles that contain the point (1, 1) is 3. Therefore, we return [1, 3]. ``` **Constraints:** `1 <= rectangles.length, points.length <= 5 * 104` `rectangles[i].length == points[j].length == 2` `1 <= li, xj <= 109` `1 <= hi, yj <= 100` All the `rectangles` are **unique**. All the `points` are **unique**.",
        "test_case": [
            {
                "label": "Example 1",
                "input": "rectangles = [[1,2],[2,3],[2,5]], points = [[2,1],[1,4]]",
                "output": "[2,1] Explanation: The first rectangle contains no points.\nThe second rectangle contains only the point (2, 1).\nThe third rectangle contains the points (2, 1) and (1, 4).\nThe number of rectangles that contain the point (2, 1) is 2.\nThe number of rectangles that contain the point (1, 4) is 1.\nTherefore, we return [2, 1]."
            },
            {
                "label": "Example 2",
                "input": "rectangles = [[1,1],[2,2],[3,3]], points = [[1,3],[1,1]]",
                "output": "[1,3] Explanation: The first rectangle contains only the point (1, 1).\nThe second rectangle contains only the point (1, 1).\nThe third rectangle contains the points (1, 3) and (1, 1).\nThe number of rectangles that contain the point (1, 3) is 1.\nThe number of rectangles that contain the point (1, 1) is 3.\nTherefore, we return [1, 3]."
            }
        ],
        "elixir_template": "defmodule Solution do\n  @spec count_rectangles(rectangles :: [[integer]], points :: [[integer]]) :: [integer]\n  def count_rectangles(rectangles, points) do\n    \n  end\nend",
        "erlang_template": "-spec count_rectangles(Rectangles :: [[integer()]], Points :: [[integer()]]) -> [integer()].\ncount_rectangles(Rectangles, Points) ->\n  .",
        "scala_template": "object Solution {\n    def countRectangles(rectangles: Array[Array[Int]], points: Array[Array[Int]]): Array[Int] = {\n        \n    }\n}"
    },
    {
        "id": 2332,
        "name": "count-lattice-points-inside-a-circle",
        "difficulty": "Medium",
        "link": "https://leetcode.com/problems/count-lattice-points-inside-a-circle/",
        "task_description": "Given a 2D integer array `circles` where `circles[i] = [xi, yi, ri]` represents the center `(xi, yi)` and radius `ri` of the `ith` circle drawn on a grid, return _the **number of lattice points** __that are present inside **at least one** circle_. **Note:** A **lattice point** is a point with integer coordinates. Points that lie **on the circumference of a circle** are also considered to be inside it. **Example 1:** ``` **Input:** circles = [[2,2,1]] **Output:** 5 **Explanation:** The figure above shows the given circle. The lattice points present inside the circle are (1, 2), (2, 1), (2, 2), (2, 3), and (3, 2) and are shown in green. Other points such as (1, 1) and (1, 3), which are shown in red, are not considered inside the circle. Hence, the number of lattice points present inside at least one circle is 5. ``` **Example 2:** ``` **Input:** circles = [[2,2,2],[3,4,1]] **Output:** 16 **Explanation:** The figure above shows the given circles. There are exactly 16 lattice points which are present inside at least one circle. Some of them are (0, 2), (2, 0), (2, 4), (3, 2), and (4, 4). ``` **Constraints:** `1 <= circles.length <= 200` `circles[i].length == 3` `1 <= xi, yi <= 100` `1 <= ri <= min(xi, yi)`",
        "test_case": [
            {
                "label": "Example 1",
                "input": "circles = [[2,2,1]]",
                "output": "5 Explanation: The figure above shows the given circle.\nThe lattice points present inside the circle are (1, 2), (2, 1), (2, 2), (2, 3), and (3, 2) and are shown in green.\nOther points such as (1, 1) and (1, 3), which are shown in red, are not considered inside the circle.\nHence, the number of lattice points present inside at least one circle is 5."
            },
            {
                "label": "Example 2",
                "input": "circles = [[2,2,2],[3,4,1]]",
                "output": "16 Explanation: The figure above shows the given circles.\nThere are exactly 16 lattice points which are present inside at least one circle. \nSome of them are (0, 2), (2, 0), (2, 4), (3, 2), and (4, 4)."
            }
        ],
        "elixir_template": "defmodule Solution do\n  @spec count_lattice_points(circles :: [[integer]]) :: integer\n  def count_lattice_points(circles) do\n    \n  end\nend",
        "erlang_template": "-spec count_lattice_points(Circles :: [[integer()]]) -> integer().\ncount_lattice_points(Circles) ->\n  .",
        "scala_template": "object Solution {\n    def countLatticePoints(circles: Array[Array[Int]]): Int = {\n        \n    }\n}"
    },
    {
        "id": 2331,
        "name": "intersection-of-multiple-arrays",
        "difficulty": "Easy",
        "link": "https://leetcode.com/problems/intersection-of-multiple-arrays/",
        "task_description": "Given a 2D integer array `nums` where `nums[i]` is a non-empty array of **distinct** positive integers, return _the list of integers that are present in **each array** of_ `nums`_ sorted in **ascending order**_. **Example 1:** ``` **Input:** nums = [[**3**,1,2,**4**,5],[1,2,**3**,**4**],[**3**,**4**,5,6]] **Output:** [3,4] **Explanation:** The only integers present in each of nums[0] = [**3**,1,2,**4**,5], nums[1] = [1,2,**3**,**4**], and nums[2] = [**3**,**4**,5,6] are 3 and 4, so we return [3,4]. ``` **Example 2:** ``` **Input:** nums = [[1,2,3],[4,5,6]] **Output:** [] **Explanation:** There does not exist any integer present both in nums[0] and nums[1], so we return an empty list []. ``` **Constraints:** `1 <= nums.length <= 1000` `1 <= sum(nums[i].length) <= 1000` `1 <= nums[i][j] <= 1000` All the values of `nums[i]` are **unique**.",
        "test_case": [
            {
                "label": "Example 1",
                "input": "nums = [[ 3 ,1,2, 4 ,5],[1,2, 3 , 4 ],[ 3 , 4 ,5,6]]",
                "output": "[3,4] Explanation: The only integers present in each of nums[0] = [ 3 ,1,2, 4 ,5], nums[1] = [1,2, 3 , 4 ], and nums[2] = [ 3 , 4 ,5,6] are 3 and 4, so we return [3,4]."
            },
            {
                "label": "Example 2",
                "input": "nums = [[1,2,3],[4,5,6]]",
                "output": "[] Explanation: There does not exist any integer present both in nums[0] and nums[1], so we return an empty list []."
            }
        ],
        "elixir_template": "defmodule Solution do\n  @spec intersection(nums :: [[integer]]) :: [integer]\n  def intersection(nums) do\n    \n  end\nend",
        "erlang_template": "-spec intersection(Nums :: [[integer()]]) -> [integer()].\nintersection(Nums) ->\n  .",
        "scala_template": "object Solution {\n    def intersection(nums: Array[Array[Int]]): List[Int] = {\n        \n    }\n}"
    },
    {
        "id": 2330,
        "name": "maximum-total-beauty-of-the-gardens",
        "difficulty": "Hard",
        "link": "https://leetcode.com/problems/maximum-total-beauty-of-the-gardens/",
        "task_description": "Alice is a caretaker of `n` gardens and she wants to plant flowers to maximize the total beauty of all her gardens. You are given a **0-indexed** integer array `flowers` of size `n`, where `flowers[i]` is the number of flowers already planted in the `ith` garden. Flowers that are already planted **cannot** be removed. You are then given another integer `newFlowers`, which is the **maximum** number of flowers that Alice can additionally plant. You are also given the integers `target`, `full`, and `partial`. A garden is considered **complete** if it has **at least** `target` flowers. The **total beauty** of the gardens is then determined as the **sum** of the following: The number of **complete** gardens multiplied by `full`. The **minimum** number of flowers in any of the **incomplete** gardens multiplied by `partial`. If there are no incomplete gardens, then this value will be `0`. Return _the **maximum** total beauty that Alice can obtain after planting at most _`newFlowers`_ flowers._ **Example 1:** ``` **Input:** flowers = [1,3,1,1], newFlowers = 7, target = 6, full = 12, partial = 1 **Output:** 14 **Explanation:** Alice can plant - 2 flowers in the 0th garden - 3 flowers in the 1st garden - 1 flower in the 2nd garden - 1 flower in the 3rd garden The gardens will then be [3,6,2,2]. She planted a total of 2 + 3 + 1 + 1 = 7 flowers. There is 1 garden that is complete. The minimum number of flowers in the incomplete gardens is 2. Thus, the total beauty is 1 * 12 + 2 * 1 = 12 + 2 = 14. No other way of planting flowers can obtain a total beauty higher than 14. ``` **Example 2:** ``` **Input:** flowers = [2,4,5,3], newFlowers = 10, target = 5, full = 2, partial = 6 **Output:** 30 **Explanation:** Alice can plant - 3 flowers in the 0th garden - 0 flowers in the 1st garden - 0 flowers in the 2nd garden - 2 flowers in the 3rd garden The gardens will then be [5,4,5,5]. She planted a total of 3 + 0 + 0 + 2 = 5 flowers. There are 3 gardens that are complete. The minimum number of flowers in the incomplete gardens is 4. Thus, the total beauty is 3 * 2 + 4 * 6 = 6 + 24 = 30. No other way of planting flowers can obtain a total beauty higher than 30. Note that Alice could make all the gardens complete but in this case, she would obtain a lower total beauty. ``` **Constraints:** `1 <= flowers.length <= 105` `1 <= flowers[i], target <= 105` `1 <= newFlowers <= 1010` `1 <= full, partial <= 105`",
        "test_case": [
            {
                "label": "Example 1",
                "input": "flowers = [1,3,1,1], newFlowers = 7, target = 6, full = 12, partial = 1",
                "output": "14 Explanation: Alice can plant\n- 2 flowers in the 0 th garden\n- 3 flowers in the 1 st garden\n- 1 flower in the 2 nd garden\n- 1 flower in the 3 rd garden\nThe gardens will then be [3,6,2,2]. She planted a total of 2 + 3 + 1 + 1 = 7 flowers.\nThere is 1 garden that is complete.\nThe minimum number of flowers in the incomplete gardens is 2.\nThus, the total beauty is 1 * 12 + 2 * 1 = 12 + 2 = 14.\nNo other way of planting flowers can obtain a total beauty higher than 14."
            },
            {
                "label": "Example 2",
                "input": "flowers = [2,4,5,3], newFlowers = 10, target = 5, full = 2, partial = 6",
                "output": "30 Explanation: Alice can plant\n- 3 flowers in the 0 th garden\n- 0 flowers in the 1 st garden\n- 0 flowers in the 2 nd garden\n- 2 flowers in the 3 rd garden\nThe gardens will then be [5,4,5,5]. She planted a total of 3 + 0 + 0 + 2 = 5 flowers.\nThere are 3 gardens that are complete.\nThe minimum number of flowers in the incomplete gardens is 4.\nThus, the total beauty is 3 * 2 + 4 * 6 = 6 + 24 = 30.\nNo other way of planting flowers can obtain a total beauty higher than 30.\nNote that Alice could make all the gardens complete but in this case, she would obtain a lower total beauty."
            }
        ],
        "elixir_template": "defmodule Solution do\n  @spec maximum_beauty(flowers :: [integer], new_flowers :: integer, target :: integer, full :: integer, partial :: integer) :: integer\n  def maximum_beauty(flowers, new_flowers, target, full, partial) do\n    \n  end\nend",
        "erlang_template": "-spec maximum_beauty(Flowers :: [integer()], NewFlowers :: integer(), Target :: integer(), Full :: integer(), Partial :: integer()) -> integer().\nmaximum_beauty(Flowers, NewFlowers, Target, Full, Partial) ->\n  .",
        "scala_template": "object Solution {\n    def maximumBeauty(flowers: Array[Int], newFlowers: Long, target: Int, full: Int, partial: Int): Long = {\n        \n    }\n}"
    },
    {
        "id": 2329,
        "name": "maximum-product-after-k-increments",
        "difficulty": "Medium",
        "link": "https://leetcode.com/problems/maximum-product-after-k-increments/",
        "task_description": "You are given an array of non-negative integers `nums` and an integer `k`. In one operation, you may choose **any** element from `nums` and **increment** it by `1`. Return_ the **maximum** **product** of _`nums`_ after **at most** _`k`_ operations. _Since the answer may be very large, return it modulo `109 + 7`. Note that you should maximize the product before taking the modulo. **Example 1:** ``` **Input:** nums = [0,4], k = 5 **Output:** 20 **Explanation:** Increment the first number 5 times. Now nums = [5, 4], with a product of 5 * 4 = 20. It can be shown that 20 is maximum product possible, so we return 20. Note that there may be other ways to increment nums to have the maximum product. ``` **Example 2:** ``` **Input:** nums = [6,3,3,2], k = 2 **Output:** 216 **Explanation:** Increment the second number 1 time and increment the fourth number 1 time. Now nums = [6, 4, 3, 3], with a product of 6 * 4 * 3 * 3 = 216. It can be shown that 216 is maximum product possible, so we return 216. Note that there may be other ways to increment nums to have the maximum product. ``` **Constraints:** `1 <= nums.length, k <= 105` `0 <= nums[i] <= 106`",
        "test_case": [
            {
                "label": "Example 1",
                "input": "nums = [0,4], k = 5",
                "output": "20 Explanation: Increment the first number 5 times.\nNow nums = [5, 4], with a product of 5 * 4 = 20.\nIt can be shown that 20 is maximum product possible, so we return 20.\nNote that there may be other ways to increment nums to have the maximum product."
            },
            {
                "label": "Example 2",
                "input": "nums = [6,3,3,2], k = 2",
                "output": "216 Explanation: Increment the second number 1 time and increment the fourth number 1 time.\nNow nums = [6, 4, 3, 3], with a product of 6 * 4 * 3 * 3 = 216.\nIt can be shown that 216 is maximum product possible, so we return 216.\nNote that there may be other ways to increment nums to have the maximum product."
            }
        ],
        "elixir_template": "defmodule Solution do\n  @spec maximum_product(nums :: [integer], k :: integer) :: integer\n  def maximum_product(nums, k) do\n    \n  end\nend",
        "erlang_template": "-spec maximum_product(Nums :: [integer()], K :: integer()) -> integer().\nmaximum_product(Nums, K) ->\n  .",
        "scala_template": "object Solution {\n    def maximumProduct(nums: Array[Int], k: Int): Int = {\n        \n    }\n}"
    },
    {
        "id": 2328,
        "name": "minimize-result-by-adding-parentheses-to-expression",
        "difficulty": "Medium",
        "link": "https://leetcode.com/problems/minimize-result-by-adding-parentheses-to-expression/",
        "task_description": "You are given a **0-indexed** string `expression` of the form `\"<num1>+<num2>\"` where `<num1>` and `<num2>` represent positive integers. Add a pair of parentheses to `expression` such that after the addition of parentheses, `expression` is a **valid** mathematical expression and evaluates to the **smallest** possible value. The left parenthesis **must** be added to the left of `'+'` and the right parenthesis **must** be added to the right of `'+'`. Return `expression`_ after adding a pair of parentheses such that _`expression`_ evaluates to the **smallest** possible value._ If there are multiple answers that yield the same result, return any of them. The input has been generated such that the original value of `expression`, and the value of `expression` after adding any pair of parentheses that meets the requirements fits within a signed 32-bit integer. **Example 1:** ``` **Input:** expression = \"247+38\" **Output:** \"2(47+38)\" **Explanation:** The `expression` evaluates to 2 * (47 + 38) = 2 * 85 = 170. Note that \"2(4)7+38\" is invalid because the right parenthesis must be to the right of the `'+'`. It can be shown that 170 is the smallest possible value. ``` **Example 2:** ``` **Input:** expression = \"12+34\" **Output:** \"1(2+3)4\" **Explanation:** The expression evaluates to 1 * (2 + 3) * 4 = 1 * 5 * 4 = 20. ``` **Example 3:** ``` **Input:** expression = \"999+999\" **Output:** \"(999+999)\" **Explanation:** The `expression` evaluates to 999 + 999 = 1998. ``` **Constraints:** `3 <= expression.length <= 10` `expression` consists of digits from `'1'` to `'9'` and `'+'`. `expression` starts and ends with digits. `expression` contains exactly one `'+'`. The original value of `expression`, and the value of `expression` after adding any pair of parentheses that meets the requirements fits within a signed 32-bit integer.",
        "test_case": [
            {
                "label": "Example 1",
                "input": "expression = \"247+38\"",
                "output": "\"2(47+38)\" Explanation: The expression evaluates to 2 * (47 + 38) = 2 * 85 = 170.\nNote that \"2(4)7+38\" is invalid because the right parenthesis must be to the right of the '+' .\nIt can be shown that 170 is the smallest possible value."
            },
            {
                "label": "Example 2",
                "input": "expression = \"12+34\"",
                "output": "\"1(2+3)4\" Explanation: The expression evaluates to 1 * (2 + 3) * 4 = 1 * 5 * 4 = 20."
            },
            {
                "label": "Example 3",
                "input": "expression = \"999+999\"",
                "output": "\"(999+999)\" Explanation: The expression evaluates to 999 + 999 = 1998."
            }
        ],
        "elixir_template": "defmodule Solution do\n  @spec minimize_result(expression :: String.t) :: String.t\n  def minimize_result(expression) do\n    \n  end\nend",
        "erlang_template": "-spec minimize_result(Expression :: unicode:unicode_binary()) -> unicode:unicode_binary().\nminimize_result(Expression) ->\n  .",
        "scala_template": "object Solution {\n    def minimizeResult(expression: String): String = {\n        \n    }\n}"
    },
    {
        "id": 2327,
        "name": "largest-number-after-digit-swaps-by-parity",
        "difficulty": "Easy",
        "link": "https://leetcode.com/problems/largest-number-after-digit-swaps-by-parity/",
        "task_description": "You are given a positive integer `num`. You may swap any two digits of `num` that have the same **parity** (i.e. both odd digits or both even digits). Return_ the **largest** possible value of _`num`_ after **any** number of swaps._ **Example 1:** ``` **Input:** num = 1234 **Output:** 3412 **Explanation:** Swap the digit 3 with the digit 1, this results in the number 3214. Swap the digit 2 with the digit 4, this results in the number 3412. Note that there may be other sequences of swaps but it can be shown that 3412 is the largest possible number. Also note that we may not swap the digit 4 with the digit 1 since they are of different parities. ``` **Example 2:** ``` **Input:** num = 65875 **Output:** 87655 **Explanation:** Swap the digit 8 with the digit 6, this results in the number 85675. Swap the first digit 5 with the digit 7, this results in the number 87655. Note that there may be other sequences of swaps but it can be shown that 87655 is the largest possible number. ``` **Constraints:** `1 <= num <= 109`",
        "test_case": [
            {
                "label": "Example 1",
                "input": "num = 1234",
                "output": "3412 Explanation: Swap the digit 3 with the digit 1, this results in the number 3214.\nSwap the digit 2 with the digit 4, this results in the number 3412.\nNote that there may be other sequences of swaps but it can be shown that 3412 is the largest possible number.\nAlso note that we may not swap the digit 4 with the digit 1 since they are of different parities."
            },
            {
                "label": "Example 2",
                "input": "num = 65875",
                "output": "87655 Explanation: Swap the digit 8 with the digit 6, this results in the number 85675.\nSwap the first digit 5 with the digit 7, this results in the number 87655.\nNote that there may be other sequences of swaps but it can be shown that 87655 is the largest possible number."
            }
        ],
        "elixir_template": "defmodule Solution do\n  @spec largest_integer(num :: integer) :: integer\n  def largest_integer(num) do\n    \n  end\nend",
        "erlang_template": "-spec largest_integer(Num :: integer()) -> integer().\nlargest_integer(Num) ->\n  .",
        "scala_template": "object Solution {\n    def largestInteger(num: Int): Int = {\n        \n    }\n}"
    },
    {
        "id": 2326,
        "name": "sum-of-scores-of-built-strings",
        "difficulty": "Hard",
        "link": "https://leetcode.com/problems/sum-of-scores-of-built-strings/",
        "task_description": "You are **building** a string `s` of length `n` **one** character at a time, **prepending** each new character to the **front** of the string. The strings are labeled from `1` to `n`, where the string with length `i` is labeled `si`. For example, for `s = \"abaca\"`, `s1 == \"a\"`, `s2 == \"ca\"`, `s3 == \"aca\"`, etc. The **score** of `si` is the length of the **longest common prefix** between `si` and `sn` (Note that `s == sn`). Given the final string `s`, return_ the **sum** of the **score** of every _`si`. **Example 1:** ``` **Input:** s = \"babab\" **Output:** 9 **Explanation:** For s1 == \"b\", the longest common prefix is \"b\" which has a score of 1. For s2 == \"ab\", there is no common prefix so the score is 0. For s3 == \"bab\", the longest common prefix is \"bab\" which has a score of 3. For s4 == \"abab\", there is no common prefix so the score is 0. For s5 == \"babab\", the longest common prefix is \"babab\" which has a score of 5. The sum of the scores is 1 + 0 + 3 + 0 + 5 = 9, so we return 9. ``` **Example 2:** ``` **Input:** s = \"azbazbzaz\" **Output:** 14 **Explanation:** For s2 == \"az\", the longest common prefix is \"az\" which has a score of 2. For s6 == \"azbzaz\", the longest common prefix is \"azb\" which has a score of 3. For s9 == \"azbazbzaz\", the longest common prefix is \"azbazbzaz\" which has a score of 9. For all other si, the score is 0. The sum of the scores is 2 + 3 + 9 = 14, so we return 14. ``` **Constraints:** `1 <= s.length <= 105` `s` consists of lowercase English letters.",
        "test_case": [
            {
                "label": "Example 1",
                "input": "s = \"babab\"",
                "output": "9 Explanation: For s 1 == \"b\", the longest common prefix is \"b\" which has a score of 1.\nFor s 2 == \"ab\", there is no common prefix so the score is 0.\nFor s 3 == \"bab\", the longest common prefix is \"bab\" which has a score of 3.\nFor s 4 == \"abab\", there is no common prefix so the score is 0.\nFor s 5 == \"babab\", the longest common prefix is \"babab\" which has a score of 5.\nThe sum of the scores is 1 + 0 + 3 + 0 + 5 = 9, so we return 9."
            },
            {
                "label": "Example 2",
                "input": "s = \"azbazbzaz\"",
                "output": "14 Explanation: For s 2 == \"az\", the longest common prefix is \"az\" which has a score of 2.\nFor s 6 == \"azbzaz\", the longest common prefix is \"azb\" which has a score of 3.\nFor s 9 == \"azbazbzaz\", the longest common prefix is \"azbazbzaz\" which has a score of 9.\nFor all other s i , the score is 0.\nThe sum of the scores is 2 + 3 + 9 = 14, so we return 14."
            }
        ],
        "elixir_template": "defmodule Solution do\n  @spec sum_scores(s :: String.t) :: integer\n  def sum_scores(s) do\n    \n  end\nend",
        "erlang_template": "-spec sum_scores(S :: unicode:unicode_binary()) -> integer().\nsum_scores(S) ->\n  .",
        "scala_template": "object Solution {\n    def sumScores(s: String): Long = {\n        \n    }\n}"
    },
    {
        "id": 2325,
        "name": "number-of-ways-to-select-buildings",
        "difficulty": "Medium",
        "link": "https://leetcode.com/problems/number-of-ways-to-select-buildings/",
        "task_description": "You are given a **0-indexed** binary string `s` which represents the types of buildings along a street where: `s[i] = '0'` denotes that the `ith` building is an office and `s[i] = '1'` denotes that the `ith` building is a restaurant. As a city official, you would like to **select** 3 buildings for random inspection. However, to ensure variety, **no two consecutive** buildings out of the **selected** buildings can be of the same type. For example, given `s = \"0**0**1**1**0**1**\"`, we cannot select the `1st`, `3rd`, and `5th` buildings as that would form `\"0**11**\"` which is **not** allowed due to having two consecutive buildings of the same type. Return _the number of valid ways to select 3 buildings._ **Example 1:** ``` **Input:** s = \"001101\" **Output:** 6 **Explanation:** The following sets of indices selected are valid: - [0,2,4] from \"**0**0**1**1**0**1\" forms \"010\" - [0,3,4] from \"**0**01**10**1\" forms \"010\" - [1,2,4] from \"0**01**1**0**1\" forms \"010\" - [1,3,4] from \"0**0**1**10**1\" forms \"010\" - [2,4,5] from \"00**1**1**01**\" forms \"101\" - [3,4,5] from \"001**101**\" forms \"101\" No other selection is valid. Thus, there are 6 total ways. ``` **Example 2:** ``` **Input:** s = \"11100\" **Output:** 0 **Explanation:** It can be shown that there are no valid selections. ``` **Constraints:** `3 <= s.length <= 105` `s[i]` is either `'0'` or `'1'`.",
        "test_case": [
            {
                "label": "Example 1",
                "input": "s = \"001101\"",
                "output": "6 Explanation: The following sets of indices selected are valid:\n- [0,2,4] from \" 0 0 1 1 0 1\" forms \"010\"\n- [0,3,4] from \" 0 01 10 1\" forms \"010\"\n- [1,2,4] from \"0 01 1 0 1\" forms \"010\"\n- [1,3,4] from \"0 0 1 10 1\" forms \"010\"\n- [2,4,5] from \"00 1 1 01 \" forms \"101\"\n- [3,4,5] from \"001 101 \" forms \"101\"\nNo other selection is valid. Thus, there are 6 total ways."
            },
            {
                "label": "Example 2",
                "input": "s = \"11100\"",
                "output": "0 Explanation: It can be shown that there are no valid selections."
            }
        ],
        "elixir_template": "defmodule Solution do\n  @spec number_of_ways(s :: String.t) :: integer\n  def number_of_ways(s) do\n    \n  end\nend",
        "erlang_template": "-spec number_of_ways(S :: unicode:unicode_binary()) -> integer().\nnumber_of_ways(S) ->\n  .",
        "scala_template": "object Solution {\n    def numberOfWays(s: String): Long = {\n        \n    }\n}"
    },
    {
        "id": 2324,
        "name": "find-triangular-sum-of-an-array",
        "difficulty": "Medium",
        "link": "https://leetcode.com/problems/find-triangular-sum-of-an-array/",
        "task_description": "You are given a **0-indexed** integer array `nums`, where `nums[i]` is a digit between `0` and `9` (**inclusive**). The **triangular sum** of `nums` is the value of the only element present in `nums` after the following process terminates: Let `nums` comprise of `n` elements. If `n == 1`, **end** the process. Otherwise, **create** a new **0-indexed** integer array `newNums` of length `n - 1`. For each index `i`, where `0 <= i < n - 1`, **assign** the value of `newNums[i]` as `(nums[i] + nums[i+1]) % 10`, where `%` denotes modulo operator. **Replace** the array `nums` with `newNums`. **Repeat** the entire process starting from step 1. Return _the triangular sum of_ `nums`. **Example 1:** ``` **Input:** nums = [1,2,3,4,5] **Output:** 8 **Explanation:** The above diagram depicts the process from which we obtain the triangular sum of the array. ``` **Example 2:** ``` **Input:** nums = [5] **Output:** 5 **Explanation:** Since there is only one element in nums, the triangular sum is the value of that element itself. ``` **Constraints:** `1 <= nums.length <= 1000` `0 <= nums[i] <= 9`",
        "test_case": [
            {
                "label": "Example 1",
                "input": "nums = [1,2,3,4,5]",
                "output": "8 Explanation: The above diagram depicts the process from which we obtain the triangular sum of the array."
            },
            {
                "label": "Example 2",
                "input": "nums = [5]",
                "output": "5 Explanation: Since there is only one element in nums, the triangular sum is the value of that element itself."
            }
        ],
        "elixir_template": "defmodule Solution do\n  @spec triangular_sum(nums :: [integer]) :: integer\n  def triangular_sum(nums) do\n    \n  end\nend",
        "erlang_template": "-spec triangular_sum(Nums :: [integer()]) -> integer().\ntriangular_sum(Nums) ->\n  .",
        "scala_template": "object Solution {\n    def triangularSum(nums: Array[Int]): Int = {\n        \n    }\n}"
    },
    {
        "id": 2323,
        "name": "minimum-bit-flips-to-convert-number",
        "difficulty": "Easy",
        "link": "https://leetcode.com/problems/minimum-bit-flips-to-convert-number/",
        "task_description": "A **bit flip** of a number `x` is choosing a bit in the binary representation of `x` and **flipping** it from either `0` to `1` or `1` to `0`. For example, for `x = 7`, the binary representation is `111` and we may choose any bit (including any leading zeros not shown) and flip it. We can flip the first bit from the right to get `110`, flip the second bit from the right to get `101`, flip the fifth bit from the right (a leading zero) to get `10111`, etc. Given two integers `start` and `goal`, return_ the **minimum** number of **bit flips** to convert _`start`_ to _`goal`. **Example 1:** ``` **Input:** start = 10, goal = 7 **Output:** 3 **Explanation:** The binary representation of 10 and 7 are 1010 and 0111 respectively. We can convert 10 to 7 in 3 steps: - Flip the first bit from the right: 1010 -> 1011. - Flip the third bit from the right: 1011 -> 1111. - Flip the fourth bit from the right: 1111 -> 0111. It can be shown we cannot convert 10 to 7 in less than 3 steps. Hence, we return 3. ``` **Example 2:** ``` **Input:** start = 3, goal = 4 **Output:** 3 **Explanation:** The binary representation of 3 and 4 are 011 and 100 respectively. We can convert 3 to 4 in 3 steps: - Flip the first bit from the right: 011 -> 010. - Flip the second bit from the right: 010 -> 000. - Flip the third bit from the right: 000 -> 100. It can be shown we cannot convert 3 to 4 in less than 3 steps. Hence, we return 3. ``` **Constraints:** `0 <= start, goal <= 109` **Note:** This question is the same as 461: Hamming Distance.",
        "test_case": [
            {
                "label": "Example 1",
                "input": "start = 10, goal = 7",
                "output": "3 Explanation: The binary representation of 10 and 7 are 1010 and 0111 respectively. We can convert 10 to 7 in 3 steps:\n- Flip the first bit from the right: 101 0 -> 101 1 .\n- Flip the third bit from the right: 1 0 11 -> 1 1 11.\n- Flip the fourth bit from the right: 1 111 -> 0 111.\nIt can be shown we cannot convert 10 to 7 in less than 3 steps. Hence, we return 3."
            },
            {
                "label": "Example 2",
                "input": "start = 3, goal = 4",
                "output": "3 Explanation: The binary representation of 3 and 4 are 011 and 100 respectively. We can convert 3 to 4 in 3 steps:\n- Flip the first bit from the right: 01 1 -> 01 0 .\n- Flip the second bit from the right: 0 1 0 -> 0 0 0.\n- Flip the third bit from the right: 0 00 -> 1 00.\nIt can be shown we cannot convert 3 to 4 in less than 3 steps. Hence, we return 3."
            }
        ],
        "elixir_template": "defmodule Solution do\n  @spec min_bit_flips(start :: integer, goal :: integer) :: integer\n  def min_bit_flips(start, goal) do\n    \n  end\nend",
        "erlang_template": "-spec min_bit_flips(Start :: integer(), Goal :: integer()) -> integer().\nmin_bit_flips(Start, Goal) ->\n  .",
        "scala_template": "object Solution {\n    def minBitFlips(start: Int, goal: Int): Int = {\n        \n    }\n}"
    },
    {
        "id": 2321,
        "name": "minimum-weighted-subgraph-with-the-required-paths",
        "difficulty": "Hard",
        "link": "https://leetcode.com/problems/minimum-weighted-subgraph-with-the-required-paths/",
        "task_description": "You are given an integer `n` denoting the number of nodes of a **weighted directed** graph. The nodes are numbered from `0` to `n - 1`. You are also given a 2D integer array `edges` where `edges[i] = [fromi, toi, weighti]` denotes that there exists a **directed** edge from `fromi` to `toi` with weight `weighti`. Lastly, you are given three **distinct** integers `src1`, `src2`, and `dest` denoting three distinct nodes of the graph. Return _the **minimum weight** of a subgraph of the graph such that it is **possible** to reach_ `dest` _from both_ `src1` _and_ `src2` _via a set of edges of this subgraph_. In case such a subgraph does not exist, return `-1`. A **subgraph** is a graph whose vertices and edges are subsets of the original graph. The **weight** of a subgraph is the sum of weights of its constituent edges. **Example 1:** ``` **Input:** n = 6, edges = [[0,2,2],[0,5,6],[1,0,3],[1,4,5],[2,1,1],[2,3,3],[2,3,4],[3,4,2],[4,5,1]], src1 = 0, src2 = 1, dest = 5 **Output:** 9 **Explanation:** The above figure represents the input graph. The blue edges represent one of the subgraphs that yield the optimal answer. Note that the subgraph [[1,0,3],[0,5,6]] also yields the optimal answer. It is not possible to get a subgraph with less weight satisfying all the constraints. ``` **Example 2:** ``` **Input:** n = 3, edges = [[0,1,1],[2,1,1]], src1 = 0, src2 = 1, dest = 2 **Output:** -1 **Explanation:** The above figure represents the input graph. It can be seen that there does not exist any path from node 1 to node 2, hence there are no subgraphs satisfying all the constraints. ``` **Constraints:** `3 <= n <= 105` `0 <= edges.length <= 105` `edges[i].length == 3` `0 <= fromi, toi, src1, src2, dest <= n - 1` `fromi != toi` `src1`, `src2`, and `dest` are pairwise distinct. `1 <= weight[i] <= 105`",
        "test_case": [
            {
                "label": "Example 1",
                "input": "n = 6, edges = [[0,2,2],[0,5,6],[1,0,3],[1,4,5],[2,1,1],[2,3,3],[2,3,4],[3,4,2],[4,5,1]], src1 = 0, src2 = 1, dest = 5",
                "output": "9 Explanation: The above figure represents the input graph.\nThe blue edges represent one of the subgraphs that yield the optimal answer.\nNote that the subgraph [[1,0,3],[0,5,6]] also yields the optimal answer. It is not possible to get a subgraph with less weight satisfying all the constraints."
            },
            {
                "label": "Example 2",
                "input": "n = 3, edges = [[0,1,1],[2,1,1]], src1 = 0, src2 = 1, dest = 2",
                "output": "-1 Explanation: The above figure represents the input graph.\nIt can be seen that there does not exist any path from node 1 to node 2, hence there are no subgraphs satisfying all the constraints."
            }
        ],
        "elixir_template": "defmodule Solution do\n  @spec minimum_weight(n :: integer, edges :: [[integer]], src1 :: integer, src2 :: integer, dest :: integer) :: integer\n  def minimum_weight(n, edges, src1, src2, dest) do\n    \n  end\nend",
        "erlang_template": "-spec minimum_weight(N :: integer(), Edges :: [[integer()]], Src1 :: integer(), Src2 :: integer(), Dest :: integer()) -> integer().\nminimum_weight(N, Edges, Src1, Src2, Dest) ->\n  .",
        "scala_template": "object Solution {\n    def minimumWeight(n: Int, edges: Array[Array[Int]], src1: Int, src2: Int, dest: Int): Long = {\n        \n    }\n}"
    },
    {
        "id": 2320,
        "name": "find-all-k-distant-indices-in-an-array",
        "difficulty": "Easy",
        "link": "https://leetcode.com/problems/find-all-k-distant-indices-in-an-array/",
        "task_description": "You are given a **0-indexed** integer array `nums` and two integers `key` and `k`. A **k-distant index** is an index `i` of `nums` for which there exists at least one index `j` such that `|i - j| <= k` and `nums[j] == key`. Return _a list of all k-distant indices sorted in **increasing order**_. **Example 1:** ``` **Input:** nums = [3,4,9,1,3,9,5], key = 9, k = 1 **Output:** [1,2,3,4,5,6] **Explanation:** Here, `nums[2] == key` and `nums[5] == key. - For index 0, |0 - 2| > k and |0 - 5| > k, so there is no j` where `|0 - j| <= k` and `nums[j] == key. Thus, 0 is not a k-distant index. - For index 1, |1 - 2| <= k and nums[2] == key, so 1 is a k-distant index. - For index 2, |2 - 2| <= k and nums[2] == key, so 2 is a k-distant index. - For index 3, |3 - 2| <= k and nums[2] == key, so 3 is a k-distant index. - For index 4, |4 - 5| <= k and nums[5] == key, so 4 is a k-distant index. - For index 5, |5 - 5| <= k and nums[5] == key, so 5 is a k-distant index. - For index 6, |6 - 5| <= k and nums[5] == key, so 6 is a k-distant index. `Thus, we return [1,2,3,4,5,6] which is sorted in increasing order. ``` **Example 2:** ``` **Input:** nums = [2,2,2,2,2], key = 2, k = 2 **Output:** [0,1,2,3,4] **Explanation:** For all indices i in nums, there exists some index j such that |i - j| <= k and nums[j] == key, so every index is a k-distant index. Hence, we return [0,1,2,3,4]. ``` **Constraints:** `1 <= nums.length <= 1000` `1 <= nums[i] <= 1000` `key` is an integer from the array `nums`. `1 <= k <= nums.length`",
        "test_case": [
            {
                "label": "Example 1",
                "input": "nums = [3,4,9,1,3,9,5], key = 9, k = 1",
                "output": "[1,2,3,4,5,6] Explanation: Here, nums[2] == key and nums[5] == key.\n- For index 0, |0 - 2| > k and |0 - 5| > k, so there is no j where |0 - j| <= k and nums[j] == key. Thus, 0 is not a k-distant index.\n- For index 1, |1 - 2| <= k and nums[2] == key, so 1 is a k-distant index.\n- For index 2, |2 - 2| <= k and nums[2] == key, so 2 is a k-distant index.\n- For index 3, |3 - 2| <= k and nums[2] == key, so 3 is a k-distant index.\n- For index 4, |4 - 5| <= k and nums[5] == key, so 4 is a k-distant index.\n- For index 5, |5 - 5| <= k and nums[5] == key, so 5 is a k-distant index.\n- For index 6, |6 - 5| <= k and nums[5] == key, so 6 is a k-distant index. Thus, we return [1,2,3,4,5,6] which is sorted in increasing order."
            },
            {
                "label": "Example 2",
                "input": "nums = [2,2,2,2,2], key = 2, k = 2",
                "output": "[0,1,2,3,4] Explanation: For all indices i in nums, there exists some index j such that |i - j| <= k and nums[j] == key, so every index is a k-distant index. \nHence, we return [0,1,2,3,4]."
            }
        ],
        "elixir_template": "defmodule Solution do\n  @spec find_k_distant_indices(nums :: [integer], key :: integer, k :: integer) :: [integer]\n  def find_k_distant_indices(nums, key, k) do\n    \n  end\nend",
        "erlang_template": "-spec find_k_distant_indices(Nums :: [integer()], Key :: integer(), K :: integer()) -> [integer()].\nfind_k_distant_indices(Nums, Key, K) ->\n  .",
        "scala_template": "object Solution {\n    def findKDistantIndices(nums: Array[Int], key: Int, k: Int): List[Int] = {\n        \n    }\n}"
    },
    {
        "id": 2319,
        "name": "longest-substring-of-one-repeating-character",
        "difficulty": "Hard",
        "link": "https://leetcode.com/problems/longest-substring-of-one-repeating-character/",
        "task_description": "You are given a **0-indexed** string `s`. You are also given a **0-indexed** string `queryCharacters` of length `k` and a **0-indexed** array of integer **indices** `queryIndices` of length `k`, both of which are used to describe `k` queries. The `ith` query updates the character in `s` at index `queryIndices[i]` to the character `queryCharacters[i]`. Return _an array_ `lengths` _of length _`k`_ where_ `lengths[i]` _is the **length** of the **longest substring** of _`s`_ consisting of **only one repeating** character **after** the_ `ith` _query__ is performed._ **Example 1:** ``` **Input:** s = \"babacc\", queryCharacters = \"bcb\", queryIndices = [1,3,3] **Output:** [3,3,4] **Explanation:** - 1st query updates s = \"b**b**bacc\". The longest substring consisting of one repeating character is \"bbb\" with length 3. - 2nd query updates s = \"bbb**c**cc\". The longest substring consisting of one repeating character can be \"bbb\" or \"ccc\" with length 3. - 3rd query updates s = \"bbb**b**cc\". The longest substring consisting of one repeating character is \"bbbb\" with length 4. Thus, we return [3,3,4]. ``` **Example 2:** ``` **Input:** s = \"abyzz\", queryCharacters = \"aa\", queryIndices = [2,1] **Output:** [2,3] **Explanation:** - 1st query updates s = \"ab**a**zz\". The longest substring consisting of one repeating character is \"zz\" with length 2. - 2nd query updates s = \"a**a**azz\". The longest substring consisting of one repeating character is \"aaa\" with length 3. Thus, we return [2,3]. ``` **Constraints:** `1 <= s.length <= 105` `s` consists of lowercase English letters. `k == queryCharacters.length == queryIndices.length` `1 <= k <= 105` `queryCharacters` consists of lowercase English letters. `0 <= queryIndices[i] < s.length`",
        "test_case": [
            {
                "label": "Example 1",
                "input": "s = \"babacc\", queryCharacters = \"bcb\", queryIndices = [1,3,3]",
                "output": "[3,3,4] Explanation: - 1 st query updates s = \" b b b acc\". The longest substring consisting of one repeating character is \"bbb\" with length 3.\n- 2 nd query updates s = \"bbb c cc \". \n  The longest substring consisting of one repeating character can be \"bbb\" or \"ccc\" with length 3.\n- 3 rd query updates s = \" bbb b cc\". The longest substring consisting of one repeating character is \"bbbb\" with length 4.\nThus, we return [3,3,4]."
            },
            {
                "label": "Example 2",
                "input": "s = \"abyzz\", queryCharacters = \"aa\", queryIndices = [2,1]",
                "output": "[2,3] Explanation: - 1 st query updates s = \"ab a zz \". The longest substring consisting of one repeating character is \"zz\" with length 2.\n- 2 nd query updates s = \" a a a zz\". The longest substring consisting of one repeating character is \"aaa\" with length 3.\nThus, we return [2,3]."
            }
        ],
        "elixir_template": "defmodule Solution do\n  @spec longest_repeating(s :: String.t, query_characters :: String.t, query_indices :: [integer]) :: [integer]\n  def longest_repeating(s, query_characters, query_indices) do\n    \n  end\nend",
        "erlang_template": "-spec longest_repeating(S :: unicode:unicode_binary(), QueryCharacters :: unicode:unicode_binary(), QueryIndices :: [integer()]) -> [integer()].\nlongest_repeating(S, QueryCharacters, QueryIndices) ->\n  .",
        "scala_template": "object Solution {\n    def longestRepeating(s: String, queryCharacters: String, queryIndices: Array[Int]): Array[Int] = {\n        \n    }\n}"
    },
    {
        "id": 2318,
        "name": "maximum-points-in-an-archery-competition",
        "difficulty": "Medium",
        "link": "https://leetcode.com/problems/maximum-points-in-an-archery-competition/",
        "task_description": "Alice and Bob are opponents in an archery competition. The competition has set the following rules: Alice first shoots `numArrows` arrows and then Bob shoots `numArrows` arrows. The points are then calculated as follows: The target has integer scoring sections ranging from `0` to `11` **inclusive**. For **each** section of the target with score `k` (in between `0` to `11`), say Alice and Bob have shot `ak` and `bk` arrows on that section respectively. If `ak >= bk`, then Alice takes `k` points. If `ak < bk`, then Bob takes `k` points. However, if `ak == bk == 0`, then **nobody** takes `k` points. For example, if Alice and Bob both shot `2` arrows on the section with score `11`, then Alice takes `11` points. On the other hand, if Alice shot `0` arrows on the section with score `11` and Bob shot `2` arrows on that same section, then Bob takes `11` points. You are given the integer `numArrows` and an integer array `aliceArrows` of size `12`, which represents the number of arrows Alice shot on each scoring section from `0` to `11`. Now, Bob wants to **maximize** the total number of points he can obtain. Return _the array _`bobArrows`_ which represents the number of arrows Bob shot on **each** scoring section from _`0`_ to _`11`. The sum of the values in `bobArrows` should equal `numArrows`. If there are multiple ways for Bob to earn the maximum total points, return **any** one of them. **Example 1:** ``` **Input:** numArrows = 9, aliceArrows = [1,1,0,1,0,0,2,1,0,1,2,0] **Output:** [0,0,0,0,1,1,0,0,1,2,3,1] **Explanation:** The table above shows how the competition is scored. Bob earns a total point of 4 + 5 + 8 + 9 + 10 + 11 = 47. It can be shown that Bob cannot obtain a score higher than 47 points. ``` **Example 2:** ``` **Input:** numArrows = 3, aliceArrows = [0,0,1,0,0,0,0,0,0,0,0,2] **Output:** [0,0,0,0,0,0,0,0,1,1,1,0] **Explanation:** The table above shows how the competition is scored. Bob earns a total point of 8 + 9 + 10 = 27. It can be shown that Bob cannot obtain a score higher than 27 points. ``` **Constraints:** `1 <= numArrows <= 105` `aliceArrows.length == bobArrows.length == 12` `0 <= aliceArrows[i], bobArrows[i] <= numArrows` `sum(aliceArrows[i]) == numArrows`",
        "test_case": [
            {
                "label": "Example 1",
                "input": "numArrows = 9, aliceArrows = [1,1,0,1,0,0,2,1,0,1,2,0]",
                "output": "[0,0,0,0,1,1,0,0,1,2,3,1] Explanation: The table above shows how the competition is scored. \nBob earns a total point of 4 + 5 + 8 + 9 + 10 + 11 = 47.\nIt can be shown that Bob cannot obtain a score higher than 47 points."
            },
            {
                "label": "Example 2",
                "input": "numArrows = 3, aliceArrows = [0,0,1,0,0,0,0,0,0,0,0,2]",
                "output": "[0,0,0,0,0,0,0,0,1,1,1,0] Explanation: The table above shows how the competition is scored.\nBob earns a total point of 8 + 9 + 10 = 27.\nIt can be shown that Bob cannot obtain a score higher than 27 points."
            }
        ],
        "elixir_template": "defmodule Solution do\n  @spec maximum_bob_points(num_arrows :: integer, alice_arrows :: [integer]) :: [integer]\n  def maximum_bob_points(num_arrows, alice_arrows) do\n    \n  end\nend",
        "erlang_template": "-spec maximum_bob_points(NumArrows :: integer(), AliceArrows :: [integer()]) -> [integer()].\nmaximum_bob_points(NumArrows, AliceArrows) ->\n  .",
        "scala_template": "object Solution {\n    def maximumBobPoints(numArrows: Int, aliceArrows: Array[Int]): Array[Int] = {\n        \n    }\n}"
    },
    {
        "id": 2317,
        "name": "count-collisions-on-a-road",
        "difficulty": "Medium",
        "link": "https://leetcode.com/problems/count-collisions-on-a-road/",
        "task_description": "There are `n` cars on an infinitely long road. The cars are numbered from `0` to `n - 1` from left to right and each car is present at a **unique** point. You are given a **0-indexed** string `directions` of length `n`. `directions[i]` can be either `'L'`, `'R'`, or `'S'` denoting whether the `ith` car is moving towards the **left**, towards the **right**, or **staying** at its current point respectively. Each moving car has the **same speed**. The number of collisions can be calculated as follows: When two cars moving in **opposite** directions collide with each other, the number of collisions increases by `2`. When a moving car collides with a stationary car, the number of collisions increases by `1`. After a collision, the cars involved can no longer move and will stay at the point where they collided. Other than that, cars cannot change their state or direction of motion. Return _the **total number of collisions** that will happen on the road_. **Example 1:** ``` **Input:** directions = \"RLRSLL\" **Output:** 5 **Explanation:** The collisions that will happen on the road are: - Cars 0 and 1 will collide with each other. Since they are moving in opposite directions, the number of collisions becomes 0 + 2 = 2. - Cars 2 and 3 will collide with each other. Since car 3 is stationary, the number of collisions becomes 2 + 1 = 3. - Cars 3 and 4 will collide with each other. Since car 3 is stationary, the number of collisions becomes 3 + 1 = 4. - Cars 4 and 5 will collide with each other. After car 4 collides with car 3, it will stay at the point of collision and get hit by car 5. The number of collisions becomes 4 + 1 = 5. Thus, the total number of collisions that will happen on the road is 5. ``` **Example 2:** ``` **Input:** directions = \"LLRR\" **Output:** 0 **Explanation:** No cars will collide with each other. Thus, the total number of collisions that will happen on the road is 0. ``` **Constraints:** `1 <= directions.length <= 105` `directions[i]` is either `'L'`, `'R'`, or `'S'`.",
        "test_case": [
            {
                "label": "Example 1",
                "input": "directions = \"RLRSLL\"",
                "output": "5 Explanation: The collisions that will happen on the road are:\n- Cars 0 and 1 will collide with each other. Since they are moving in opposite directions, the number of collisions becomes 0 + 2 = 2.\n- Cars 2 and 3 will collide with each other. Since car 3 is stationary, the number of collisions becomes 2 + 1 = 3.\n- Cars 3 and 4 will collide with each other. Since car 3 is stationary, the number of collisions becomes 3 + 1 = 4.\n- Cars 4 and 5 will collide with each other. After car 4 collides with car 3, it will stay at the point of collision and get hit by car 5. The number of collisions becomes 4 + 1 = 5.\nThus, the total number of collisions that will happen on the road is 5."
            },
            {
                "label": "Example 2",
                "input": "directions = \"LLRR\"",
                "output": "0 Explanation: No cars will collide with each other. Thus, the total number of collisions that will happen on the road is 0."
            }
        ],
        "elixir_template": "defmodule Solution do\n  @spec count_collisions(directions :: String.t) :: integer\n  def count_collisions(directions) do\n    \n  end\nend",
        "erlang_template": "-spec count_collisions(Directions :: unicode:unicode_binary()) -> integer().\ncount_collisions(Directions) ->\n  .",
        "scala_template": "object Solution {\n    def countCollisions(directions: String): Int = {\n        \n    }\n}"
    },
    {
        "id": 2316,
        "name": "count-hills-and-valleys-in-an-array",
        "difficulty": "Easy",
        "link": "https://leetcode.com/problems/count-hills-and-valleys-in-an-array/",
        "task_description": "You are given a **0-indexed** integer array `nums`. An index `i` is part of a **hill** in `nums` if the closest non-equal neighbors of `i` are smaller than `nums[i]`. Similarly, an index `i` is part of a **valley** in `nums` if the closest non-equal neighbors of `i` are larger than `nums[i]`. Adjacent indices `i` and `j` are part of the **same** hill or valley if `nums[i] == nums[j]`. Note that for an index to be part of a hill or valley, it must have a non-equal neighbor on **both** the left and right of the index. Return the number of hills and valleys in `nums`. **Example 1:** ``` **Input:** nums = [2,4,1,1,6,5] **Output:** 3 **Explanation:** At index 0: There is no non-equal neighbor of 2 on the left, so index 0 is neither a hill nor a valley. At index 1: The closest non-equal neighbors of 4 are 2 and 1. Since 4 > 2 and 4 > 1, index 1 is a hill. At index 2: The closest non-equal neighbors of 1 are 4 and 6. Since 1 < 4 and 1 < 6, index 2 is a valley. At index 3: The closest non-equal neighbors of 1 are 4 and 6. Since 1 < 4 and 1 < 6, index 3 is a valley, but note that it is part of the same valley as index 2. At index 4: The closest non-equal neighbors of 6 are 1 and 5. Since 6 > 1 and 6 > 5, index 4 is a hill. At index 5: There is no non-equal neighbor of 5 on the right, so index 5 is neither a hill nor a valley. There are 3 hills and valleys so we return 3. ``` **Example 2:** ``` **Input:** nums = [6,6,5,5,4,1] **Output:** 0 **Explanation:** At index 0: There is no non-equal neighbor of 6 on the left, so index 0 is neither a hill nor a valley. At index 1: There is no non-equal neighbor of 6 on the left, so index 1 is neither a hill nor a valley. At index 2: The closest non-equal neighbors of 5 are 6 and 4. Since 5 < 6 and 5 > 4, index 2 is neither a hill nor a valley. At index 3: The closest non-equal neighbors of 5 are 6 and 4. Since 5 < 6 and 5 > 4, index 3 is neither a hill nor a valley. At index 4: The closest non-equal neighbors of 4 are 5 and 1. Since 4 < 5 and 4 > 1, index 4 is neither a hill nor a valley. At index 5: There is no non-equal neighbor of 1 on the right, so index 5 is neither a hill nor a valley. There are 0 hills and valleys so we return 0. ``` **Constraints:** `3 <= nums.length <= 100` `1 <= nums[i] <= 100`",
        "test_case": [
            {
                "label": "Example 1",
                "input": "nums = [2,4,1,1,6,5]",
                "output": "3 Explanation: At index 0: There is no non-equal neighbor of 2 on the left, so index 0 is neither a hill nor a valley.\nAt index 1: The closest non-equal neighbors of 4 are 2 and 1. Since 4 > 2 and 4 > 1, index 1 is a hill. \nAt index 2: The closest non-equal neighbors of 1 are 4 and 6. Since 1 < 4 and 1 < 6, index 2 is a valley.\nAt index 3: The closest non-equal neighbors of 1 are 4 and 6. Since 1 < 4 and 1 < 6, index 3 is a valley, but note that it is part of the same valley as index 2.\nAt index 4: The closest non-equal neighbors of 6 are 1 and 5. Since 6 > 1 and 6 > 5, index 4 is a hill.\nAt index 5: There is no non-equal neighbor of 5 on the right, so index 5 is neither a hill nor a valley. \nThere are 3 hills and valleys so we return 3."
            },
            {
                "label": "Example 2",
                "input": "nums = [6,6,5,5,4,1]",
                "output": "0 Explanation: At index 0: There is no non-equal neighbor of 6 on the left, so index 0 is neither a hill nor a valley.\nAt index 1: There is no non-equal neighbor of 6 on the left, so index 1 is neither a hill nor a valley.\nAt index 2: The closest non-equal neighbors of 5 are 6 and 4. Since 5 < 6 and 5 > 4, index 2 is neither a hill nor a valley.\nAt index 3: The closest non-equal neighbors of 5 are 6 and 4. Since 5 < 6 and 5 > 4, index 3 is neither a hill nor a valley.\nAt index 4: The closest non-equal neighbors of 4 are 5 and 1. Since 4 < 5 and 4 > 1, index 4 is neither a hill nor a valley.\nAt index 5: There is no non-equal neighbor of 1 on the right, so index 5 is neither a hill nor a valley.\nThere are 0 hills and valleys so we return 0."
            }
        ],
        "elixir_template": "defmodule Solution do\n  @spec count_hill_valley(nums :: [integer]) :: integer\n  def count_hill_valley(nums) do\n    \n  end\nend",
        "erlang_template": "-spec count_hill_valley(Nums :: [integer()]) -> integer().\ncount_hill_valley(Nums) ->\n  .",
        "scala_template": "object Solution {\n    def countHillValley(nums: Array[Int]): Int = {\n        \n    }\n}"
    },
    {
        "id": 2312,
        "name": "most-frequent-number-following-key-in-an-array",
        "difficulty": "Easy",
        "link": "https://leetcode.com/problems/most-frequent-number-following-key-in-an-array/",
        "task_description": "You are given a **0-indexed** integer array `nums`.** **You are also given an integer `key`, which is present in `nums`. For every unique integer `target` in `nums`, **count** the number of times `target` immediately follows an occurrence of `key` in `nums`. In other words, count the number of indices `i` such that: `0 <= i <= nums.length - 2`, `nums[i] == key` and, `nums[i + 1] == target`. Return _the _`target`_ with the **maximum** count_. The test cases will be generated such that the `target` with maximum count is unique. **Example 1:** ``` **Input:** nums = [1,100,200,1,100], key = 1 **Output:** 100 **Explanation:** For target = 100, there are 2 occurrences at indices 1 and 4 which follow an occurrence of key. No other integers follow an occurrence of key, so we return 100. ``` **Example 2:** ``` **Input:** nums = [2,2,2,2,3], key = 2 **Output:** 2 **Explanation:** For target = 2, there are 3 occurrences at indices 1, 2, and 3 which follow an occurrence of key. For target = 3, there is only one occurrence at index 4 which follows an occurrence of key. target = 2 has the maximum number of occurrences following an occurrence of key, so we return 2. ``` **Constraints:** `2 <= nums.length <= 1000` `1 <= nums[i] <= 1000` The test cases will be generated such that the answer is unique.",
        "test_case": [
            {
                "label": "Example 1",
                "input": "nums = [1,100,200,1,100], key = 1",
                "output": "100 Explanation: For target = 100, there are 2 occurrences at indices 1 and 4 which follow an occurrence of key.\nNo other integers follow an occurrence of key, so we return 100."
            },
            {
                "label": "Example 2",
                "input": "nums = [2,2,2,2,3], key = 2",
                "output": "2 Explanation: For target = 2, there are 3 occurrences at indices 1, 2, and 3 which follow an occurrence of key.\nFor target = 3, there is only one occurrence at index 4 which follows an occurrence of key.\ntarget = 2 has the maximum number of occurrences following an occurrence of key, so we return 2."
            }
        ],
        "elixir_template": "defmodule Solution do\n  @spec most_frequent(nums :: [integer], key :: integer) :: integer\n  def most_frequent(nums, key) do\n    \n  end\nend",
        "erlang_template": "-spec most_frequent(Nums :: [integer()], Key :: integer()) -> integer().\nmost_frequent(Nums, Key) ->\n  .",
        "scala_template": "object Solution {\n    def mostFrequent(nums: Array[Int], key: Int): Int = {\n        \n    }\n}"
    },
    {
        "id": 2311,
        "name": "minimum-white-tiles-after-covering-with-carpets",
        "difficulty": "Hard",
        "link": "https://leetcode.com/problems/minimum-white-tiles-after-covering-with-carpets/",
        "task_description": "You are given a **0-indexed binary** string `floor`, which represents the colors of tiles on a floor: `floor[i] = '0'` denotes that the `ith` tile of the floor is colored **black**. On the other hand, `floor[i] = '1'` denotes that the `ith` tile of the floor is colored **white**. You are also given `numCarpets` and `carpetLen`. You have `numCarpets` **black** carpets, each of length `carpetLen` tiles. Cover the tiles with the given carpets such that the number of **white** tiles still visible is **minimum**. Carpets may overlap one another. Return _the **minimum** number of white tiles still visible._ **Example 1:** ``` **Input:** floor = \"10110101\", numCarpets = 2, carpetLen = 2 **Output:** 2 **Explanation:** The figure above shows one way of covering the tiles with the carpets such that only 2 white tiles are visible. No other way of covering the tiles with the carpets can leave less than 2 white tiles visible. ``` **Example 2:** ``` **Input:** floor = \"11111\", numCarpets = 2, carpetLen = 3 **Output:** 0 **Explanation:** The figure above shows one way of covering the tiles with the carpets such that no white tiles are visible. Note that the carpets are able to overlap one another. ``` **Constraints:** `1 <= carpetLen <= floor.length <= 1000` `floor[i]` is either `'0'` or `'1'`. `1 <= numCarpets <= 1000`",
        "test_case": [
            {
                "label": "Example 1",
                "input": "floor = \"10110101\", numCarpets = 2, carpetLen = 2",
                "output": "2 Explanation: The figure above shows one way of covering the tiles with the carpets such that only 2 white tiles are visible.\nNo other way of covering the tiles with the carpets can leave less than 2 white tiles visible."
            },
            {
                "label": "Example 2",
                "input": "floor = \"11111\", numCarpets = 2, carpetLen = 3",
                "output": "0 Explanation: The figure above shows one way of covering the tiles with the carpets such that no white tiles are visible.\nNote that the carpets are able to overlap one another."
            }
        ],
        "elixir_template": "defmodule Solution do\n  @spec minimum_white_tiles(floor :: String.t, num_carpets :: integer, carpet_len :: integer) :: integer\n  def minimum_white_tiles(floor, num_carpets, carpet_len) do\n    \n  end\nend",
        "erlang_template": "-spec minimum_white_tiles(Floor :: unicode:unicode_binary(), NumCarpets :: integer(), CarpetLen :: integer()) -> integer().\nminimum_white_tiles(Floor, NumCarpets, CarpetLen) ->\n  .",
        "scala_template": "object Solution {\n    def minimumWhiteTiles(floor: String, numCarpets: Int, carpetLen: Int): Int = {\n        \n    }\n}"
    },
    {
        "id": 2310,
        "name": "minimum-operations-to-halve-array-sum",
        "difficulty": "Medium",
        "link": "https://leetcode.com/problems/minimum-operations-to-halve-array-sum/",
        "task_description": "You are given an array `nums` of positive integers. In one operation, you can choose **any** number from `nums` and reduce it to **exactly** half the number. (Note that you may choose this reduced number in future operations.) Return_ the **minimum** number of operations to reduce the sum of _`nums`_ by **at least** half._ **Example 1:** ``` **Input:** nums = [5,19,8,1] **Output:** 3 **Explanation:** The initial sum of nums is equal to 5 + 19 + 8 + 1 = 33. The following is one of the ways to reduce the sum by at least half: Pick the number 19 and reduce it to 9.5. Pick the number 9.5 and reduce it to 4.75. Pick the number 8 and reduce it to 4. The final array is [5, 4.75, 4, 1] with a total sum of 5 + 4.75 + 4 + 1 = 14.75. The sum of nums has been reduced by 33 - 14.75 = 18.25, which is at least half of the initial sum, 18.25 >= 33/2 = 16.5. Overall, 3 operations were used so we return 3. It can be shown that we cannot reduce the sum by at least half in less than 3 operations. ``` **Example 2:** ``` **Input:** nums = [3,8,20] **Output:** 3 **Explanation:** The initial sum of nums is equal to 3 + 8 + 20 = 31. The following is one of the ways to reduce the sum by at least half: Pick the number 20 and reduce it to 10. Pick the number 10 and reduce it to 5. Pick the number 3 and reduce it to 1.5. The final array is [1.5, 8, 5] with a total sum of 1.5 + 8 + 5 = 14.5. The sum of nums has been reduced by 31 - 14.5 = 16.5, which is at least half of the initial sum, 16.5 >= 31/2 = 15.5. Overall, 3 operations were used so we return 3. It can be shown that we cannot reduce the sum by at least half in less than 3 operations. ``` **Constraints:** `1 <= nums.length <= 105` `1 <= nums[i] <= 107`",
        "test_case": [
            {
                "label": "Example 1",
                "input": "nums = [5,19,8,1]",
                "output": "3 Explanation: The initial sum of nums is equal to 5 + 19 + 8 + 1 = 33.\nThe following is one of the ways to reduce the sum by at least half:\nPick the number 19 and reduce it to 9.5.\nPick the number 9.5 and reduce it to 4.75.\nPick the number 8 and reduce it to 4.\nThe final array is [5, 4.75, 4, 1] with a total sum of 5 + 4.75 + 4 + 1 = 14.75. \nThe sum of nums has been reduced by 33 - 14.75 = 18.25, which is at least half of the initial sum, 18.25 >= 33/2 = 16.5.\nOverall, 3 operations were used so we return 3.\nIt can be shown that we cannot reduce the sum by at least half in less than 3 operations."
            },
            {
                "label": "Example 2",
                "input": "nums = [3,8,20]",
                "output": "3 Explanation: The initial sum of nums is equal to 3 + 8 + 20 = 31.\nThe following is one of the ways to reduce the sum by at least half:\nPick the number 20 and reduce it to 10.\nPick the number 10 and reduce it to 5.\nPick the number 3 and reduce it to 1.5.\nThe final array is [1.5, 8, 5] with a total sum of 1.5 + 8 + 5 = 14.5. \nThe sum of nums has been reduced by 31 - 14.5 = 16.5, which is at least half of the initial sum, 16.5 >= 31/2 = 15.5.\nOverall, 3 operations were used so we return 3.\nIt can be shown that we cannot reduce the sum by at least half in less than 3 operations."
            }
        ],
        "elixir_template": "defmodule Solution do\n  @spec halve_array(nums :: [integer]) :: integer\n  def halve_array(nums) do\n    \n  end\nend",
        "erlang_template": "-spec halve_array(Nums :: [integer()]) -> integer().\nhalve_array(Nums) ->\n  .",
        "scala_template": "object Solution {\n    def halveArray(nums: Array[Int]): Int = {\n        \n    }\n}"
    },
    {
        "id": 2309,
        "name": "maximize-number-of-subsequences-in-a-string",
        "difficulty": "Medium",
        "link": "https://leetcode.com/problems/maximize-number-of-subsequences-in-a-string/",
        "task_description": "You are given a **0-indexed** string `text` and another **0-indexed** string `pattern` of length `2`, both of which consist of only lowercase English letters. You can add **either** `pattern[0]` **or** `pattern[1]` anywhere in `text` **exactly once**. Note that the character can be added even at the beginning or at the end of `text`. Return _the **maximum** number of times_ `pattern` _can occur as a **subsequence** of the modified _`text`. A subsequence is a string that can be derived from another string by deleting some or no characters without changing the order of the remaining characters. **Example 1:** ``` **Input:** text = \"abdcdbc\", pattern = \"ac\" **Output:** 4 **Explanation:** If we add pattern[0] = 'a' in between text[1] and text[2], we get \"ab**a**dcdbc\". Now, the number of times \"ac\" occurs as a subsequence is 4. Some other strings which have 4 subsequences \"ac\" after adding a character to text are \"**a**abdcdbc\" and \"abd**a**cdbc\". However, strings such as \"abdc**a**dbc\", \"abd**c**cdbc\", and \"abdcdbc**c**\", although obtainable, have only 3 subsequences \"ac\" and are thus suboptimal. It can be shown that it is not possible to get more than 4 subsequences \"ac\" by adding only one character. ``` **Example 2:** ``` **Input:** text = \"aabb\", pattern = \"ab\" **Output:** 6 **Explanation:** Some of the strings which can be obtained from text and have 6 subsequences \"ab\" are \"**a**aabb\", \"aa**a**bb\", and \"aab**b**b\". ``` **Constraints:** `1 <= text.length <= 105` `pattern.length == 2` `text` and `pattern` consist only of lowercase English letters.",
        "test_case": [
            {
                "label": "Example 1",
                "input": "text = \"abdcdbc\", pattern = \"ac\"",
                "output": "4 Explanation: If we add pattern[0] = 'a' in between text[1] and text[2], we get \"ab a dcdbc\". Now, the number of times \"ac\" occurs as a subsequence is 4.\nSome other strings which have 4 subsequences \"ac\" after adding a character to text are \" a abdcdbc\" and \"abd a cdbc\".\nHowever, strings such as \"abdc a dbc\", \"abd c cdbc\", and \"abdcdbc c \", although obtainable, have only 3 subsequences \"ac\" and are thus suboptimal.\nIt can be shown that it is not possible to get more than 4 subsequences \"ac\" by adding only one character."
            },
            {
                "label": "Example 2",
                "input": "text = \"aabb\", pattern = \"ab\"",
                "output": "6 Explanation: Some of the strings which can be obtained from text and have 6 subsequences \"ab\" are \" a aabb\", \"aa a bb\", and \"aab b b\"."
            }
        ],
        "elixir_template": "defmodule Solution do\n  @spec maximum_subsequence_count(text :: String.t, pattern :: String.t) :: integer\n  def maximum_subsequence_count(text, pattern) do\n    \n  end\nend",
        "erlang_template": "-spec maximum_subsequence_count(Text :: unicode:unicode_binary(), Pattern :: unicode:unicode_binary()) -> integer().\nmaximum_subsequence_count(Text, Pattern) ->\n  .",
        "scala_template": "object Solution {\n    def maximumSubsequenceCount(text: String, pattern: String): Long = {\n        \n    }\n}"
    },
    {
        "id": 2308,
        "name": "divide-array-into-equal-pairs",
        "difficulty": "Easy",
        "link": "https://leetcode.com/problems/divide-array-into-equal-pairs/",
        "task_description": "You are given an integer array `nums` consisting of `2 * n` integers. You need to divide `nums` into `n` pairs such that: Each element belongs to **exactly one** pair. The elements present in a pair are **equal**. Return `true` _if nums can be divided into_ `n` _pairs, otherwise return_ `false`. **Example 1:** ``` **Input:** nums = [3,2,3,2,2,2] **Output:** true **Explanation:** There are 6 elements in nums, so they should be divided into 6 / 2 = 3 pairs. If nums is divided into the pairs (2, 2), (3, 3), and (2, 2), it will satisfy all the conditions. ``` **Example 2:** ``` **Input:** nums = [1,2,3,4] **Output:** false **Explanation:** There is no way to divide nums into 4 / 2 = 2 pairs such that the pairs satisfy every condition. ``` **Constraints:** `nums.length == 2 * n` `1 <= n <= 500` `1 <= nums[i] <= 500`",
        "test_case": [
            {
                "label": "Example 1",
                "input": "nums = [3,2,3,2,2,2]",
                "output": "true Explanation: There are 6 elements in nums, so they should be divided into 6 / 2 = 3 pairs.\nIf nums is divided into the pairs (2, 2), (3, 3), and (2, 2), it will satisfy all the conditions."
            },
            {
                "label": "Example 2",
                "input": "nums = [1,2,3,4]",
                "output": "false Explanation: There is no way to divide nums into 4 / 2 = 2 pairs such that the pairs satisfy every condition. Constraints: nums.length == 2 * n 1 <= n <= 500 1 <= nums[i] <= 500"
            }
        ],
        "elixir_template": "defmodule Solution do\n  @spec divide_array(nums :: [integer]) :: boolean\n  def divide_array(nums) do\n    \n  end\nend",
        "erlang_template": "-spec divide_array(Nums :: [integer()]) -> boolean().\ndivide_array(Nums) ->\n  .",
        "scala_template": "object Solution {\n    def divideArray(nums: Array[Int]): Boolean = {\n        \n    }\n}"
    },
    {
        "id": 2307,
        "name": "replace-non-coprime-numbers-in-array",
        "difficulty": "Hard",
        "link": "https://leetcode.com/problems/replace-non-coprime-numbers-in-array/",
        "task_description": "You are given an array of integers `nums`. Perform the following steps: Find **any** two **adjacent** numbers in `nums` that are **non-coprime**. If no such numbers are found, **stop** the process. Otherwise, delete the two numbers and **replace** them with their **LCM (Least Common Multiple)**. **Repeat** this process as long as you keep finding two adjacent non-coprime numbers. Return _the **final** modified array._ It can be shown that replacing adjacent non-coprime numbers in **any** arbitrary order will lead to the same result. The test cases are generated such that the values in the final array are **less than or equal** to `108`. Two values `x` and `y` are **non-coprime** if `GCD(x, y) > 1` where `GCD(x, y)` is the **Greatest Common Divisor** of `x` and `y`. **Example 1:** ``` **Input:** nums = [6,4,3,2,7,6,2] **Output:** [12,7,6] **Explanation:** - (6, 4) are non-coprime with LCM(6, 4) = 12. Now, nums = [**12**,3,2,7,6,2]. - (12, 3) are non-coprime with LCM(12, 3) = 12. Now, nums = [**12**,2,7,6,2]. - (12, 2) are non-coprime with LCM(12, 2) = 12. Now, nums = [**12**,7,6,2]. - (6, 2) are non-coprime with LCM(6, 2) = 6. Now, nums = [12,7,**6**]. There are no more adjacent non-coprime numbers in nums. Thus, the final modified array is [12,7,6]. Note that there are other ways to obtain the same resultant array. ``` **Example 2:** ``` **Input:** nums = [2,2,1,1,3,3,3] **Output:** [2,1,1,3] **Explanation:** - (3, 3) are non-coprime with LCM(3, 3) = 3. Now, nums = [2,2,1,1,**3**,3]. - (3, 3) are non-coprime with LCM(3, 3) = 3. Now, nums = [2,2,1,1,**3**]. - (2, 2) are non-coprime with LCM(2, 2) = 2. Now, nums = [**2**,1,1,3]. There are no more adjacent non-coprime numbers in nums. Thus, the final modified array is [2,1,1,3]. Note that there are other ways to obtain the same resultant array. ``` **Constraints:** `1 <= nums.length <= 105` `1 <= nums[i] <= 105` The test cases are generated such that the values in the final array are **less than or equal** to `108`.",
        "test_case": [
            {
                "label": "Example 1",
                "input": "nums = [6,4,3,2,7,6,2]",
                "output": "[12,7,6] Explanation: - (6, 4) are non-coprime with LCM(6, 4) = 12. Now, nums = [ 12 ,3,2,7,6,2].\n- (12, 3) are non-coprime with LCM(12, 3) = 12. Now, nums = [ 12 ,2,7,6,2].\n- (12, 2) are non-coprime with LCM(12, 2) = 12. Now, nums = [ 12 ,7,6,2].\n- (6, 2) are non-coprime with LCM(6, 2) = 6. Now, nums = [12,7, 6 ].\nThere are no more adjacent non-coprime numbers in nums.\nThus, the final modified array is [12,7,6].\nNote that there are other ways to obtain the same resultant array."
            },
            {
                "label": "Example 2",
                "input": "nums = [2,2,1,1,3,3,3]",
                "output": "[2,1,1,3] Explanation: - (3, 3) are non-coprime with LCM(3, 3) = 3. Now, nums = [2,2,1,1, 3 ,3].\n- (3, 3) are non-coprime with LCM(3, 3) = 3. Now, nums = [2,2,1,1, 3 ].\n- (2, 2) are non-coprime with LCM(2, 2) = 2. Now, nums = [ 2 ,1,1,3].\nThere are no more adjacent non-coprime numbers in nums.\nThus, the final modified array is [2,1,1,3].\nNote that there are other ways to obtain the same resultant array."
            }
        ],
        "elixir_template": "defmodule Solution do\n  @spec replace_non_coprimes(nums :: [integer]) :: [integer]\n  def replace_non_coprimes(nums) do\n    \n  end\nend",
        "erlang_template": "-spec replace_non_coprimes(Nums :: [integer()]) -> [integer()].\nreplace_non_coprimes(Nums) ->\n  .",
        "scala_template": "object Solution {\n    def replaceNonCoprimes(nums: Array[Int]): List[Int] = {\n        \n    }\n}"
    },
    {
        "id": 2306,
        "name": "create-binary-tree-from-descriptions",
        "difficulty": "Medium",
        "link": "https://leetcode.com/problems/create-binary-tree-from-descriptions/",
        "task_description": "You are given a 2D integer array `descriptions` where `descriptions[i] = [parenti, childi, isLefti]` indicates that `parenti` is the **parent** of `childi` in a **binary** tree of **unique** values. Furthermore, If `isLefti == 1`, then `childi` is the left child of `parenti`. If `isLefti == 0`, then `childi` is the right child of `parenti`. Construct the binary tree described by `descriptions` and return _its **root**_. The test cases will be generated such that the binary tree is **valid**. **Example 1:** ``` **Input:** descriptions = [[20,15,1],[20,17,0],[50,20,1],[50,80,0],[80,19,1]] **Output:** [50,20,80,15,17,19] **Explanation:** The root node is the node with value 50 since it has no parent. The resulting binary tree is shown in the diagram. ``` **Example 2:** ``` **Input:** descriptions = [[1,2,1],[2,3,0],[3,4,1]] **Output:** [1,2,null,null,3,4] **Explanation:** The root node is the node with value 1 since it has no parent. The resulting binary tree is shown in the diagram. ``` **Constraints:** `1 <= descriptions.length <= 104` `descriptions[i].length == 3` `1 <= parenti, childi <= 105` `0 <= isLefti <= 1` The binary tree described by `descriptions` is valid.",
        "test_case": [
            {
                "label": "Example 1",
                "input": "descriptions = [[20,15,1],[20,17,0],[50,20,1],[50,80,0],[80,19,1]]",
                "output": "[50,20,80,15,17,19] Explanation: The root node is the node with value 50 since it has no parent.\nThe resulting binary tree is shown in the diagram."
            },
            {
                "label": "Example 2",
                "input": "descriptions = [[1,2,1],[2,3,0],[3,4,1]]",
                "output": "[1,2,null,null,3,4] Explanation: The root node is the node with value 1 since it has no parent.\nThe resulting binary tree is shown in the diagram."
            }
        ],
        "elixir_template": "# Definition for a binary tree node.\n#\n# defmodule TreeNode do\n#   @type t :: %__MODULE__{\n#           val: integer,\n#           left: TreeNode.t() | nil,\n#           right: TreeNode.t() | nil\n#         }\n#   defstruct val: 0, left: nil, right: nil\n# end\n\ndefmodule Solution do\n  @spec create_binary_tree(descriptions :: [[integer]]) :: TreeNode.t | nil\n  def create_binary_tree(descriptions) do\n    \n  end\nend",
        "erlang_template": "%% Definition for a binary tree node.\n%%\n%% -record(tree_node, {val = 0 :: integer(),\n%%                     left = null  :: 'null' | #tree_node{},\n%%                     right = null :: 'null' | #tree_node{}}).\n\n-spec create_binary_tree(Descriptions :: [[integer()]]) -> #tree_node{} | null.\ncreate_binary_tree(Descriptions) ->\n  .",
        "scala_template": "/**\n * Definition for a binary tree node.\n * class TreeNode(_value: Int = 0, _left: TreeNode = null, _right: TreeNode = null) {\n *   var value: Int = _value\n *   var left: TreeNode = _left\n *   var right: TreeNode = _right\n * }\n */\nobject Solution {\n    def createBinaryTree(descriptions: Array[Array[Int]]): TreeNode = {\n        \n    }\n}"
    },
    {
        "id": 2305,
        "name": "append-k-integers-with-minimal-sum",
        "difficulty": "Medium",
        "link": "https://leetcode.com/problems/append-k-integers-with-minimal-sum/",
        "task_description": "You are given an integer array `nums` and an integer `k`. Append `k` **unique positive** integers that do **not** appear in `nums` to `nums` such that the resulting total sum is **minimum**. Return_ the sum of the_ `k` _integers appended to_ `nums`. **Example 1:** ``` **Input:** nums = [1,4,25,10,25], k = 2 **Output:** 5 **Explanation:** The two unique positive integers that do not appear in nums which we append are 2 and 3. The resulting sum of nums is 1 + 4 + 25 + 10 + 25 + 2 + 3 = 70, which is the minimum. The sum of the two integers appended is 2 + 3 = 5, so we return 5. ``` **Example 2:** ``` **Input:** nums = [5,6], k = 6 **Output:** 25 **Explanation:** The six unique positive integers that do not appear in nums which we append are 1, 2, 3, 4, 7, and 8. The resulting sum of nums is 5 + 6 + 1 + 2 + 3 + 4 + 7 + 8 = 36, which is the minimum. The sum of the six integers appended is 1 + 2 + 3 + 4 + 7 + 8 = 25, so we return 25. ``` **Constraints:** `1 <= nums.length <= 105` `1 <= nums[i] <= 109` `1 <= k <= 108`",
        "test_case": [
            {
                "label": "Example 1",
                "input": "nums = [1,4,25,10,25], k = 2",
                "output": "5 Explanation: The two unique positive integers that do not appear in nums which we append are 2 and 3.\nThe resulting sum of nums is 1 + 4 + 25 + 10 + 25 + 2 + 3 = 70, which is the minimum.\nThe sum of the two integers appended is 2 + 3 = 5, so we return 5."
            },
            {
                "label": "Example 2",
                "input": "nums = [5,6], k = 6",
                "output": "25 Explanation: The six unique positive integers that do not appear in nums which we append are 1, 2, 3, 4, 7, and 8.\nThe resulting sum of nums is 5 + 6 + 1 + 2 + 3 + 4 + 7 + 8 = 36, which is the minimum. \nThe sum of the six integers appended is 1 + 2 + 3 + 4 + 7 + 8 = 25, so we return 25."
            }
        ],
        "elixir_template": "defmodule Solution do\n  @spec minimal_k_sum(nums :: [integer], k :: integer) :: integer\n  def minimal_k_sum(nums, k) do\n    \n  end\nend",
        "erlang_template": "-spec minimal_k_sum(Nums :: [integer()], K :: integer()) -> integer().\nminimal_k_sum(Nums, K) ->\n  .",
        "scala_template": "object Solution {\n    def minimalKSum(nums: Array[Int], k: Int): Long = {\n        \n    }\n}"
    },
    {
        "id": 2304,
        "name": "cells-in-a-range-on-an-excel-sheet",
        "difficulty": "Easy",
        "link": "https://leetcode.com/problems/cells-in-a-range-on-an-excel-sheet/",
        "task_description": "A cell `(r, c)` of an excel sheet is represented as a string `\"<col><row>\"` where: `<col>` denotes the column number `c` of the cell. It is represented by **alphabetical letters**. For example, the `1st` column is denoted by `'A'`, the `2nd` by `'B'`, the `3rd` by `'C'`, and so on. `<row>` is the row number `r` of the cell. The `rth` row is represented by the **integer** `r`. You are given a string `s` in the format `\"<col1><row1>:<col2><row2>\"`, where `<col1>` represents the column `c1`, `<row1>` represents the row `r1`, `<col2>` represents the column `c2`, and `<row2>` represents the row `r2`, such that `r1 <= r2` and `c1 <= c2`. Return _the **list of cells**_ `(x, y)` _such that_ `r1 <= x <= r2` _and_ `c1 <= y <= c2`. The cells should be represented as **strings** in the format mentioned above and be sorted in **non-decreasing** order first by columns and then by rows. **Example 1:** ``` **Input:** s = \"K1:L2\" **Output:** [\"K1\",\"K2\",\"L1\",\"L2\"] **Explanation:** The above diagram shows the cells which should be present in the list. The red arrows denote the order in which the cells should be presented. ``` **Example 2:** ``` **Input:** s = \"A1:F1\" **Output:** [\"A1\",\"B1\",\"C1\",\"D1\",\"E1\",\"F1\"] **Explanation:** The above diagram shows the cells which should be present in the list. The red arrow denotes the order in which the cells should be presented. ``` **Constraints:** `s.length == 5` `'A' <= s[0] <= s[3] <= 'Z'` `'1' <= s[1] <= s[4] <= '9'` `s` consists of uppercase English letters, digits and `':'`.",
        "test_case": [
            {
                "label": "Example 1",
                "input": "s = \"K1:L2\"",
                "output": "[\"K1\",\"K2\",\"L1\",\"L2\"] Explanation: The above diagram shows the cells which should be present in the list.\nThe red arrows denote the order in which the cells should be presented."
            },
            {
                "label": "Example 2",
                "input": "s = \"A1:F1\"",
                "output": "[\"A1\",\"B1\",\"C1\",\"D1\",\"E1\",\"F1\"] Explanation: The above diagram shows the cells which should be present in the list.\nThe red arrow denotes the order in which the cells should be presented. Constraints: s.length == 5 'A' <= s[0] <= s[3] <= 'Z' '1' <= s[1] <= s[4] <= '9' s consists of uppercase English letters, digits and ':' ."
            }
        ],
        "elixir_template": "defmodule Solution do\n  @spec cells_in_range(s :: String.t) :: [String.t]\n  def cells_in_range(s) do\n    \n  end\nend",
        "erlang_template": "-spec cells_in_range(S :: unicode:unicode_binary()) -> [unicode:unicode_binary()].\ncells_in_range(S) ->\n  .",
        "scala_template": "object Solution {\n    def cellsInRange(s: String): List[String] = {\n        \n    }\n}"
    },
    {
        "id": 2301,
        "name": "count-array-pairs-divisible-by-k",
        "difficulty": "Hard",
        "link": "https://leetcode.com/problems/count-array-pairs-divisible-by-k/",
        "task_description": "Given a **0-indexed** integer array `nums` of length `n` and an integer `k`, return _the **number of pairs**_ `(i, j)` _such that:_ `0 <= i < j <= n - 1` _and_ `nums[i] * nums[j]` _is divisible by_ `k`. **Example 1:** ``` **Input:** nums = [1,2,3,4,5], k = 2 **Output:** 7 **Explanation:** The 7 pairs of indices whose corresponding products are divisible by 2 are (0, 1), (0, 3), (1, 2), (1, 3), (1, 4), (2, 3), and (3, 4). Their products are 2, 4, 6, 8, 10, 12, and 20 respectively. Other pairs such as (0, 2) and (2, 4) have products 3 and 15 respectively, which are not divisible by 2. ``` **Example 2:** ``` **Input:** nums = [1,2,3,4], k = 5 **Output:** 0 **Explanation:** There does not exist any pair of indices whose corresponding product is divisible by 5. ``` **Constraints:** `1 <= nums.length <= 105` `1 <= nums[i], k <= 105`",
        "test_case": [
            {
                "label": "Example 1",
                "input": "nums = [1,2,3,4,5], k = 2",
                "output": "7 Explanation: The 7 pairs of indices whose corresponding products are divisible by 2 are\n(0, 1), (0, 3), (1, 2), (1, 3), (1, 4), (2, 3), and (3, 4).\nTheir products are 2, 4, 6, 8, 10, 12, and 20 respectively.\nOther pairs such as (0, 2) and (2, 4) have products 3 and 15 respectively, which are not divisible by 2."
            },
            {
                "label": "Example 2",
                "input": "nums = [1,2,3,4], k = 5",
                "output": "0 Explanation: There does not exist any pair of indices whose corresponding product is divisible by 5."
            }
        ],
        "elixir_template": "defmodule Solution do\n  @spec count_pairs(nums :: [integer], k :: integer) :: integer\n  def count_pairs(nums, k) do\n    \n  end\nend",
        "erlang_template": "-spec count_pairs(Nums :: [integer()], K :: integer()) -> integer().\ncount_pairs(Nums, K) ->\n  .",
        "scala_template": "object Solution {\n    def countPairs(nums: Array[Int], k: Int): Long = {\n        \n    }\n}"
    },
    {
        "id": 2300,
        "name": "construct-string-with-repeat-limit",
        "difficulty": "Medium",
        "link": "https://leetcode.com/problems/construct-string-with-repeat-limit/",
        "task_description": "You are given a string `s` and an integer `repeatLimit`. Construct a new string `repeatLimitedString` using the characters of `s` such that no letter appears **more than** `repeatLimit` times **in a row**. You do **not** have to use all characters from `s`. Return _the **lexicographically largest** _`repeatLimitedString` _possible_. A string `a` is **lexicographically larger** than a string `b` if in the first position where `a` and `b` differ, string `a` has a letter that appears later in the alphabet than the corresponding letter in `b`. If the first `min(a.length, b.length)` characters do not differ, then the longer string is the lexicographically larger one. **Example 1:** ``` **Input:** s = \"cczazcc\", repeatLimit = 3 **Output:** \"zzcccac\" **Explanation:** We use all of the characters from s to construct the repeatLimitedString \"zzcccac\". The letter 'a' appears at most 1 time in a row. The letter 'c' appears at most 3 times in a row. The letter 'z' appears at most 2 times in a row. Hence, no letter appears more than repeatLimit times in a row and the string is a valid repeatLimitedString. The string is the lexicographically largest repeatLimitedString possible so we return \"zzcccac\". Note that the string \"zzcccca\" is lexicographically larger but the letter 'c' appears more than 3 times in a row, so it is not a valid repeatLimitedString. ``` **Example 2:** ``` **Input:** s = \"aababab\", repeatLimit = 2 **Output:** \"bbabaa\" **Explanation:** We use only some of the characters from s to construct the repeatLimitedString \"bbabaa\". The letter 'a' appears at most 2 times in a row. The letter 'b' appears at most 2 times in a row. Hence, no letter appears more than repeatLimit times in a row and the string is a valid repeatLimitedString. The string is the lexicographically largest repeatLimitedString possible so we return \"bbabaa\". Note that the string \"bbabaaa\" is lexicographically larger but the letter 'a' appears more than 2 times in a row, so it is not a valid repeatLimitedString. ``` **Constraints:** `1 <= repeatLimit <= s.length <= 105` `s` consists of lowercase English letters.",
        "test_case": [
            {
                "label": "Example 1",
                "input": "s = \"cczazcc\", repeatLimit = 3",
                "output": "\"zzcccac\" Explanation: We use all of the characters from s to construct the repeatLimitedString \"zzcccac\".\nThe letter 'a' appears at most 1 time in a row.\nThe letter 'c' appears at most 3 times in a row.\nThe letter 'z' appears at most 2 times in a row.\nHence, no letter appears more than repeatLimit times in a row and the string is a valid repeatLimitedString.\nThe string is the lexicographically largest repeatLimitedString possible so we return \"zzcccac\".\nNote that the string \"zzcccca\" is lexicographically larger but the letter 'c' appears more than 3 times in a row, so it is not a valid repeatLimitedString."
            },
            {
                "label": "Example 2",
                "input": "s = \"aababab\", repeatLimit = 2",
                "output": "\"bbabaa\" Explanation: We use only some of the characters from s to construct the repeatLimitedString \"bbabaa\". \nThe letter 'a' appears at most 2 times in a row.\nThe letter 'b' appears at most 2 times in a row.\nHence, no letter appears more than repeatLimit times in a row and the string is a valid repeatLimitedString.\nThe string is the lexicographically largest repeatLimitedString possible so we return \"bbabaa\".\nNote that the string \"bbabaaa\" is lexicographically larger but the letter 'a' appears more than 2 times in a row, so it is not a valid repeatLimitedString."
            }
        ],
        "elixir_template": "defmodule Solution do\n  @spec repeat_limited_string(s :: String.t, repeat_limit :: integer) :: String.t\n  def repeat_limited_string(s, repeat_limit) do\n    \n  end\nend",
        "erlang_template": "-spec repeat_limited_string(S :: unicode:unicode_binary(), RepeatLimit :: integer()) -> unicode:unicode_binary().\nrepeat_limited_string(S, RepeatLimit) ->\n  .",
        "scala_template": "object Solution {\n    def repeatLimitedString(s: String, repeatLimit: Int): String = {\n        \n    }\n}"
    },
    {
        "id": 2299,
        "name": "merge-nodes-in-between-zeros",
        "difficulty": "Medium",
        "link": "https://leetcode.com/problems/merge-nodes-in-between-zeros/",
        "task_description": "You are given the `head` of a linked list, which contains a series of integers **separated** by `0`'s. The **beginning** and **end** of the linked list will have `Node.val == 0`. For **every **two consecutive `0`'s, **merge** all the nodes lying in between them into a single node whose value is the **sum** of all the merged nodes. The modified list should not contain any `0`'s. Return _the_ `head` _of the modified linked list_. **Example 1:** ``` **Input:** head = [0,3,1,0,4,5,2,0] **Output:** [4,11] **Explanation:** The above figure represents the given linked list. The modified list contains - The sum of the nodes marked in green: 3 + 1 = 4. - The sum of the nodes marked in red: 4 + 5 + 2 = 11. ``` **Example 2:** ``` **Input:** head = [0,1,0,3,0,2,2,0] **Output:** [1,3,4] **Explanation:** The above figure represents the given linked list. The modified list contains - The sum of the nodes marked in green: 1 = 1. - The sum of the nodes marked in red: 3 = 3. - The sum of the nodes marked in yellow: 2 + 2 = 4. ``` **Constraints:** The number of nodes in the list is in the range `[3, 2 * 105]`. `0 <= Node.val <= 1000` There are **no** two consecutive nodes with `Node.val == 0`. The **beginning** and **end** of the linked list have `Node.val == 0`.",
        "test_case": [
            {
                "label": "Example 1",
                "input": "head = [0,3,1,0,4,5,2,0]",
                "output": "[4,11] Explanation: The above figure represents the given linked list. The modified list contains\n- The sum of the nodes marked in green: 3 + 1 = 4.\n- The sum of the nodes marked in red: 4 + 5 + 2 = 11."
            },
            {
                "label": "Example 2",
                "input": "head = [0,1,0,3,0,2,2,0]",
                "output": "[1,3,4] Explanation: The above figure represents the given linked list. The modified list contains\n- The sum of the nodes marked in green: 1 = 1.\n- The sum of the nodes marked in red: 3 = 3.\n- The sum of the nodes marked in yellow: 2 + 2 = 4. Constraints: The number of nodes in the list is in the range [3, 2 * 10 5 ] . 0 <= Node.val <= 1000 There are no two consecutive nodes with Node.val == 0 . The beginning and end of the linked list have Node.val == 0 ."
            }
        ],
        "elixir_template": "# Definition for singly-linked list.\n#\n# defmodule ListNode do\n#   @type t :: %__MODULE__{\n#           val: integer,\n#           next: ListNode.t() | nil\n#         }\n#   defstruct val: 0, next: nil\n# end\n\ndefmodule Solution do\n  @spec merge_nodes(head :: ListNode.t | nil) :: ListNode.t | nil\n  def merge_nodes(head) do\n    \n  end\nend",
        "erlang_template": "%% Definition for singly-linked list.\n%%\n%% -record(list_node, {val = 0 :: integer(),\n%%                     next = null :: 'null' | #list_node{}}).\n\n-spec merge_nodes(Head :: #list_node{} | null) -> #list_node{} | null.\nmerge_nodes(Head) ->\n  .",
        "scala_template": "/**\n * Definition for singly-linked list.\n * class ListNode(_x: Int = 0, _next: ListNode = null) {\n *   var next: ListNode = _next\n *   var x: Int = _x\n * }\n */\nobject Solution {\n    def mergeNodes(head: ListNode): ListNode = {\n        \n    }\n}"
    },
    {
        "id": 2298,
        "name": "count-integers-with-even-digit-sum",
        "difficulty": "Easy",
        "link": "https://leetcode.com/problems/count-integers-with-even-digit-sum/",
        "task_description": "Given a positive integer `num`, return _the number of positive integers **less than or equal to**_ `num` _whose digit sums are **even**_. The **digit sum** of a positive integer is the sum of all its digits. **Example 1:** ``` **Input:** num = 4 **Output:** 2 **Explanation:** The only integers less than or equal to 4 whose digit sums are even are 2 and 4. ``` **Example 2:** ``` **Input:** num = 30 **Output:** 14 **Explanation:** The 14 integers less than or equal to 30 whose digit sums are even are 2, 4, 6, 8, 11, 13, 15, 17, 19, 20, 22, 24, 26, and 28. ``` **Constraints:** `1 <= num <= 1000`",
        "test_case": [
            {
                "label": "Example 1",
                "input": "num = 4",
                "output": "2 Explanation: The only integers less than or equal to 4 whose digit sums are even are 2 and 4."
            },
            {
                "label": "Example 2",
                "input": "num = 30",
                "output": "14 Explanation: The 14 integers less than or equal to 30 whose digit sums are even are\n2, 4, 6, 8, 11, 13, 15, 17, 19, 20, 22, 24, 26, and 28."
            }
        ],
        "elixir_template": "defmodule Solution do\n  @spec count_even(num :: integer) :: integer\n  def count_even(num) do\n    \n  end\nend",
        "erlang_template": "-spec count_even(Num :: integer()) -> integer().\ncount_even(Num) ->\n  .",
        "scala_template": "object Solution {\n    def countEven(num: Int): Int = {\n        \n    }\n}"
    },
    {
        "id": 2295,
        "name": "minimum-time-to-finish-the-race",
        "difficulty": "Hard",
        "link": "https://leetcode.com/problems/minimum-time-to-finish-the-race/",
        "task_description": "You are given a **0-indexed** 2D integer array `tires` where `tires[i] = [fi, ri]` indicates that the `ith` tire can finish its `xth` successive lap in `fi * ri(x-1)` seconds. For example, if `fi = 3` and `ri = 2`, then the tire would finish its `1st` lap in `3` seconds, its `2nd` lap in `3 * 2 = 6` seconds, its `3rd` lap in `3 * 22 = 12` seconds, etc. You are also given an integer `changeTime` and an integer `numLaps`. The race consists of `numLaps` laps and you may start the race with **any** tire. You have an **unlimited** supply of each tire and after every lap, you may **change** to any given tire (including the current tire type) if you wait `changeTime` seconds. Return_ the **minimum** time to finish the race._ **Example 1:** ``` **Input:** tires = [[2,3],[3,4]], changeTime = 5, numLaps = 4 **Output:** 21 **Explanation:** Lap 1: Start with tire 0 and finish the lap in 2 seconds. Lap 2: Continue with tire 0 and finish the lap in 2 * 3 = 6 seconds. Lap 3: Change tires to a new tire 0 for 5 seconds and then finish the lap in another 2 seconds. Lap 4: Continue with tire 0 and finish the lap in 2 * 3 = 6 seconds. Total time = 2 + 6 + 5 + 2 + 6 = 21 seconds. The minimum time to complete the race is 21 seconds. ``` **Example 2:** ``` **Input:** tires = [[1,10],[2,2],[3,4]], changeTime = 6, numLaps = 5 **Output:** 25 **Explanation:** Lap 1: Start with tire 1 and finish the lap in 2 seconds. Lap 2: Continue with tire 1 and finish the lap in 2 * 2 = 4 seconds. Lap 3: Change tires to a new tire 1 for 6 seconds and then finish the lap in another 2 seconds. Lap 4: Continue with tire 1 and finish the lap in 2 * 2 = 4 seconds. Lap 5: Change tires to tire 0 for 6 seconds then finish the lap in another 1 second. Total time = 2 + 4 + 6 + 2 + 4 + 6 + 1 = 25 seconds. The minimum time to complete the race is 25 seconds. ``` **Constraints:** `1 <= tires.length <= 105` `tires[i].length == 2` `1 <= fi, changeTime <= 105` `2 <= ri <= 105` `1 <= numLaps <= 1000`",
        "test_case": [
            {
                "label": "Example 1",
                "input": "tires = [[2,3],[3,4]], changeTime = 5, numLaps = 4",
                "output": "21 Explanation: Lap 1: Start with tire 0 and finish the lap in 2 seconds.\nLap 2: Continue with tire 0 and finish the lap in 2 * 3 = 6 seconds.\nLap 3: Change tires to a new tire 0 for 5 seconds and then finish the lap in another 2 seconds.\nLap 4: Continue with tire 0 and finish the lap in 2 * 3 = 6 seconds.\nTotal time = 2 + 6 + 5 + 2 + 6 = 21 seconds.\nThe minimum time to complete the race is 21 seconds."
            },
            {
                "label": "Example 2",
                "input": "tires = [[1,10],[2,2],[3,4]], changeTime = 6, numLaps = 5",
                "output": "25 Explanation: Lap 1: Start with tire 1 and finish the lap in 2 seconds.\nLap 2: Continue with tire 1 and finish the lap in 2 * 2 = 4 seconds.\nLap 3: Change tires to a new tire 1 for 6 seconds and then finish the lap in another 2 seconds.\nLap 4: Continue with tire 1 and finish the lap in 2 * 2 = 4 seconds.\nLap 5: Change tires to tire 0 for 6 seconds then finish the lap in another 1 second.\nTotal time = 2 + 4 + 6 + 2 + 4 + 6 + 1 = 25 seconds.\nThe minimum time to complete the race is 25 seconds."
            }
        ],
        "elixir_template": "defmodule Solution do\n  @spec minimum_finish_time(tires :: [[integer]], change_time :: integer, num_laps :: integer) :: integer\n  def minimum_finish_time(tires, change_time, num_laps) do\n    \n  end\nend",
        "erlang_template": "-spec minimum_finish_time(Tires :: [[integer()]], ChangeTime :: integer(), NumLaps :: integer()) -> integer().\nminimum_finish_time(Tires, ChangeTime, NumLaps) ->\n  .",
        "scala_template": "object Solution {\n    def minimumFinishTime(tires: Array[Array[Int]], changeTime: Int, numLaps: Int): Int = {\n        \n    }\n}"
    },
    {
        "id": 2294,
        "name": "minimum-time-to-complete-trips",
        "difficulty": "Medium",
        "link": "https://leetcode.com/problems/minimum-time-to-complete-trips/",
        "task_description": "You are given an array `time` where `time[i]` denotes the time taken by the `ith` bus to complete **one trip**. Each bus can make multiple trips **successively**; that is, the next trip can start **immediately after** completing the current trip. Also, each bus operates **independently**; that is, the trips of one bus do not influence the trips of any other bus. You are also given an integer `totalTrips`, which denotes the number of trips all buses should make **in total**. Return _the **minimum time** required for all buses to complete **at least** _`totalTrips`_ trips_. **Example 1:** ``` **Input:** time = [1,2,3], totalTrips = 5 **Output:** 3 **Explanation:** - At time t = 1, the number of trips completed by each bus are [1,0,0]. The total number of trips completed is 1 + 0 + 0 = 1. - At time t = 2, the number of trips completed by each bus are [2,1,0]. The total number of trips completed is 2 + 1 + 0 = 3. - At time t = 3, the number of trips completed by each bus are [3,1,1]. The total number of trips completed is 3 + 1 + 1 = 5. So the minimum time needed for all buses to complete at least 5 trips is 3. ``` **Example 2:** ``` **Input:** time = [2], totalTrips = 1 **Output:** 2 **Explanation:** There is only one bus, and it will complete its first trip at t = 2. So the minimum time needed to complete 1 trip is 2. ``` **Constraints:** `1 <= time.length <= 105` `1 <= time[i], totalTrips <= 107`",
        "test_case": [
            {
                "label": "Example 1",
                "input": "time = [1,2,3], totalTrips = 5",
                "output": "3 Explanation: - At time t = 1, the number of trips completed by each bus are [1,0,0]. \n  The total number of trips completed is 1 + 0 + 0 = 1.\n- At time t = 2, the number of trips completed by each bus are [2,1,0]. \n  The total number of trips completed is 2 + 1 + 0 = 3.\n- At time t = 3, the number of trips completed by each bus are [3,1,1]. \n  The total number of trips completed is 3 + 1 + 1 = 5.\nSo the minimum time needed for all buses to complete at least 5 trips is 3."
            },
            {
                "label": "Example 2",
                "input": "time = [2], totalTrips = 1",
                "output": "2 Explanation: There is only one bus, and it will complete its first trip at t = 2.\nSo the minimum time needed to complete 1 trip is 2."
            }
        ],
        "elixir_template": "defmodule Solution do\n  @spec minimum_time(time :: [integer], total_trips :: integer) :: integer\n  def minimum_time(time, total_trips) do\n    \n  end\nend",
        "erlang_template": "-spec minimum_time(Time :: [integer()], TotalTrips :: integer()) -> integer().\nminimum_time(Time, TotalTrips) ->\n  .",
        "scala_template": "object Solution {\n    def minimumTime(time: Array[Int], totalTrips: Int): Long = {\n        \n    }\n}"
    },
    {
        "id": 2293,
        "name": "minimum-number-of-steps-to-make-two-strings-anagram-ii",
        "difficulty": "Medium",
        "link": "https://leetcode.com/problems/minimum-number-of-steps-to-make-two-strings-anagram-ii/",
        "task_description": "You are given two strings `s` and `t`. In one step, you can append **any character** to either `s` or `t`. Return _the minimum number of steps to make _`s`_ and _`t`_ **anagrams** of each other._ An **anagram** of a string is a string that contains the same characters with a different (or the same) ordering. **Example 1:** ``` **Input:** s = \"**lee**tco**de**\", t = \"co**a**t**s**\" **Output:** 7 **Explanation:** - In 2 steps, we can append the letters in \"as\" onto s = \"leetcode\", forming s = \"leetcode**as**\". - In 5 steps, we can append the letters in \"leede\" onto t = \"coats\", forming t = \"coats**leede**\". \"leetcodeas\" and \"coatsleede\" are now anagrams of each other. We used a total of 2 + 5 = 7 steps. It can be shown that there is no way to make them anagrams of each other with less than 7 steps. ``` **Example 2:** ``` **Input:** s = \"night\", t = \"thing\" **Output:** 0 **Explanation:** The given strings are already anagrams of each other. Thus, we do not need any further steps. ``` **Constraints:** `1 <= s.length, t.length <= 2 * 105` `s` and `t` consist of lowercase English letters.",
        "test_case": [
            {
                "label": "Example 1",
                "input": "s = \" lee tco de \", t = \"co a t s \"",
                "output": "7 Explanation: - In 2 steps, we can append the letters in \"as\" onto s = \"leetcode\", forming s = \"leetcode as \".\n- In 5 steps, we can append the letters in \"leede\" onto t = \"coats\", forming t = \"coats leede \".\n\"leetcodeas\" and \"coatsleede\" are now anagrams of each other.\nWe used a total of 2 + 5 = 7 steps.\nIt can be shown that there is no way to make them anagrams of each other with less than 7 steps."
            },
            {
                "label": "Example 2",
                "input": "s = \"night\", t = \"thing\"",
                "output": "0 Explanation: The given strings are already anagrams of each other. Thus, we do not need any further steps."
            }
        ],
        "elixir_template": "defmodule Solution do\n  @spec min_steps(s :: String.t, t :: String.t) :: integer\n  def min_steps(s, t) do\n    \n  end\nend",
        "erlang_template": "-spec min_steps(S :: unicode:unicode_binary(), T :: unicode:unicode_binary()) -> integer().\nmin_steps(S, T) ->\n  .",
        "scala_template": "object Solution {\n    def minSteps(s: String, t: String): Int = {\n        \n    }\n}"
    },
    {
        "id": 2292,
        "name": "counting-words-with-a-given-prefix",
        "difficulty": "Easy",
        "link": "https://leetcode.com/problems/counting-words-with-a-given-prefix/",
        "task_description": "You are given an array of strings `words` and a string `pref`. Return _the number of strings in _`words`_ that contain _`pref`_ as a **prefix**_. A **prefix** of a string `s` is any leading contiguous substring of `s`. **Example 1:** ``` **Input:** words = [\"pay\",\"**at**tention\",\"practice\",\"**at**tend\"], `pref `= \"at\" **Output:** 2 **Explanation:** The 2 strings that contain \"at\" as a prefix are: \"**at**tention\" and \"**at**tend\". ``` **Example 2:** ``` **Input:** words = [\"leetcode\",\"win\",\"loops\",\"success\"], `pref `= \"code\" **Output:** 0 **Explanation:** There are no strings that contain \"code\" as a prefix. ``` **Constraints:** `1 <= words.length <= 100` `1 <= words[i].length, pref.length <= 100` `words[i]` and `pref` consist of lowercase English letters.",
        "test_case": [
            {
                "label": "Example 1",
                "input": "words = [\"pay\",\" at tention\",\"practice\",\" at tend\"], pref = \"at\"",
                "output": "2 Explanation: The 2 strings that contain \"at\" as a prefix are: \" at tention\" and \" at tend\"."
            },
            {
                "label": "Example 2",
                "input": "words = [\"leetcode\",\"win\",\"loops\",\"success\"], pref = \"code\"",
                "output": "0 Explanation: There are no strings that contain \"code\" as a prefix."
            }
        ],
        "elixir_template": "defmodule Solution do\n  @spec prefix_count(words :: [String.t], pref :: String.t) :: integer\n  def prefix_count(words, pref) do\n    \n  end\nend",
        "erlang_template": "-spec prefix_count(Words :: [unicode:unicode_binary()], Pref :: unicode:unicode_binary()) -> integer().\nprefix_count(Words, Pref) ->\n  .",
        "scala_template": "object Solution {\n    def prefixCount(words: Array[String], pref: String): Int = {\n        \n    }\n}"
    },
    {
        "id": 2291,
        "name": "maximum-and-sum-of-array",
        "difficulty": "Hard",
        "link": "https://leetcode.com/problems/maximum-and-sum-of-array/",
        "task_description": "You are given an integer array `nums` of length `n` and an integer `numSlots` such that `2 * numSlots >= n`. There are `numSlots` slots numbered from `1` to `numSlots`. You have to place all `n` integers into the slots such that each slot contains at **most** two numbers. The **AND sum** of a given placement is the sum of the **bitwise** `AND` of every number with its respective slot number. For example, the **AND sum** of placing the numbers `[1, 3]` into slot `1` and `[4, 6]` into slot `2` is equal to `(1 AND 1) + (3 AND 1) + (4 AND 2) + (6 AND 2) = 1 + 1 + 0 + 2 = 4`. Return _the maximum possible **AND sum** of _`nums`_ given _`numSlots`_ slots._ **Example 1:** ``` **Input:** nums = [1,2,3,4,5,6], numSlots = 3 **Output:** 9 **Explanation:** One possible placement is [1, 4] into slot 1, [2, 6] into slot 2, and [3, 5] into slot 3. This gives the maximum AND sum of (1 AND 1) + (4 AND 1) + (2 AND 2) + (6 AND 2) + (3 AND 3) + (5 AND 3) = 1 + 0 + 2 + 2 + 3 + 1 = 9. ``` **Example 2:** ``` **Input:** nums = [1,3,10,4,7,1], numSlots = 9 **Output:** 24 **Explanation:** One possible placement is [1, 1] into slot 1, [3] into slot 3, [4] into slot 4, [7] into slot 7, and [10] into slot 9. This gives the maximum AND sum of (1 AND 1) + (1 AND 1) + (3 AND 3) + (4 AND 4) + (7 AND 7) + (10 AND 9) = 1 + 1 + 3 + 4 + 7 + 8 = 24. Note that slots 2, 5, 6, and 8 are empty which is permitted. ``` **Constraints:** `n == nums.length` `1 <= numSlots <= 9` `1 <= n <= 2 * numSlots` `1 <= nums[i] <= 15`",
        "test_case": [
            {
                "label": "Example 1",
                "input": "nums = [1,2,3,4,5,6], numSlots = 3",
                "output": "9 Explanation: One possible placement is [1, 4] into slot 1 , [2, 6] into slot 2 , and [3, 5] into slot 3 . \nThis gives the maximum AND sum of (1 AND 1 ) + (4 AND 1 ) + (2 AND 2 ) + (6 AND 2 ) + (3 AND 3 ) + (5 AND 3 ) = 1 + 0 + 2 + 2 + 3 + 1 = 9."
            },
            {
                "label": "Example 2",
                "input": "nums = [1,3,10,4,7,1], numSlots = 9",
                "output": "24 Explanation: One possible placement is [1, 1] into slot 1 , [3] into slot 3 , [4] into slot 4 , [7] into slot 7 , and [10] into slot 9 .\nThis gives the maximum AND sum of (1 AND 1 ) + (1 AND 1 ) + (3 AND 3 ) + (4 AND 4 ) + (7 AND 7 ) + (10 AND 9 ) = 1 + 1 + 3 + 4 + 7 + 8 = 24.\nNote that slots 2, 5, 6, and 8 are empty which is permitted. Constraints: n == nums.length 1 <= numSlots <= 9 1 <= n <= 2 * numSlots 1 <= nums[i] <= 15"
            }
        ],
        "elixir_template": "defmodule Solution do\n  @spec maximum_and_sum(nums :: [integer], num_slots :: integer) :: integer\n  def maximum_and_sum(nums, num_slots) do\n    \n  end\nend",
        "erlang_template": "-spec maximum_and_sum(Nums :: [integer()], NumSlots :: integer()) -> integer().\nmaximum_and_sum(Nums, NumSlots) ->\n  .",
        "scala_template": "object Solution {\n    def maximumANDSum(nums: Array[Int], numSlots: Int): Int = {\n        \n    }\n}"
    },
    {
        "id": 2290,
        "name": "removing-minimum-number-of-magic-beans",
        "difficulty": "Medium",
        "link": "https://leetcode.com/problems/removing-minimum-number-of-magic-beans/",
        "task_description": "You are given an array of **positive** integers `beans`, where each integer represents the number of magic beans found in a particular magic bag. **Remove** any number of beans (**possibly none**) from each bag such that the number of beans in each remaining **non-empty** bag (still containing **at least one** bean) is **equal**. Once a bean has been removed from a bag, you are **not** allowed to return it to any of the bags. Return _the **minimum** number of magic beans that you have to remove_. **Example 1:** ``` **Input:** beans = [4,1,6,5] **Output:** 4 **Explanation:** - We remove 1 bean from the bag with only 1 bean. This results in the remaining bags: [4,**0**,6,5] - Then we remove 2 beans from the bag with 6 beans. This results in the remaining bags: [4,0,**4**,5] - Then we remove 1 bean from the bag with 5 beans. This results in the remaining bags: [4,0,4,**4**] We removed a total of 1 + 2 + 1 = 4 beans to make the remaining non-empty bags have an equal number of beans. There are no other solutions that remove 4 beans or fewer. ``` **Example 2:** ``` **Input:** beans = [2,10,3,2] **Output:** 7 **Explanation:** - We remove 2 beans from one of the bags with 2 beans. This results in the remaining bags: [**0**,10,3,2] - Then we remove 2 beans from the other bag with 2 beans. This results in the remaining bags: [0,10,3,**0**] - Then we remove 3 beans from the bag with 3 beans. This results in the remaining bags: [0,10,**0**,0] We removed a total of 2 + 2 + 3 = 7 beans to make the remaining non-empty bags have an equal number of beans. There are no other solutions that removes 7 beans or fewer. ``` **Constraints:** `1 <= beans.length <= 105` `1 <= beans[i] <= 105`",
        "test_case": [
            {
                "label": "Example 1",
                "input": "beans = [4,1,6,5]",
                "output": "4 Explanation: - We remove 1 bean from the bag with only 1 bean.\n  This results in the remaining bags: [4, 0 ,6,5]\n- Then we remove 2 beans from the bag with 6 beans.\n  This results in the remaining bags: [4,0, 4 ,5]\n- Then we remove 1 bean from the bag with 5 beans.\n  This results in the remaining bags: [4,0,4, 4 ]\nWe removed a total of 1 + 2 + 1 = 4 beans to make the remaining non-empty bags have an equal number of beans.\nThere are no other solutions that remove 4 beans or fewer."
            },
            {
                "label": "Example 2",
                "input": "beans = [2,10,3,2]",
                "output": "7 Explanation: - We remove 2 beans from one of the bags with 2 beans.\n  This results in the remaining bags: [ 0 ,10,3,2]\n- Then we remove 2 beans from the other bag with 2 beans.\n  This results in the remaining bags: [0,10,3, 0 ]\n- Then we remove 3 beans from the bag with 3 beans. \n  This results in the remaining bags: [0,10, 0 ,0]\nWe removed a total of 2 + 2 + 3 = 7 beans to make the remaining non-empty bags have an equal number of beans.\nThere are no other solutions that removes 7 beans or fewer."
            }
        ],
        "elixir_template": "defmodule Solution do\n  @spec minimum_removal(beans :: [integer]) :: integer\n  def minimum_removal(beans) do\n    \n  end\nend",
        "erlang_template": "-spec minimum_removal(Beans :: [integer()]) -> integer().\nminimum_removal(Beans) ->\n  .",
        "scala_template": "object Solution {\n    def minimumRemoval(beans: Array[Int]): Long = {\n        \n    }\n}"
    },
    {
        "id": 2289,
        "name": "minimum-operations-to-make-the-array-alternating",
        "difficulty": "Medium",
        "link": "https://leetcode.com/problems/minimum-operations-to-make-the-array-alternating/",
        "task_description": "You are given a **0-indexed** array `nums` consisting of `n` positive integers. The array `nums` is called **alternating** if: `nums[i - 2] == nums[i]`, where `2 <= i <= n - 1`. `nums[i - 1] != nums[i]`, where `1 <= i <= n - 1`. In one **operation**, you can choose an index `i` and **change** `nums[i]` into **any** positive integer. Return _the **minimum number of operations** required to make the array alternating_. **Example 1:** ``` **Input:** nums = [3,1,3,2,4,3] **Output:** 3 **Explanation:** One way to make the array alternating is by converting it to [3,1,3,**1**,**3**,**1**]. The number of operations required in this case is 3. It can be proven that it is not possible to make the array alternating in less than 3 operations. ``` **Example 2:** ``` **Input:** nums = [1,2,2,2,2] **Output:** 2 **Explanation:** One way to make the array alternating is by converting it to [1,2,**1**,2,**1**]. The number of operations required in this case is 2. Note that the array cannot be converted to [**2**,2,2,2,2] because in this case nums[0] == nums[1] which violates the conditions of an alternating array. ``` **Constraints:** `1 <= nums.length <= 105` `1 <= nums[i] <= 105`",
        "test_case": [
            {
                "label": "Example 1",
                "input": "nums = [3,1,3,2,4,3]",
                "output": "3 Explanation: One way to make the array alternating is by converting it to [3,1,3, 1 , 3 , 1 ].\nThe number of operations required in this case is 3.\nIt can be proven that it is not possible to make the array alternating in less than 3 operations."
            },
            {
                "label": "Example 2",
                "input": "nums = [1,2,2,2,2]",
                "output": "2 Explanation: One way to make the array alternating is by converting it to [1,2, 1 ,2, 1 ].\nThe number of operations required in this case is 2.\nNote that the array cannot be converted to [ 2 ,2,2,2,2] because in this case nums[0] == nums[1] which violates the conditions of an alternating array."
            }
        ],
        "elixir_template": "defmodule Solution do\n  @spec minimum_operations(nums :: [integer]) :: integer\n  def minimum_operations(nums) do\n    \n  end\nend",
        "erlang_template": "-spec minimum_operations(Nums :: [integer()]) -> integer().\nminimum_operations(Nums) ->\n  .",
        "scala_template": "object Solution {\n    def minimumOperations(nums: Array[Int]): Int = {\n        \n    }\n}"
    },
    {
        "id": 2288,
        "name": "count-operations-to-obtain-zero",
        "difficulty": "Easy",
        "link": "https://leetcode.com/problems/count-operations-to-obtain-zero/",
        "task_description": "You are given two **non-negative** integers `num1` and `num2`. In one **operation**, if `num1 >= num2`, you must subtract `num2` from `num1`, otherwise subtract `num1` from `num2`. For example, if `num1 = 5` and `num2 = 4`, subtract `num2` from `num1`, thus obtaining `num1 = 1` and `num2 = 4`. However, if `num1 = 4` and `num2 = 5`, after one operation, `num1 = 4` and `num2 = 1`. Return _the **number of operations** required to make either_ `num1 = 0` _or_ `num2 = 0`. **Example 1:** ``` **Input:** num1 = 2, num2 = 3 **Output:** 3 **Explanation:** - Operation 1: num1 = 2, num2 = 3. Since num1 < num2, we subtract num1 from num2 and get num1 = 2, num2 = 3 - 2 = 1. - Operation 2: num1 = 2, num2 = 1. Since num1 > num2, we subtract num2 from num1. - Operation 3: num1 = 1, num2 = 1. Since num1 == num2, we subtract num2 from num1. Now num1 = 0 and num2 = 1. Since num1 == 0, we do not need to perform any further operations. So the total number of operations required is 3. ``` **Example 2:** ``` **Input:** num1 = 10, num2 = 10 **Output:** 1 **Explanation:** - Operation 1: num1 = 10, num2 = 10. Since num1 == num2, we subtract num2 from num1 and get num1 = 10 - 10 = 0. Now num1 = 0 and num2 = 10. Since num1 == 0, we are done. So the total number of operations required is 1. ``` **Constraints:** `0 <= num1, num2 <= 105`",
        "test_case": [
            {
                "label": "Example 1",
                "input": "num1 = 2, num2 = 3",
                "output": "3 Explanation: - Operation 1: num1 = 2, num2 = 3. Since num1 < num2, we subtract num1 from num2 and get num1 = 2, num2 = 3 - 2 = 1.\n- Operation 2: num1 = 2, num2 = 1. Since num1 > num2, we subtract num2 from num1.\n- Operation 3: num1 = 1, num2 = 1. Since num1 == num2, we subtract num2 from num1.\nNow num1 = 0 and num2 = 1. Since num1 == 0, we do not need to perform any further operations.\nSo the total number of operations required is 3."
            },
            {
                "label": "Example 2",
                "input": "num1 = 10, num2 = 10",
                "output": "1 Explanation: - Operation 1: num1 = 10, num2 = 10. Since num1 == num2, we subtract num2 from num1 and get num1 = 10 - 10 = 0.\nNow num1 = 0 and num2 = 10. Since num1 == 0, we are done.\nSo the total number of operations required is 1."
            }
        ],
        "elixir_template": "defmodule Solution do\n  @spec count_operations(num1 :: integer, num2 :: integer) :: integer\n  def count_operations(num1, num2) do\n    \n  end\nend",
        "erlang_template": "-spec count_operations(Num1 :: integer(), Num2 :: integer()) -> integer().\ncount_operations(Num1, Num2) ->\n  .",
        "scala_template": "object Solution {\n    def countOperations(num1: Int, num2: Int): Int = {\n        \n    }\n}"
    },
    {
        "id": 2286,
        "name": "minimum-time-to-remove-all-cars-containing-illegal-goods",
        "difficulty": "Hard",
        "link": "https://leetcode.com/problems/minimum-time-to-remove-all-cars-containing-illegal-goods/",
        "task_description": "You are given a **0-indexed** binary string `s` which represents a sequence of train cars. `s[i] = '0'` denotes that the `ith` car does **not** contain illegal goods and `s[i] = '1'` denotes that the `ith` car does contain illegal goods. As the train conductor, you would like to get rid of all the cars containing illegal goods. You can do any of the following three operations **any** number of times: Remove a train car from the **left** end (i.e., remove `s[0]`) which takes 1 unit of time. Remove a train car from the **right** end (i.e., remove `s[s.length - 1]`) which takes 1 unit of time. Remove a train car from **anywhere** in the sequence which takes 2 units of time. Return _the **minimum** time to remove all the cars containing illegal goods_. Note that an empty sequence of cars is considered to have no cars containing illegal goods. **Example 1:** ``` **Input:** s = \"**11**00**1**0**1**\" **Output:** 5 **Explanation:** One way to remove all the cars containing illegal goods from the sequence is to - remove a car from the left end 2 times. Time taken is 2 * 1 = 2. - remove a car from the right end. Time taken is 1. - remove the car containing illegal goods found in the middle. Time taken is 2. This obtains a total time of 2 + 1 + 2 = 5. An alternative way is to - remove a car from the left end 2 times. Time taken is 2 * 1 = 2. - remove a car from the right end 3 times. Time taken is 3 * 1 = 3. This also obtains a total time of 2 + 3 = 5. 5 is the minimum time taken to remove all the cars containing illegal goods. There are no other ways to remove them with less time. ``` **Example 2:** ``` **Input:** s = \"00**1**0\" **Output:** 2 **Explanation:** One way to remove all the cars containing illegal goods from the sequence is to - remove a car from the left end 3 times. Time taken is 3 * 1 = 3. This obtains a total time of 3. Another way to remove all the cars containing illegal goods from the sequence is to - remove the car containing illegal goods found in the middle. Time taken is 2. This obtains a total time of 2. Another way to remove all the cars containing illegal goods from the sequence is to - remove a car from the right end 2 times. Time taken is 2 * 1 = 2. This obtains a total time of 2. 2 is the minimum time taken to remove all the cars containing illegal goods. There are no other ways to remove them with less time. ``` **Constraints:** `1 <= s.length <= 2 * 105` `s[i]` is either `'0'` or `'1'`.",
        "test_case": [
            {
                "label": "Example 1",
                "input": "s = \" 11 00 1 0 1 \"",
                "output": "5 Explanation: One way to remove all the cars containing illegal goods from the sequence is to\n- remove a car from the left end 2 times. Time taken is 2 * 1 = 2.\n- remove a car from the right end. Time taken is 1.\n- remove the car containing illegal goods found in the middle. Time taken is 2.\nThis obtains a total time of 2 + 1 + 2 = 5. \n\nAn alternative way is to\n- remove a car from the left end 2 times. Time taken is 2 * 1 = 2.\n- remove a car from the right end 3 times. Time taken is 3 * 1 = 3.\nThis also obtains a total time of 2 + 3 = 5.\n\n5 is the minimum time taken to remove all the cars containing illegal goods. \nThere are no other ways to remove them with less time."
            },
            {
                "label": "Example 2",
                "input": "s = \"00 1 0\"",
                "output": "2 Explanation: One way to remove all the cars containing illegal goods from the sequence is to\n- remove a car from the left end 3 times. Time taken is 3 * 1 = 3.\nThis obtains a total time of 3.\n\nAnother way to remove all the cars containing illegal goods from the sequence is to\n- remove the car containing illegal goods found in the middle. Time taken is 2.\nThis obtains a total time of 2.\n\nAnother way to remove all the cars containing illegal goods from the sequence is to \n- remove a car from the right end 2 times. Time taken is 2 * 1 = 2. \nThis obtains a total time of 2.\n\n2 is the minimum time taken to remove all the cars containing illegal goods. \nThere are no other ways to remove them with less time."
            }
        ],
        "elixir_template": "defmodule Solution do\n  @spec minimum_time(s :: String.t) :: integer\n  def minimum_time(s) do\n    \n  end\nend",
        "erlang_template": "-spec minimum_time(S :: unicode:unicode_binary()) -> integer().\nminimum_time(S) ->\n  .",
        "scala_template": "object Solution {\n    def minimumTime(s: String): Int = {\n        \n    }\n}"
    },
    {
        "id": 2285,
        "name": "design-bitset",
        "difficulty": "Medium",
        "link": "https://leetcode.com/problems/design-bitset/",
        "task_description": "A **Bitset** is a data structure that compactly stores bits. Implement the `Bitset` class: `Bitset(int size)` Initializes the Bitset with `size` bits, all of which are `0`. `void fix(int idx)` Updates the value of the bit at the index `idx` to `1`. If the value was already `1`, no change occurs. `void unfix(int idx)` Updates the value of the bit at the index `idx` to `0`. If the value was already `0`, no change occurs. `void flip()` Flips the values of each bit in the Bitset. In other words, all bits with value `0` will now have value `1` and vice versa. `boolean all()` Checks if the value of **each** bit in the Bitset is `1`. Returns `true` if it satisfies the condition, `false` otherwise. `boolean one()` Checks if there is **at least one** bit in the Bitset with value `1`. Returns `true` if it satisfies the condition, `false` otherwise. `int count()` Returns the **total number** of bits in the Bitset which have value `1`. `String toString()` Returns the current composition of the Bitset. Note that in the resultant string, the character at the `ith` index should coincide with the value at the `ith` bit of the Bitset. **Example 1:** ``` **Input** [\"Bitset\", \"fix\", \"fix\", \"flip\", \"all\", \"unfix\", \"flip\", \"one\", \"unfix\", \"count\", \"toString\"] [[5], [3], [1], [], [], [0], [], [], [0], [], []] **Output** [null, null, null, null, false, null, null, true, null, 2, \"01010\"] **Explanation** Bitset bs = new Bitset(5); // bitset = \"00000\". bs.fix(3); // the value at idx = 3 is updated to 1, so bitset = \"00010\". bs.fix(1); // the value at idx = 1 is updated to 1, so bitset = \"01010\". bs.flip(); // the value of each bit is flipped, so bitset = \"10101\". bs.all(); // return False, as not all values of the bitset are 1. bs.unfix(0); // the value at idx = 0 is updated to 0, so bitset = \"00101\". bs.flip(); // the value of each bit is flipped, so bitset = \"11010\". bs.one(); // return True, as there is at least 1 index with value 1. bs.unfix(0); // the value at idx = 0 is updated to 0, so bitset = \"01010\". bs.count(); // return 2, as there are 2 bits with value 1. bs.toString(); // return \"01010\", which is the composition of bitset. ``` **Constraints:** `1 <= size <= 105` `0 <= idx <= size - 1` At most `105` calls will be made **in total** to `fix`, `unfix`, `flip`, `all`, `one`, `count`, and `toString`. At least one call will be made to `all`, `one`, `count`, or `toString`. At most `5` calls will be made to `toString`.",
        "test_case": [],
        "elixir_template": "defmodule Bitset do\n  @spec init_(size :: integer) :: any\n  def init_(size) do\n    \n  end\n\n  @spec fix(idx :: integer) :: any\n  def fix(idx) do\n    \n  end\n\n  @spec unfix(idx :: integer) :: any\n  def unfix(idx) do\n    \n  end\n\n  @spec flip() :: any\n  def flip() do\n    \n  end\n\n  @spec all() :: boolean\n  def all() do\n    \n  end\n\n  @spec one() :: boolean\n  def one() do\n    \n  end\n\n  @spec count() :: integer\n  def count() do\n    \n  end\n\n  @spec to_string() :: String.t\n  def to_string() do\n    \n  end\nend\n\n# Your functions will be called as such:\n# Bitset.init_(size)\n# Bitset.fix(idx)\n# Bitset.unfix(idx)\n# Bitset.flip()\n# param_4 = Bitset.all()\n# param_5 = Bitset.one()\n# param_6 = Bitset.count()\n# param_7 = Bitset.to_string()\n\n# Bitset.init_ will be called before every test case, in which you can do some necessary initializations.",
        "erlang_template": "-spec bitset_init_(Size :: integer()) -> any().\nbitset_init_(Size) ->\n  .\n\n-spec bitset_fix(Idx :: integer()) -> any().\nbitset_fix(Idx) ->\n  .\n\n-spec bitset_unfix(Idx :: integer()) -> any().\nbitset_unfix(Idx) ->\n  .\n\n-spec bitset_flip() -> any().\nbitset_flip() ->\n  .\n\n-spec bitset_all() -> boolean().\nbitset_all() ->\n  .\n\n-spec bitset_one() -> boolean().\nbitset_one() ->\n  .\n\n-spec bitset_count() -> integer().\nbitset_count() ->\n  .\n\n-spec bitset_to_string() -> unicode:unicode_binary().\nbitset_to_string() ->\n  .\n\n\n%% Your functions will be called as such:\n%% bitset_init_(Size),\n%% bitset_fix(Idx),\n%% bitset_unfix(Idx),\n%% bitset_flip(),\n%% Param_4 = bitset_all(),\n%% Param_5 = bitset_one(),\n%% Param_6 = bitset_count(),\n%% Param_7 = bitset_to_string(),\n\n%% bitset_init_ will be called before every test case, in which you can do some necessary initializations.",
        "scala_template": "class Bitset(_size: Int) {\n\n    def fix(idx: Int): Unit = {\n        \n    }\n\n    def unfix(idx: Int): Unit = {\n        \n    }\n\n    def flip(): Unit = {\n        \n    }\n\n    def all(): Boolean = {\n        \n    }\n\n    def one(): Boolean = {\n        \n    }\n\n    def count(): Int = {\n        \n    }\n\n    def toString(): String = {\n        \n    }\n\n}\n\n/**\n * Your Bitset object will be instantiated and called as such:\n * val obj = new Bitset(size)\n * obj.fix(idx)\n * obj.unfix(idx)\n * obj.flip()\n * val param_4 = obj.all()\n * val param_5 = obj.one()\n * val param_6 = obj.count()\n * val param_7 = obj.toString()\n */"
    },
    {
        "id": 2284,
        "name": "smallest-value-of-the-rearranged-number",
        "difficulty": "Medium",
        "link": "https://leetcode.com/problems/smallest-value-of-the-rearranged-number/",
        "task_description": "You are given an integer `num.` **Rearrange** the digits of `num` such that its value is **minimized** and it does not contain **any** leading zeros. Return _the rearranged number with minimal value_. Note that the sign of the number does not change after rearranging the digits. **Example 1:** ``` **Input:** num = 310 **Output:** 103 **Explanation:** The possible arrangements for the digits of 310 are 013, 031, 103, 130, 301, 310. The arrangement with the smallest value that does not contain any leading zeros is 103. ``` **Example 2:** ``` **Input:** num = -7605 **Output:** -7650 **Explanation:** Some possible arrangements for the digits of -7605 are -7650, -6705, -5076, -0567. The arrangement with the smallest value that does not contain any leading zeros is -7650. ``` **Constraints:** `-1015 <= num <= 1015`",
        "test_case": [
            {
                "label": "Example 1",
                "input": "num = 310",
                "output": "103 Explanation: The possible arrangements for the digits of 310 are 013, 031, 103, 130, 301, 310. \nThe arrangement with the smallest value that does not contain any leading zeros is 103."
            },
            {
                "label": "Example 2",
                "input": "num = -7605",
                "output": "-7650 Explanation: Some possible arrangements for the digits of -7605 are -7650, -6705, -5076, -0567.\nThe arrangement with the smallest value that does not contain any leading zeros is -7650. Constraints: -10 15 <= num <= 10 15"
            }
        ],
        "elixir_template": "defmodule Solution do\n  @spec smallest_number(num :: integer) :: integer\n  def smallest_number(num) do\n    \n  end\nend",
        "erlang_template": "-spec smallest_number(Num :: integer()) -> integer().\nsmallest_number(Num) ->\n  .",
        "scala_template": "object Solution {\n    def smallestNumber(num: Long): Long = {\n        \n    }\n}"
    },
    {
        "id": 2283,
        "name": "sort-even-and-odd-indices-independently",
        "difficulty": "Easy",
        "link": "https://leetcode.com/problems/sort-even-and-odd-indices-independently/",
        "task_description": "You are given a **0-indexed** integer array `nums`. Rearrange the values of `nums` according to the following rules: Sort the values at **odd indices** of `nums` in **non-increasing** order. For example, if `nums = [4,**1**,2,**3**]` before this step, it becomes `[4,**3**,2,**1**]` after. The values at odd indices `1` and `3` are sorted in non-increasing order. Sort the values at **even indices** of `nums` in **non-decreasing** order. For example, if `nums = [**4**,1,**2**,3]` before this step, it becomes `[**2**,1,**4**,3]` after. The values at even indices `0` and `2` are sorted in non-decreasing order. Return _the array formed after rearranging the values of_ `nums`. **Example 1:** ``` **Input:** nums = [4,1,2,3] **Output:** [2,3,4,1] **Explanation:** First, we sort the values present at odd indices (1 and 3) in non-increasing order. So, nums changes from [4,**1**,2,**3**] to [4,**3**,2,**1**]. Next, we sort the values present at even indices (0 and 2) in non-decreasing order. So, nums changes from [**4**,1,**2**,3] to [**2**,3,**4**,1]. Thus, the array formed after rearranging the values is [2,3,4,1]. ``` **Example 2:** ``` **Input:** nums = [2,1] **Output:** [2,1] **Explanation:** Since there is exactly one odd index and one even index, no rearrangement of values takes place. The resultant array formed is [2,1], which is the same as the initial array. ``` **Constraints:** `1 <= nums.length <= 100` `1 <= nums[i] <= 100`",
        "test_case": [
            {
                "label": "Example 1",
                "input": "nums = [4,1,2,3]",
                "output": "[2,3,4,1] Explanation: First, we sort the values present at odd indices (1 and 3) in non-increasing order.\nSo, nums changes from [4, 1 ,2, 3 ] to [4, 3 ,2, 1 ].\nNext, we sort the values present at even indices (0 and 2) in non-decreasing order.\nSo, nums changes from [ 4 ,1, 2 ,3] to [ 2 ,3, 4 ,1].\nThus, the array formed after rearranging the values is [2,3,4,1]."
            },
            {
                "label": "Example 2",
                "input": "nums = [2,1]",
                "output": "[2,1] Explanation: Since there is exactly one odd index and one even index, no rearrangement of values takes place.\nThe resultant array formed is [2,1], which is the same as the initial array."
            }
        ],
        "elixir_template": "defmodule Solution do\n  @spec sort_even_odd(nums :: [integer]) :: [integer]\n  def sort_even_odd(nums) do\n    \n  end\nend",
        "erlang_template": "-spec sort_even_odd(Nums :: [integer()]) -> [integer()].\nsort_even_odd(Nums) ->\n  .",
        "scala_template": "object Solution {\n    def sortEvenOdd(nums: Array[Int]): Array[Int] = {\n        \n    }\n}"
    },
    {
        "id": 2280,
        "name": "count-good-triplets-in-an-array",
        "difficulty": "Hard",
        "link": "https://leetcode.com/problems/count-good-triplets-in-an-array/",
        "task_description": "You are given two **0-indexed** arrays `nums1` and `nums2` of length `n`, both of which are **permutations** of `[0, 1, ..., n - 1]`. A **good triplet** is a set of `3` **distinct** values which are present in **increasing order** by position both in `nums1` and `nums2`. In other words, if we consider `pos1v` as the index of the value `v` in `nums1` and `pos2v` as the index of the value `v` in `nums2`, then a good triplet will be a set `(x, y, z)` where `0 <= x, y, z <= n - 1`, such that `pos1x < pos1y < pos1z` and `pos2x < pos2y < pos2z`. Return _the **total number** of good triplets_. **Example 1:** ``` **Input:** nums1 = [2,0,1,3], nums2 = [0,1,2,3] **Output:** 1 **Explanation:** There are 4 triplets (x,y,z) such that pos1x < pos1y < pos1z. They are (2,0,1), (2,0,3), (2,1,3), and (0,1,3). Out of those triplets, only the triplet (0,1,3) satisfies pos2x < pos2y < pos2z. Hence, there is only 1 good triplet. ``` **Example 2:** ``` **Input:** nums1 = [4,0,1,3,2], nums2 = [4,1,0,2,3] **Output:** 4 **Explanation:** The 4 good triplets are (4,0,3), (4,0,2), (4,1,3), and (4,1,2). ``` **Constraints:** `n == nums1.length == nums2.length` `3 <= n <= 105` `0 <= nums1[i], nums2[i] <= n - 1` `nums1` and `nums2` are permutations of `[0, 1, ..., n - 1]`.",
        "test_case": [
            {
                "label": "Example 1",
                "input": "nums1 = [2,0,1,3], nums2 = [0,1,2,3]",
                "output": "1 Explanation: There are 4 triplets (x,y,z) such that pos1 x < pos1 y < pos1 z . They are (2,0,1), (2,0,3), (2,1,3), and (0,1,3). \nOut of those triplets, only the triplet (0,1,3) satisfies pos2 x < pos2 y < pos2 z . Hence, there is only 1 good triplet."
            },
            {
                "label": "Example 2",
                "input": "nums1 = [4,0,1,3,2], nums2 = [4,1,0,2,3]",
                "output": "4 Explanation: The 4 good triplets are (4,0,3), (4,0,2), (4,1,3), and (4,1,2). Constraints: n == nums1.length == nums2.length 3 <= n <= 10 5 0 <= nums1[i], nums2[i] <= n - 1 nums1 and nums2 are permutations of [0, 1, ..., n - 1] ."
            }
        ],
        "elixir_template": "defmodule Solution do\n  @spec good_triplets(nums1 :: [integer], nums2 :: [integer]) :: integer\n  def good_triplets(nums1, nums2) do\n    \n  end\nend",
        "erlang_template": "-spec good_triplets(Nums1 :: [integer()], Nums2 :: [integer()]) -> integer().\ngood_triplets(Nums1, Nums2) ->\n  .",
        "scala_template": "object Solution {\n    def goodTriplets(nums1: Array[Int], nums2: Array[Int]): Long = {\n        \n    }\n}"
    },
    {
        "id": 2279,
        "name": "maximum-split-of-positive-even-integers",
        "difficulty": "Medium",
        "link": "https://leetcode.com/problems/maximum-split-of-positive-even-integers/",
        "task_description": "You are given an integer `finalSum`. Split it into a sum of a **maximum** number of **unique** positive even integers. For example, given `finalSum = 12`, the following splits are **valid** (unique positive even integers summing up to `finalSum`): `(12)`, `(2 + 10)`, `(2 + 4 + 6)`, and `(4 + 8)`. Among them, `(2 + 4 + 6)` contains the maximum number of integers. Note that `finalSum` cannot be split into `(2 + 2 + 4 + 4)` as all the numbers should be unique. Return _a list of integers that represent a valid split containing a **maximum** number of integers_. If no valid split exists for `finalSum`, return _an **empty** list_. You may return the integers in **any** order. **Example 1:** ``` **Input:** finalSum = 12 **Output:** [2,4,6] **Explanation:** The following are valid splits: `(12)`, `(2 + 10)`, `(2 + 4 + 6)`, and `(4 + 8)`. (2 + 4 + 6) has the maximum number of integers, which is 3. Thus, we return [2,4,6]. Note that [2,6,4], [6,2,4], etc. are also accepted. ``` **Example 2:** ``` **Input:** finalSum = 7 **Output:** [] **Explanation:** There are no valid splits for the given finalSum. Thus, we return an empty array. ``` **Example 3:** ``` **Input:** finalSum = 28 **Output:** [6,8,2,12] **Explanation:** The following are valid splits: `(2 + 26)`, `(6 + 8 + 2 + 12)`, and `(4 + 24)`. `(6 + 8 + 2 + 12)` has the maximum number of integers, which is 4. Thus, we return [6,8,2,12]. Note that [10,2,4,12], [6,2,4,16], etc. are also accepted. ``` **Constraints:** `1 <= finalSum <= 1010`",
        "test_case": [
            {
                "label": "Example 1",
                "input": "finalSum = 12",
                "output": "[2,4,6] Explanation: The following are valid splits: (12) , (2 + 10) , (2 + 4 + 6) , and (4 + 8) .\n(2 + 4 + 6) has the maximum number of integers, which is 3. Thus, we return [2,4,6].\nNote that [2,6,4], [6,2,4], etc. are also accepted."
            },
            {
                "label": "Example 2",
                "input": "finalSum = 7",
                "output": "[] Explanation: There are no valid splits for the given finalSum.\nThus, we return an empty array."
            },
            {
                "label": "Example 3",
                "input": "finalSum = 28",
                "output": "[6,8,2,12] Explanation: The following are valid splits: (2 + 26) , (6 + 8 + 2 + 12) , and (4 + 24) . (6 + 8 + 2 + 12) has the maximum number of integers, which is 4. Thus, we return [6,8,2,12].\nNote that [10,2,4,12], [6,2,4,16], etc. are also accepted."
            }
        ],
        "elixir_template": "defmodule Solution do\n  @spec maximum_even_split(final_sum :: integer) :: [integer]\n  def maximum_even_split(final_sum) do\n    \n  end\nend",
        "erlang_template": "-spec maximum_even_split(FinalSum :: integer()) -> [integer()].\nmaximum_even_split(FinalSum) ->\n  .",
        "scala_template": "object Solution {\n    def maximumEvenSplit(finalSum: Long): List[Long] = {\n        \n    }\n}"
    },
    {
        "id": 2278,
        "name": "find-three-consecutive-integers-that-sum-to-a-given-number",
        "difficulty": "Medium",
        "link": "https://leetcode.com/problems/find-three-consecutive-integers-that-sum-to-a-given-number/",
        "task_description": "Given an integer `num`, return _three consecutive integers (as a sorted array)__ that **sum** to _`num`. If `num` cannot be expressed as the sum of three consecutive integers, return_ an **empty** array._ **Example 1:** ``` **Input:** num = 33 **Output:** [10,11,12] **Explanation:** 33 can be expressed as 10 + 11 + 12 = 33. 10, 11, 12 are 3 consecutive integers, so we return [10, 11, 12]. ``` **Example 2:** ``` **Input:** num = 4 **Output:** [] **Explanation:** There is no way to express 4 as the sum of 3 consecutive integers. ``` **Constraints:** `0 <= num <= 1015`",
        "test_case": [
            {
                "label": "Example 1",
                "input": "num = 33",
                "output": "[10,11,12] Explanation: 33 can be expressed as 10 + 11 + 12 = 33.\n10, 11, 12 are 3 consecutive integers, so we return [10, 11, 12]."
            },
            {
                "label": "Example 2",
                "input": "num = 4",
                "output": "[] Explanation: There is no way to express 4 as the sum of 3 consecutive integers."
            }
        ],
        "elixir_template": "defmodule Solution do\n  @spec sum_of_three(num :: integer) :: [integer]\n  def sum_of_three(num) do\n    \n  end\nend",
        "erlang_template": "-spec sum_of_three(Num :: integer()) -> [integer()].\nsum_of_three(Num) ->\n  .",
        "scala_template": "object Solution {\n    def sumOfThree(num: Long): Array[Long] = {\n        \n    }\n}"
    },
    {
        "id": 2277,
        "name": "count-equal-and-divisible-pairs-in-an-array",
        "difficulty": "Easy",
        "link": "https://leetcode.com/problems/count-equal-and-divisible-pairs-in-an-array/",
        "task_description": "Given a **0-indexed** integer array `nums` of length `n` and an integer `k`, return _the **number of pairs**_ `(i, j)` _where_ `0 <= i < j < n`, _such that_ `nums[i] == nums[j]` _and_ `(i * j)` _is divisible by_ `k`. **Example 1:** ``` **Input:** nums = [3,1,2,2,2,1,3], k = 2 **Output:** 4 **Explanation:** There are 4 pairs that meet all the requirements: - nums[0] == nums[6], and 0 * 6 == 0, which is divisible by 2. - nums[2] == nums[3], and 2 * 3 == 6, which is divisible by 2. - nums[2] == nums[4], and 2 * 4 == 8, which is divisible by 2. - nums[3] == nums[4], and 3 * 4 == 12, which is divisible by 2. ``` **Example 2:** ``` **Input:** nums = [1,2,3,4], k = 1 **Output:** 0 **Explanation:** Since no value in nums is repeated, there are no pairs (i,j) that meet all the requirements. ``` **Constraints:** `1 <= nums.length <= 100` `1 <= nums[i], k <= 100`",
        "test_case": [
            {
                "label": "Example 1",
                "input": "nums = [3,1,2,2,2,1,3], k = 2",
                "output": "4 Explanation: There are 4 pairs that meet all the requirements:\n- nums[0] == nums[6], and 0 * 6 == 0, which is divisible by 2.\n- nums[2] == nums[3], and 2 * 3 == 6, which is divisible by 2.\n- nums[2] == nums[4], and 2 * 4 == 8, which is divisible by 2.\n- nums[3] == nums[4], and 3 * 4 == 12, which is divisible by 2."
            },
            {
                "label": "Example 2",
                "input": "nums = [1,2,3,4], k = 1",
                "output": "0 Explanation: Since no value in nums is repeated, there are no pairs (i,j) that meet all the requirements."
            }
        ],
        "elixir_template": "defmodule Solution do\n  @spec count_pairs(nums :: [integer], k :: integer) :: integer\n  def count_pairs(nums, k) do\n    \n  end\nend",
        "erlang_template": "-spec count_pairs(Nums :: [integer()], K :: integer()) -> integer().\ncount_pairs(Nums, K) ->\n  .",
        "scala_template": "object Solution {\n    def countPairs(nums: Array[Int], k: Int): Int = {\n        \n    }\n}"
    },
    {
        "id": 2276,
        "name": "groups-of-strings",
        "difficulty": "Hard",
        "link": "https://leetcode.com/problems/groups-of-strings/",
        "task_description": "You are given a **0-indexed** array of strings `words`. Each string consists of **lowercase English letters** only. No letter occurs more than once in any string of `words`. Two strings `s1` and `s2` are said to be **connected** if the set of letters of `s2` can be obtained from the set of letters of `s1` by any **one** of the following operations: Adding exactly one letter to the set of the letters of `s1`. Deleting exactly one letter from the set of the letters of `s1`. Replacing exactly one letter from the set of the letters of `s1` with any letter, **including** itself. The array `words` can be divided into one or more non-intersecting **groups**. A string belongs to a group if any **one** of the following is true: It is connected to **at least one** other string of the group. It is the **only** string present in the group. Note that the strings in `words` should be grouped in such a manner that a string belonging to a group cannot be connected to a string present in any other group. It can be proved that such an arrangement is always unique. Return _an array_ `ans` _of size_ `2` _where:_ `ans[0]` _is the **maximum number** of groups_ `words` _can be divided into, and_ `ans[1]` _is the **size of the largest** group_. **Example 1:** ``` **Input:** words = [\"a\",\"b\",\"ab\",\"cde\"] **Output:** [2,3] **Explanation:** - words[0] can be used to obtain words[1] (by replacing 'a' with 'b'), and words[2] (by adding 'b'). So words[0] is connected to words[1] and words[2]. - words[1] can be used to obtain words[0] (by replacing 'b' with 'a'), and words[2] (by adding 'a'). So words[1] is connected to words[0] and words[2]. - words[2] can be used to obtain words[0] (by deleting 'b'), and words[1] (by deleting 'a'). So words[2] is connected to words[0] and words[1]. - words[3] is not connected to any string in words. Thus, words can be divided into 2 groups [\"a\",\"b\",\"ab\"] and [\"cde\"]. The size of the largest group is 3. ``` **Example 2:** ``` **Input:** words = [\"a\",\"ab\",\"abc\"] **Output:** [1,3] **Explanation:** - words[0] is connected to words[1]. - words[1] is connected to words[0] and words[2]. - words[2] is connected to words[1]. Since all strings are connected to each other, they should be grouped together. Thus, the size of the largest group is 3. ``` **Constraints:** `1 <= words.length <= 2 * 104` `1 <= words[i].length <= 26` `words[i]` consists of lowercase English letters only. No letter occurs more than once in `words[i]`.",
        "test_case": [
            {
                "label": "Example 1",
                "input": "words = [\"a\",\"b\",\"ab\",\"cde\"]",
                "output": "[2,3] Explanation: - words[0] can be used to obtain words[1] (by replacing 'a' with 'b'), and words[2] (by adding 'b'). So words[0] is connected to words[1] and words[2].\n- words[1] can be used to obtain words[0] (by replacing 'b' with 'a'), and words[2] (by adding 'a'). So words[1] is connected to words[0] and words[2].\n- words[2] can be used to obtain words[0] (by deleting 'b'), and words[1] (by deleting 'a'). So words[2] is connected to words[0] and words[1].\n- words[3] is not connected to any string in words.\nThus, words can be divided into 2 groups [\"a\",\"b\",\"ab\"] and [\"cde\"]. The size of the largest group is 3."
            },
            {
                "label": "Example 2",
                "input": "words = [\"a\",\"ab\",\"abc\"]",
                "output": "[1,3] Explanation: - words[0] is connected to words[1].\n- words[1] is connected to words[0] and words[2].\n- words[2] is connected to words[1].\nSince all strings are connected to each other, they should be grouped together.\nThus, the size of the largest group is 3."
            }
        ],
        "elixir_template": "defmodule Solution do\n  @spec group_strings(words :: [String.t]) :: [integer]\n  def group_strings(words) do\n    \n  end\nend",
        "erlang_template": "-spec group_strings(Words :: [unicode:unicode_binary()]) -> [integer()].\ngroup_strings(Words) ->\n  .",
        "scala_template": "object Solution {\n    def groupStrings(words: Array[String]): Array[Int] = {\n        \n    }\n}"
    },
    {
        "id": 2275,
        "name": "find-substring-with-given-hash-value",
        "difficulty": "Hard",
        "link": "https://leetcode.com/problems/find-substring-with-given-hash-value/",
        "task_description": "The hash of a **0-indexed** string `s` of length `k`, given integers `p` and `m`, is computed using the following function: `hash(s, p, m) = (val(s[0]) * p0 + val(s[1]) * p1 + ... + val(s[k-1]) * pk-1) mod m`. Where `val(s[i])` represents the index of `s[i]` in the alphabet from `val('a') = 1` to `val('z') = 26`. You are given a string `s` and the integers `power`, `modulo`, `k`, and `hashValue.` Return `sub`,_ the **first** **substring** of _`s`_ of length _`k`_ such that _`hash(sub, power, modulo) == hashValue`. The test cases will be generated such that an answer always **exists**. A substring is a contiguous non-empty sequence of characters within a string. **Example 1:** ``` **Input:** s = \"leetcode\", power = 7, modulo = 20, k = 2, hashValue = 0 **Output:** \"ee\" **Explanation:** The hash of \"ee\" can be computed to be hash(\"ee\", 7, 20) = (5 * 1 + 5 * 7) mod 20 = 40 mod 20 = 0. \"ee\" is the first substring of length 2 with hashValue 0. Hence, we return \"ee\". ``` **Example 2:** ``` **Input:** s = \"fbxzaad\", power = 31, modulo = 100, k = 3, hashValue = 32 **Output:** \"fbx\" **Explanation:** The hash of \"fbx\" can be computed to be hash(\"fbx\", 31, 100) = (6 * 1 + 2 * 31 + 24 * 312) mod 100 = 23132 mod 100 = 32. The hash of \"bxz\" can be computed to be hash(\"bxz\", 31, 100) = (2 * 1 + 24 * 31 + 26 * 312) mod 100 = 25732 mod 100 = 32. \"fbx\" is the first substring of length 3 with hashValue 32. Hence, we return \"fbx\". Note that \"bxz\" also has a hash of 32 but it appears later than \"fbx\". ``` **Constraints:** `1 <= k <= s.length <= 2 * 104` `1 <= power, modulo <= 109` `0 <= hashValue < modulo` `s` consists of lowercase English letters only. The test cases are generated such that an answer always **exists**.",
        "test_case": [
            {
                "label": "Example 1",
                "input": "s = \"leetcode\", power = 7, modulo = 20, k = 2, hashValue = 0",
                "output": "\"ee\" Explanation: The hash of \"ee\" can be computed to be hash(\"ee\", 7, 20) = (5 * 1 + 5 * 7) mod 20 = 40 mod 20 = 0. \n\"ee\" is the first substring of length 2 with hashValue 0. Hence, we return \"ee\"."
            },
            {
                "label": "Example 2",
                "input": "s = \"fbxzaad\", power = 31, modulo = 100, k = 3, hashValue = 32",
                "output": "\"fbx\" Explanation: The hash of \"fbx\" can be computed to be hash(\"fbx\", 31, 100) = (6 * 1 + 2 * 31 + 24 * 31 2 ) mod 100 = 23132 mod 100 = 32. \nThe hash of \"bxz\" can be computed to be hash(\"bxz\", 31, 100) = (2 * 1 + 24 * 31 + 26 * 31 2 ) mod 100 = 25732 mod 100 = 32. \n\"fbx\" is the first substring of length 3 with hashValue 32. Hence, we return \"fbx\".\nNote that \"bxz\" also has a hash of 32 but it appears later than \"fbx\"."
            }
        ],
        "elixir_template": "defmodule Solution do\n  @spec sub_str_hash(s :: String.t, power :: integer, modulo :: integer, k :: integer, hash_value :: integer) :: String.t\n  def sub_str_hash(s, power, modulo, k, hash_value) do\n    \n  end\nend",
        "erlang_template": "-spec sub_str_hash(S :: unicode:unicode_binary(), Power :: integer(), Modulo :: integer(), K :: integer(), HashValue :: integer()) -> unicode:unicode_binary().\nsub_str_hash(S, Power, Modulo, K, HashValue) ->\n  .",
        "scala_template": "object Solution {\n    def subStrHash(s: String, power: Int, modulo: Int, k: Int, hashValue: Int): String = {\n        \n    }\n}"
    },
    {
        "id": 2274,
        "name": "keep-multiplying-found-values-by-two",
        "difficulty": "Easy",
        "link": "https://leetcode.com/problems/keep-multiplying-found-values-by-two/",
        "task_description": "You are given an array of integers `nums`. You are also given an integer `original` which is the first number that needs to be searched for in `nums`. You then do the following steps: If `original` is found in `nums`, **multiply** it by two (i.e., set `original = 2 * original`). Otherwise, **stop** the process. **Repeat** this process with the new number as long as you keep finding the number. Return _the **final** value of _`original`. **Example 1:** ``` **Input:** nums = [5,3,6,1,12], original = 3 **Output:** 24 **Explanation:** - 3 is found in nums. 3 is multiplied by 2 to obtain 6. - 6 is found in nums. 6 is multiplied by 2 to obtain 12. - 12 is found in nums. 12 is multiplied by 2 to obtain 24. - 24 is not found in nums. Thus, 24 is returned. ``` **Example 2:** ``` **Input:** nums = [2,7,9], original = 4 **Output:** 4 **Explanation:** - 4 is not found in nums. Thus, 4 is returned. ``` **Constraints:** `1 <= nums.length <= 1000` `1 <= nums[i], original <= 1000`",
        "test_case": [
            {
                "label": "Example 1",
                "input": "nums = [5,3,6,1,12], original = 3",
                "output": "24 Explanation: - 3 is found in nums. 3 is multiplied by 2 to obtain 6.\n- 6 is found in nums. 6 is multiplied by 2 to obtain 12.\n- 12 is found in nums. 12 is multiplied by 2 to obtain 24.\n- 24 is not found in nums. Thus, 24 is returned."
            },
            {
                "label": "Example 2",
                "input": "nums = [2,7,9], original = 4",
                "output": "4 Explanation: - 4 is not found in nums. Thus, 4 is returned."
            }
        ],
        "elixir_template": "defmodule Solution do\n  @spec find_final_value(nums :: [integer], original :: integer) :: integer\n  def find_final_value(nums, original) do\n    \n  end\nend",
        "erlang_template": "-spec find_final_value(Nums :: [integer()], Original :: integer()) -> integer().\nfind_final_value(Nums, Original) ->\n  .",
        "scala_template": "object Solution {\n    def findFinalValue(nums: Array[Int], original: Int): Int = {\n        \n    }\n}"
    },
    {
        "id": 2272,
        "name": "maximum-good-people-based-on-statements",
        "difficulty": "Hard",
        "link": "https://leetcode.com/problems/maximum-good-people-based-on-statements/",
        "task_description": "There are two types of persons: The **good person**: The person who always tells the truth. The **bad person**: The person who might tell the truth and might lie. You are given a **0-indexed** 2D integer array `statements` of size `n x n` that represents the statements made by `n` people about each other. More specifically, `statements[i][j]` could be one of the following: `0` which represents a statement made by person `i` that person `j` is a **bad** person. `1` which represents a statement made by person `i` that person `j` is a **good** person. `2` represents that **no statement** is made by person `i` about person `j`. Additionally, no person ever makes a statement about themselves. Formally, we have that `statements[i][i] = 2` for all `0 <= i < n`. Return _the **maximum** number of people who can be **good** based on the statements made by the _`n`_ people_. **Example 1:** ``` **Input:** statements = [[2,1,2],[1,2,2],[2,0,2]] **Output:** 2 **Explanation:** Each person makes a single statement. - Person 0 states that person 1 is good. - Person 1 states that person 0 is good. - Person 2 states that person 1 is bad. Let's take person 2 as the key. - Assuming that person 2 is a good person: - Based on the statement made by person 2, person 1 is a bad person. - Now we know for sure that person 1 is bad and person 2 is good. - Based on the statement made by person 1, and since person 1 is bad, they could be: - telling the truth. There will be a contradiction in this case and this assumption is invalid. - lying. In this case, person 0 is also a bad person and lied in their statement. - **Following that person 2 is a good person, there will be only one good person in the group**. - Assuming that person 2 is a bad person: - Based on the statement made by person 2, and since person 2 is bad, they could be: - telling the truth. Following this scenario, person 0 and 1 are both bad as explained before. - **Following that person 2 is bad but told the truth, there will be no good persons in the group**. - lying. In this case person 1 is a good person. - Since person 1 is a good person, person 0 is also a good person. - **Following that person 2 is bad and lied, there will be two good persons in the group**. We can see that at most 2 persons are good in the best case, so we return 2. Note that there is more than one way to arrive at this conclusion. ``` **Example 2:** ``` **Input:** statements = [[2,0],[0,2]] **Output:** 1 **Explanation:** Each person makes a single statement. - Person 0 states that person 1 is bad. - Person 1 states that person 0 is bad. Let's take person 0 as the key. - Assuming that person 0 is a good person: - Based on the statement made by person 0, person 1 is a bad person and was lying. - **Following that person 0 is a good person, there will be only one good person in the group**. - Assuming that person 0 is a bad person: - Based on the statement made by person 0, and since person 0 is bad, they could be: - telling the truth. Following this scenario, person 0 and 1 are both bad. - **Following that person 0 is bad but told the truth, there will be no good persons in the group**. - lying. In this case person 1 is a good person. - **Following that person 0 is bad and lied, there will be only one good person in the group**. We can see that at most, one person is good in the best case, so we return 1. Note that there is more than one way to arrive at this conclusion. ``` **Constraints:** `n == statements.length == statements[i].length` `2 <= n <= 15` `statements[i][j]` is either `0`, `1`, or `2`. `statements[i][i] == 2`",
        "test_case": [
            {
                "label": "Example 1",
                "input": "statements = [[2,1,2],[1,2,2],[2,0,2]]",
                "output": "2 Explanation: Each person makes a single statement.\n- Person 0 states that person 1 is good.\n- Person 1 states that person 0 is good.\n- Person 2 states that person 1 is bad.\nLet's take person 2 as the key.\n- Assuming that person 2 is a good person:\n    - Based on the statement made by person 2, person 1 is a bad person.\n    - Now we know for sure that person 1 is bad and person 2 is good.\n    - Based on the statement made by person 1, and since person 1 is bad, they could be:\n        - telling the truth. There will be a contradiction in this case and this assumption is invalid.\n        - lying. In this case, person 0 is also a bad person and lied in their statement.\n    - Following that person 2 is a good person, there will be only one good person in the group .\n- Assuming that person 2 is a bad person:\n    - Based on the statement made by person 2, and since person 2 is bad, they could be:\n        - telling the truth. Following this scenario, person 0 and 1 are both bad as explained before.\n            - Following that person 2 is bad but told the truth, there will be no good persons in the group .\n        - lying. In this case person 1 is a good person.\n            - Since person 1 is a good person, person 0 is also a good person.\n            - Following that person 2 is bad and lied, there will be two good persons in the group .\nWe can see that at most 2 persons are good in the best case, so we return 2.\nNote that there is more than one way to arrive at this conclusion."
            },
            {
                "label": "Example 2",
                "input": "statements = [[2,0],[0,2]]",
                "output": "1 Explanation: Each person makes a single statement.\n- Person 0 states that person 1 is bad.\n- Person 1 states that person 0 is bad.\nLet's take person 0 as the key.\n- Assuming that person 0 is a good person:\n    - Based on the statement made by person 0, person 1 is a bad person and was lying.\n    - Following that person 0 is a good person, there will be only one good person in the group .\n- Assuming that person 0 is a bad person:\n    - Based on the statement made by person 0, and since person 0 is bad, they could be:\n        - telling the truth. Following this scenario, person 0 and 1 are both bad.\n            - Following that person 0 is bad but told the truth, there will be no good persons in the group .\n        - lying. In this case person 1 is a good person.\n            - Following that person 0 is bad and lied, there will be only one good person in the group .\nWe can see that at most, one person is good in the best case, so we return 1.\nNote that there is more than one way to arrive at this conclusion. Constraints: n == statements.length == statements[i].length 2 <= n <= 15 statements[i][j] is either 0 , 1 , or 2 . statements[i][i] == 2"
            }
        ],
        "elixir_template": "defmodule Solution do\n  @spec maximum_good(statements :: [[integer]]) :: integer\n  def maximum_good(statements) do\n    \n  end\nend",
        "erlang_template": "-spec maximum_good(Statements :: [[integer()]]) -> integer().\nmaximum_good(Statements) ->\n  .",
        "scala_template": "object Solution {\n    def maximumGood(statements: Array[Array[Int]]): Int = {\n        \n    }\n}"
    },
    {
        "id": 2271,
        "name": "rearrange-array-elements-by-sign",
        "difficulty": "Medium",
        "link": "https://leetcode.com/problems/rearrange-array-elements-by-sign/",
        "task_description": "You are given a **0-indexed** integer array `nums` of **even** length consisting of an **equal** number of positive and negative integers. You should return the array of nums such that the the array follows the given conditions: Every **consecutive pair** of integers have **opposite signs**. For all integers with the same sign, the **order** in which they were present in `nums` is **preserved**. The rearranged array begins with a positive integer. Return _the modified array after rearranging the elements to satisfy the aforementioned conditions_. **Example 1:** ``` **Input:** nums = [3,1,-2,-5,2,-4] **Output:** [3,-2,1,-5,2,-4] **Explanation:** The positive integers in nums are [3,1,2]. The negative integers are [-2,-5,-4]. The only possible way to rearrange them such that they satisfy all conditions is [3,-2,1,-5,2,-4]. Other ways such as [1,-2,2,-5,3,-4], [3,1,2,-2,-5,-4], [-2,3,-5,1,-4,2] are incorrect because they do not satisfy one or more conditions. ``` **Example 2:** ``` **Input:** nums = [-1,1] **Output:** [1,-1] **Explanation:** 1 is the only positive integer and -1 the only negative integer in nums. So nums is rearranged to [1,-1]. ``` **Constraints:** `2 <= nums.length <= 2 * 105` `nums.length` is **even** `1 <= |nums[i]| <= 105` `nums` consists of **equal** number of positive and negative integers. It is not required to do the modifications in-place.",
        "test_case": [
            {
                "label": "Example 1",
                "input": "nums = [3,1,-2,-5,2,-4]",
                "output": "[3,-2,1,-5,2,-4] Explanation: The positive integers in nums are [3,1,2]. The negative integers are [-2,-5,-4].\nThe only possible way to rearrange them such that they satisfy all conditions is [3,-2,1,-5,2,-4].\nOther ways such as [1,-2,2,-5,3,-4], [3,1,2,-2,-5,-4], [-2,3,-5,1,-4,2] are incorrect because they do not satisfy one or more conditions."
            },
            {
                "label": "Example 2",
                "input": "nums = [-1,1]",
                "output": "[1,-1] Explanation: 1 is the only positive integer and -1 the only negative integer in nums.\nSo nums is rearranged to [1,-1]."
            }
        ],
        "elixir_template": "defmodule Solution do\n  @spec rearrange_array(nums :: [integer]) :: [integer]\n  def rearrange_array(nums) do\n    \n  end\nend",
        "erlang_template": "-spec rearrange_array(Nums :: [integer()]) -> [integer()].\nrearrange_array(Nums) ->\n  .",
        "scala_template": "object Solution {\n    def rearrangeArray(nums: Array[Int]): Array[Int] = {\n        \n    }\n}"
    },
    {
        "id": 2270,
        "name": "find-all-lonely-numbers-in-the-array",
        "difficulty": "Medium",
        "link": "https://leetcode.com/problems/find-all-lonely-numbers-in-the-array/",
        "task_description": "You are given an integer array `nums`. A number `x` is **lonely** when it appears only **once**, and no **adjacent** numbers (i.e. `x + 1` and `x - 1)` appear in the array. Return _**all** lonely numbers in _`nums`. You may return the answer in **any order**. **Example 1:** ``` **Input:** nums = [10,6,5,8] **Output:** [10,8] **Explanation:** - 10 is a lonely number since it appears exactly once and 9 and 11 does not appear in nums. - 8 is a lonely number since it appears exactly once and 7 and 9 does not appear in nums. - 5 is not a lonely number since 6 appears in nums and vice versa. Hence, the lonely numbers in nums are [10, 8]. Note that [8, 10] may also be returned. ``` **Example 2:** ``` **Input:** nums = [1,3,5,3] **Output:** [1,5] **Explanation:** - 1 is a lonely number since it appears exactly once and 0 and 2 does not appear in nums. - 5 is a lonely number since it appears exactly once and 4 and 6 does not appear in nums. - 3 is not a lonely number since it appears twice. Hence, the lonely numbers in nums are [1, 5]. Note that [5, 1] may also be returned. ``` **Constraints:** `1 <= nums.length <= 105` `0 <= nums[i] <= 106`",
        "test_case": [
            {
                "label": "Example 1",
                "input": "nums = [10,6,5,8]",
                "output": "[10,8] Explanation: - 10 is a lonely number since it appears exactly once and 9 and 11 does not appear in nums.\n- 8 is a lonely number since it appears exactly once and 7 and 9 does not appear in nums.\n- 5 is not a lonely number since 6 appears in nums and vice versa.\nHence, the lonely numbers in nums are [10, 8].\nNote that [8, 10] may also be returned."
            },
            {
                "label": "Example 2",
                "input": "nums = [1,3,5,3]",
                "output": "[1,5] Explanation: - 1 is a lonely number since it appears exactly once and 0 and 2 does not appear in nums.\n- 5 is a lonely number since it appears exactly once and 4 and 6 does not appear in nums.\n- 3 is not a lonely number since it appears twice.\nHence, the lonely numbers in nums are [1, 5].\nNote that [5, 1] may also be returned."
            }
        ],
        "elixir_template": "defmodule Solution do\n  @spec find_lonely(nums :: [integer]) :: [integer]\n  def find_lonely(nums) do\n    \n  end\nend",
        "erlang_template": "-spec find_lonely(Nums :: [integer()]) -> [integer()].\nfind_lonely(Nums) ->\n  .",
        "scala_template": "object Solution {\n    def findLonely(nums: Array[Int]): List[Int] = {\n        \n    }\n}"
    },
    {
        "id": 2269,
        "name": "count-elements-with-strictly-smaller-and-greater-elements",
        "difficulty": "Easy",
        "link": "https://leetcode.com/problems/count-elements-with-strictly-smaller-and-greater-elements/",
        "task_description": "Given an integer array `nums`, return _the number of elements that have **both** a strictly smaller and a strictly greater element appear in _`nums`. **Example 1:** ``` **Input:** nums = [11,7,2,15] **Output:** 2 **Explanation:** The element 7 has the element 2 strictly smaller than it and the element 11 strictly greater than it. Element 11 has element 7 strictly smaller than it and element 15 strictly greater than it. In total there are 2 elements having both a strictly smaller and a strictly greater element appear in `nums`. ``` **Example 2:** ``` **Input:** nums = [-3,3,3,90] **Output:** 2 **Explanation:** The element 3 has the element -3 strictly smaller than it and the element 90 strictly greater than it. Since there are two elements with the value 3, in total there are 2 elements having both a strictly smaller and a strictly greater element appear in `nums`. ``` **Constraints:** `1 <= nums.length <= 100` `-105 <= nums[i] <= 105`",
        "test_case": [
            {
                "label": "Example 1",
                "input": "nums = [11,7,2,15]",
                "output": "2 Explanation: The element 7 has the element 2 strictly smaller than it and the element 11 strictly greater than it.\nElement 11 has element 7 strictly smaller than it and element 15 strictly greater than it.\nIn total there are 2 elements having both a strictly smaller and a strictly greater element appear in nums ."
            },
            {
                "label": "Example 2",
                "input": "nums = [-3,3,3,90]",
                "output": "2 Explanation: The element 3 has the element -3 strictly smaller than it and the element 90 strictly greater than it.\nSince there are two elements with the value 3, in total there are 2 elements having both a strictly smaller and a strictly greater element appear in nums ."
            }
        ],
        "elixir_template": "defmodule Solution do\n  @spec count_elements(nums :: [integer]) :: integer\n  def count_elements(nums) do\n    \n  end\nend",
        "erlang_template": "-spec count_elements(Nums :: [integer()]) -> integer().\ncount_elements(Nums) ->\n  .",
        "scala_template": "object Solution {\n    def countElements(nums: Array[Int]): Int = {\n        \n    }\n}"
    },
    {
        "id": 2267,
        "name": "minimum-difference-in-sums-after-removal-of-elements",
        "difficulty": "Hard",
        "link": "https://leetcode.com/problems/minimum-difference-in-sums-after-removal-of-elements/",
        "task_description": "You are given a **0-indexed** integer array `nums` consisting of `3 * n` elements. You are allowed to remove any **subsequence** of elements of size **exactly** `n` from `nums`. The remaining `2 * n` elements will be divided into two **equal** parts: The first `n` elements belonging to the first part and their sum is `sumfirst`. The next `n` elements belonging to the second part and their sum is `sumsecond`. The **difference in sums** of the two parts is denoted as `sumfirst - sumsecond`. For example, if `sumfirst = 3` and `sumsecond = 2`, their difference is `1`. Similarly, if `sumfirst = 2` and `sumsecond = 3`, their difference is `-1`. Return _the **minimum difference** possible between the sums of the two parts after the removal of _`n`_ elements_. **Example 1:** ``` **Input:** nums = [3,1,2] **Output:** -1 **Explanation:** Here, nums has 3 elements, so n = 1. Thus we have to remove 1 element from nums and divide the array into two equal parts. - If we remove nums[0] = 3, the array will be [1,2]. The difference in sums of the two parts will be 1 - 2 = -1. - If we remove nums[1] = 1, the array will be [3,2]. The difference in sums of the two parts will be 3 - 2 = 1. - If we remove nums[2] = 2, the array will be [3,1]. The difference in sums of the two parts will be 3 - 1 = 2. The minimum difference between sums of the two parts is min(-1,1,2) = -1. ``` **Example 2:** ``` **Input:** nums = [7,9,5,8,1,3] **Output:** 1 **Explanation:** Here n = 2. So we must remove 2 elements and divide the remaining array into two parts containing two elements each. If we remove nums[2] = 5 and nums[3] = 8, the resultant array will be [7,9,1,3]. The difference in sums will be (7+9) - (1+3) = 12. To obtain the minimum difference, we should remove nums[1] = 9 and nums[4] = 1. The resultant array becomes [7,5,8,3]. The difference in sums of the two parts is (7+5) - (8+3) = 1. It can be shown that it is not possible to obtain a difference smaller than 1. ``` **Constraints:** `nums.length == 3 * n` `1 <= n <= 105` `1 <= nums[i] <= 105`",
        "test_case": [
            {
                "label": "Example 1",
                "input": "nums = [3,1,2]",
                "output": "-1 Explanation: Here, nums has 3 elements, so n = 1. \nThus we have to remove 1 element from nums and divide the array into two equal parts.\n- If we remove nums[0] = 3, the array will be [1,2]. The difference in sums of the two parts will be 1 - 2 = -1.\n- If we remove nums[1] = 1, the array will be [3,2]. The difference in sums of the two parts will be 3 - 2 = 1.\n- If we remove nums[2] = 2, the array will be [3,1]. The difference in sums of the two parts will be 3 - 1 = 2.\nThe minimum difference between sums of the two parts is min(-1,1,2) = -1."
            },
            {
                "label": "Example 2",
                "input": "nums = [7,9,5,8,1,3]",
                "output": "1 Explanation: Here n = 2. So we must remove 2 elements and divide the remaining array into two parts containing two elements each.\nIf we remove nums[2] = 5 and nums[3] = 8, the resultant array will be [7,9,1,3]. The difference in sums will be (7+9) - (1+3) = 12.\nTo obtain the minimum difference, we should remove nums[1] = 9 and nums[4] = 1. The resultant array becomes [7,5,8,3]. The difference in sums of the two parts is (7+5) - (8+3) = 1.\nIt can be shown that it is not possible to obtain a difference smaller than 1. Constraints: nums.length == 3 * n 1 <= n <= 10 5 1 <= nums[i] <= 10 5"
            }
        ],
        "elixir_template": "defmodule Solution do\n  @spec minimum_difference(nums :: [integer]) :: integer\n  def minimum_difference(nums) do\n    \n  end\nend",
        "erlang_template": "-spec minimum_difference(Nums :: [integer()]) -> integer().\nminimum_difference(Nums) ->\n  .",
        "scala_template": "object Solution {\n    def minimumDifference(nums: Array[Int]): Long = {\n        \n    }\n}"
    },
    {
        "id": 2266,
        "name": "minimum-cost-to-set-cooking-time",
        "difficulty": "Medium",
        "link": "https://leetcode.com/problems/minimum-cost-to-set-cooking-time/",
        "task_description": "A generic microwave supports cooking times for: at least `1` second. at most `99` minutes and `99` seconds. To set the cooking time, you push **at most four digits**. The microwave normalizes what you push as four digits by **prepending zeroes**. It interprets the **first** two digits as the minutes and the **last** two digits as the seconds. It then **adds** them up as the cooking time. For example, You push `9` `5` `4` (three digits). It is normalized as `0954` and interpreted as `9` minutes and `54` seconds. You push `0` `0` `0` `8` (four digits). It is interpreted as `0` minutes and `8` seconds. You push `8` `0` `9` `0`. It is interpreted as `80` minutes and `90` seconds. You push `8` `1` `3` `0`. It is interpreted as `81` minutes and `30` seconds. You are given integers `startAt`, `moveCost`, `pushCost`, and `targetSeconds`. **Initially**, your finger is on the digit `startAt`. Moving the finger above **any specific digit** costs `moveCost` units of fatigue. Pushing the digit below the finger **once** costs `pushCost` units of fatigue. There can be multiple ways to set the microwave to cook for `targetSeconds` seconds but you are interested in the way with the minimum cost. Return _the **minimum cost** to set_ `targetSeconds` _seconds of cooking time_. Remember that one minute consists of `60` seconds. **Example 1:** ``` **Input:** startAt = 1, moveCost = 2, pushCost = 1, targetSeconds = 600 **Output:** 6 **Explanation:** The following are the possible ways to set the cooking time. - 1 0 0 0, interpreted as 10 minutes and 0 seconds. The finger is already on digit 1, pushes 1 (with cost 1), moves to 0 (with cost 2), pushes 0 (with cost 1), pushes 0 (with cost 1), and pushes 0 (with cost 1). The cost is: 1 + 2 + 1 + 1 + 1 = 6. This is the minimum cost. - 0 9 6 0, interpreted as 9 minutes and 60 seconds. That is also 600 seconds. The finger moves to 0 (with cost 2), pushes 0 (with cost 1), moves to 9 (with cost 2), pushes 9 (with cost 1), moves to 6 (with cost 2), pushes 6 (with cost 1), moves to 0 (with cost 2), and pushes 0 (with cost 1). The cost is: 2 + 1 + 2 + 1 + 2 + 1 + 2 + 1 = 12. - 9 6 0, normalized as 0960 and interpreted as 9 minutes and 60 seconds. The finger moves to 9 (with cost 2), pushes 9 (with cost 1), moves to 6 (with cost 2), pushes 6 (with cost 1), moves to 0 (with cost 2), and pushes 0 (with cost 1). The cost is: 2 + 1 + 2 + 1 + 2 + 1 = 9. ``` **Example 2:** ``` **Input:** startAt = 0, moveCost = 1, pushCost = 2, targetSeconds = 76 **Output:** 6 **Explanation:** The optimal way is to push two digits: 7 6, interpreted as 76 seconds. The finger moves to 7 (with cost 1), pushes 7 (with cost 2), moves to 6 (with cost 1), and pushes 6 (with cost 2). The total cost is: 1 + 2 + 1 + 2 = 6 Note other possible ways are 0076, 076, 0116, and 116, but none of them produces the minimum cost. ``` **Constraints:** `0 <= startAt <= 9` `1 <= moveCost, pushCost <= 105` `1 <= targetSeconds <= 6039`",
        "test_case": [
            {
                "label": "Example 1",
                "input": "startAt = 1, moveCost = 2, pushCost = 1, targetSeconds = 600",
                "output": "6 Explanation: The following are the possible ways to set the cooking time.\n- 1 0 0 0, interpreted as 10 minutes and 0 seconds.\n\u00a0 The finger is already on digit 1, pushes 1 (with cost 1), moves to 0 (with cost 2), pushes 0 (with cost 1), pushes 0 (with cost 1), and pushes 0 (with cost 1).\n\u00a0 The cost is: 1 + 2 + 1 + 1 + 1 = 6. This is the minimum cost.\n- 0 9 6 0, interpreted as 9 minutes and 60 seconds. That is also 600 seconds.\n\u00a0 The finger moves to 0 (with cost 2), pushes 0 (with cost 1), moves to 9 (with cost 2), pushes 9 (with cost 1), moves to 6 (with cost 2), pushes 6 (with cost 1), moves to 0 (with cost 2), and pushes 0 (with cost 1).\n\u00a0 The cost is: 2 + 1 + 2 + 1 + 2 + 1 + 2 + 1 = 12.\n- 9 6 0, normalized as 0960 and interpreted as 9 minutes and 60 seconds.\n\u00a0 The finger moves to 9 (with cost 2), pushes 9 (with cost 1), moves to 6 (with cost 2), pushes 6 (with cost 1), moves to 0 (with cost 2), and pushes 0 (with cost 1).\n\u00a0 The cost is: 2 + 1 + 2 + 1 + 2 + 1 = 9."
            },
            {
                "label": "Example 2",
                "input": "startAt = 0, moveCost = 1, pushCost = 2, targetSeconds = 76",
                "output": "6 Explanation: The optimal way is to push two digits: 7 6, interpreted as 76 seconds.\nThe finger moves to 7 (with cost 1), pushes 7 (with cost 2), moves to 6 (with cost 1), and pushes 6 (with cost 2). The total cost is: 1 + 2 + 1 + 2 = 6\nNote other possible ways are 0076, 076, 0116, and 116, but none of them produces the minimum cost."
            }
        ],
        "elixir_template": "defmodule Solution do\n  @spec min_cost_set_time(start_at :: integer, move_cost :: integer, push_cost :: integer, target_seconds :: integer) :: integer\n  def min_cost_set_time(start_at, move_cost, push_cost, target_seconds) do\n    \n  end\nend",
        "erlang_template": "-spec min_cost_set_time(StartAt :: integer(), MoveCost :: integer(), PushCost :: integer(), TargetSeconds :: integer()) -> integer().\nmin_cost_set_time(StartAt, MoveCost, PushCost, TargetSeconds) ->\n  .",
        "scala_template": "object Solution {\n    def minCostSetTime(startAt: Int, moveCost: Int, pushCost: Int, targetSeconds: Int): Int = {\n        \n    }\n}"
    },
    {
        "id": 2265,
        "name": "partition-array-according-to-given-pivot",
        "difficulty": "Medium",
        "link": "https://leetcode.com/problems/partition-array-according-to-given-pivot/",
        "task_description": "You are given a **0-indexed** integer array `nums` and an integer `pivot`. Rearrange `nums` such that the following conditions are satisfied: Every element less than `pivot` appears **before** every element greater than `pivot`. Every element equal to `pivot` appears **in between** the elements less than and greater than `pivot`. The **relative order** of the elements less than `pivot` and the elements greater than `pivot` is maintained. More formally, consider every `pi`, `pj` where `pi` is the new position of the `ith` element and `pj` is the new position of the `jth` element. For elements less than `pivot`, if `i < j` and `nums[i] < pivot` and `nums[j] < pivot`, then `pi < pj`. Similarly for elements greater than `pivot`, if `i < j` and `nums[i] > pivot` and `nums[j] > pivot`, then `pi < pj`. Return `nums`_ after the rearrangement._ **Example 1:** ``` **Input:** nums = [9,12,5,10,14,3,10], pivot = 10 **Output:** [9,5,3,10,10,12,14] **Explanation:** The elements 9, 5, and 3 are less than the pivot so they are on the left side of the array. The elements 12 and 14 are greater than the pivot so they are on the right side of the array. The relative ordering of the elements less than and greater than pivot is also maintained. [9, 5, 3] and [12, 14] are the respective orderings. ``` **Example 2:** ``` **Input:** nums = [-3,4,3,2], pivot = 2 **Output:** [-3,2,4,3] **Explanation:** The element -3 is less than the pivot so it is on the left side of the array. The elements 4 and 3 are greater than the pivot so they are on the right side of the array. The relative ordering of the elements less than and greater than pivot is also maintained. [-3] and [4, 3] are the respective orderings. ``` **Constraints:** `1 <= nums.length <= 105` `-106 <= nums[i] <= 106` `pivot` equals to an element of `nums`.",
        "test_case": [
            {
                "label": "Example 1",
                "input": "nums = [9,12,5,10,14,3,10], pivot = 10",
                "output": "[9,5,3,10,10,12,14] Explanation: The elements 9, 5, and 3 are less than the pivot so they are on the left side of the array.\nThe elements 12 and 14 are greater than the pivot so they are on the right side of the array.\nThe relative ordering of the elements less than and greater than pivot is also maintained. [9, 5, 3] and [12, 14] are the respective orderings."
            },
            {
                "label": "Example 2",
                "input": "nums = [-3,4,3,2], pivot = 2",
                "output": "[-3,2,4,3] Explanation: The element -3 is less than the pivot so it is on the left side of the array.\nThe elements 4 and 3 are greater than the pivot so they are on the right side of the array.\nThe relative ordering of the elements less than and greater than pivot is also maintained. [-3] and [4, 3] are the respective orderings."
            }
        ],
        "elixir_template": "defmodule Solution do\n  @spec pivot_array(nums :: [integer], pivot :: integer) :: [integer]\n  def pivot_array(nums, pivot) do\n    \n  end\nend",
        "erlang_template": "-spec pivot_array(Nums :: [integer()], Pivot :: integer()) -> [integer()].\npivot_array(Nums, Pivot) ->\n  .",
        "scala_template": "object Solution {\n    def pivotArray(nums: Array[Int], pivot: Int): Array[Int] = {\n        \n    }\n}"
    },
    {
        "id": 2264,
        "name": "minimum-sum-of-four-digit-number-after-splitting-digits",
        "difficulty": "Easy",
        "link": "https://leetcode.com/problems/minimum-sum-of-four-digit-number-after-splitting-digits/",
        "task_description": "You are given a **positive** integer `num` consisting of exactly four digits. Split `num` into two new integers `new1` and `new2` by using the **digits** found in `num`. **Leading zeros** are allowed in `new1` and `new2`, and **all** the digits found in `num` must be used. For example, given `num = 2932`, you have the following digits: two `2`'s, one `9` and one `3`. Some of the possible pairs `[new1, new2]` are `[22, 93]`, `[23, 92]`, `[223, 9]` and `[2, 329]`. Return _the **minimum** possible sum of _`new1`_ and _`new2`. **Example 1:** ``` **Input:** num = 2932 **Output:** 52 **Explanation:** Some possible pairs [new1, new2] are [29, 23], [223, 9], etc. The minimum sum can be obtained by the pair [29, 23]: 29 + 23 = 52. ``` **Example 2:** ``` **Input:** num = 4009 **Output:** 13 **Explanation:** Some possible pairs [new1, new2] are [0, 49], [490, 0], etc. The minimum sum can be obtained by the pair [4, 9]: 4 + 9 = 13. ``` **Constraints:** `1000 <= num <= 9999`",
        "test_case": [
            {
                "label": "Example 1",
                "input": "num = 2932",
                "output": "52 Explanation: Some possible pairs [new1, new2] are [29, 23], [223, 9], etc.\nThe minimum sum can be obtained by the pair [29, 23]: 29 + 23 = 52."
            },
            {
                "label": "Example 2",
                "input": "num = 4009",
                "output": "13 Explanation: Some possible pairs [new1, new2] are [0, 49], [490, 0], etc. \nThe minimum sum can be obtained by the pair [4, 9]: 4 + 9 = 13."
            }
        ],
        "elixir_template": "defmodule Solution do\n  @spec minimum_sum(num :: integer) :: integer\n  def minimum_sum(num) do\n    \n  end\nend",
        "erlang_template": "-spec minimum_sum(Num :: integer()) -> integer().\nminimum_sum(Num) ->\n  .",
        "scala_template": "object Solution {\n    def minimumSum(num: Int): Int = {\n        \n    }\n}"
    },
    {
        "id": 2263,
        "name": "maximum-running-time-of-n-computers",
        "difficulty": "Hard",
        "link": "https://leetcode.com/problems/maximum-running-time-of-n-computers/",
        "task_description": "You have `n` computers. You are given the integer `n` and a **0-indexed** integer array `batteries` where the `ith` battery can **run** a computer for `batteries[i]` minutes. You are interested in running **all** `n` computers **simultaneously** using the given batteries. Initially, you can insert **at most one battery** into each computer. After that and at any integer time moment, you can remove a battery from a computer and insert another battery **any number of times**. The inserted battery can be a totally new battery or a battery from another computer. You may assume that the removing and inserting processes take no time. Note that the batteries cannot be recharged. Return _the **maximum** number of minutes you can run all the _`n`_ computers simultaneously._ **Example 1:** ``` **Input:** n = 2, batteries = [3,3,3] **Output:** 4 **Explanation:** Initially, insert battery 0 into the first computer and battery 1 into the second computer. After two minutes, remove battery 1 from the second computer and insert battery 2 instead. Note that battery 1 can still run for one minute. At the end of the third minute, battery 0 is drained, and you need to remove it from the first computer and insert battery 1 instead. By the end of the fourth minute, battery 1 is also drained, and the first computer is no longer running. We can run the two computers simultaneously for at most 4 minutes, so we return 4. ``` **Example 2:** ``` **Input:** n = 2, batteries = [1,1,1,1] **Output:** 2 **Explanation:** Initially, insert battery 0 into the first computer and battery 2 into the second computer. After one minute, battery 0 and battery 2 are drained so you need to remove them and insert battery 1 into the first computer and battery 3 into the second computer. After another minute, battery 1 and battery 3 are also drained so the first and second computers are no longer running. We can run the two computers simultaneously for at most 2 minutes, so we return 2. ``` **Constraints:** `1 <= n <= batteries.length <= 105` `1 <= batteries[i] <= 109`",
        "test_case": [
            {
                "label": "Example 1",
                "input": "n = 2, batteries = [3,3,3]",
                "output": "4 Explanation: Initially, insert battery 0 into the first computer and battery 1 into the second computer.\nAfter two minutes, remove battery 1 from the second computer and insert battery 2 instead. Note that battery 1 can still run for one minute.\nAt the end of the third minute, battery 0 is drained, and you need to remove it from the first computer and insert battery 1 instead.\nBy the end of the fourth minute, battery 1 is also drained, and the first computer is no longer running.\nWe can run the two computers simultaneously for at most 4 minutes, so we return 4."
            },
            {
                "label": "Example 2",
                "input": "n = 2, batteries = [1,1,1,1]",
                "output": "2 Explanation: Initially, insert battery 0 into the first computer and battery 2 into the second computer. \nAfter one minute, battery 0 and battery 2 are drained so you need to remove them and insert battery 1 into the first computer and battery 3 into the second computer. \nAfter another minute, battery 1 and battery 3 are also drained so the first and second computers are no longer running.\nWe can run the two computers simultaneously for at most 2 minutes, so we return 2."
            }
        ],
        "elixir_template": "defmodule Solution do\n  @spec max_run_time(n :: integer, batteries :: [integer]) :: integer\n  def max_run_time(n, batteries) do\n    \n  end\nend",
        "erlang_template": "-spec max_run_time(N :: integer(), Batteries :: [integer()]) -> integer().\nmax_run_time(N, Batteries) ->\n  .",
        "scala_template": "object Solution {\n    def maxRunTime(n: Int, batteries: Array[Int]): Long = {\n        \n    }\n}"
    },
    {
        "id": 2262,
        "name": "solving-questions-with-brainpower",
        "difficulty": "Medium",
        "link": "https://leetcode.com/problems/solving-questions-with-brainpower/",
        "task_description": "You are given a **0-indexed** 2D integer array `questions` where `questions[i] = [pointsi, brainpoweri]`. The array describes the questions of an exam, where you have to process the questions **in order** (i.e., starting from question `0`) and make a decision whether to **solve** or **skip** each question. Solving question `i` will **earn** you `pointsi` points but you will be **unable** to solve each of the next `brainpoweri` questions. If you skip question `i`, you get to make the decision on the next question. For example, given `questions = [[3, 2], [4, 3], [4, 4], [2, 5]]`: If question `0` is solved, you will earn `3` points but you will be unable to solve questions `1` and `2`. If instead, question `0` is skipped and question `1` is solved, you will earn `4` points but you will be unable to solve questions `2` and `3`. Return _the **maximum** points you can earn for the exam_. **Example 1:** ``` **Input:** questions = [[3,2],[4,3],[4,4],[2,5]] **Output:** 5 **Explanation:** The maximum points can be earned by solving questions 0 and 3. - Solve question 0: Earn 3 points, will be unable to solve the next 2 questions - Unable to solve questions 1 and 2 - Solve question 3: Earn 2 points Total points earned: 3 + 2 = 5. There is no other way to earn 5 or more points. ``` **Example 2:** ``` **Input:** questions = [[1,1],[2,2],[3,3],[4,4],[5,5]] **Output:** 7 **Explanation:** The maximum points can be earned by solving questions 1 and 4. - Skip question 0 - Solve question 1: Earn 2 points, will be unable to solve the next 2 questions - Unable to solve questions 2 and 3 - Solve question 4: Earn 5 points Total points earned: 2 + 5 = 7. There is no other way to earn 7 or more points. ``` **Constraints:** `1 <= questions.length <= 105` `questions[i].length == 2` `1 <= pointsi, brainpoweri <= 105`",
        "test_case": [
            {
                "label": "Example 1",
                "input": "questions = [[3,2],[4,3],[4,4],[2,5]]",
                "output": "5 Explanation: The maximum points can be earned by solving questions 0 and 3.\n- Solve question 0: Earn 3 points, will be unable to solve the next 2 questions\n- Unable to solve questions 1 and 2\n- Solve question 3: Earn 2 points\nTotal points earned: 3 + 2 = 5. There is no other way to earn 5 or more points."
            },
            {
                "label": "Example 2",
                "input": "questions = [[1,1],[2,2],[3,3],[4,4],[5,5]]",
                "output": "7 Explanation: The maximum points can be earned by solving questions 1 and 4.\n- Skip question 0\n- Solve question 1: Earn 2 points, will be unable to solve the next 2 questions\n- Unable to solve questions 2 and 3\n- Solve question 4: Earn 5 points\nTotal points earned: 2 + 5 = 7. There is no other way to earn 7 or more points."
            }
        ],
        "elixir_template": "defmodule Solution do\n  @spec most_points(questions :: [[integer]]) :: integer\n  def most_points(questions) do\n    \n  end\nend",
        "erlang_template": "-spec most_points(Questions :: [[integer()]]) -> integer().\nmost_points(Questions) ->\n  .",
        "scala_template": "object Solution {\n    def mostPoints(questions: Array[Array[Int]]): Long = {\n        \n    }\n}"
    },
    {
        "id": 2261,
        "name": "all-divisions-with-the-highest-score-of-a-binary-array",
        "difficulty": "Medium",
        "link": "https://leetcode.com/problems/all-divisions-with-the-highest-score-of-a-binary-array/",
        "task_description": "You are given a **0-indexed** binary array `nums` of length `n`. `nums` can be divided at index `i` (where `0 <= i <= n)` into two arrays (possibly empty) `numsleft` and `numsright`: `numsleft` has all the elements of `nums` between index `0` and `i - 1` **(inclusive)**, while `numsright` has all the elements of nums between index `i` and `n - 1` **(inclusive)**. If `i == 0`, `numsleft` is **empty**, while `numsright` has all the elements of `nums`. If `i == n`, `numsleft` has all the elements of nums, while `numsright` is **empty**. The **division score** of an index `i` is the **sum** of the number of `0`'s in `numsleft` and the number of `1`'s in `numsright`. Return _**all distinct indices** that have the **highest** possible **division score**_. You may return the answer in **any order**. **Example 1:** ``` **Input:** nums = [0,0,1,0] **Output:** [2,4] **Explanation:** Division at index - 0: numsleft is []. numsright is [0,0,**1**,0]. The score is 0 + 1 = 1. - 1: numsleft is [**0**]. numsright is [0,**1**,0]. The score is 1 + 1 = 2. - 2: numsleft is [**0**,**0**]. numsright is [**1**,0]. The score is 2 + 1 = 3. - 3: numsleft is [**0**,**0**,1]. numsright is [0]. The score is 2 + 0 = 2. - 4: numsleft is [**0**,**0**,1,**0**]. numsright is []. The score is 3 + 0 = 3. Indices 2 and 4 both have the highest possible division score 3. Note the answer [4,2] would also be accepted. ``` **Example 2:** ``` **Input:** nums = [0,0,0] **Output:** [3] **Explanation:** Division at index - 0: numsleft is []. numsright is [0,0,0]. The score is 0 + 0 = 0. - 1: numsleft is [**0**]. numsright is [0,0]. The score is 1 + 0 = 1. - 2: numsleft is [**0**,**0**]. numsright is [0]. The score is 2 + 0 = 2. - 3: numsleft is [**0**,**0**,**0**]. numsright is []. The score is 3 + 0 = 3. Only index 3 has the highest possible division score 3. ``` **Example 3:** ``` **Input:** nums = [1,1] **Output:** [0] **Explanation:** Division at index - 0: numsleft is []. numsright is [**1**,**1**]. The score is 0 + 2 = 2. - 1: numsleft is [1]. numsright is [**1**]. The score is 0 + 1 = 1. - 2: numsleft is [1,1]. numsright is []. The score is 0 + 0 = 0. Only index 0 has the highest possible division score 2. ``` **Constraints:** `n == nums.length` `1 <= n <= 105` `nums[i]` is either `0` or `1`.",
        "test_case": [
            {
                "label": "Example 1",
                "input": "nums = [0,0,1,0]",
                "output": "[2,4] Explanation: Division at index\n- 0: nums left is []. nums right is [0,0, 1 ,0]. The score is 0 + 1 = 1.\n- 1: nums left is [ 0 ]. nums right is [0, 1 ,0]. The score is 1 + 1 = 2.\n- 2: nums left is [ 0 , 0 ]. nums right is [ 1 ,0]. The score is 2 + 1 = 3.\n- 3: nums left is [ 0 , 0 ,1]. nums right is [0]. The score is 2 + 0 = 2.\n- 4: nums left is [ 0 , 0 ,1, 0 ]. nums right is []. The score is 3 + 0 = 3.\nIndices 2 and 4 both have the highest possible division score 3.\nNote the answer [4,2] would also be accepted."
            },
            {
                "label": "Example 2",
                "input": "nums = [0,0,0]",
                "output": "[3] Explanation: Division at index\n- 0: nums left is []. nums right is [0,0,0]. The score is 0 + 0 = 0.\n- 1: nums left is [ 0 ]. nums right is [0,0]. The score is 1 + 0 = 1.\n- 2: nums left is [ 0 , 0 ]. nums right is [0]. The score is 2 + 0 = 2.\n- 3: nums left is [ 0 , 0 , 0 ]. nums right is []. The score is 3 + 0 = 3.\nOnly index 3 has the highest possible division score 3."
            },
            {
                "label": "Example 3",
                "input": "nums = [1,1]",
                "output": "[0] Explanation: Division at index\n- 0: nums left is []. nums right is [ 1 , 1 ]. The score is 0 + 2 = 2.\n- 1: nums left is [1]. nums right is [ 1 ]. The score is 0 + 1 = 1.\n- 2: nums left is [1,1]. nums right is []. The score is 0 + 0 = 0.\nOnly index 0 has the highest possible division score 2. Constraints: n == nums.length 1 <= n <= 10 5 nums[i] is either 0 or 1 ."
            }
        ],
        "elixir_template": "defmodule Solution do\n  @spec max_score_indices(nums :: [integer]) :: [integer]\n  def max_score_indices(nums) do\n    \n  end\nend",
        "erlang_template": "-spec max_score_indices(Nums :: [integer()]) -> [integer()].\nmax_score_indices(Nums) ->\n  .",
        "scala_template": "object Solution {\n    def maxScoreIndices(nums: Array[Int]): List[Int] = {\n        \n    }\n}"
    },
    {
        "id": 2260,
        "name": "divide-a-string-into-groups-of-size-k",
        "difficulty": "Easy",
        "link": "https://leetcode.com/problems/divide-a-string-into-groups-of-size-k/",
        "task_description": "A string `s` can be partitioned into groups of size `k` using the following procedure: The first group consists of the first `k` characters of the string, the second group consists of the next `k` characters of the string, and so on. Each character can be a part of **exactly one** group. For the last group, if the string **does not** have `k` characters remaining, a character `fill` is used to complete the group. Note that the partition is done so that after removing the `fill` character from the last group (if it exists) and concatenating all the groups in order, the resultant string should be `s`. Given the string `s`, the size of each group `k` and the character `fill`, return _a string array denoting the **composition of every group** _`s`_ has been divided into, using the above procedure_. **Example 1:** ``` **Input:** s = \"abcdefghi\", k = 3, fill = \"x\" **Output:** [\"abc\",\"def\",\"ghi\"] **Explanation:** The first 3 characters \"abc\" form the first group. The next 3 characters \"def\" form the second group. The last 3 characters \"ghi\" form the third group. Since all groups can be completely filled by characters from the string, we do not need to use fill. Thus, the groups formed are \"abc\", \"def\", and \"ghi\". ``` **Example 2:** ``` **Input:** s = \"abcdefghij\", k = 3, fill = \"x\" **Output:** [\"abc\",\"def\",\"ghi\",\"jxx\"] **Explanation:** Similar to the previous example, we are forming the first three groups \"abc\", \"def\", and \"ghi\". For the last group, we can only use the character 'j' from the string. To complete this group, we add 'x' twice. Thus, the 4 groups formed are \"abc\", \"def\", \"ghi\", and \"jxx\". ``` **Constraints:** `1 <= s.length <= 100` `s` consists of lowercase English letters only. `1 <= k <= 100` `fill` is a lowercase English letter.",
        "test_case": [
            {
                "label": "Example 1",
                "input": "s = \"abcdefghi\", k = 3, fill = \"x\"",
                "output": "[\"abc\",\"def\",\"ghi\"] Explanation: The first 3 characters \"abc\" form the first group.\nThe next 3 characters \"def\" form the second group.\nThe last 3 characters \"ghi\" form the third group.\nSince all groups can be completely filled by characters from the string, we do not need to use fill.\nThus, the groups formed are \"abc\", \"def\", and \"ghi\"."
            },
            {
                "label": "Example 2",
                "input": "s = \"abcdefghij\", k = 3, fill = \"x\"",
                "output": "[\"abc\",\"def\",\"ghi\",\"jxx\"] Explanation: Similar to the previous example, we are forming the first three groups \"abc\", \"def\", and \"ghi\".\nFor the last group, we can only use the character 'j' from the string. To complete this group, we add 'x' twice.\nThus, the 4 groups formed are \"abc\", \"def\", \"ghi\", and \"jxx\"."
            }
        ],
        "elixir_template": "defmodule Solution do\n  @spec divide_string(s :: String.t, k :: integer, fill :: char) :: [String.t]\n  def divide_string(s, k, fill) do\n    \n  end\nend",
        "erlang_template": "-spec divide_string(S :: unicode:unicode_binary(), K :: integer(), Fill :: char()) -> [unicode:unicode_binary()].\ndivide_string(S, K, Fill) ->\n  .",
        "scala_template": "object Solution {\n    def divideString(s: String, k: Int, fill: Char): Array[String] = {\n        \n    }\n}"
    },
    {
        "id": 2257,
        "name": "earliest-possible-day-of-full-bloom",
        "difficulty": "Hard",
        "link": "https://leetcode.com/problems/earliest-possible-day-of-full-bloom/",
        "task_description": "You have `n` flower seeds. Every seed must be planted first before it can begin to grow, then bloom. Planting a seed takes time and so does the growth of a seed. You are given two **0-indexed** integer arrays `plantTime` and `growTime`, of length `n` each: `plantTime[i]` is the number of **full days** it takes you to **plant** the `ith` seed. Every day, you can work on planting exactly one seed. You **do not** have to work on planting the same seed on consecutive days, but the planting of a seed is not complete **until** you have worked `plantTime[i]` days on planting it in total. `growTime[i]` is the number of **full days** it takes the `ith` seed to grow after being completely planted. **After** the last day of its growth, the flower **blooms** and stays bloomed forever. From the beginning of day `0`, you can plant the seeds in **any** order. Return _the **earliest** possible day where **all** seeds are blooming_. **Example 1:** ``` **Input:** plantTime = [1,4,3], growTime = [2,3,1] **Output:** 9 **Explanation:** The grayed out pots represent planting days, colored pots represent growing days, and the flower represents the day it blooms. One optimal way is: On day 0, plant the 0th seed. The seed grows for 2 full days and blooms on day 3. On days 1, 2, 3, and 4, plant the 1st seed. The seed grows for 3 full days and blooms on day 8. On days 5, 6, and 7, plant the 2nd seed. The seed grows for 1 full day and blooms on day 9. Thus, on day 9, all the seeds are blooming. ``` **Example 2:** ``` **Input:** plantTime = [1,2,3,2], growTime = [2,1,2,1] **Output:** 9 **Explanation:** The grayed out pots represent planting days, colored pots represent growing days, and the flower represents the day it blooms. One optimal way is: On day 1, plant the 0th seed. The seed grows for 2 full days and blooms on day 4. On days 0 and 3, plant the 1st seed. The seed grows for 1 full day and blooms on day 5. On days 2, 4, and 5, plant the 2nd seed. The seed grows for 2 full days and blooms on day 8. On days 6 and 7, plant the 3rd seed. The seed grows for 1 full day and blooms on day 9. Thus, on day 9, all the seeds are blooming. ``` **Example 3:** ``` **Input:** plantTime = [1], growTime = [1] **Output:** 2 **Explanation:** On day 0, plant the 0th seed. The seed grows for 1 full day and blooms on day 2. Thus, on day 2, all the seeds are blooming. ``` **Constraints:** `n == plantTime.length == growTime.length` `1 <= n <= 105` `1 <= plantTime[i], growTime[i] <= 104`",
        "test_case": [
            {
                "label": "Example 1",
                "input": "plantTime = [1,4,3], growTime = [2,3,1]",
                "output": "9 Explanation: The grayed out pots represent planting days, colored pots represent growing days, and the flower represents the day it blooms.\nOne optimal way is:\nOn day 0, plant the 0 th seed. The seed grows for 2 full days and blooms on day 3.\nOn days 1, 2, 3, and 4, plant the 1 st seed. The seed grows for 3 full days and blooms on day 8.\nOn days 5, 6, and 7, plant the 2 nd seed. The seed grows for 1 full day and blooms on day 9.\nThus, on day 9, all the seeds are blooming."
            },
            {
                "label": "Example 2",
                "input": "plantTime = [1,2,3,2], growTime = [2,1,2,1]",
                "output": "9 Explanation: The grayed out pots represent planting days, colored pots represent growing days, and the flower represents the day it blooms.\nOne optimal way is:\nOn day 1, plant the 0 th seed. The seed grows for 2 full days and blooms on day 4.\nOn days 0 and 3, plant the 1 st seed. The seed grows for 1 full day and blooms on day 5.\nOn days 2, 4, and 5, plant the 2 nd seed. The seed grows for 2 full days and blooms on day 8.\nOn days 6 and 7, plant the 3 rd seed. The seed grows for 1 full day and blooms on day 9.\nThus, on day 9, all the seeds are blooming."
            },
            {
                "label": "Example 3",
                "input": "plantTime = [1], growTime = [1]",
                "output": "2 Explanation: On day 0, plant the 0 th seed. The seed grows for 1 full day and blooms on day 2.\nThus, on day 2, all the seeds are blooming. Constraints: n == plantTime.length == growTime.length 1 <= n <= 10 5 1 <= plantTime[i], growTime[i] <= 10 4"
            }
        ],
        "elixir_template": "defmodule Solution do\n  @spec earliest_full_bloom(plant_time :: [integer], grow_time :: [integer]) :: integer\n  def earliest_full_bloom(plant_time, grow_time) do\n    \n  end\nend",
        "erlang_template": "-spec earliest_full_bloom(PlantTime :: [integer()], GrowTime :: [integer()]) -> integer().\nearliest_full_bloom(PlantTime, GrowTime) ->\n  .",
        "scala_template": "object Solution {\n    def earliestFullBloom(plantTime: Array[Int], growTime: Array[Int]): Int = {\n        \n    }\n}"
    },
    {
        "id": 2256,
        "name": "count-words-obtained-after-adding-a-letter",
        "difficulty": "Medium",
        "link": "https://leetcode.com/problems/count-words-obtained-after-adding-a-letter/",
        "task_description": "You are given two **0-indexed** arrays of strings `startWords` and `targetWords`. Each string consists of **lowercase English letters** only. For each string in `targetWords`, check if it is possible to choose a string from `startWords` and perform a **conversion operation** on it to be equal to that from `targetWords`. The **conversion operation** is described in the following two steps: **Append** any lowercase letter that is **not present** in the string to its end. For example, if the string is `\"abc\"`, the letters `'d'`, `'e'`, or `'y'` can be added to it, but not `'a'`. If `'d'` is added, the resulting string will be `\"abcd\"`. **Rearrange** the letters of the new string in **any** arbitrary order. For example, `\"abcd\"` can be rearranged to `\"acbd\"`, `\"bacd\"`, `\"cbda\"`, and so on. Note that it can also be rearranged to `\"abcd\"` itself. Return _the **number of strings** in _`targetWords`_ that can be obtained by performing the operations on **any** string of _`startWords`. **Note** that you will only be verifying if the string in `targetWords` can be obtained from a string in `startWords` by performing the operations. The strings in `startWords` **do not** actually change during this process. **Example 1:** ``` **Input:** startWords = [\"ant\",\"act\",\"tack\"], targetWords = [\"tack\",\"act\",\"acti\"] **Output:** 2 **Explanation:** - In order to form targetWords[0] = \"tack\", we use startWords[1] = \"act\", append 'k' to it, and rearrange \"actk\" to \"tack\". - There is no string in startWords that can be used to obtain targetWords[1] = \"act\". Note that \"act\" does exist in startWords, but we **must** append one letter to the string before rearranging it. - In order to form targetWords[2] = \"acti\", we use startWords[1] = \"act\", append 'i' to it, and rearrange \"acti\" to \"acti\" itself. ``` **Example 2:** ``` **Input:** startWords = [\"ab\",\"a\"], targetWords = [\"abc\",\"abcd\"] **Output:** 1 **Explanation:** - In order to form targetWords[0] = \"abc\", we use startWords[0] = \"ab\", add 'c' to it, and rearrange it to \"abc\". - There is no string in startWords that can be used to obtain targetWords[1] = \"abcd\". ``` **Constraints:** `1 <= startWords.length, targetWords.length <= 5 * 104` `1 <= startWords[i].length, targetWords[j].length <= 26` Each string of `startWords` and `targetWords` consists of lowercase English letters only. No letter occurs more than once in any string of `startWords` or `targetWords`.",
        "test_case": [
            {
                "label": "Example 1",
                "input": "startWords = [\"ant\",\"act\",\"tack\"], targetWords = [\"tack\",\"act\",\"acti\"]",
                "output": "2 Explanation: - In order to form targetWords[0] = \"tack\", we use startWords[1] = \"act\", append 'k' to it, and rearrange \"actk\" to \"tack\".\n- There is no string in startWords that can be used to obtain targetWords[1] = \"act\".\n  Note that \"act\" does exist in startWords, but we must append one letter to the string before rearranging it.\n- In order to form targetWords[2] = \"acti\", we use startWords[1] = \"act\", append 'i' to it, and rearrange \"acti\" to \"acti\" itself."
            },
            {
                "label": "Example 2",
                "input": "startWords = [\"ab\",\"a\"], targetWords = [\"abc\",\"abcd\"]",
                "output": "1 Explanation: - In order to form targetWords[0] = \"abc\", we use startWords[0] = \"ab\", add 'c' to it, and rearrange it to \"abc\".\n- There is no string in startWords that can be used to obtain targetWords[1] = \"abcd\"."
            }
        ],
        "elixir_template": "defmodule Solution do\n  @spec word_count(start_words :: [String.t], target_words :: [String.t]) :: integer\n  def word_count(start_words, target_words) do\n    \n  end\nend",
        "erlang_template": "-spec word_count(StartWords :: [unicode:unicode_binary()], TargetWords :: [unicode:unicode_binary()]) -> integer().\nword_count(StartWords, TargetWords) ->\n  .",
        "scala_template": "object Solution {\n    def wordCount(startWords: Array[String], targetWords: Array[String]): Int = {\n        \n    }\n}"
    },
    {
        "id": 2255,
        "name": "minimum-swaps-to-group-all-1s-together-ii",
        "difficulty": "Medium",
        "link": "https://leetcode.com/problems/minimum-swaps-to-group-all-1s-together-ii/",
        "task_description": "A **swap** is defined as taking two **distinct** positions in an array and swapping the values in them. A **circular** array is defined as an array where we consider the **first** element and the **last** element to be **adjacent**. Given a **binary** **circular** array `nums`, return _the minimum number of swaps required to group all _`1`_'s present in the array together at **any location**_. **Example 1:** ``` **Input:** nums = [0,1,0,1,1,0,0] **Output:** 1 **Explanation:** Here are a few of the ways to group all the 1's together: [0,0,1,1,1,0,0] using 1 swap. [0,1,1,1,0,0,0] using 1 swap. [1,1,0,0,0,0,1] using 2 swaps (using the circular property of the array). There is no way to group all 1's together with 0 swaps. Thus, the minimum number of swaps required is 1. ``` **Example 2:** ``` **Input:** nums = [0,1,1,1,0,0,1,1,0] **Output:** 2 **Explanation:** Here are a few of the ways to group all the 1's together: [1,1,1,0,0,0,0,1,1] using 2 swaps (using the circular property of the array). [1,1,1,1,1,0,0,0,0] using 2 swaps. There is no way to group all 1's together with 0 or 1 swaps. Thus, the minimum number of swaps required is 2. ``` **Example 3:** ``` **Input:** nums = [1,1,0,0,1] **Output:** 0 **Explanation:** All the 1's are already grouped together due to the circular property of the array. Thus, the minimum number of swaps required is 0. ``` **Constraints:** `1 <= nums.length <= 105` `nums[i]` is either `0` or `1`.",
        "test_case": [
            {
                "label": "Example 1",
                "input": "nums = [0,1,0,1,1,0,0]",
                "output": "1 Explanation: Here are a few of the ways to group all the 1's together:\n[0, 0 , 1 ,1,1,0,0] using 1 swap.\n[0,1, 1 ,1, 0 ,0,0] using 1 swap.\n[1,1,0,0,0,0,1] using 2 swaps (using the circular property of the array).\nThere is no way to group all 1's together with 0 swaps.\nThus, the minimum number of swaps required is 1."
            },
            {
                "label": "Example 2",
                "input": "nums = [0,1,1,1,0,0,1,1,0]",
                "output": "2 Explanation: Here are a few of the ways to group all the 1's together:\n[1,1,1,0,0,0,0,1,1] using 2 swaps (using the circular property of the array).\n[1,1,1,1,1,0,0,0,0] using 2 swaps.\nThere is no way to group all 1's together with 0 or 1 swaps.\nThus, the minimum number of swaps required is 2."
            },
            {
                "label": "Example 3",
                "input": "nums = [1,1,0,0,1]",
                "output": "0 Explanation: All the 1's are already grouped together due to the circular property of the array.\nThus, the minimum number of swaps required is 0."
            }
        ],
        "elixir_template": "defmodule Solution do\n  @spec min_swaps(nums :: [integer]) :: integer\n  def min_swaps(nums) do\n    \n  end\nend",
        "erlang_template": "-spec min_swaps(Nums :: [integer()]) -> integer().\nmin_swaps(Nums) ->\n  .",
        "scala_template": "object Solution {\n    def minSwaps(nums: Array[Int]): Int = {\n        \n    }\n}"
    },
    {
        "id": 2254,
        "name": "check-if-every-row-and-column-contains-all-numbers",
        "difficulty": "Easy",
        "link": "https://leetcode.com/problems/check-if-every-row-and-column-contains-all-numbers/",
        "task_description": "An `n x n` matrix is **valid** if every row and every column contains **all** the integers from `1` to `n` (**inclusive**). Given an `n x n` integer matrix `matrix`, return `true` _if the matrix is **valid**._ Otherwise, return `false`. **Example 1:** ``` **Input:** matrix = [[1,2,3],[3,1,2],[2,3,1]] **Output:** true **Explanation:** In this case, n = 3, and every row and column contains the numbers 1, 2, and 3. Hence, we return true. ``` **Example 2:** ``` **Input:** matrix = [[1,1,1],[1,2,3],[1,2,3]] **Output:** false **Explanation:** In this case, n = 3, but the first row and the first column do not contain the numbers 2 or 3. Hence, we return false. ``` **Constraints:** `n == matrix.length == matrix[i].length` `1 <= n <= 100` `1 <= matrix[i][j] <= n`",
        "test_case": [
            {
                "label": "Example 1",
                "input": "matrix = [[1,2,3],[3,1,2],[2,3,1]]",
                "output": "true Explanation: In this case, n = 3, and every row and column contains the numbers 1, 2, and 3.\nHence, we return true."
            },
            {
                "label": "Example 2",
                "input": "matrix = [[1,1,1],[1,2,3],[1,2,3]]",
                "output": "false Explanation: In this case, n = 3, but the first row and the first column do not contain the numbers 2 or 3.\nHence, we return false. Constraints: n == matrix.length == matrix[i].length 1 <= n <= 100 1 <= matrix[i][j] <= n"
            }
        ],
        "elixir_template": "defmodule Solution do\n  @spec check_valid(matrix :: [[integer]]) :: boolean\n  def check_valid(matrix) do\n    \n  end\nend",
        "erlang_template": "-spec check_valid(Matrix :: [[integer()]]) -> boolean().\ncheck_valid(Matrix) ->\n  .",
        "scala_template": "object Solution {\n    def checkValid(matrix: Array[Array[Int]]): Boolean = {\n        \n    }\n}"
    },
    {
        "id": 2251,
        "name": "number-of-ways-to-divide-a-long-corridor",
        "difficulty": "Hard",
        "link": "https://leetcode.com/problems/number-of-ways-to-divide-a-long-corridor/",
        "task_description": "Along a long library corridor, there is a line of seats and decorative plants. You are given a **0-indexed** string `corridor` of length `n` consisting of letters `'S'` and `'P'` where each `'S'` represents a seat and each `'P'` represents a plant. One room divider has **already** been installed to the left of index `0`, and **another** to the right of index `n - 1`. Additional room dividers can be installed. For each position between indices `i - 1` and `i` (`1 <= i <= n - 1`), at most one divider can be installed. Divide the corridor into non-overlapping sections, where each section has **exactly two seats** with any number of plants. There may be multiple ways to perform the division. Two ways are **different** if there is a position with a room divider installed in the first way but not in the second way. Return _the number of ways to divide the corridor_. Since the answer may be very large, return it **modulo** `109 + 7`. If there is no way, return `0`. **Example 1:** ``` **Input:** corridor = \"SSPPSPS\" **Output:** 3 **Explanation:** There are 3 different ways to divide the corridor. The black bars in the above image indicate the two room dividers already installed. Note that in each of the ways, **each** section has exactly **two** seats. ``` **Example 2:** ``` **Input:** corridor = \"PPSPSP\" **Output:** 1 **Explanation:** There is only 1 way to divide the corridor, by not installing any additional dividers. Installing any would create some section that does not have exactly two seats. ``` **Example 3:** ``` **Input:** corridor = \"S\" **Output:** 0 **Explanation:** There is no way to divide the corridor because there will always be a section that does not have exactly two seats. ``` **Constraints:** `n == corridor.length` `1 <= n <= 105` `corridor[i]` is either `'S'` or `'P'`.",
        "test_case": [
            {
                "label": "Example 1",
                "input": "corridor = \"SSPPSPS\"",
                "output": "3 Explanation: There are 3 different ways to divide the corridor.\nThe black bars in the above image indicate the two room dividers already installed.\nNote that in each of the ways, each section has exactly two seats."
            },
            {
                "label": "Example 2",
                "input": "corridor = \"PPSPSP\"",
                "output": "1 Explanation: There is only 1 way to divide the corridor, by not installing any additional dividers.\nInstalling any would create some section that does not have exactly two seats."
            },
            {
                "label": "Example 3",
                "input": "corridor = \"S\"",
                "output": "0 Explanation: There is no way to divide the corridor because there will always be a section that does not have exactly two seats. Constraints: n == corridor.length 1 <= n <= 10 5 corridor[i] is either 'S' or 'P' ."
            }
        ],
        "elixir_template": "defmodule Solution do\n  @spec number_of_ways(corridor :: String.t) :: integer\n  def number_of_ways(corridor) do\n    \n  end\nend",
        "erlang_template": "-spec number_of_ways(Corridor :: unicode:unicode_binary()) -> integer().\nnumber_of_ways(Corridor) ->\n  .",
        "scala_template": "object Solution {\n    def numberOfWays(corridor: String): Int = {\n        \n    }\n}"
    },
    {
        "id": 2250,
        "name": "k-highest-ranked-items-within-a-price-range",
        "difficulty": "Medium",
        "link": "https://leetcode.com/problems/k-highest-ranked-items-within-a-price-range/",
        "task_description": "You are given a **0-indexed** 2D integer array `grid` of size `m x n` that represents a map of the items in a shop. The integers in the grid represent the following: `0` represents a wall that you cannot pass through. `1` represents an empty cell that you can freely move to and from. All other positive integers represent the price of an item in that cell. You may also freely move to and from these item cells. It takes `1` step to travel between adjacent grid cells. You are also given integer arrays `pricing` and `start` where `pricing = [low, high]` and `start = [row, col]` indicates that you start at the position `(row, col)` and are interested only in items with a price in the range of `[low, high]` (**inclusive**). You are further given an integer `k`. You are interested in the **positions** of the `k` **highest-ranked** items whose prices are **within** the given price range. The rank is determined by the **first** of these criteria that is different: Distance, defined as the length of the shortest path from the `start` (**shorter** distance has a higher rank). Price (**lower** price has a higher rank, but it must be **in the price range**). The row number (**smaller** row number has a higher rank). The column number (**smaller** column number has a higher rank). Return _the _`k`_ highest-ranked items within the price range **sorted** by their rank (highest to lowest)_. If there are fewer than `k` reachable items within the price range, return _**all** of them_. **Example 1:** ``` **Input:** grid = [[1,2,0,1],[1,3,0,1],[0,2,5,1]], pricing = [2,5], start = [0,0], k = 3 **Output:** [[0,1],[1,1],[2,1]] **Explanation:** You start at (0,0). With a price range of [2,5], we can take items from (0,1), (1,1), (2,1) and (2,2). The ranks of these items are: - (0,1) with distance 1 - (1,1) with distance 2 - (2,1) with distance 3 - (2,2) with distance 4 Thus, the 3 highest ranked items in the price range are (0,1), (1,1), and (2,1). ``` **Example 2:** ``` **Input:** grid = [[1,2,0,1],[1,3,3,1],[0,2,5,1]], pricing = [2,3], start = [2,3], k = 2 **Output:** [[2,1],[1,2]] **Explanation:** You start at (2,3). With a price range of [2,3], we can take items from (0,1), (1,1), (1,2) and (2,1). The ranks of these items are: - (2,1) with distance 2, price 2 - (1,2) with distance 2, price 3 - (1,1) with distance 3 - (0,1) with distance 4 Thus, the 2 highest ranked items in the price range are (2,1) and (1,2). ``` **Example 3:** ``` **Input:** grid = [[1,1,1],[0,0,1],[2,3,4]], pricing = [2,3], start = [0,0], k = 3 **Output:** [[2,1],[2,0]] **Explanation:** You start at (0,0). With a price range of [2,3], we can take items from (2,0) and (2,1). The ranks of these items are: - (2,1) with distance 5 - (2,0) with distance 6 Thus, the 2 highest ranked items in the price range are (2,1) and (2,0). Note that k = 3 but there are only 2 reachable items within the price range. ``` **Constraints:** `m == grid.length` `n == grid[i].length` `1 <= m, n <= 105` `1 <= m * n <= 105` `0 <= grid[i][j] <= 105` `pricing.length == 2` `2 <= low <= high <= 105` `start.length == 2` `0 <= row <= m - 1` `0 <= col <= n - 1` `grid[row][col] > 0` `1 <= k <= m * n`",
        "test_case": [
            {
                "label": "Example 1",
                "input": "grid = [[1,2,0,1],[1,3,0,1],[0,2,5,1]], pricing = [2,5], start = [0,0], k = 3",
                "output": "[[0,1],[1,1],[2,1]] Explanation: You start at (0,0).\nWith a price range of [2,5], we can take items from (0,1), (1,1), (2,1) and (2,2).\nThe ranks of these items are:\n- (0,1) with distance 1\n- (1,1) with distance 2\n- (2,1) with distance 3\n- (2,2) with distance 4\nThus, the 3 highest ranked items in the price range are (0,1), (1,1), and (2,1)."
            },
            {
                "label": "Example 2",
                "input": "grid = [[1,2,0,1],[1,3,3,1],[0,2,5,1]], pricing = [2,3], start = [2,3], k = 2",
                "output": "[[2,1],[1,2]] Explanation: You start at (2,3).\nWith a price range of [2,3], we can take items from (0,1), (1,1), (1,2) and (2,1).\nThe ranks of these items are:\n- (2,1) with distance 2, price 2\n- (1,2) with distance 2, price 3\n- (1,1) with distance 3\n- (0,1) with distance 4\nThus, the 2 highest ranked items in the price range are (2,1) and (1,2)."
            },
            {
                "label": "Example 3",
                "input": "grid = [[1,1,1],[0,0,1],[2,3,4]], pricing = [2,3], start = [0,0], k = 3",
                "output": "[[2,1],[2,0]] Explanation: You start at (0,0).\nWith a price range of [2,3], we can take items from (2,0) and (2,1). \nThe ranks of these items are: \n- (2,1) with distance 5\n- (2,0) with distance 6\nThus, the 2 highest ranked items in the price range are (2,1) and (2,0). \nNote that k = 3 but there are only 2 reachable items within the price range. Constraints: m == grid.length n == grid[i].length 1 <= m, n <= 10 5 1 <= m * n <= 10 5 0 <= grid[i][j] <= 10 5 pricing.length == 2 2 <= low <= high <= 10 5 start.length == 2 0 <= row <= m - 1 0 <= col <= n - 1 grid[row][col] > 0 1 <= k <= m * n"
            }
        ],
        "elixir_template": "defmodule Solution do\n  @spec highest_ranked_k_items(grid :: [[integer]], pricing :: [integer], start :: [integer], k :: integer) :: [[integer]]\n  def highest_ranked_k_items(grid, pricing, start, k) do\n    \n  end\nend",
        "erlang_template": "-spec highest_ranked_k_items(Grid :: [[integer()]], Pricing :: [integer()], Start :: [integer()], K :: integer()) -> [[integer()]].\nhighest_ranked_k_items(Grid, Pricing, Start, K) ->\n  .",
        "scala_template": "object Solution {\n    def highestRankedKItems(grid: Array[Array[Int]], pricing: Array[Int], start: Array[Int], k: Int): List[List[Int]] = {\n        \n    }\n}"
    },
    {
        "id": 2249,
        "name": "count-the-hidden-sequences",
        "difficulty": "Medium",
        "link": "https://leetcode.com/problems/count-the-hidden-sequences/",
        "task_description": "You are given a **0-indexed** array of `n` integers `differences`, which describes the **differences **between each pair of **consecutive **integers of a **hidden** sequence of length `(n + 1)`. More formally, call the hidden sequence `hidden`, then we have that `differences[i] = hidden[i + 1] - hidden[i]`. You are further given two integers `lower` and `upper` that describe the **inclusive** range of values `[lower, upper]` that the hidden sequence can contain. For example, given `differences = [1, -3, 4]`, `lower = 1`, `upper = 6`, the hidden sequence is a sequence of length `4` whose elements are in between `1` and `6` (**inclusive**). `[3, 4, 1, 5]` and `[4, 5, 2, 6]` are possible hidden sequences. `[5, 6, 3, 7]` is not possible since it contains an element greater than `6`. `[1, 2, 3, 4]` is not possible since the differences are not correct. Return _the number of **possible** hidden sequences there are._ If there are no possible sequences, return `0`. **Example 1:** ``` **Input:** differences = [1,-3,4], lower = 1, upper = 6 **Output:** 2 **Explanation:** The possible hidden sequences are: - [3, 4, 1, 5] - [4, 5, 2, 6] Thus, we return 2. ``` **Example 2:** ``` **Input:** differences = [3,-4,5,1,-2], lower = -4, upper = 5 **Output:** 4 **Explanation:** The possible hidden sequences are: - [-3, 0, -4, 1, 2, 0] - [-2, 1, -3, 2, 3, 1] - [-1, 2, -2, 3, 4, 2] - [0, 3, -1, 4, 5, 3] Thus, we return 4. ``` **Example 3:** ``` **Input:** differences = [4,-7,2], lower = 3, upper = 6 **Output:** 0 **Explanation:** There are no possible hidden sequences. Thus, we return 0. ``` **Constraints:** `n == differences.length` `1 <= n <= 105` `-105 <= differences[i] <= 105` `-105 <= lower <= upper <= 105`",
        "test_case": [
            {
                "label": "Example 1",
                "input": "differences = [1,-3,4], lower = 1, upper = 6",
                "output": "2 Explanation: The possible hidden sequences are:\n- [3, 4, 1, 5]\n- [4, 5, 2, 6]\nThus, we return 2."
            },
            {
                "label": "Example 2",
                "input": "differences = [3,-4,5,1,-2], lower = -4, upper = 5",
                "output": "4 Explanation: The possible hidden sequences are:\n- [-3, 0, -4, 1, 2, 0]\n- [-2, 1, -3, 2, 3, 1]\n- [-1, 2, -2, 3, 4, 2]\n- [0, 3, -1, 4, 5, 3]\nThus, we return 4."
            },
            {
                "label": "Example 3",
                "input": "differences = [4,-7,2], lower = 3, upper = 6",
                "output": "0 Explanation: There are no possible hidden sequences. Thus, we return 0. Constraints: n == differences.length 1 <= n <= 10 5 -10 5 <= differences[i] <= 10 5 -10 5 <= lower <= upper <= 10 5"
            }
        ],
        "elixir_template": "defmodule Solution do\n  @spec number_of_arrays(differences :: [integer], lower :: integer, upper :: integer) :: integer\n  def number_of_arrays(differences, lower, upper) do\n    \n  end\nend",
        "erlang_template": "-spec number_of_arrays(Differences :: [integer()], Lower :: integer(), Upper :: integer()) -> integer().\nnumber_of_arrays(Differences, Lower, Upper) ->\n  .",
        "scala_template": "object Solution {\n    def numberOfArrays(differences: Array[Int], lower: Int, upper: Int): Int = {\n        \n    }\n}"
    },
    {
        "id": 2248,
        "name": "minimum-cost-of-buying-candies-with-discount",
        "difficulty": "Easy",
        "link": "https://leetcode.com/problems/minimum-cost-of-buying-candies-with-discount/",
        "task_description": "A shop is selling candies at a discount. For **every two** candies sold, the shop gives a **third** candy for **free**. The customer can choose **any** candy to take away for free as long as the cost of the chosen candy is less than or equal to the **minimum** cost of the two candies bought. For example, if there are `4` candies with costs `1`, `2`, `3`, and `4`, and the customer buys candies with costs `2` and `3`, they can take the candy with cost `1` for free, but not the candy with cost `4`. Given a **0-indexed** integer array `cost`, where `cost[i]` denotes the cost of the `ith` candy, return _the **minimum cost** of buying **all** the candies_. **Example 1:** ``` **Input:** cost = [1,2,3] **Output:** 5 **Explanation:** We buy the candies with costs 2 and 3, and take the candy with cost 1 for free. The total cost of buying all candies is 2 + 3 = 5. This is the **only** way we can buy the candies. Note that we cannot buy candies with costs 1 and 3, and then take the candy with cost 2 for free. The cost of the free candy has to be less than or equal to the minimum cost of the purchased candies. ``` **Example 2:** ``` **Input:** cost = [6,5,7,9,2,2] **Output:** 23 **Explanation:** The way in which we can get the minimum cost is described below: - Buy candies with costs 9 and 7 - Take the candy with cost 6 for free - We buy candies with costs 5 and 2 - Take the last remaining candy with cost 2 for free Hence, the minimum cost to buy all candies is 9 + 7 + 5 + 2 = 23. ``` **Example 3:** ``` **Input:** cost = [5,5] **Output:** 10 **Explanation:** Since there are only 2 candies, we buy both of them. There is not a third candy we can take for free. Hence, the minimum cost to buy all candies is 5 + 5 = 10. ``` **Constraints:** `1 <= cost.length <= 100` `1 <= cost[i] <= 100`",
        "test_case": [
            {
                "label": "Example 1",
                "input": "cost = [1,2,3]",
                "output": "5 Explanation: We buy the candies with costs 2 and 3, and take the candy with cost 1 for free.\nThe total cost of buying all candies is 2 + 3 = 5. This is the only way we can buy the candies.\nNote that we cannot buy candies with costs 1 and 3, and then take the candy with cost 2 for free.\nThe cost of the free candy has to be less than or equal to the minimum cost of the purchased candies."
            },
            {
                "label": "Example 2",
                "input": "cost = [6,5,7,9,2,2]",
                "output": "23 Explanation: The way in which we can get the minimum cost is described below:\n- Buy candies with costs 9 and 7\n- Take the candy with cost 6 for free\n- We buy candies with costs 5 and 2\n- Take the last remaining candy with cost 2 for free\nHence, the minimum cost to buy all candies is 9 + 7 + 5 + 2 = 23."
            },
            {
                "label": "Example 3",
                "input": "cost = [5,5]",
                "output": "10 Explanation: Since there are only 2 candies, we buy both of them. There is not a third candy we can take for free.\nHence, the minimum cost to buy all candies is 5 + 5 = 10."
            }
        ],
        "elixir_template": "defmodule Solution do\n  @spec minimum_cost(cost :: [integer]) :: integer\n  def minimum_cost(cost) do\n    \n  end\nend",
        "erlang_template": "-spec minimum_cost(Cost :: [integer()]) -> integer().\nminimum_cost(Cost) ->\n  .",
        "scala_template": "object Solution {\n    def minimumCost(cost: Array[Int]): Int = {\n        \n    }\n}"
    },
    {
        "id": 2246,
        "name": "maximum-employees-to-be-invited-to-a-meeting",
        "difficulty": "Hard",
        "link": "https://leetcode.com/problems/maximum-employees-to-be-invited-to-a-meeting/",
        "task_description": "A company is organizing a meeting and has a list of `n` employees, waiting to be invited. They have arranged for a large **circular** table, capable of seating **any number** of employees. The employees are numbered from `0` to `n - 1`. Each employee has a **favorite** person and they will attend the meeting **only if** they can sit next to their favorite person at the table. The favorite person of an employee is **not** themself. Given a **0-indexed** integer array `favorite`, where `favorite[i]` denotes the favorite person of the `ith` employee, return _the **maximum number of employees** that can be invited to the meeting_. **Example 1:** ``` **Input:** favorite = [2,2,1,2] **Output:** 3 **Explanation:** The above figure shows how the company can invite employees 0, 1, and 2, and seat them at the round table. All employees cannot be invited because employee 2 cannot sit beside employees 0, 1, and 3, simultaneously. Note that the company can also invite employees 1, 2, and 3, and give them their desired seats. The maximum number of employees that can be invited to the meeting is 3. ``` **Example 2:** ``` **Input:** favorite = [1,2,0] **Output:** 3 **Explanation:** Each employee is the favorite person of at least one other employee, and the only way the company can invite them is if they invite every employee. The seating arrangement will be the same as that in the figure given in example 1: - Employee 0 will sit between employees 2 and 1. - Employee 1 will sit between employees 0 and 2. - Employee 2 will sit between employees 1 and 0. The maximum number of employees that can be invited to the meeting is 3. ``` **Example 3:** ``` **Input:** favorite = [3,0,1,4,1] **Output:** 4 **Explanation:** The above figure shows how the company will invite employees 0, 1, 3, and 4, and seat them at the round table. Employee 2 cannot be invited because the two spots next to their favorite employee 1 are taken. So the company leaves them out of the meeting. The maximum number of employees that can be invited to the meeting is 4. ``` **Constraints:** `n == favorite.length` `2 <= n <= 105` `0 <= favorite[i] <= n - 1` `favorite[i] != i`",
        "test_case": [
            {
                "label": "Example 1",
                "input": "favorite = [2,2,1,2]",
                "output": "3 Explanation: The above figure shows how the company can invite employees 0, 1, and 2, and seat them at the round table.\nAll employees cannot be invited because employee 2 cannot sit beside employees 0, 1, and 3, simultaneously.\nNote that the company can also invite employees 1, 2, and 3, and give them their desired seats.\nThe maximum number of employees that can be invited to the meeting is 3."
            },
            {
                "label": "Example 2",
                "input": "favorite = [1,2,0]",
                "output": "3 Explanation: Each employee is the favorite person of at least one other employee, and the only way the company can invite them is if they invite every employee.\nThe seating arrangement will be the same as that in the figure given in example 1:\n- Employee 0 will sit between employees 2 and 1.\n- Employee 1 will sit between employees 0 and 2.\n- Employee 2 will sit between employees 1 and 0.\nThe maximum number of employees that can be invited to the meeting is 3."
            },
            {
                "label": "Example 3",
                "input": "favorite = [3,0,1,4,1]",
                "output": "4 Explanation: The above figure shows how the company will invite employees 0, 1, 3, and 4, and seat them at the round table.\nEmployee 2 cannot be invited because the two spots next to their favorite employee 1 are taken.\nSo the company leaves them out of the meeting.\nThe maximum number of employees that can be invited to the meeting is 4. Constraints: n == favorite.length 2 <= n <= 10 5 0 <= favorite[i] <=\u00a0n - 1 favorite[i] != i"
            }
        ],
        "elixir_template": "defmodule Solution do\n  @spec maximum_invitations(favorite :: [integer]) :: integer\n  def maximum_invitations(favorite) do\n    \n  end\nend",
        "erlang_template": "-spec maximum_invitations(Favorite :: [integer()]) -> integer().\nmaximum_invitations(Favorite) ->\n  .",
        "scala_template": "object Solution {\n    def maximumInvitations(favorite: Array[Int]): Int = {\n        \n    }\n}"
    },
    {
        "id": 2245,
        "name": "destroying-asteroids",
        "difficulty": "Medium",
        "link": "https://leetcode.com/problems/destroying-asteroids/",
        "task_description": "You are given an integer `mass`, which represents the original mass of a planet. You are further given an integer array `asteroids`, where `asteroids[i]` is the mass of the `ith` asteroid. You can arrange for the planet to collide with the asteroids in **any arbitrary order**. If the mass of the planet is greater than or equal to the mass of the asteroid, the asteroid is **destroyed** and the planet **gains** the mass of the asteroid. Otherwise, the planet is destroyed. Return `true`_ if **all** asteroids can be destroyed. Otherwise, return _`false`_._ **Example 1:** ``` **Input:** mass = 10, asteroids = [3,9,19,5,21] **Output:** true **Explanation:** One way to order the asteroids is [9,19,5,3,21]: - The planet collides with the asteroid with a mass of 9. New planet mass: 10 + 9 = 19 - The planet collides with the asteroid with a mass of 19. New planet mass: 19 + 19 = 38 - The planet collides with the asteroid with a mass of 5. New planet mass: 38 + 5 = 43 - The planet collides with the asteroid with a mass of 3. New planet mass: 43 + 3 = 46 - The planet collides with the asteroid with a mass of 21. New planet mass: 46 + 21 = 67 All asteroids are destroyed. ``` **Example 2:** ``` **Input:** mass = 5, asteroids = [4,9,23,4] **Output:** false **Explanation:** The planet cannot ever gain enough mass to destroy the asteroid with a mass of 23. After the planet destroys the other asteroids, it will have a mass of 5 + 4 + 9 + 4 = 22. This is less than 23, so a collision would not destroy the last asteroid. ``` **Constraints:** `1 <= mass <= 105` `1 <= asteroids.length <= 105` `1 <= asteroids[i] <= 105`",
        "test_case": [
            {
                "label": "Example 1",
                "input": "mass = 10, asteroids = [3,9,19,5,21]",
                "output": "true Explanation: One way to order the asteroids is [9,19,5,3,21]:\n- The planet collides with the asteroid with a mass of 9. New planet mass: 10 + 9 = 19\n- The planet collides with the asteroid with a mass of 19. New planet mass: 19 + 19 = 38\n- The planet collides with the asteroid with a mass of 5. New planet mass: 38 + 5 = 43\n- The planet collides with the asteroid with a mass of 3. New planet mass: 43 + 3 = 46\n- The planet collides with the asteroid with a mass of 21. New planet mass: 46 + 21 = 67\nAll asteroids are destroyed."
            },
            {
                "label": "Example 2",
                "input": "mass = 5, asteroids = [4,9,23,4]",
                "output": "false Explanation: The planet cannot ever gain enough mass to destroy the asteroid with a mass of 23.\nAfter the planet destroys the other asteroids, it will have a mass of 5 + 4 + 9 + 4 = 22.\nThis is less than 23, so a collision would not destroy the last asteroid."
            }
        ],
        "elixir_template": "defmodule Solution do\n  @spec asteroids_destroyed(mass :: integer, asteroids :: [integer]) :: boolean\n  def asteroids_destroyed(mass, asteroids) do\n    \n  end\nend",
        "erlang_template": "-spec asteroids_destroyed(Mass :: integer(), Asteroids :: [integer()]) -> boolean().\nasteroids_destroyed(Mass, Asteroids) ->\n  .",
        "scala_template": "object Solution {\n    def asteroidsDestroyed(mass: Int, asteroids: Array[Int]): Boolean = {\n        \n    }\n}"
    },
    {
        "id": 2244,
        "name": "number-of-laser-beams-in-a-bank",
        "difficulty": "Medium",
        "link": "https://leetcode.com/problems/number-of-laser-beams-in-a-bank/",
        "task_description": "Anti-theft security devices are activated inside a bank. You are given a **0-indexed** binary string array `bank` representing the floor plan of the bank, which is an `m x n` 2D matrix. `bank[i]` represents the `ith` row, consisting of `'0'`s and `'1'`s. `'0'` means the cell is empty, while`'1'` means the cell has a security device. There is **one** laser beam between any **two** security devices **if both** conditions are met: The two devices are located on two **different rows**: `r1` and `r2`, where `r1 < r2`. For **each** row `i` where `r1 < i < r2`, there are **no security devices** in the `ith` row. Laser beams are independent, i.e., one beam does not interfere nor join with another. Return _the total number of laser beams in the bank_. **Example 1:** ``` **Input:** bank = [\"011001\",\"000000\",\"010100\",\"001000\"] **Output:** 8 **Explanation:** Between each of the following device pairs, there is one beam. In total, there are 8 beams: * bank[0][1] -- bank[2][1] * bank[0][1] -- bank[2][3] * bank[0][2] -- bank[2][1] * bank[0][2] -- bank[2][3] * bank[0][5] -- bank[2][1] * bank[0][5] -- bank[2][3] * bank[2][1] -- bank[3][2] * bank[2][3] -- bank[3][2] Note that there is no beam between any device on the 0th row with any on the 3rd row. This is because the 2nd row contains security devices, which breaks the second condition. ``` **Example 2:** ``` **Input:** bank = [\"000\",\"111\",\"000\"] **Output:** 0 **Explanation:** There does not exist two devices located on two different rows. ``` **Constraints:** `m == bank.length` `n == bank[i].length` `1 <= m, n <= 500` `bank[i][j]` is either `'0'` or `'1'`.",
        "test_case": [
            {
                "label": "Example 1",
                "input": "bank = [\"011001\",\"000000\",\"010100\",\"001000\"]",
                "output": "8 Explanation: Between each of the following device pairs, there is one beam. In total, there are 8 beams:\n * bank[0][1] -- bank[2][1]\n * bank[0][1] -- bank[2][3]\n * bank[0][2] -- bank[2][1]\n * bank[0][2] -- bank[2][3]\n * bank[0][5] -- bank[2][1]\n * bank[0][5] -- bank[2][3]\n * bank[2][1] -- bank[3][2]\n * bank[2][3] -- bank[3][2]\nNote that there is no beam between any device on the 0 th row with any on the 3 rd row.\nThis is because the 2 nd row contains security devices, which breaks the second condition."
            },
            {
                "label": "Example 2",
                "input": "bank = [\"000\",\"111\",\"000\"]",
                "output": "0 Explanation: There does not exist two devices located on two different rows. Constraints: m == bank.length n == bank[i].length 1 <= m, n <= 500 bank[i][j] is either '0' or '1' ."
            }
        ],
        "elixir_template": "defmodule Solution do\n  @spec number_of_beams(bank :: [String.t]) :: integer\n  def number_of_beams(bank) do\n    \n  end\nend",
        "erlang_template": "-spec number_of_beams(Bank :: [unicode:unicode_binary()]) -> integer().\nnumber_of_beams(Bank) ->\n  .",
        "scala_template": "object Solution {\n    def numberOfBeams(bank: Array[String]): Int = {\n        \n    }\n}"
    },
    {
        "id": 2243,
        "name": "check-if-all-as-appears-before-all-bs",
        "difficulty": "Easy",
        "link": "https://leetcode.com/problems/check-if-all-as-appears-before-all-bs/",
        "task_description": "Given a string `s` consisting of **only** the characters `'a'` and `'b'`, return `true` _if **every** _`'a'` _appears before **every** _`'b'`_ in the string_. Otherwise, return `false`. **Example 1:** ``` **Input:** s = \"aaabbb\" **Output:** true **Explanation:** The 'a's are at indices 0, 1, and 2, while the 'b's are at indices 3, 4, and 5. Hence, every 'a' appears before every 'b' and we return true. ``` **Example 2:** ``` **Input:** s = \"abab\" **Output:** false **Explanation:** There is an 'a' at index 2 and a 'b' at index 1. Hence, not every 'a' appears before every 'b' and we return false. ``` **Example 3:** ``` **Input:** s = \"bbb\" **Output:** true **Explanation:** There are no 'a's, hence, every 'a' appears before every 'b' and we return true. ``` **Constraints:** `1 <= s.length <= 100` `s[i]` is either `'a'` or `'b'`.",
        "test_case": [
            {
                "label": "Example 1",
                "input": "s = \"aaabbb\"",
                "output": "true Explanation: The 'a's are at indices 0, 1, and 2, while the 'b's are at indices 3, 4, and 5.\nHence, every 'a' appears before every 'b' and we return true."
            },
            {
                "label": "Example 2",
                "input": "s = \"abab\"",
                "output": "false Explanation: There is an 'a' at index 2 and a 'b' at index 1.\nHence, not every 'a' appears before every 'b' and we return false."
            },
            {
                "label": "Example 3",
                "input": "s = \"bbb\"",
                "output": "true Explanation: There are no 'a's, hence, every 'a' appears before every 'b' and we return true."
            }
        ],
        "elixir_template": "defmodule Solution do\n  @spec check_string(s :: String.t) :: boolean\n  def check_string(s) do\n    \n  end\nend",
        "erlang_template": "-spec check_string(S :: unicode:unicode_binary()) -> boolean().\ncheck_string(S) ->\n  .",
        "scala_template": "object Solution {\n    def checkString(s: String): Boolean = {\n        \n    }\n}"
    },
    {
        "id": 2241,
        "name": "recover-the-original-array",
        "difficulty": "Hard",
        "link": "https://leetcode.com/problems/recover-the-original-array/",
        "task_description": "Alice had a **0-indexed** array `arr` consisting of `n` **positive** integers. She chose an arbitrary **positive integer** `k` and created two new **0-indexed** integer arrays `lower` and `higher` in the following manner: `lower[i] = arr[i] - k`, for every index `i` where `0 <= i < n` `higher[i] = arr[i] + k`, for every index `i` where `0 <= i < n` Unfortunately, Alice lost all three arrays. However, she remembers the integers that were present in the arrays `lower` and `higher`, but not the array each integer belonged to. Help Alice and recover the original array. Given an array `nums` consisting of `2n` integers, where **exactly** `n` of the integers were present in `lower` and the remaining in `higher`, return _the **original** array_ `arr`. In case the answer is not unique, return _**any** valid array_. **Note:** The test cases are generated such that there exists **at least one** valid array `arr`. **Example 1:** ``` **Input:** nums = [2,10,6,4,8,12] **Output:** [3,7,11] **Explanation:** If arr = [3,7,11] and k = 1, we get lower = [2,6,10] and higher = [4,8,12]. Combining lower and higher gives us [2,6,10,4,8,12], which is a permutation of nums. Another valid possibility is that arr = [5,7,9] and k = 3. In that case, lower = [2,4,6] and higher = [8,10,12]. ``` **Example 2:** ``` **Input:** nums = [1,1,3,3] **Output:** [2,2] **Explanation:** If arr = [2,2] and k = 1, we get lower = [1,1] and higher = [3,3]. Combining lower and higher gives us [1,1,3,3], which is equal to nums. Note that arr cannot be [1,3] because in that case, the only possible way to obtain [1,1,3,3] is with k = 0. This is invalid since k must be positive. ``` **Example 3:** ``` **Input:** nums = [5,435] **Output:** [220] **Explanation:** The only possible combination is arr = [220] and k = 215. Using them, we get lower = [5] and higher = [435]. ``` **Constraints:** `2 * n == nums.length` `1 <= n <= 1000` `1 <= nums[i] <= 109` The test cases are generated such that there exists **at least one** valid array `arr`.",
        "test_case": [
            {
                "label": "Example 1",
                "input": "nums = [2,10,6,4,8,12]",
                "output": "[3,7,11] Explanation: If arr = [3,7,11] and k = 1, we get lower = [2,6,10] and higher = [4,8,12].\nCombining lower and higher gives us [2,6,10,4,8,12], which is a permutation of nums.\nAnother valid possibility is that arr = [5,7,9] and k = 3. In that case, lower = [2,4,6] and higher = [8,10,12]."
            },
            {
                "label": "Example 2",
                "input": "nums = [1,1,3,3]",
                "output": "[2,2] Explanation: If arr = [2,2] and k = 1, we get lower = [1,1] and higher = [3,3].\nCombining lower and higher gives us [1,1,3,3], which is equal to nums.\nNote that arr cannot be [1,3] because in that case, the only possible way to obtain [1,1,3,3] is with k = 0.\nThis is invalid since k must be positive."
            },
            {
                "label": "Example 3",
                "input": "nums = [5,435]",
                "output": "[220] Explanation: The only possible combination is arr = [220] and k = 215. Using them, we get lower = [5] and higher = [435]."
            }
        ],
        "elixir_template": "defmodule Solution do\n  @spec recover_array(nums :: [integer]) :: [integer]\n  def recover_array(nums) do\n    \n  end\nend",
        "erlang_template": "-spec recover_array(Nums :: [integer()]) -> [integer()].\nrecover_array(Nums) ->\n  .",
        "scala_template": "object Solution {\n    def recoverArray(nums: Array[Int]): Array[Int] = {\n        \n    }\n}"
    },
    {
        "id": 2240,
        "name": "intervals-between-identical-elements",
        "difficulty": "Medium",
        "link": "https://leetcode.com/problems/intervals-between-identical-elements/",
        "task_description": "You are given a **0-indexed** array of `n` integers `arr`. The **interval** between two elements in `arr` is defined as the **absolute difference** between their indices. More formally, the **interval** between `arr[i]` and `arr[j]` is `|i - j|`. Return _an array_ `intervals` _of length_ `n` _where_ `intervals[i]` _is **the sum of intervals** between _`arr[i]`_ and each element in _`arr`_ with the same value as _`arr[i]`_._ **Note:** `|x|` is the absolute value of `x`. **Example 1:** ``` **Input:** arr = [2,1,3,1,2,3,3] **Output:** [4,2,7,2,4,4,5] **Explanation:** - Index 0: Another 2 is found at index 4. |0 - 4| = 4 - Index 1: Another 1 is found at index 3. |1 - 3| = 2 - Index 2: Two more 3s are found at indices 5 and 6. |2 - 5| + |2 - 6| = 7 - Index 3: Another 1 is found at index 1. |3 - 1| = 2 - Index 4: Another 2 is found at index 0. |4 - 0| = 4 - Index 5: Two more 3s are found at indices 2 and 6. |5 - 2| + |5 - 6| = 4 - Index 6: Two more 3s are found at indices 2 and 5. |6 - 2| + |6 - 5| = 5 ``` **Example 2:** ``` **Input:** arr = [10,5,10,10] **Output:** [5,0,3,4] **Explanation:** - Index 0: Two more 10s are found at indices 2 and 3. |0 - 2| + |0 - 3| = 5 - Index 1: There is only one 5 in the array, so its sum of intervals to identical elements is 0. - Index 2: Two more 10s are found at indices 0 and 3. |2 - 0| + |2 - 3| = 3 - Index 3: Two more 10s are found at indices 0 and 2. |3 - 0| + |3 - 2| = 4 ``` **Constraints:** `n == arr.length` `1 <= n <= 105` `1 <= arr[i] <= 105` **Note:** This question is the same as 2615: Sum of Distances.",
        "test_case": [
            {
                "label": "Example 1",
                "input": "arr = [2,1,3,1,2,3,3]",
                "output": "[4,2,7,2,4,4,5] Explanation: - Index 0: Another 2 is found at index 4. |0 - 4| = 4\n- Index 1: Another 1 is found at index 3. |1 - 3| = 2\n- Index 2: Two more 3s are found at indices 5 and 6. |2 - 5| + |2 - 6| = 7\n- Index 3: Another 1 is found at index 1. |3 - 1| = 2\n- Index 4: Another 2 is found at index 0. |4 - 0| = 4\n- Index 5: Two more 3s are found at indices 2 and 6. |5 - 2| + |5 - 6| = 4\n- Index 6: Two more 3s are found at indices 2 and 5. |6 - 2| + |6 - 5| = 5"
            },
            {
                "label": "Example 2",
                "input": "arr = [10,5,10,10]",
                "output": "[5,0,3,4] Explanation: - Index 0: Two more 10s are found at indices 2 and 3. |0 - 2| + |0 - 3| = 5\n- Index 1: There is only one 5 in the array, so its sum of intervals to identical elements is 0.\n- Index 2: Two more 10s are found at indices 0 and 3. |2 - 0| + |2 - 3| = 3\n- Index 3: Two more 10s are found at indices 0 and 2. |3 - 0| + |3 - 2| = 4 Constraints: n == arr.length 1 <= n <= 10 5 1 <= arr[i] <= 10 5 Note: This question is the same as 2615: Sum of Distances."
            }
        ],
        "elixir_template": "defmodule Solution do\n  @spec get_distances(arr :: [integer]) :: [integer]\n  def get_distances(arr) do\n    \n  end\nend",
        "erlang_template": "-spec get_distances(Arr :: [integer()]) -> [integer()].\nget_distances(Arr) ->\n  .",
        "scala_template": "object Solution {\n    def getDistances(arr: Array[Int]): Array[Long] = {\n        \n    }\n}"
    },
    {
        "id": 2239,
        "name": "execution-of-all-suffix-instructions-staying-in-a-grid",
        "difficulty": "Medium",
        "link": "https://leetcode.com/problems/execution-of-all-suffix-instructions-staying-in-a-grid/",
        "task_description": "There is an `n x n` grid, with the top-left cell at `(0, 0)` and the bottom-right cell at `(n - 1, n - 1)`. You are given the integer `n` and an integer array `startPos` where `startPos = [startrow, startcol]` indicates that a robot is initially at cell `(startrow, startcol)`. You are also given a **0-indexed** string `s` of length `m` where `s[i]` is the `ith` instruction for the robot: `'L'` (move left), `'R'` (move right), `'U'` (move up), and `'D'` (move down). The robot can begin executing from any `ith` instruction in `s`. It executes the instructions one by one towards the end of `s` but it stops if either of these conditions is met: The next instruction will move the robot off the grid. There are no more instructions left to execute. Return _an array_ `answer` _of length_ `m` _where_ `answer[i]` _is **the number of instructions** the robot can execute if the robot **begins executing from** the_ `ith` _instruction in_ `s`. **Example 1:** ``` **Input:** n = 3, startPos = [0,1], s = \"RRDDLU\" **Output:** [1,5,4,3,1,0] **Explanation:** Starting from startPos and beginning execution from the ith instruction: - 0th: \"**R**RDDLU\". Only one instruction \"R\" can be executed before it moves off the grid. - 1st: \"**RDDLU**\". All five instructions can be executed while it stays in the grid and ends at (1, 1). - 2nd: \"**DDLU**\". All four instructions can be executed while it stays in the grid and ends at (1, 0). - 3rd: \"**DLU**\". All three instructions can be executed while it stays in the grid and ends at (0, 0). - 4th: \"**L**U\". Only one instruction \"L\" can be executed before it moves off the grid. - 5th: \"U\". If moving up, it would move off the grid. ``` **Example 2:** ``` **Input:** n = 2, startPos = [1,1], s = \"LURD\" **Output:** [4,1,0,0] **Explanation:** - 0th: \"**LURD**\". - 1st: \"**U**RD\". - 2nd: \"RD\". - 3rd: \"D\". ``` **Example 3:** ``` **Input:** n = 1, startPos = [0,0], s = \"LRUD\" **Output:** [0,0,0,0] **Explanation:** No matter which instruction the robot begins execution from, it would move off the grid. ``` **Constraints:** `m == s.length` `1 <= n, m <= 500` `startPos.length == 2` `0 <= startrow, startcol < n` `s` consists of `'L'`, `'R'`, `'U'`, and `'D'`.",
        "test_case": [
            {
                "label": "Example 1",
                "input": "n = 3, startPos = [0,1], s = \"RRDDLU\"",
                "output": "[1,5,4,3,1,0] Explanation: Starting from startPos and beginning execution from the i th instruction:\n- 0 th : \" R RDDLU\". Only one instruction \"R\" can be executed before it moves off the grid.\n- 1 st :  \" RDDLU \". All five instructions can be executed while it stays in the grid and ends at (1, 1).\n- 2 nd :   \" DDLU \". All four instructions can be executed while it stays in the grid and ends at (1, 0).\n- 3 rd :    \" DLU \". All three instructions can be executed while it stays in the grid and ends at (0, 0).\n- 4 th :     \" L U\". Only one instruction \"L\" can be executed before it moves off the grid.\n- 5 th :      \"U\". If moving up, it would move off the grid."
            },
            {
                "label": "Example 2",
                "input": "n = 2, startPos = [1,1], s = \"LURD\"",
                "output": "[4,1,0,0] Explanation: - 0 th : \" LURD \".\n- 1 st :  \" U RD\".\n- 2 nd :   \"RD\".\n- 3 rd :    \"D\"."
            },
            {
                "label": "Example 3",
                "input": "n = 1, startPos = [0,0], s = \"LRUD\"",
                "output": "[0,0,0,0] Explanation: No matter which instruction the robot begins execution from, it would move off the grid. Constraints: m == s.length 1 <= n, m <= 500 startPos.length == 2 0 <= start row , start col < n s consists of 'L' , 'R' , 'U' , and 'D' ."
            }
        ],
        "elixir_template": "defmodule Solution do\n  @spec execute_instructions(n :: integer, start_pos :: [integer], s :: String.t) :: [integer]\n  def execute_instructions(n, start_pos, s) do\n    \n  end\nend",
        "erlang_template": "-spec execute_instructions(N :: integer(), StartPos :: [integer()], S :: unicode:unicode_binary()) -> [integer()].\nexecute_instructions(N, StartPos, S) ->\n  .",
        "scala_template": "object Solution {\n    def executeInstructions(n: Int, startPos: Array[Int], s: String): Array[Int] = {\n        \n    }\n}"
    },
    {
        "id": 2238,
        "name": "a-number-after-a-double-reversal",
        "difficulty": "Easy",
        "link": "https://leetcode.com/problems/a-number-after-a-double-reversal/",
        "task_description": "**Reversing** an integer means to reverse all its digits. For example, reversing `2021` gives `1202`. Reversing `12300` gives `321` as the **leading zeros are not retained**. Given an integer `num`, **reverse** `num` to get `reversed1`, **then reverse** `reversed1` to get `reversed2`. Return `true` _if_ `reversed2` _equals_ `num`. Otherwise return `false`. **Example 1:** ``` **Input:** num = 526 **Output:** true **Explanation:** Reverse num to get 625, then reverse 625 to get 526, which equals num. ``` **Example 2:** ``` **Input:** num = 1800 **Output:** false **Explanation:** Reverse num to get 81, then reverse 81 to get 18, which does not equal num. ``` **Example 3:** ``` **Input:** num = 0 **Output:** true **Explanation:** Reverse num to get 0, then reverse 0 to get 0, which equals num. ``` **Constraints:** `0 <= num <= 106`",
        "test_case": [
            {
                "label": "Example 1",
                "input": "num = 526",
                "output": "true Explanation: Reverse num to get 625, then reverse 625 to get 526, which equals num."
            },
            {
                "label": "Example 2",
                "input": "num = 1800",
                "output": "false Explanation: Reverse num to get 81, then reverse 81 to get 18, which does not equal num."
            },
            {
                "label": "Example 3",
                "input": "num = 0",
                "output": "true Explanation: Reverse num to get 0, then reverse 0 to get 0, which equals num."
            }
        ],
        "elixir_template": "defmodule Solution do\n  @spec is_same_after_reversals(num :: integer) :: boolean\n  def is_same_after_reversals(num) do\n    \n  end\nend",
        "erlang_template": "-spec is_same_after_reversals(Num :: integer()) -> boolean().\nis_same_after_reversals(Num) ->\n  .",
        "scala_template": "object Solution {\n    def isSameAfterReversals(num: Int): Boolean = {\n        \n    }\n}"
    },
    {
        "id": 2237,
        "name": "longest-palindrome-by-concatenating-two-letter-words",
        "difficulty": "Medium",
        "link": "https://leetcode.com/problems/longest-palindrome-by-concatenating-two-letter-words/",
        "task_description": "You are given an array of strings `words`. Each element of `words` consists of **two** lowercase English letters. Create the **longest possible palindrome** by selecting some elements from `words` and concatenating them in **any order**. Each element can be selected **at most once**. Return _the **length** of the longest palindrome that you can create_. If it is impossible to create any palindrome, return `0`. A **palindrome** is a string that reads the same forward and backward. **Example 1:** ``` **Input:** words = [\"lc\",\"cl\",\"gg\"] **Output:** 6 **Explanation:** One longest palindrome is \"lc\" + \"gg\" + \"cl\" = \"lcggcl\", of length 6. Note that \"clgglc\" is another longest palindrome that can be created. ``` **Example 2:** ``` **Input:** words = [\"ab\",\"ty\",\"yt\",\"lc\",\"cl\",\"ab\"] **Output:** 8 **Explanation:** One longest palindrome is \"ty\" + \"lc\" + \"cl\" + \"yt\" = \"tylcclyt\", of length 8. Note that \"lcyttycl\" is another longest palindrome that can be created. ``` **Example 3:** ``` **Input:** words = [\"cc\",\"ll\",\"xx\"] **Output:** 2 **Explanation:** One longest palindrome is \"cc\", of length 2. Note that \"ll\" is another longest palindrome that can be created, and so is \"xx\". ``` **Constraints:** `1 <= words.length <= 105` `words[i].length == 2` `words[i]` consists of lowercase English letters.",
        "test_case": [
            {
                "label": "Example 1",
                "input": "words = [\"lc\",\"cl\",\"gg\"]",
                "output": "6 Explanation: One longest palindrome is \"lc\" + \"gg\" + \"cl\" = \"lcggcl\", of length 6.\nNote that \"clgglc\" is another longest palindrome that can be created."
            },
            {
                "label": "Example 2",
                "input": "words = [\"ab\",\"ty\",\"yt\",\"lc\",\"cl\",\"ab\"]",
                "output": "8 Explanation: One longest palindrome is \"ty\" + \"lc\" + \"cl\" + \"yt\" = \"tylcclyt\", of length 8.\nNote that \"lcyttycl\" is another longest palindrome that can be created."
            },
            {
                "label": "Example 3",
                "input": "words = [\"cc\",\"ll\",\"xx\"]",
                "output": "2 Explanation: One longest palindrome is \"cc\", of length 2.\nNote that \"ll\" is another longest palindrome that can be created, and so is \"xx\"."
            }
        ],
        "elixir_template": "defmodule Solution do\n  @spec longest_palindrome(words :: [String.t]) :: integer\n  def longest_palindrome(words) do\n    \n  end\nend",
        "erlang_template": "-spec longest_palindrome(Words :: [unicode:unicode_binary()]) -> integer().\nlongest_palindrome(Words) ->\n  .",
        "scala_template": "object Solution {\n    def longestPalindrome(words: Array[String]): Int = {\n        \n    }\n}"
    },
    {
        "id": 2236,
        "name": "maximum-twin-sum-of-a-linked-list",
        "difficulty": "Medium",
        "link": "https://leetcode.com/problems/maximum-twin-sum-of-a-linked-list/",
        "task_description": "In a linked list of size `n`, where `n` is **even**, the `ith` node (**0-indexed**) of the linked list is known as the **twin** of the `(n-1-i)th` node, if `0 <= i <= (n / 2) - 1`. For example, if `n = 4`, then node `0` is the twin of node `3`, and node `1` is the twin of node `2`. These are the only nodes with twins for `n = 4`. The **twin sum **is defined as the sum of a node and its twin. Given the `head` of a linked list with even length, return _the **maximum twin sum** of the linked list_. **Example 1:** ``` **Input:** head = [5,4,2,1] **Output:** 6 **Explanation:** Nodes 0 and 1 are the twins of nodes 3 and 2, respectively. All have twin sum = 6. There are no other nodes with twins in the linked list. Thus, the maximum twin sum of the linked list is 6. ``` **Example 2:** ``` **Input:** head = [4,2,2,3] **Output:** 7 **Explanation:** The nodes with twins present in this linked list are: - Node 0 is the twin of node 3 having a twin sum of 4 + 3 = 7. - Node 1 is the twin of node 2 having a twin sum of 2 + 2 = 4. Thus, the maximum twin sum of the linked list is max(7, 4) = 7. ``` **Example 3:** ``` **Input:** head = [1,100000] **Output:** 100001 **Explanation:** There is only one node with a twin in the linked list having twin sum of 1 + 100000 = 100001. ``` **Constraints:** The number of nodes in the list is an **even** integer in the range `[2, 105]`. `1 <= Node.val <= 105`",
        "test_case": [
            {
                "label": "Example 1",
                "input": "head = [5,4,2,1]",
                "output": "6 Explanation: Nodes 0 and 1 are the twins of nodes 3 and 2, respectively. All have twin sum = 6.\nThere are no other nodes with twins in the linked list.\nThus, the maximum twin sum of the linked list is 6."
            },
            {
                "label": "Example 2",
                "input": "head = [4,2,2,3]",
                "output": "7 Explanation: The nodes with twins present in this linked list are:\n- Node 0 is the twin of node 3 having a twin sum of 4 + 3 = 7.\n- Node 1 is the twin of node 2 having a twin sum of 2 + 2 = 4.\nThus, the maximum twin sum of the linked list is max(7, 4) = 7."
            },
            {
                "label": "Example 3",
                "input": "head = [1,100000]",
                "output": "100001 Explanation: There is only one node with a twin in the linked list having twin sum of 1 + 100000 = 100001. Constraints: The number of nodes in the list is an even integer in the range [2, 10 5 ] . 1 <= Node.val <= 10 5"
            }
        ],
        "elixir_template": "# Definition for singly-linked list.\n#\n# defmodule ListNode do\n#   @type t :: %__MODULE__{\n#           val: integer,\n#           next: ListNode.t() | nil\n#         }\n#   defstruct val: 0, next: nil\n# end\n\ndefmodule Solution do\n  @spec pair_sum(head :: ListNode.t | nil) :: integer\n  def pair_sum(head) do\n    \n  end\nend",
        "erlang_template": "%% Definition for singly-linked list.\n%%\n%% -record(list_node, {val = 0 :: integer(),\n%%                     next = null :: 'null' | #list_node{}}).\n\n-spec pair_sum(Head :: #list_node{} | null) -> integer().\npair_sum(Head) ->\n  .",
        "scala_template": "/**\n * Definition for singly-linked list.\n * class ListNode(_x: Int = 0, _next: ListNode = null) {\n *   var next: ListNode = _next\n *   var x: Int = _x\n * }\n */\nobject Solution {\n    def pairSum(head: ListNode): Int = {\n        \n    }\n}"
    },
    {
        "id": 2235,
        "name": "capitalize-the-title",
        "difficulty": "Easy",
        "link": "https://leetcode.com/problems/capitalize-the-title/",
        "task_description": "You are given a string `title` consisting of one or more words separated by a single space, where each word consists of English letters. **Capitalize** the string by changing the capitalization of each word such that: If the length of the word is `1` or `2` letters, change all letters to lowercase. Otherwise, change the first letter to uppercase and the remaining letters to lowercase. Return _the **capitalized** _`title`. **Example 1:** ``` **Input:** title = \"capiTalIze tHe titLe\" **Output:** \"Capitalize The Title\" **Explanation:** Since all the words have a length of at least 3, the first letter of each word is uppercase, and the remaining letters are lowercase. ``` **Example 2:** ``` **Input:** title = \"First leTTeR of EACH Word\" **Output:** \"First Letter of Each Word\" **Explanation:** The word \"of\" has length 2, so it is all lowercase. The remaining words have a length of at least 3, so the first letter of each remaining word is uppercase, and the remaining letters are lowercase. ``` **Example 3:** ``` **Input:** title = \"i lOve leetcode\" **Output:** \"i Love Leetcode\" **Explanation:** The word \"i\" has length 1, so it is lowercase. The remaining words have a length of at least 3, so the first letter of each remaining word is uppercase, and the remaining letters are lowercase. ``` **Constraints:** `1 <= title.length <= 100` `title` consists of words separated by a single space without any leading or trailing spaces. Each word consists of uppercase and lowercase English letters and is **non-empty**.",
        "test_case": [
            {
                "label": "Example 1",
                "input": "title = \"capiTalIze tHe titLe\"",
                "output": "\"Capitalize The Title\" Explanation: Since all the words have a length of at least 3, the first letter of each word is uppercase, and the remaining letters are lowercase."
            },
            {
                "label": "Example 2",
                "input": "title = \"First leTTeR of EACH Word\"",
                "output": "\"First Letter of Each Word\" Explanation: The word \"of\" has length 2, so it is all lowercase.\nThe remaining words have a length of at least 3, so the first letter of each remaining word is uppercase, and the remaining letters are lowercase."
            },
            {
                "label": "Example 3",
                "input": "title = \"i lOve leetcode\"",
                "output": "\"i Love Leetcode\" Explanation: The word \"i\" has length 1, so it is lowercase.\nThe remaining words have a length of at least 3, so the first letter of each remaining word is uppercase, and the remaining letters are lowercase."
            }
        ],
        "elixir_template": "defmodule Solution do\n  @spec capitalize_title(title :: String.t) :: String.t\n  def capitalize_title(title) do\n    \n  end\nend",
        "erlang_template": "-spec capitalize_title(Title :: unicode:unicode_binary()) -> unicode:unicode_binary().\ncapitalize_title(Title) ->\n  .",
        "scala_template": "object Solution {\n    def capitalizeTitle(title: String): String = {\n        \n    }\n}"
    },
    {
        "id": 2234,
        "name": "minimum-operations-to-make-the-array-k-increasing",
        "difficulty": "Hard",
        "link": "https://leetcode.com/problems/minimum-operations-to-make-the-array-k-increasing/",
        "task_description": "You are given a **0-indexed** array `arr` consisting of `n` positive integers, and a positive integer `k`. The array `arr` is called **K-increasing** if `arr[i-k] <= arr[i]` holds for every index `i`, where `k <= i <= n-1`. For example, `arr = [4, 1, 5, 2, 6, 2]` is K-increasing for `k = 2` because: `arr[0] <= arr[2] (4 <= 5)` `arr[1] <= arr[3] (1 <= 2)` `arr[2] <= arr[4] (5 <= 6)` `arr[3] <= arr[5] (2 <= 2)` However, the same `arr` is not K-increasing for `k = 1` (because `arr[0] > arr[1]`) or `k = 3` (because `arr[0] > arr[3]`). In one **operation**, you can choose an index `i` and **change** `arr[i]` into **any** positive integer. Return _the **minimum number of operations** required to make the array K-increasing for the given _`k`. **Example 1:** ``` **Input:** arr = [5,4,3,2,1], k = 1 **Output:** 4 **Explanation: **For k = 1, the resultant array has to be non-decreasing. Some of the K-increasing arrays that can be formed are [5,**6**,**7**,**8**,**9**], [**1**,**1**,**1**,**1**,1], [**2**,**2**,3,**4**,**4**]. All of them require 4 operations. It is suboptimal to change the array to, for example, [**6**,**7**,**8**,**9**,**10**] because it would take 5 operations. It can be shown that we cannot make the array K-increasing in less than 4 operations. ``` **Example 2:** ``` **Input:** arr = [4,1,5,2,6,2], k = 2 **Output:** 0 **Explanation:** This is the same example as the one in the problem description. Here, for every index i where 2 <= i <= 5, arr[i-2] <= arr[i]. Since the given array is already K-increasing, we do not need to perform any operations. ``` **Example 3:** ``` **Input:** arr = [4,1,5,2,6,2], k = 3 **Output:** 2 **Explanation:** Indices 3 and 5 are the only ones not satisfying arr[i-3] <= arr[i] for 3 <= i <= 5. One of the ways we can make the array K-increasing is by changing arr[3] to 4 and arr[5] to 5. The array will now be [4,1,5,**4**,6,**5**]. Note that there can be other ways to make the array K-increasing, but none of them require less than 2 operations. ``` **Constraints:** `1 <= arr.length <= 105` `1 <= arr[i], k <= arr.length`",
        "test_case": [
            {
                "label": "Example 1",
                "input": "arr = [5,4,3,2,1], k = 1",
                "output": "4 Explanation: For k = 1, the resultant array has to be non-decreasing.\nSome of the K-increasing arrays that can be formed are [5, 6 , 7 , 8 , 9 ], [ 1 , 1 , 1 , 1 ,1], [ 2 , 2 ,3, 4 , 4 ]. All of them require 4 operations.\nIt is suboptimal to change the array to, for example, [ 6 , 7 , 8 , 9 , 10 ] because it would take 5 operations.\nIt can be shown that we cannot make the array K-increasing in less than 4 operations."
            },
            {
                "label": "Example 2",
                "input": "arr = [4,1,5,2,6,2], k = 2",
                "output": "0 Explanation: This is the same example as the one in the problem description.\nHere, for every index i where 2 <= i <= 5, arr[i-2] <= arr[i].\nSince the given array is already K-increasing, we do not need to perform any operations."
            },
            {
                "label": "Example 3",
                "input": "arr = [4,1,5,2,6,2], k = 3",
                "output": "2 Explanation: Indices 3 and 5 are the only ones not satisfying arr[i-3] <= arr[i] for 3 <= i <= 5.\nOne of the ways we can make the array K-increasing is by changing arr[3] to 4 and arr[5] to 5.\nThe array will now be [4,1,5, 4 ,6, 5 ].\nNote that there can be other ways to make the array K-increasing, but none of them require less than 2 operations."
            }
        ],
        "elixir_template": "defmodule Solution do\n  @spec k_increasing(arr :: [integer], k :: integer) :: integer\n  def k_increasing(arr, k) do\n    \n  end\nend",
        "erlang_template": "-spec k_increasing(Arr :: [integer()], K :: integer()) -> integer().\nk_increasing(Arr, K) ->\n  .",
        "scala_template": "object Solution {\n    def kIncreasing(arr: Array[Int], k: Int): Int = {\n        \n    }\n}"
    },
    {
        "id": 2233,
        "name": "number-of-smooth-descent-periods-of-a-stock",
        "difficulty": "Medium",
        "link": "https://leetcode.com/problems/number-of-smooth-descent-periods-of-a-stock/",
        "task_description": "You are given an integer array `prices` representing the daily price history of a stock, where `prices[i]` is the stock price on the `ith` day. A **smooth descent period** of a stock consists of **one or more contiguous** days such that the price on each day is **lower** than the price on the **preceding day** by **exactly** `1`. The first day of the period is exempted from this rule. Return _the number of **smooth descent periods**_. **Example 1:** ``` **Input:** prices = [3,2,1,4] **Output:** 7 **Explanation:** There are 7 smooth descent periods: [3], [2], [1], [4], [3,2], [2,1], and [3,2,1] Note that a period with one day is a smooth descent period by the definition. ``` **Example 2:** ``` **Input:** prices = [8,6,7,7] **Output:** 4 **Explanation:** There are 4 smooth descent periods: [8], [6], [7], and [7] Note that [8,6] is not a smooth descent period as 8 - 6 \u2260 1. ``` **Example 3:** ``` **Input:** prices = [1] **Output:** 1 **Explanation:** There is 1 smooth descent period: [1] ``` **Constraints:** `1 <= prices.length <= 105` `1 <= prices[i] <= 105`",
        "test_case": [
            {
                "label": "Example 1",
                "input": "prices = [3,2,1,4]",
                "output": "7 Explanation: There are 7 smooth descent periods:\n[3], [2], [1], [4], [3,2], [2,1], and [3,2,1]\nNote that a period with one day is a smooth descent period by the definition."
            },
            {
                "label": "Example 2",
                "input": "prices = [8,6,7,7]",
                "output": "4 Explanation: There are 4 smooth descent periods: [8], [6], [7], and [7]\nNote that [8,6] is not a smooth descent period as 8 - 6 \u2260 1."
            },
            {
                "label": "Example 3",
                "input": "prices = [1]",
                "output": "1 Explanation: There is 1 smooth descent period: [1]"
            }
        ],
        "elixir_template": "defmodule Solution do\n  @spec get_descent_periods(prices :: [integer]) :: integer\n  def get_descent_periods(prices) do\n    \n  end\nend",
        "erlang_template": "-spec get_descent_periods(Prices :: [integer()]) -> integer().\nget_descent_periods(Prices) ->\n  .",
        "scala_template": "object Solution {\n    def getDescentPeriods(prices: Array[Int]): Long = {\n        \n    }\n}"
    },
    {
        "id": 2232,
        "name": "adding-spaces-to-a-string",
        "difficulty": "Medium",
        "link": "https://leetcode.com/problems/adding-spaces-to-a-string/",
        "task_description": "You are given a **0-indexed** string `s` and a **0-indexed** integer array `spaces` that describes the indices in the original string where spaces will be added. Each space should be inserted **before** the character at the given index. For example, given `s = \"EnjoyYourCoffee\"` and `spaces = [5, 9]`, we place spaces before `'Y'` and `'C'`, which are at indices `5` and `9` respectively. Thus, we obtain `\"Enjoy **Y**our **C**offee\"`. Return** **_the modified string **after** the spaces have been added._ **Example 1:** ``` **Input:** s = \"LeetcodeHelpsMeLearn\", spaces = [8,13,15] **Output:** \"Leetcode Helps Me Learn\" **Explanation:** The indices 8, 13, and 15 correspond to the underlined characters in \"Leetcode**H**elps**M**e**L**earn\". We then place spaces before those characters. ``` **Example 2:** ``` **Input:** s = \"icodeinpython\", spaces = [1,5,7,9] **Output:** \"i code in py thon\" **Explanation:** The indices 1, 5, 7, and 9 correspond to the underlined characters in \"i**c**ode**i**n**p**y**t**hon\". We then place spaces before those characters. ``` **Example 3:** ``` **Input:** s = \"spacing\", spaces = [0,1,2,3,4,5,6] **Output:** \" s p a c i n g\" **Explanation:** We are also able to place spaces before the first character of the string. ``` **Constraints:** `1 <= s.length <= 3 * 105` `s` consists only of lowercase and uppercase English letters. `1 <= spaces.length <= 3 * 105` `0 <= spaces[i] <= s.length - 1` All the values of `spaces` are **strictly increasing**.",
        "test_case": [
            {
                "label": "Example 1",
                "input": "s = \"LeetcodeHelpsMeLearn\", spaces = [8,13,15]",
                "output": "\"Leetcode Helps Me Learn\" Explanation: The indices 8, 13, and 15 correspond to the underlined characters in \"Leetcode H elps M e L earn\".\nWe then place spaces before those characters."
            },
            {
                "label": "Example 2",
                "input": "s = \"icodeinpython\", spaces = [1,5,7,9]",
                "output": "\"i code in py thon\" Explanation: The indices 1, 5, 7, and 9 correspond to the underlined characters in \"i c ode i n p y t hon\".\nWe then place spaces before those characters."
            },
            {
                "label": "Example 3",
                "input": "s = \"spacing\", spaces = [0,1,2,3,4,5,6]",
                "output": "\" s p a c i n g\" Explanation: We are also able to place spaces before the first character of the string."
            }
        ],
        "elixir_template": "defmodule Solution do\n  @spec add_spaces(s :: String.t, spaces :: [integer]) :: String.t\n  def add_spaces(s, spaces) do\n    \n  end\nend",
        "erlang_template": "-spec add_spaces(S :: unicode:unicode_binary(), Spaces :: [integer()]) -> unicode:unicode_binary().\nadd_spaces(S, Spaces) ->\n  .",
        "scala_template": "object Solution {\n    def addSpaces(s: String, spaces: Array[Int]): String = {\n        \n    }\n}"
    },
    {
        "id": 2231,
        "name": "find-first-palindromic-string-in-the-array",
        "difficulty": "Easy",
        "link": "https://leetcode.com/problems/find-first-palindromic-string-in-the-array/",
        "task_description": "Given an array of strings `words`, return _the first **palindromic** string in the array_. If there is no such string, return _an **empty string** _`\"\"`. A string is **palindromic** if it reads the same forward and backward. **Example 1:** ``` **Input:** words = [\"abc\",\"car\",\"ada\",\"racecar\",\"cool\"] **Output:** \"ada\" **Explanation:** The first string that is palindromic is \"ada\". Note that \"racecar\" is also palindromic, but it is not the first. ``` **Example 2:** ``` **Input:** words = [\"notapalindrome\",\"racecar\"] **Output:** \"racecar\" **Explanation:** The first and only string that is palindromic is \"racecar\". ``` **Example 3:** ``` **Input:** words = [\"def\",\"ghi\"] **Output:** \"\" **Explanation:** There are no palindromic strings, so the empty string is returned. ``` **Constraints:** `1 <= words.length <= 100` `1 <= words[i].length <= 100` `words[i]` consists only of lowercase English letters.",
        "test_case": [
            {
                "label": "Example 1",
                "input": "words = [\"abc\",\"car\",\"ada\",\"racecar\",\"cool\"]",
                "output": "\"ada\" Explanation: The first string that is palindromic is \"ada\".\nNote that \"racecar\" is also palindromic, but it is not the first."
            },
            {
                "label": "Example 2",
                "input": "words = [\"notapalindrome\",\"racecar\"]",
                "output": "\"racecar\" Explanation: The first and only string that is palindromic is \"racecar\"."
            },
            {
                "label": "Example 3",
                "input": "words = [\"def\",\"ghi\"]",
                "output": "\"\" Explanation: There are no palindromic strings, so the empty string is returned."
            }
        ],
        "elixir_template": "defmodule Solution do\n  @spec first_palindrome(words :: [String.t]) :: String.t\n  def first_palindrome(words) do\n    \n  end\nend",
        "erlang_template": "-spec first_palindrome(Words :: [unicode:unicode_binary()]) -> unicode:unicode_binary().\nfirst_palindrome(Words) ->\n  .",
        "scala_template": "object Solution {\n    def firstPalindrome(words: Array[String]): String = {\n        \n    }\n}"
    },
    {
        "id": 2229,
        "name": "maximum-fruits-harvested-after-at-most-k-steps",
        "difficulty": "Hard",
        "link": "https://leetcode.com/problems/maximum-fruits-harvested-after-at-most-k-steps/",
        "task_description": "Fruits are available at some positions on an infinite x-axis. You are given a 2D integer array `fruits` where `fruits[i] = [positioni, amounti]` depicts `amounti` fruits at the position `positioni`. `fruits` is already **sorted** by `positioni` in **ascending order**, and each `positioni` is **unique**. You are also given an integer `startPos` and an integer `k`. Initially, you are at the position `startPos`. From any position, you can either walk to the **left or right**. It takes **one step** to move **one unit** on the x-axis, and you can walk **at most** `k` steps in total. For every position you reach, you harvest all the fruits at that position, and the fruits will disappear from that position. Return _the **maximum total number** of fruits you can harvest_. **Example 1:** ``` **Input:** fruits = [[2,8],[6,3],[8,6]], startPos = 5, k = 4 **Output:** 9 **Explanation:** The optimal way is to: - Move right to position 6 and harvest 3 fruits - Move right to position 8 and harvest 6 fruits You moved 3 steps and harvested 3 + 6 = 9 fruits in total. ``` **Example 2:** ``` **Input:** fruits = [[0,9],[4,1],[5,7],[6,2],[7,4],[10,9]], startPos = 5, k = 4 **Output:** 14 **Explanation:** You can move at most k = 4 steps, so you cannot reach position 0 nor 10. The optimal way is to: - Harvest the 7 fruits at the starting position 5 - Move left to position 4 and harvest 1 fruit - Move right to position 6 and harvest 2 fruits - Move right to position 7 and harvest 4 fruits You moved 1 + 3 = 4 steps and harvested 7 + 1 + 2 + 4 = 14 fruits in total. ``` **Example 3:** ``` **Input:** fruits = [[0,3],[6,4],[8,5]], startPos = 3, k = 2 **Output:** 0 **Explanation:** You can move at most k = 2 steps and cannot reach any position with fruits. ``` **Constraints:** `1 <= fruits.length <= 105` `fruits[i].length == 2` `0 <= startPos, positioni <= 2 * 105` `positioni-1 < positioni` for any `i > 0` (**0-indexed**) `1 <= amounti <= 104` `0 <= k <= 2 * 105`",
        "test_case": [
            {
                "label": "Example 1",
                "input": "fruits = [[2,8],[6,3],[8,6]], startPos = 5, k = 4",
                "output": "9 Explanation: The optimal way is to:\n- Move right to position 6 and harvest 3 fruits\n- Move right to position 8 and harvest 6 fruits\nYou moved 3 steps and harvested 3 + 6 = 9 fruits in total."
            },
            {
                "label": "Example 2",
                "input": "fruits = [[0,9],[4,1],[5,7],[6,2],[7,4],[10,9]], startPos = 5, k = 4",
                "output": "14 Explanation: You can move at most k = 4 steps, so you cannot reach position 0 nor 10.\nThe optimal way is to:\n- Harvest the 7 fruits at the starting position 5\n- Move left to position 4 and harvest 1 fruit\n- Move right to position 6 and harvest 2 fruits\n- Move right to position 7 and harvest 4 fruits\nYou moved 1 + 3 = 4 steps and harvested 7 + 1 + 2 + 4 = 14 fruits in total."
            },
            {
                "label": "Example 3",
                "input": "fruits = [[0,3],[6,4],[8,5]], startPos = 3, k = 2",
                "output": "0 Explanation: You can move at most k = 2 steps and cannot reach any position with fruits."
            }
        ],
        "elixir_template": "defmodule Solution do\n  @spec max_total_fruits(fruits :: [[integer]], start_pos :: integer, k :: integer) :: integer\n  def max_total_fruits(fruits, start_pos, k) do\n    \n  end\nend",
        "erlang_template": "-spec max_total_fruits(Fruits :: [[integer()]], StartPos :: integer(), K :: integer()) -> integer().\nmax_total_fruits(Fruits, StartPos, K) ->\n  .",
        "scala_template": "object Solution {\n    def maxTotalFruits(fruits: Array[Array[Int]], startPos: Int, k: Int): Int = {\n        \n    }\n}"
    },
    {
        "id": 2228,
        "name": "watering-plants-ii",
        "difficulty": "Medium",
        "link": "https://leetcode.com/problems/watering-plants-ii/",
        "task_description": "Alice and Bob want to water `n` plants in their garden. The plants are arranged in a row and are labeled from `0` to `n - 1` from left to right where the `ith` plant is located at `x = i`. Each plant needs a specific amount of water. Alice and Bob have a watering can each, **initially full**. They water the plants in the following way: Alice waters the plants in order from **left to right**, starting from the `0th` plant. Bob waters the plants in order from **right to left**, starting from the `(n - 1)th` plant. They begin watering the plants **simultaneously**. It takes the same amount of time to water each plant regardless of how much water it needs. Alice/Bob **must** water the plant if they have enough in their can to **fully** water it. Otherwise, they **first** refill their can (instantaneously) then water the plant. In case both Alice and Bob reach the same plant, the one with **more** water currently in his/her watering can should water this plant. If they have the same amount of water, then Alice should water this plant. Given a **0-indexed** integer array `plants` of `n` integers, where `plants[i]` is the amount of water the `ith` plant needs, and two integers `capacityA` and `capacityB` representing the capacities of Alice's and Bob's watering cans respectively, return _the **number of times** they have to refill to water all the plants_. **Example 1:** ``` **Input:** plants = [2,2,3,3], capacityA = 5, capacityB = 5 **Output:** 1 **Explanation:** - Initially, Alice and Bob have 5 units of water each in their watering cans. - Alice waters plant 0, Bob waters plant 3. - Alice and Bob now have 3 units and 2 units of water respectively. - Alice has enough water for plant 1, so she waters it. Bob does not have enough water for plant 2, so he refills his can then waters it. So, the total number of times they have to refill to water all the plants is 0 + 0 + 1 + 0 = 1. ``` **Example 2:** ``` **Input:** plants = [2,2,3,3], capacityA = 3, capacityB = 4 **Output:** 2 **Explanation:** - Initially, Alice and Bob have 3 units and 4 units of water in their watering cans respectively. - Alice waters plant 0, Bob waters plant 3. - Alice and Bob now have 1 unit of water each, and need to water plants 1 and 2 respectively. - Since neither of them have enough water for their current plants, they refill their cans and then water the plants. So, the total number of times they have to refill to water all the plants is 0 + 1 + 1 + 0 = 2. ``` **Example 3:** ``` **Input:** plants = [5], capacityA = 10, capacityB = 8 **Output:** 0 **Explanation:** - There is only one plant. - Alice's watering can has 10 units of water, whereas Bob's can has 8 units. Since Alice has more water in her can, she waters this plant. So, the total number of times they have to refill is 0. ``` **Constraints:** `n == plants.length` `1 <= n <= 105` `1 <= plants[i] <= 106` `max(plants[i]) <= capacityA, capacityB <= 109`",
        "test_case": [
            {
                "label": "Example 1",
                "input": "plants = [2,2,3,3], capacityA = 5, capacityB = 5",
                "output": "1 Explanation: - Initially, Alice and Bob have 5 units of water each in their watering cans.\n- Alice waters plant 0, Bob waters plant 3.\n- Alice and Bob now have 3 units and 2 units of water respectively.\n- Alice has enough water for plant 1, so she waters it. Bob does not have enough water for plant 2, so he refills his can then waters it.\nSo, the total number of times they have to refill to water all the plants is 0 + 0 + 1 + 0 = 1."
            },
            {
                "label": "Example 2",
                "input": "plants = [2,2,3,3], capacityA = 3, capacityB = 4",
                "output": "2 Explanation: - Initially, Alice and Bob have 3 units and 4 units of water in their watering cans respectively.\n- Alice waters plant 0, Bob waters plant 3.\n- Alice and Bob now have 1 unit of water each, and need to water plants 1 and 2 respectively.\n- Since neither of them have enough water for their current plants, they refill their cans and then water the plants.\nSo, the total number of times they have to refill to water all the plants is 0 + 1 + 1 + 0 = 2."
            },
            {
                "label": "Example 3",
                "input": "plants = [5], capacityA = 10, capacityB = 8",
                "output": "0 Explanation: - There is only one plant.\n- Alice's watering can has 10 units of water, whereas Bob's can has 8 units. Since Alice has more water in her can, she waters this plant.\nSo, the total number of times they have to refill is 0. Constraints: n == plants.length 1 <= n <= 10 5 1 <= plants[i] <= 10 6 max(plants[i]) <= capacityA, capacityB <= 10 9"
            }
        ],
        "elixir_template": "defmodule Solution do\n  @spec minimum_refill(plants :: [integer], capacity_a :: integer, capacity_b :: integer) :: integer\n  def minimum_refill(plants, capacity_a, capacity_b) do\n    \n  end\nend",
        "erlang_template": "-spec minimum_refill(Plants :: [integer()], CapacityA :: integer(), CapacityB :: integer()) -> integer().\nminimum_refill(Plants, CapacityA, CapacityB) ->\n  .",
        "scala_template": "object Solution {\n    def minimumRefill(plants: Array[Int], capacityA: Int, capacityB: Int): Int = {\n        \n    }\n}"
    },
    {
        "id": 2227,
        "name": "sum-of-subarray-ranges",
        "difficulty": "Medium",
        "link": "https://leetcode.com/problems/sum-of-subarray-ranges/",
        "task_description": "You are given an integer array `nums`. The **range** of a subarray of `nums` is the difference between the largest and smallest element in the subarray. Return _the **sum of all** subarray ranges of _`nums`_._ A subarray is a contiguous **non-empty** sequence of elements within an array. **Example 1:** ``` **Input:** nums = [1,2,3] **Output:** 4 **Explanation:** The 6 subarrays of nums are the following: [1], range = largest - smallest = 1 - 1 = 0 [2], range = 2 - 2 = 0 [3], range = 3 - 3 = 0 [1,2], range = 2 - 1 = 1 [2,3], range = 3 - 2 = 1 [1,2,3], range = 3 - 1 = 2 So the sum of all ranges is 0 + 0 + 0 + 1 + 1 + 2 = 4. ``` **Example 2:** ``` **Input:** nums = [1,3,3] **Output:** 4 **Explanation:** The 6 subarrays of nums are the following: [1], range = largest - smallest = 1 - 1 = 0 [3], range = 3 - 3 = 0 [3], range = 3 - 3 = 0 [1,3], range = 3 - 1 = 2 [3,3], range = 3 - 3 = 0 [1,3,3], range = 3 - 1 = 2 So the sum of all ranges is 0 + 0 + 0 + 2 + 0 + 2 = 4. ``` **Example 3:** ``` **Input:** nums = [4,-2,-3,4,1] **Output:** 59 **Explanation:** The sum of all subarray ranges of nums is 59. ``` **Constraints:** `1 <= nums.length <= 1000` `-109 <= nums[i] <= 109` **Follow-up:** Could you find a solution with `O(n)` time complexity?",
        "test_case": [
            {
                "label": "Example 1",
                "input": "nums = [1,2,3]",
                "output": "4 Explanation: The 6 subarrays of nums are the following:\n[1], range = largest - smallest = 1 - 1 = 0 \n[2], range = 2 - 2 = 0\n[3], range = 3 - 3 = 0\n[1,2], range = 2 - 1 = 1\n[2,3], range = 3 - 2 = 1\n[1,2,3], range = 3 - 1 = 2\nSo the sum of all ranges is 0 + 0 + 0 + 1 + 1 + 2 = 4."
            },
            {
                "label": "Example 2",
                "input": "nums = [1,3,3]",
                "output": "4 Explanation: The 6 subarrays of nums are the following:\n[1], range = largest - smallest = 1 - 1 = 0\n[3], range = 3 - 3 = 0\n[3], range = 3 - 3 = 0\n[1,3], range = 3 - 1 = 2\n[3,3], range = 3 - 3 = 0\n[1,3,3], range = 3 - 1 = 2\nSo the sum of all ranges is 0 + 0 + 0 + 2 + 0 + 2 = 4."
            },
            {
                "label": "Example 3",
                "input": "nums = [4,-2,-3,4,1]",
                "output": "59 Explanation: The sum of all subarray ranges of nums is 59."
            }
        ],
        "elixir_template": "defmodule Solution do\n  @spec sub_array_ranges(nums :: [integer]) :: integer\n  def sub_array_ranges(nums) do\n    \n  end\nend",
        "erlang_template": "-spec sub_array_ranges(Nums :: [integer()]) -> integer().\nsub_array_ranges(Nums) ->\n  .",
        "scala_template": "object Solution {\n    def subArrayRanges(nums: Array[Int]): Long = {\n        \n    }\n}"
    },
    {
        "id": 2226,
        "name": "rings-and-rods",
        "difficulty": "Easy",
        "link": "https://leetcode.com/problems/rings-and-rods/",
        "task_description": "There are `n` rings and each ring is either red, green, or blue. The rings are distributed **across ten rods** labeled from `0` to `9`. You are given a string `rings` of length `2n` that describes the `n` rings that are placed onto the rods. Every two characters in `rings` forms a **color-position pair** that is used to describe each ring where: The **first** character of the `ith` pair denotes the `ith` ring's **color** (`'R'`, `'G'`, `'B'`). The **second** character of the `ith` pair denotes the **rod** that the `ith` ring is placed on (`'0'` to `'9'`). For example, `\"R3G2B1\"` describes `n == 3` rings: a red ring placed onto the rod labeled 3, a green ring placed onto the rod labeled 2, and a blue ring placed onto the rod labeled 1. Return _the number of rods that have **all three colors** of rings on them._ **Example 1:** ``` **Input:** rings = \"B0B6G0R6R0R6G9\" **Output:** 1 **Explanation:** - The rod labeled 0 holds 3 rings with all colors: red, green, and blue. - The rod labeled 6 holds 3 rings, but it only has red and blue. - The rod labeled 9 holds only a green ring. Thus, the number of rods with all three colors is 1. ``` **Example 2:** ``` **Input:** rings = \"B0R0G0R9R0B0G0\" **Output:** 1 **Explanation:** - The rod labeled 0 holds 6 rings with all colors: red, green, and blue. - The rod labeled 9 holds only a red ring. Thus, the number of rods with all three colors is 1. ``` **Example 3:** ``` **Input:** rings = \"G4\" **Output:** 0 **Explanation:** Only one ring is given. Thus, no rods have all three colors. ``` **Constraints:** `rings.length == 2 * n` `1 <= n <= 100` `rings[i]` where `i` is **even** is either `'R'`, `'G'`, or `'B'` (**0-indexed**). `rings[i]` where `i` is **odd** is a digit from `'0'` to `'9'` (**0-indexed**).",
        "test_case": [
            {
                "label": "Example 1",
                "input": "rings = \"B0B6G0R6R0R6G9\"",
                "output": "1 Explanation: - The rod labeled 0 holds 3 rings with all colors: red, green, and blue.\n- The rod labeled 6 holds 3 rings, but it only has red and blue.\n- The rod labeled 9 holds only a green ring.\nThus, the number of rods with all three colors is 1."
            },
            {
                "label": "Example 2",
                "input": "rings = \"B0R0G0R9R0B0G0\"",
                "output": "1 Explanation: - The rod labeled 0 holds 6 rings with all colors: red, green, and blue.\n- The rod labeled 9 holds only a red ring.\nThus, the number of rods with all three colors is 1."
            },
            {
                "label": "Example 3",
                "input": "rings = \"G4\"",
                "output": "0 Explanation: Only one ring is given. Thus, no rods have all three colors. Constraints: rings.length == 2 * n 1 <= n <= 100 rings[i] where i is even is either 'R' , 'G' , or 'B' ( 0-indexed ). rings[i] where i is odd is a digit from '0' to '9' ( 0-indexed )."
            }
        ],
        "elixir_template": "defmodule Solution do\n  @spec count_points(rings :: String.t) :: integer\n  def count_points(rings) do\n    \n  end\nend",
        "erlang_template": "-spec count_points(Rings :: unicode:unicode_binary()) -> integer().\ncount_points(Rings) ->\n  .",
        "scala_template": "object Solution {\n    def countPoints(rings: String): Int = {\n        \n    }\n}"
    },
    {
        "id": 2222,
        "name": "abbreviating-the-product-of-a-range",
        "difficulty": "Hard",
        "link": "https://leetcode.com/problems/abbreviating-the-product-of-a-range/",
        "task_description": "You are given two positive integers `left` and `right` with `left <= right`. Calculate the **product** of all integers in the **inclusive** range `[left, right]`. Since the product may be very large, you will **abbreviate** it following these steps: Count all **trailing** zeros in the product and **remove** them. Let us denote this count as `C`. For example, there are `3` trailing zeros in `1000`, and there are `0` trailing zeros in `546`. Denote the remaining number of digits in the product as `d`. If `d > 10`, then express the product as `<pre>...<suf>` where `<pre>` denotes the **first** `5` digits of the product, and `<suf>` denotes the **last** `5` digits of the product **after** removing all trailing zeros. If `d <= 10`, we keep it unchanged. For example, we express `1234567654321` as `12345...54321`, but `1234567` is represented as `1234567`. Finally, represent the product as a **string** `\"<pre>...<suf>eC\"`. For example, `12345678987600000` will be represented as `\"12345...89876e5\"`. Return _a string denoting the **abbreviated product** of all integers in the **inclusive** range_ `[left, right]`. **Example 1:** ``` **Input:** left = 1, right = 4 **Output:** \"24e0\" **Explanation:** The product is 1 \u00d7 2 \u00d7 3 \u00d7 4 = 24. There are no trailing zeros, so 24 remains the same. The abbreviation will end with \"e0\". Since the number of digits is 2, which is less than 10, we do not have to abbreviate it further. Thus, the final representation is \"24e0\". ``` **Example 2:** ``` **Input:** left = 2, right = 11 **Output:** \"399168e2\" **Explanation:** The product is 39916800. There are 2 trailing zeros, which we remove to get 399168. The abbreviation will end with \"e2\". The number of digits after removing the trailing zeros is 6, so we do not abbreviate it further. Hence, the abbreviated product is \"399168e2\". ``` **Example 3:** ``` **Input:** left = 371, right = 375 **Output:** \"7219856259e3\" **Explanation:** The product is 7219856259000. ``` **Constraints:** `1 <= left <= right <= 104`",
        "test_case": [
            {
                "label": "Example 1",
                "input": "left = 1, right = 4",
                "output": "\"24e0\" Explanation: The product is 1 \u00d7 2 \u00d7 3 \u00d7 4 = 24.\nThere are no trailing zeros, so 24 remains the same. The abbreviation will end with \"e0\".\nSince the number of digits is 2, which is less than 10, we do not have to abbreviate it further.\nThus, the final representation is \"24e0\"."
            },
            {
                "label": "Example 2",
                "input": "left = 2, right = 11",
                "output": "\"399168e2\" Explanation: The product is 39916800.\nThere are 2 trailing zeros, which we remove to get 399168. The abbreviation will end with \"e2\".\nThe number of digits after removing the trailing zeros is 6, so we do not abbreviate it further.\nHence, the abbreviated product is \"399168e2\"."
            },
            {
                "label": "Example 3",
                "input": "left = 371, right = 375",
                "output": "\"7219856259e3\" Explanation: The product is 7219856259000."
            }
        ],
        "elixir_template": "defmodule Solution do\n  @spec abbreviate_product(left :: integer, right :: integer) :: String.t\n  def abbreviate_product(left, right) do\n    \n  end\nend",
        "erlang_template": "-spec abbreviate_product(Left :: integer(), Right :: integer()) -> unicode:unicode_binary().\nabbreviate_product(Left, Right) ->\n  .",
        "scala_template": "object Solution {\n    def abbreviateProduct(left: Int, right: Int): String = {\n        \n    }\n}"
    },
    {
        "id": 2221,
        "name": "check-if-a-parentheses-string-can-be-valid",
        "difficulty": "Medium",
        "link": "https://leetcode.com/problems/check-if-a-parentheses-string-can-be-valid/",
        "task_description": "A parentheses string is a **non-empty** string consisting only of `'('` and `')'`. It is valid if **any** of the following conditions is **true**: It is `()`. It can be written as `AB` (`A` concatenated with `B`), where `A` and `B` are valid parentheses strings. It can be written as `(A)`, where `A` is a valid parentheses string. You are given a parentheses string `s` and a string `locked`, both of length `n`. `locked` is a binary string consisting only of `'0'`s and `'1'`s. For **each** index `i` of `locked`, If `locked[i]` is `'1'`, you **cannot** change `s[i]`. But if `locked[i]` is `'0'`, you **can** change `s[i]` to either `'('` or `')'`. Return `true` _if you can make `s` a valid parentheses string_. Otherwise, return `false`. **Example 1:** ``` **Input:** s = \"))()))\", locked = \"010100\" **Output:** true **Explanation:** locked[1] == '1' and locked[3] == '1', so we cannot change s[1] or s[3]. We change s[0] and s[4] to '(' while leaving s[2] and s[5] unchanged to make s valid. ``` **Example 2:** ``` **Input:** s = \"()()\", locked = \"0000\" **Output:** true **Explanation:** We do not need to make any changes because s is already valid. ``` **Example 3:** ``` **Input:** s = \")\", locked = \"0\" **Output:** false **Explanation:** locked permits us to change s[0]. Changing s[0] to either '(' or ')' will not make s valid. ``` **Constraints:** `n == s.length == locked.length` `1 <= n <= 105` `s[i]` is either `'('` or `')'`. `locked[i]` is either `'0'` or `'1'`.",
        "test_case": [
            {
                "label": "Example 1",
                "input": "s = \"))()))\", locked = \"010100\"",
                "output": "true Explanation: locked[1] == '1' and locked[3] == '1', so we cannot change s[1] or s[3].\nWe change s[0] and s[4] to '(' while leaving s[2] and s[5] unchanged to make s valid."
            },
            {
                "label": "Example 2",
                "input": "s = \"()()\", locked = \"0000\"",
                "output": "true Explanation: We do not need to make any changes because s is already valid."
            },
            {
                "label": "Example 3",
                "input": "s = \")\", locked = \"0\"",
                "output": "false Explanation: locked permits us to change s[0]. \nChanging s[0] to either '(' or ')' will not make s valid. Constraints: n == s.length == locked.length 1 <= n <= 10 5 s[i] is either '(' or ')' . locked[i] is either '0' or '1' ."
            }
        ],
        "elixir_template": "defmodule Solution do\n  @spec can_be_valid(s :: String.t, locked :: String.t) :: boolean\n  def can_be_valid(s, locked) do\n    \n  end\nend",
        "erlang_template": "-spec can_be_valid(S :: unicode:unicode_binary(), Locked :: unicode:unicode_binary()) -> boolean().\ncan_be_valid(S, Locked) ->\n  .",
        "scala_template": "object Solution {\n    def canBeValid(s: String, locked: String): Boolean = {\n        \n    }\n}"
    },
    {
        "id": 2220,
        "name": "find-all-possible-recipes-from-given-supplies",
        "difficulty": "Medium",
        "link": "https://leetcode.com/problems/find-all-possible-recipes-from-given-supplies/",
        "task_description": "You have information about `n` different recipes. You are given a string array `recipes` and a 2D string array `ingredients`. The `ith` recipe has the name `recipes[i]`, and you can **create** it if you have **all** the needed ingredients from `ingredients[i]`. Ingredients to a recipe may need to be created from **other **recipes, i.e., `ingredients[i]` may contain a string that is in `recipes`. You are also given a string array `supplies` containing all the ingredients that you initially have, and you have an infinite supply of all of them. Return _a list of all the recipes that you can create. _You may return the answer in **any order**. Note that two recipes may contain each other in their ingredients. **Example 1:** ``` **Input:** recipes = [\"bread\"], ingredients = [[\"yeast\",\"flour\"]], supplies = [\"yeast\",\"flour\",\"corn\"] **Output:** [\"bread\"] **Explanation:** We can create \"bread\" since we have the ingredients \"yeast\" and \"flour\". ``` **Example 2:** ``` **Input:** recipes = [\"bread\",\"sandwich\"], ingredients = [[\"yeast\",\"flour\"],[\"bread\",\"meat\"]], supplies = [\"yeast\",\"flour\",\"meat\"] **Output:** [\"bread\",\"sandwich\"] **Explanation:** We can create \"bread\" since we have the ingredients \"yeast\" and \"flour\". We can create \"sandwich\" since we have the ingredient \"meat\" and can create the ingredient \"bread\". ``` **Example 3:** ``` **Input:** recipes = [\"bread\",\"sandwich\",\"burger\"], ingredients = [[\"yeast\",\"flour\"],[\"bread\",\"meat\"],[\"sandwich\",\"meat\",\"bread\"]], supplies = [\"yeast\",\"flour\",\"meat\"] **Output:** [\"bread\",\"sandwich\",\"burger\"] **Explanation:** We can create \"bread\" since we have the ingredients \"yeast\" and \"flour\". We can create \"sandwich\" since we have the ingredient \"meat\" and can create the ingredient \"bread\". We can create \"burger\" since we have the ingredient \"meat\" and can create the ingredients \"bread\" and \"sandwich\". ``` **Constraints:** `n == recipes.length == ingredients.length` `1 <= n <= 100` `1 <= ingredients[i].length, supplies.length <= 100` `1 <= recipes[i].length, ingredients[i][j].length, supplies[k].length <= 10` `recipes[i], ingredients[i][j]`, and `supplies[k]` consist only of lowercase English letters. All the values of `recipes` and `supplies` combined are unique. Each `ingredients[i]` does not contain any duplicate values.",
        "test_case": [
            {
                "label": "Example 1",
                "input": "recipes = [\"bread\"], ingredients = [[\"yeast\",\"flour\"]], supplies = [\"yeast\",\"flour\",\"corn\"]",
                "output": "[\"bread\"] Explanation: We can create \"bread\" since we have the ingredients \"yeast\" and \"flour\"."
            },
            {
                "label": "Example 2",
                "input": "recipes = [\"bread\",\"sandwich\"], ingredients = [[\"yeast\",\"flour\"],[\"bread\",\"meat\"]], supplies = [\"yeast\",\"flour\",\"meat\"]",
                "output": "[\"bread\",\"sandwich\"] Explanation: We can create \"bread\" since we have the ingredients \"yeast\" and \"flour\".\nWe can create \"sandwich\" since we have the ingredient \"meat\" and can create the ingredient \"bread\"."
            },
            {
                "label": "Example 3",
                "input": "recipes = [\"bread\",\"sandwich\",\"burger\"], ingredients = [[\"yeast\",\"flour\"],[\"bread\",\"meat\"],[\"sandwich\",\"meat\",\"bread\"]], supplies = [\"yeast\",\"flour\",\"meat\"]",
                "output": "[\"bread\",\"sandwich\",\"burger\"] Explanation: We can create \"bread\" since we have the ingredients \"yeast\" and \"flour\".\nWe can create \"sandwich\" since we have the ingredient \"meat\" and can create the ingredient \"bread\".\nWe can create \"burger\" since we have the ingredient \"meat\" and can create the ingredients \"bread\" and \"sandwich\". Constraints: n == recipes.length == ingredients.length 1 <= n <= 100 1 <= ingredients[i].length, supplies.length <= 100 1 <= recipes[i].length, ingredients[i][j].length, supplies[k].length <= 10 recipes[i], ingredients[i][j] , and supplies[k] consist only of lowercase English letters. All the values of recipes and supplies combined are unique. Each ingredients[i] does not contain any duplicate values."
            }
        ],
        "elixir_template": "defmodule Solution do\n  @spec find_all_recipes(recipes :: [String.t], ingredients :: [[String.t]], supplies :: [String.t]) :: [String.t]\n  def find_all_recipes(recipes, ingredients, supplies) do\n    \n  end\nend",
        "erlang_template": "-spec find_all_recipes(Recipes :: [unicode:unicode_binary()], Ingredients :: [[unicode:unicode_binary()]], Supplies :: [unicode:unicode_binary()]) -> [unicode:unicode_binary()].\nfind_all_recipes(Recipes, Ingredients, Supplies) ->\n  .",
        "scala_template": "object Solution {\n    def findAllRecipes(recipes: Array[String], ingredients: List[List[String]], supplies: Array[String]): List[String] = {\n        \n    }\n}"
    },
    {
        "id": 2219,
        "name": "maximum-number-of-words-found-in-sentences",
        "difficulty": "Easy",
        "link": "https://leetcode.com/problems/maximum-number-of-words-found-in-sentences/",
        "task_description": "A **sentence** is a list of **words** that are separated by a single space with no leading or trailing spaces. You are given an array of strings `sentences`, where each `sentences[i]` represents a single **sentence**. Return _the **maximum number of words** that appear in a single sentence_. **Example 1:** ``` **Input:** sentences = [\"alice and bob love leetcode\", \"i think so too\", \"this is great thanks very much\"] **Output:** 6 **Explanation:** - The first sentence, \"alice and bob love leetcode\", has 5 words in total. - The second sentence, \"i think so too\", has 4 words in total. - The third sentence, \"this is great thanks very much\", has 6 words in total. Thus, the maximum number of words in a single sentence comes from the third sentence, which has 6 words. ``` **Example 2:** ``` **Input:** sentences = [\"please wait\", \"continue to fight\", \"continue to win\"] **Output:** 3 **Explanation:** It is possible that multiple sentences contain the same number of words. In this example, the second and third sentences (underlined) have the same number of words. ``` **Constraints:** `1 <= sentences.length <= 100` `1 <= sentences[i].length <= 100` `sentences[i]` consists only of lowercase English letters and `' '` only. `sentences[i]` does not have leading or trailing spaces. All the words in `sentences[i]` are separated by a single space.",
        "test_case": [
            {
                "label": "Example 1",
                "input": "sentences = [\"alice and bob love leetcode\", \"i think so too\", \"this is great thanks very much\" ]",
                "output": "6 Explanation: - The first sentence, \"alice and bob love leetcode\", has 5 words in total.\n- The second sentence, \"i think so too\", has 4 words in total.\n- The third sentence, \"this is great thanks very much\", has 6 words in total.\nThus, the maximum number of words in a single sentence comes from the third sentence, which has 6 words."
            },
            {
                "label": "Example 2",
                "input": "sentences = [\"please wait\", \"continue to fight\" , \"continue to win\" ]",
                "output": "3 Explanation: It is possible that multiple sentences contain the same number of words. \nIn this example, the second and third sentences (underlined) have the same number of words."
            }
        ],
        "elixir_template": "defmodule Solution do\n  @spec most_words_found(sentences :: [String.t]) :: integer\n  def most_words_found(sentences) do\n    \n  end\nend",
        "erlang_template": "-spec most_words_found(Sentences :: [unicode:unicode_binary()]) -> integer().\nmost_words_found(Sentences) ->\n  .",
        "scala_template": "object Solution {\n    def mostWordsFound(sentences: Array[String]): Int = {\n        \n    }\n}"
    },
    {
        "id": 2217,
        "name": "step-by-step-directions-from-a-binary-tree-node-to-another",
        "difficulty": "Medium",
        "link": "https://leetcode.com/problems/step-by-step-directions-from-a-binary-tree-node-to-another/",
        "task_description": "You are given the `root` of a **binary tree** with `n` nodes. Each node is uniquely assigned a value from `1` to `n`. You are also given an integer `startValue` representing the value of the start node `s`, and a different integer `destValue` representing the value of the destination node `t`. Find the **shortest path** starting from node `s` and ending at node `t`. Generate step-by-step directions of such path as a string consisting of only the **uppercase** letters `'L'`, `'R'`, and `'U'`. Each letter indicates a specific direction: `'L'` means to go from a node to its **left child** node. `'R'` means to go from a node to its **right child** node. `'U'` means to go from a node to its **parent** node. Return _the step-by-step directions of the **shortest path** from node _`s`_ to node_ `t`. **Example 1:** ``` **Input:** root = [5,1,2,3,null,6,4], startValue = 3, destValue = 6 **Output:** \"UURL\" **Explanation:** The shortest path is: 3 \u2192 1 \u2192 5 \u2192 2 \u2192 6. ``` **Example 2:** ``` **Input:** root = [2,1], startValue = 2, destValue = 1 **Output:** \"L\" **Explanation:** The shortest path is: 2 \u2192 1. ``` **Constraints:** The number of nodes in the tree is `n`. `2 <= n <= 105` `1 <= Node.val <= n` All the values in the tree are **unique**. `1 <= startValue, destValue <= n` `startValue != destValue`",
        "test_case": [
            {
                "label": "Example 1",
                "input": "root = [5,1,2,3,null,6,4], startValue = 3, destValue = 6",
                "output": "\"UURL\" Explanation: The shortest path is: 3 \u2192 1 \u2192 5 \u2192 2 \u2192 6."
            },
            {
                "label": "Example 2",
                "input": "root = [2,1], startValue = 2, destValue = 1",
                "output": "\"L\" Explanation: The shortest path is: 2 \u2192 1. Constraints: The number of nodes in the tree is n . 2 <= n <= 10 5 1 <= Node.val <= n All the values in the tree are unique . 1 <= startValue, destValue <= n startValue != destValue"
            }
        ],
        "elixir_template": "# Definition for a binary tree node.\n#\n# defmodule TreeNode do\n#   @type t :: %__MODULE__{\n#           val: integer,\n#           left: TreeNode.t() | nil,\n#           right: TreeNode.t() | nil\n#         }\n#   defstruct val: 0, left: nil, right: nil\n# end\n\ndefmodule Solution do\n  @spec get_directions(root :: TreeNode.t | nil, start_value :: integer, dest_value :: integer) :: String.t\n  def get_directions(root, start_value, dest_value) do\n    \n  end\nend",
        "erlang_template": "%% Definition for a binary tree node.\n%%\n%% -record(tree_node, {val = 0 :: integer(),\n%%                     left = null  :: 'null' | #tree_node{},\n%%                     right = null :: 'null' | #tree_node{}}).\n\n-spec get_directions(Root :: #tree_node{} | null, StartValue :: integer(), DestValue :: integer()) -> unicode:unicode_binary().\nget_directions(Root, StartValue, DestValue) ->\n  .",
        "scala_template": "/**\n * Definition for a binary tree node.\n * class TreeNode(_value: Int = 0, _left: TreeNode = null, _right: TreeNode = null) {\n *   var value: Int = _value\n *   var left: TreeNode = _left\n *   var right: TreeNode = _right\n * }\n */\nobject Solution {\n    def getDirections(root: TreeNode, startValue: Int, destValue: Int): String = {\n        \n    }\n}"
    },
    {
        "id": 2216,
        "name": "delete-the-middle-node-of-a-linked-list",
        "difficulty": "Medium",
        "link": "https://leetcode.com/problems/delete-the-middle-node-of-a-linked-list/",
        "task_description": "You are given the `head` of a linked list. **Delete** the **middle node**, and return _the_ `head` _of the modified linked list_. The **middle node** of a linked list of size `n` is the `\u230an / 2\u230bth` node from the start using **0-based indexing**, where `\u230ax\u230b` denotes the largest integer less than or equal to `x`. For `n` = `1`, `2`, `3`, `4`, and `5`, the middle nodes are `0`, `1`, `1`, `2`, and `2`, respectively. **Example 1:** ``` **Input:** head = [1,3,4,7,1,2,6] **Output:** [1,3,4,1,2,6] **Explanation:** The above figure represents the given linked list. The indices of the nodes are written below. Since n = 7, node 3 with value 7 is the middle node, which is marked in red. We return the new list after removing this node. ``` **Example 2:** ``` **Input:** head = [1,2,3,4] **Output:** [1,2,4] **Explanation:** The above figure represents the given linked list. For n = 4, node 2 with value 3 is the middle node, which is marked in red. ``` **Example 3:** ``` **Input:** head = [2,1] **Output:** [2] **Explanation:** The above figure represents the given linked list. For n = 2, node 1 with value 1 is the middle node, which is marked in red. Node 0 with value 2 is the only node remaining after removing node 1. ``` **Constraints:** The number of nodes in the list is in the range `[1, 105]`. `1 <= Node.val <= 105`",
        "test_case": [
            {
                "label": "Example 1",
                "input": "head = [1,3,4,7,1,2,6]",
                "output": "[1,3,4,1,2,6] Explanation: The above figure represents the given linked list. The indices of the nodes are written below.\nSince n = 7, node 3 with value 7 is the middle node, which is marked in red.\nWe return the new list after removing this node."
            },
            {
                "label": "Example 2",
                "input": "head = [1,2,3,4]",
                "output": "[1,2,4] Explanation: The above figure represents the given linked list.\nFor n = 4, node 2 with value 3 is the middle node, which is marked in red."
            },
            {
                "label": "Example 3",
                "input": "head = [2,1]",
                "output": "[2] Explanation: The above figure represents the given linked list.\nFor n = 2, node 1 with value 1 is the middle node, which is marked in red.\nNode 0 with value 2 is the only node remaining after removing node 1. Constraints: The number of nodes in the list is in the range [1, 10 5 ] . 1 <= Node.val <= 10 5"
            }
        ],
        "elixir_template": "# Definition for singly-linked list.\n#\n# defmodule ListNode do\n#   @type t :: %__MODULE__{\n#           val: integer,\n#           next: ListNode.t() | nil\n#         }\n#   defstruct val: 0, next: nil\n# end\n\ndefmodule Solution do\n  @spec delete_middle(head :: ListNode.t | nil) :: ListNode.t | nil\n  def delete_middle(head) do\n    \n  end\nend",
        "erlang_template": "%% Definition for singly-linked list.\n%%\n%% -record(list_node, {val = 0 :: integer(),\n%%                     next = null :: 'null' | #list_node{}}).\n\n-spec delete_middle(Head :: #list_node{} | null) -> #list_node{} | null.\ndelete_middle(Head) ->\n  .",
        "scala_template": "/**\n * Definition for singly-linked list.\n * class ListNode(_x: Int = 0, _next: ListNode = null) {\n *   var next: ListNode = _next\n *   var x: Int = _x\n * }\n */\nobject Solution {\n    def deleteMiddle(head: ListNode): ListNode = {\n        \n    }\n}"
    },
    {
        "id": 2215,
        "name": "finding-3-digit-even-numbers",
        "difficulty": "Easy",
        "link": "https://leetcode.com/problems/finding-3-digit-even-numbers/",
        "task_description": "You are given an integer array `digits`, where each element is a digit. The array may contain duplicates. You need to find **all** the **unique** integers that follow the given requirements: The integer consists of the **concatenation** of **three** elements from `digits` in **any** arbitrary order. The integer does not have **leading zeros**. The integer is **even**. For example, if the given `digits` were `[1, 2, 3]`, integers `132` and `312` follow the requirements. Return _a **sorted** array of the unique integers._ **Example 1:** ``` **Input:** digits = [2,1,3,0] **Output:** [102,120,130,132,210,230,302,310,312,320] **Explanation:** All the possible integers that follow the requirements are in the output array. Notice that there are no **odd** integers or integers with **leading zeros**. ``` **Example 2:** ``` **Input:** digits = [2,2,8,8,2] **Output:** [222,228,282,288,822,828,882] **Explanation:** The same digit can be used as many times as it appears in digits. In this example, the digit 8 is used twice each time in 288, 828, and 882. ``` **Example 3:** ``` **Input:** digits = [3,7,5] **Output:** [] **Explanation:** No **even** integers can be formed using the given digits. ``` **Constraints:** `3 <= digits.length <= 100` `0 <= digits[i] <= 9`",
        "test_case": [
            {
                "label": "Example 1",
                "input": "digits = [2,1,3,0]",
                "output": "[102,120,130,132,210,230,302,310,312,320] Explanation: All the possible integers that follow the requirements are in the output array. \nNotice that there are no odd integers or integers with leading zeros ."
            },
            {
                "label": "Example 2",
                "input": "digits = [2,2,8,8,2]",
                "output": "[222,228,282,288,822,828,882] Explanation: The same digit can be used as many times as it appears in digits. \nIn this example, the digit 8 is used twice each time in 288, 828, and 882."
            },
            {
                "label": "Example 3",
                "input": "digits = [3,7,5]",
                "output": "[] Explanation: No even integers can be formed using the given digits."
            }
        ],
        "elixir_template": "defmodule Solution do\n  @spec find_even_numbers(digits :: [integer]) :: [integer]\n  def find_even_numbers(digits) do\n    \n  end\nend",
        "erlang_template": "-spec find_even_numbers(Digits :: [integer()]) -> [integer()].\nfind_even_numbers(Digits) ->\n  .",
        "scala_template": "object Solution {\n    def findEvenNumbers(digits: Array[Int]): Array[Int] = {\n        \n    }\n}"
    },
    {
        "id": 2213,
        "name": "find-all-people-with-secret",
        "difficulty": "Hard",
        "link": "https://leetcode.com/problems/find-all-people-with-secret/",
        "task_description": "You are given an integer `n` indicating there are `n` people numbered from `0` to `n - 1`. You are also given a **0-indexed** 2D integer array `meetings` where `meetings[i] = [xi, yi, timei]` indicates that person `xi` and person `yi` have a meeting at `timei`. A person may attend **multiple meetings** at the same time. Finally, you are given an integer `firstPerson`. Person `0` has a **secret** and initially shares the secret with a person `firstPerson` at time `0`. This secret is then shared every time a meeting takes place with a person that has the secret. More formally, for every meeting, if a person `xi` has the secret at `timei`, then they will share the secret with person `yi`, and vice versa. The secrets are shared **instantaneously**. That is, a person may receive the secret and share it with people in other meetings within the same time frame. Return _a list of all the people that have the secret after all the meetings have taken place. _You may return the answer in **any order**. **Example 1:** ``` **Input:** n = 6, meetings = [[1,2,5],[2,3,8],[1,5,10]], firstPerson = 1 **Output:** [0,1,2,3,5] **Explanation: **At time 0, person 0 shares the secret with person 1. At time 5, person 1 shares the secret with person 2. At time 8, person 2 shares the secret with person 3. At time 10, person 1 shares the secret with person 5.\u200b\u200b\u200b\u200b Thus, people 0, 1, 2, 3, and 5 know the secret after all the meetings. ``` **Example 2:** ``` **Input:** n = 4, meetings = [[3,1,3],[1,2,2],[0,3,3]], firstPerson = 3 **Output:** [0,1,3] **Explanation:** At time 0, person 0 shares the secret with person 3. At time 2, neither person 1 nor person 2 know the secret. At time 3, person 3 shares the secret with person 0 and person 1. Thus, people 0, 1, and 3 know the secret after all the meetings. ``` **Example 3:** ``` **Input:** n = 5, meetings = [[3,4,2],[1,2,1],[2,3,1]], firstPerson = 1 **Output:** [0,1,2,3,4] **Explanation:** At time 0, person 0 shares the secret with person 1. At time 1, person 1 shares the secret with person 2, and person 2 shares the secret with person 3. Note that person 2 can share the secret at the same time as receiving it. At time 2, person 3 shares the secret with person 4. Thus, people 0, 1, 2, 3, and 4 know the secret after all the meetings. ``` **Constraints:** `2 <= n <= 105` `1 <= meetings.length <= 105` `meetings[i].length == 3` `0 <= xi, yi <= n - 1` `xi != yi` `1 <= timei <= 105` `1 <= firstPerson <= n - 1`",
        "test_case": [
            {
                "label": "Example 1",
                "input": "n = 6, meetings = [[1,2,5],[2,3,8],[1,5,10]], firstPerson = 1",
                "output": "[0,1,2,3,5] Explanation: At time 0, person 0 shares the secret with person 1.\nAt time 5, person 1 shares the secret with person 2.\nAt time 8, person 2 shares the secret with person 3.\nAt time 10, person 1 shares the secret with person 5.\u200b\u200b\u200b\u200b\nThus, people 0, 1, 2, 3, and 5 know the secret after all the meetings."
            },
            {
                "label": "Example 2",
                "input": "n = 4, meetings = [[3,1,3],[1,2,2],[0,3,3]], firstPerson = 3",
                "output": "[0,1,3] Explanation: At time 0, person 0 shares the secret with person 3.\nAt time 2, neither person 1 nor person 2 know the secret.\nAt time 3, person 3 shares the secret with person 0 and person 1.\nThus, people 0, 1, and 3 know the secret after all the meetings."
            },
            {
                "label": "Example 3",
                "input": "n = 5, meetings = [[3,4,2],[1,2,1],[2,3,1]], firstPerson = 1",
                "output": "[0,1,2,3,4] Explanation: At time 0, person 0 shares the secret with person 1.\nAt time 1, person 1 shares the secret with person 2, and person 2 shares the secret with person 3.\nNote that person 2 can share the secret at the same time as receiving it.\nAt time 2, person 3 shares the secret with person 4.\nThus, people 0, 1, 2, 3, and 4 know the secret after all the meetings."
            }
        ],
        "elixir_template": "defmodule Solution do\n  @spec find_all_people(n :: integer, meetings :: [[integer]], first_person :: integer) :: [integer]\n  def find_all_people(n, meetings, first_person) do\n    \n  end\nend",
        "erlang_template": "-spec find_all_people(N :: integer(), Meetings :: [[integer()]], FirstPerson :: integer()) -> [integer()].\nfind_all_people(N, Meetings, FirstPerson) ->\n  .",
        "scala_template": "object Solution {\n    def findAllPeople(n: Int, meetings: Array[Array[Int]], firstPerson: Int): List[Int] = {\n        \n    }\n}"
    },
    {
        "id": 2212,
        "name": "removing-minimum-and-maximum-from-array",
        "difficulty": "Medium",
        "link": "https://leetcode.com/problems/removing-minimum-and-maximum-from-array/",
        "task_description": "You are given a **0-indexed** array of **distinct** integers `nums`. There is an element in `nums` that has the **lowest** value and an element that has the **highest** value. We call them the **minimum** and **maximum** respectively. Your goal is to remove **both** these elements from the array. A **deletion** is defined as either removing an element from the **front** of the array or removing an element from the **back** of the array. Return _the **minimum** number of deletions it would take to remove **both** the minimum and maximum element from the array._ **Example 1:** ``` **Input:** nums = [2,**10**,7,5,4,**1**,8,6] **Output:** 5 **Explanation:** The minimum element in the array is nums[5], which is 1. The maximum element in the array is nums[1], which is 10. We can remove both the minimum and maximum by removing 2 elements from the front and 3 elements from the back. This results in 2 + 3 = 5 deletions, which is the minimum number possible. ``` **Example 2:** ``` **Input:** nums = [0,**-4**,**19**,1,8,-2,-3,5] **Output:** 3 **Explanation:** The minimum element in the array is nums[1], which is -4. The maximum element in the array is nums[2], which is 19. We can remove both the minimum and maximum by removing 3 elements from the front. This results in only 3 deletions, which is the minimum number possible. ``` **Example 3:** ``` **Input:** nums = [**101**] **Output:** 1 **Explanation:** There is only one element in the array, which makes it both the minimum and maximum element. We can remove it with 1 deletion. ``` **Constraints:** `1 <= nums.length <= 105` `-105 <= nums[i] <= 105` The integers in `nums` are **distinct**.",
        "test_case": [
            {
                "label": "Example 1",
                "input": "nums = [2, 10 ,7,5,4, 1 ,8,6]",
                "output": "5 Explanation: The minimum element in the array is nums[5], which is 1.\nThe maximum element in the array is nums[1], which is 10.\nWe can remove both the minimum and maximum by removing 2 elements from the front and 3 elements from the back.\nThis results in 2 + 3 = 5 deletions, which is the minimum number possible."
            },
            {
                "label": "Example 2",
                "input": "nums = [0, -4 , 19 ,1,8,-2,-3,5]",
                "output": "3 Explanation: The minimum element in the array is nums[1], which is -4.\nThe maximum element in the array is nums[2], which is 19.\nWe can remove both the minimum and maximum by removing 3 elements from the front.\nThis results in only 3 deletions, which is the minimum number possible."
            },
            {
                "label": "Example 3",
                "input": "nums = [ 101 ]",
                "output": "1 Explanation: There is only one element in the array, which makes it both the minimum and maximum element.\nWe can remove it with 1 deletion."
            }
        ],
        "elixir_template": "defmodule Solution do\n  @spec minimum_deletions(nums :: [integer]) :: integer\n  def minimum_deletions(nums) do\n    \n  end\nend",
        "erlang_template": "-spec minimum_deletions(Nums :: [integer()]) -> integer().\nminimum_deletions(Nums) ->\n  .",
        "scala_template": "object Solution {\n    def minimumDeletions(nums: Array[Int]): Int = {\n        \n    }\n}"
    },
    {
        "id": 2211,
        "name": "k-radius-subarray-averages",
        "difficulty": "Medium",
        "link": "https://leetcode.com/problems/k-radius-subarray-averages/",
        "task_description": "You are given a **0-indexed** array `nums` of `n` integers, and an integer `k`. The **k-radius average** for a subarray of `nums` **centered** at some index `i` with the **radius** `k` is the average of **all** elements in `nums` between the indices `i - k` and `i + k` (**inclusive**). If there are less than `k` elements before **or** after the index `i`, then the **k-radius average** is `-1`. Build and return _an array _`avgs`_ of length _`n`_ where _`avgs[i]`_ is the **k-radius average** for the subarray centered at index _`i`. The **average** of `x` elements is the sum of the `x` elements divided by `x`, using **integer division**. The integer division truncates toward zero, which means losing its fractional part. For example, the average of four elements `2`, `3`, `1`, and `5` is `(2 + 3 + 1 + 5) / 4 = 11 / 4 = 2.75`, which truncates to `2`. **Example 1:** ``` **Input:** nums = [7,4,3,9,1,8,5,2,6], k = 3 **Output:** [-1,-1,-1,5,4,4,-1,-1,-1] **Explanation:** - avg[0], avg[1], and avg[2] are -1 because there are less than k elements **before** each index. - The sum of the subarray centered at index 3 with radius 3 is: 7 + 4 + 3 + 9 + 1 + 8 + 5 = 37. Using **integer division**, avg[3] = 37 / 7 = 5. - For the subarray centered at index 4, avg[4] = (4 + 3 + 9 + 1 + 8 + 5 + 2) / 7 = 4. - For the subarray centered at index 5, avg[5] = (3 + 9 + 1 + 8 + 5 + 2 + 6) / 7 = 4. - avg[6], avg[7], and avg[8] are -1 because there are less than k elements **after** each index. ``` **Example 2:** ``` **Input:** nums = [100000], k = 0 **Output:** [100000] **Explanation:** - The sum of the subarray centered at index 0 with radius 0 is: 100000. avg[0] = 100000 / 1 = 100000. ``` **Example 3:** ``` **Input:** nums = [8], k = 100000 **Output:** [-1] **Explanation:** - avg[0] is -1 because there are less than k elements before and after index 0. ``` **Constraints:** `n == nums.length` `1 <= n <= 105` `0 <= nums[i], k <= 105`",
        "test_case": [
            {
                "label": "Example 1",
                "input": "nums = [7,4,3,9,1,8,5,2,6], k = 3",
                "output": "[-1,-1,-1,5,4,4,-1,-1,-1] Explanation: - avg[0], avg[1], and avg[2] are -1 because there are less than k elements before each index.\n- The sum of the subarray centered at index 3 with radius 3 is: 7 + 4 + 3 + 9 + 1 + 8 + 5 = 37.\n  Using integer division , avg[3] = 37 / 7 = 5.\n- For the subarray centered at index 4, avg[4] = (4 + 3 + 9 + 1 + 8 + 5 + 2) / 7 = 4.\n- For the subarray centered at index 5, avg[5] = (3 + 9 + 1 + 8 + 5 + 2 + 6) / 7 = 4.\n- avg[6], avg[7], and avg[8] are -1 because there are less than k elements after each index."
            },
            {
                "label": "Example 2",
                "input": "nums = [100000], k = 0",
                "output": "[100000] Explanation: - The sum of the subarray centered at index 0 with radius 0 is: 100000.\n  avg[0] = 100000 / 1 = 100000."
            },
            {
                "label": "Example 3",
                "input": "nums = [8], k = 100000",
                "output": "[-1] Explanation: - avg[0] is -1 because there are less than k elements before and after index 0. Constraints: n == nums.length 1 <= n <= 10 5 0 <= nums[i], k <= 10 5"
            }
        ],
        "elixir_template": "defmodule Solution do\n  @spec get_averages(nums :: [integer], k :: integer) :: [integer]\n  def get_averages(nums, k) do\n    \n  end\nend",
        "erlang_template": "-spec get_averages(Nums :: [integer()], K :: integer()) -> [integer()].\nget_averages(Nums, K) ->\n  .",
        "scala_template": "object Solution {\n    def getAverages(nums: Array[Int], k: Int): Array[Int] = {\n        \n    }\n}"
    },
    {
        "id": 2210,
        "name": "find-target-indices-after-sorting-array",
        "difficulty": "Easy",
        "link": "https://leetcode.com/problems/find-target-indices-after-sorting-array/",
        "task_description": "You are given a **0-indexed** integer array `nums` and a target element `target`. A **target index** is an index `i` such that `nums[i] == target`. Return _a list of the target indices of_ `nums` after_ sorting _`nums`_ in **non-decreasing** order_. If there are no target indices, return _an **empty** list_. The returned list must be sorted in **increasing** order. **Example 1:** ``` **Input:** nums = [1,2,5,2,3], target = 2 **Output:** [1,2] **Explanation:** After sorting, nums is [1,**2**,**2**,3,5]. The indices where nums[i] == 2 are 1 and 2. ``` **Example 2:** ``` **Input:** nums = [1,2,5,2,3], target = 3 **Output:** [3] **Explanation:** After sorting, nums is [1,2,2,**3**,5]. The index where nums[i] == 3 is 3. ``` **Example 3:** ``` **Input:** nums = [1,2,5,2,3], target = 5 **Output:** [4] **Explanation:** After sorting, nums is [1,2,2,3,**5**]. The index where nums[i] == 5 is 4. ``` **Constraints:** `1 <= nums.length <= 100` `1 <= nums[i], target <= 100`",
        "test_case": [
            {
                "label": "Example 1",
                "input": "nums = [1,2,5,2,3], target = 2",
                "output": "[1,2] Explanation: After sorting, nums is [1, 2 , 2 ,3,5].\nThe indices where nums[i] == 2 are 1 and 2."
            },
            {
                "label": "Example 2",
                "input": "nums = [1,2,5,2,3], target = 3",
                "output": "[3] Explanation: After sorting, nums is [1,2,2, 3 ,5].\nThe index where nums[i] == 3 is 3."
            },
            {
                "label": "Example 3",
                "input": "nums = [1,2,5,2,3], target = 5",
                "output": "[4] Explanation: After sorting, nums is [1,2,2,3, 5 ].\nThe index where nums[i] == 5 is 4."
            }
        ],
        "elixir_template": "defmodule Solution do\n  @spec target_indices(nums :: [integer], target :: integer) :: [integer]\n  def target_indices(nums, target) do\n    \n  end\nend",
        "erlang_template": "-spec target_indices(Nums :: [integer()], Target :: integer()) -> [integer()].\ntarget_indices(Nums, Target) ->\n  .",
        "scala_template": "object Solution {\n    def targetIndices(nums: Array[Int], target: Int): List[Int] = {\n        \n    }\n}"
    },
    {
        "id": 2207,
        "name": "sequentially-ordinal-rank-tracker",
        "difficulty": "Hard",
        "link": "https://leetcode.com/problems/sequentially-ordinal-rank-tracker/",
        "task_description": "A scenic location is represented by its `name` and attractiveness `score`, where `name` is a **unique** string among all locations and `score` is an integer. Locations can be ranked from the best to the worst. The **higher** the score, the better the location. If the scores of two locations are equal, then the location with the **lexicographically smaller** name is better. You are building a system that tracks the ranking of locations with the system initially starting with no locations. It supports: **Adding** scenic locations, **one at a time**. **Querying** the `ith` **best** location of **all locations already added**, where `i` is the number of times the system has been queried (including the current query). For example, when the system is queried for the `4th` time, it returns the `4th` best location of all locations already added. Note that the test data are generated so that **at any time**, the number of queries **does not exceed** the number of locations added to the system. Implement the `SORTracker` class: `SORTracker()` Initializes the tracker system. `void add(string name, int score)` Adds a scenic location with `name` and `score` to the system. `string get()` Queries and returns the `ith` best location, where `i` is the number of times this method has been invoked (including this invocation). **Example 1:** ``` **Input** [\"SORTracker\", \"add\", \"add\", \"get\", \"add\", \"get\", \"add\", \"get\", \"add\", \"get\", \"add\", \"get\", \"get\"] [[], [\"bradford\", 2], [\"branford\", 3], [], [\"alps\", 2], [], [\"orland\", 2], [], [\"orlando\", 3], [], [\"alpine\", 2], [], []] **Output** [null, null, null, \"branford\", null, \"alps\", null, \"bradford\", null, \"bradford\", null, \"bradford\", \"orland\"] **Explanation** SORTracker tracker = new SORTracker(); // Initialize the tracker system. tracker.add(\"bradford\", 2); // Add location with name=\"bradford\" and score=2 to the system. tracker.add(\"branford\", 3); // Add location with name=\"branford\" and score=3 to the system. tracker.get(); // The sorted locations, from best to worst, are: branford, bradford. // Note that branford precedes bradford due to its **higher score** (3 > 2). // This is the 1st time get() is called, so return the best location: \"branford\". tracker.add(\"alps\", 2); // Add location with name=\"alps\" and score=2 to the system. tracker.get(); // Sorted locations: branford, alps, bradford. // Note that alps precedes bradford even though they have the same score (2). // This is because \"alps\" is **lexicographically smaller** than \"bradford\". // Return the 2nd best location \"alps\", as it is the 2nd time get() is called. tracker.add(\"orland\", 2); // Add location with name=\"orland\" and score=2 to the system. tracker.get(); // Sorted locations: branford, alps, bradford, orland. // Return \"bradford\", as it is the 3rd time get() is called. tracker.add(\"orlando\", 3); // Add location with name=\"orlando\" and score=3 to the system. tracker.get(); // Sorted locations: branford, orlando, alps, bradford, orland. // Return \"bradford\". tracker.add(\"alpine\", 2); // Add location with name=\"alpine\" and score=2 to the system. tracker.get(); // Sorted locations: branford, orlando, alpine, alps, bradford, orland. // Return \"bradford\". tracker.get(); // Sorted locations: branford, orlando, alpine, alps, bradford, orland. // Return \"orland\". ``` **Constraints:** `name` consists of lowercase English letters, and is unique among all locations. `1 <= name.length <= 10` `1 <= score <= 105` At any time, the number of calls to `get` does not exceed the number of calls to `add`. At most `4 * 104` calls **in total** will be made to `add` and `get`.",
        "test_case": [],
        "elixir_template": "defmodule SORTracker do\n  @spec init_() :: any\n  def init_() do\n    \n  end\n\n  @spec add(name :: String.t, score :: integer) :: any\n  def add(name, score) do\n    \n  end\n\n  @spec get() :: String.t\n  def get() do\n    \n  end\nend\n\n# Your functions will be called as such:\n# SORTracker.init_()\n# SORTracker.add(name, score)\n# param_2 = SORTracker.get()\n\n# SORTracker.init_ will be called before every test case, in which you can do some necessary initializations.",
        "erlang_template": "-spec sor_tracker_init_() -> any().\nsor_tracker_init_() ->\n  .\n\n-spec sor_tracker_add(Name :: unicode:unicode_binary(), Score :: integer()) -> any().\nsor_tracker_add(Name, Score) ->\n  .\n\n-spec sor_tracker_get() -> unicode:unicode_binary().\nsor_tracker_get() ->\n  .\n\n\n%% Your functions will be called as such:\n%% sor_tracker_init_(),\n%% sor_tracker_add(Name, Score),\n%% Param_2 = sor_tracker_get(),\n\n%% sor_tracker_init_ will be called before every test case, in which you can do some necessary initializations.",
        "scala_template": "class SORTracker() {\n\n    def add(name: String, score: Int): Unit = {\n        \n    }\n\n    def get(): String = {\n        \n    }\n\n}\n\n/**\n * Your SORTracker object will be instantiated and called as such:\n * val obj = new SORTracker()\n * obj.add(name,score)\n * val param_2 = obj.get()\n */"
    },
    {
        "id": 2206,
        "name": "detonate-the-maximum-bombs",
        "difficulty": "Medium",
        "link": "https://leetcode.com/problems/detonate-the-maximum-bombs/",
        "task_description": "You are given a list of bombs. The **range** of a bomb is defined as the area where its effect can be felt. This area is in the shape of a **circle** with the center as the location of the bomb. The bombs are represented by a **0-indexed** 2D integer array `bombs` where `bombs[i] = [xi, yi, ri]`. `xi` and `yi` denote the X-coordinate and Y-coordinate of the location of the `ith` bomb, whereas `ri` denotes the **radius** of its range. You may choose to detonate a **single** bomb. When a bomb is detonated, it will detonate **all bombs** that lie in its range. These bombs will further detonate the bombs that lie in their ranges. Given the list of `bombs`, return _the **maximum** number of bombs that can be detonated if you are allowed to detonate **only one** bomb_. **Example 1:** ``` **Input:** bombs = [[2,1,3],[6,1,4]] **Output:** 2 **Explanation:** The above figure shows the positions and ranges of the 2 bombs. If we detonate the left bomb, the right bomb will not be affected. But if we detonate the right bomb, both bombs will be detonated. So the maximum bombs that can be detonated is max(1, 2) = 2. ``` **Example 2:** ``` **Input:** bombs = [[1,1,5],[10,10,5]] **Output:** 1 **Explanation: **Detonating either bomb will not detonate the other bomb, so the maximum number of bombs that can be detonated is 1. ``` **Example 3:** ``` **Input:** bombs = [[1,2,3],[2,3,1],[3,4,2],[4,5,3],[5,6,4]] **Output:** 5 **Explanation:** The best bomb to detonate is bomb 0 because: - Bomb 0 detonates bombs 1 and 2. The red circle denotes the range of bomb 0. - Bomb 2 detonates bomb 3. The blue circle denotes the range of bomb 2. - Bomb 3 detonates bomb 4. The green circle denotes the range of bomb 3. Thus all 5 bombs are detonated. ``` **Constraints:** `1 <= bombs.length <= 100` `bombs[i].length == 3` `1 <= xi, yi, ri <= 105`",
        "test_case": [
            {
                "label": "Example 1",
                "input": "bombs = [[2,1,3],[6,1,4]]",
                "output": "2 Explanation: The above figure shows the positions and ranges of the 2 bombs.\nIf we detonate the left bomb, the right bomb will not be affected.\nBut if we detonate the right bomb, both bombs will be detonated.\nSo the maximum bombs that can be detonated is max(1, 2) = 2."
            },
            {
                "label": "Example 2",
                "input": "bombs = [[1,1,5],[10,10,5]]",
                "output": "1 Explanation: Detonating either bomb will not detonate the other bomb, so the maximum number of bombs that can be detonated is 1."
            },
            {
                "label": "Example 3",
                "input": "bombs = [[1,2,3],[2,3,1],[3,4,2],[4,5,3],[5,6,4]]",
                "output": "5 Explanation: The best bomb to detonate is bomb 0 because:\n- Bomb 0 detonates bombs 1 and 2. The red circle denotes the range of bomb 0.\n- Bomb 2 detonates bomb 3. The blue circle denotes the range of bomb 2.\n- Bomb 3 detonates bomb 4. The green circle denotes the range of bomb 3.\nThus all 5 bombs are detonated."
            }
        ],
        "elixir_template": "defmodule Solution do\n  @spec maximum_detonation(bombs :: [[integer]]) :: integer\n  def maximum_detonation(bombs) do\n    \n  end\nend",
        "erlang_template": "-spec maximum_detonation(Bombs :: [[integer()]]) -> integer().\nmaximum_detonation(Bombs) ->\n  .",
        "scala_template": "object Solution {\n    def maximumDetonation(bombs: Array[Array[Int]]): Int = {\n        \n    }\n}"
    },
    {
        "id": 2205,
        "name": "find-good-days-to-rob-the-bank",
        "difficulty": "Medium",
        "link": "https://leetcode.com/problems/find-good-days-to-rob-the-bank/",
        "task_description": "You and a gang of thieves are planning on robbing a bank. You are given a **0-indexed** integer array `security`, where `security[i]` is the number of guards on duty on the `ith` day. The days are numbered starting from `0`. You are also given an integer `time`. The `ith` day is a good day to rob the bank if: There are at least `time` days before and after the `ith` day, The number of guards at the bank for the `time` days **before** `i` are **non-increasing**, and The number of guards at the bank for the `time` days **after** `i` are **non-decreasing**. More formally, this means day `i` is a good day to rob the bank if and only if `security[i - time] >= security[i - time + 1] >= ... >= security[i] <= ... <= security[i + time - 1] <= security[i + time]`. Return _a list of **all** days **(0-indexed) **that are good days to rob the bank_._ The order that the days are returned in does** ****not** matter._ **Example 1:** ``` **Input:** security = [5,3,3,3,5,6,2], time = 2 **Output:** [2,3] **Explanation:** On day 2, we have security[0] >= security[1] >= security[2] <= security[3] <= security[4]. On day 3, we have security[1] >= security[2] >= security[3] <= security[4] <= security[5]. No other days satisfy this condition, so days 2 and 3 are the only good days to rob the bank. ``` **Example 2:** ``` **Input:** security = [1,1,1,1,1], time = 0 **Output:** [0,1,2,3,4] **Explanation:** Since time equals 0, every day is a good day to rob the bank, so return every day. ``` **Example 3:** ``` **Input:** security = [1,2,3,4,5,6], time = 2 **Output:** [] **Explanation:** No day has 2 days before it that have a non-increasing number of guards. Thus, no day is a good day to rob the bank, so return an empty list. ``` **Constraints:** `1 <= security.length <= 105` `0 <= security[i], time <= 105`",
        "test_case": [
            {
                "label": "Example 1",
                "input": "security = [5,3,3,3,5,6,2], time = 2",
                "output": "[2,3] Explanation: On day 2, we have security[0] >= security[1] >= security[2] <= security[3] <= security[4].\nOn day 3, we have security[1] >= security[2] >= security[3] <= security[4] <= security[5].\nNo other days satisfy this condition, so days 2 and 3 are the only good days to rob the bank."
            },
            {
                "label": "Example 2",
                "input": "security = [1,1,1,1,1], time = 0",
                "output": "[0,1,2,3,4] Explanation: Since time equals 0, every day is a good day to rob the bank, so return every day."
            },
            {
                "label": "Example 3",
                "input": "security = [1,2,3,4,5,6], time = 2",
                "output": "[] Explanation: No day has 2 days before it that have a non-increasing number of guards.\nThus, no day is a good day to rob the bank, so return an empty list."
            }
        ],
        "elixir_template": "defmodule Solution do\n  @spec good_days_to_rob_bank(security :: [integer], time :: integer) :: [integer]\n  def good_days_to_rob_bank(security, time) do\n    \n  end\nend",
        "erlang_template": "-spec good_days_to_rob_bank(Security :: [integer()], Time :: integer()) -> [integer()].\ngood_days_to_rob_bank(Security, Time) ->\n  .",
        "scala_template": "object Solution {\n    def goodDaysToRobBank(security: Array[Int], time: Int): List[Int] = {\n        \n    }\n}"
    },
    {
        "id": 2204,
        "name": "find-subsequence-of-length-k-with-the-largest-sum",
        "difficulty": "Easy",
        "link": "https://leetcode.com/problems/find-subsequence-of-length-k-with-the-largest-sum/",
        "task_description": "You are given an integer array `nums` and an integer `k`. You want to find a **subsequence **of `nums` of length `k` that has the **largest** sum. Return_ __**any** such subsequence as an integer array of length _`k`. A **subsequence** is an array that can be derived from another array by deleting some or no elements without changing the order of the remaining elements. **Example 1:** ``` **Input:** nums = [2,1,3,3], k = 2 **Output:** [3,3] **Explanation:** The subsequence has the largest sum of 3 + 3 = 6. ``` **Example 2:** ``` **Input:** nums = [-1,-2,3,4], k = 3 **Output:** [-1,3,4] **Explanation:** The subsequence has the largest sum of -1 + 3 + 4 = 6. ``` **Example 3:** ``` **Input:** nums = [3,4,3,3], k = 2 **Output:** [3,4] **Explanation:** The subsequence has the largest sum of 3 + 4 = 7. Another possible subsequence is [4, 3]. ``` **Constraints:** `1 <= nums.length <= 1000` `-105 <= nums[i] <= 105` `1 <= k <= nums.length`",
        "test_case": [
            {
                "label": "Example 1",
                "input": "nums = [2,1,3,3], k = 2",
                "output": "[3,3] Explanation: The subsequence has the largest sum of 3 + 3 = 6."
            },
            {
                "label": "Example 2",
                "input": "nums = [-1,-2,3,4], k = 3",
                "output": "[-1,3,4] Explanation: The subsequence has the largest sum of -1 + 3 + 4 = 6."
            },
            {
                "label": "Example 3",
                "input": "nums = [3,4,3,3], k = 2",
                "output": "[3,4] Explanation: The subsequence has the largest sum of 3 + 4 = 7. \nAnother possible subsequence is [4, 3]."
            }
        ],
        "elixir_template": "defmodule Solution do\n  @spec max_subsequence(nums :: [integer], k :: integer) :: [integer]\n  def max_subsequence(nums, k) do\n    \n  end\nend",
        "erlang_template": "-spec max_subsequence(Nums :: [integer()], K :: integer()) -> [integer()].\nmax_subsequence(Nums, K) ->\n  .",
        "scala_template": "object Solution {\n    def maxSubsequence(nums: Array[Int], k: Int): Array[Int] = {\n        \n    }\n}"
    },
    {
        "id": 2202,
        "name": "sum-of-k-mirror-numbers",
        "difficulty": "Hard",
        "link": "https://leetcode.com/problems/sum-of-k-mirror-numbers/",
        "task_description": "A **k-mirror number** is a **positive** integer **without leading zeros** that reads the same both forward and backward in base-10 **as well as** in base-k. For example, `9` is a 2-mirror number. The representation of `9` in base-10 and base-2 are `9` and `1001` respectively, which read the same both forward and backward. On the contrary, `4` is not a 2-mirror number. The representation of `4` in base-2 is `100`, which does not read the same both forward and backward. Given the base `k` and the number `n`, return _the **sum** of the_ `n` _**smallest** k-mirror numbers_. **Example 1:** ``` **Input:** k = 2, n = 5 **Output:** 25 **Explanation: **The 5 smallest 2-mirror numbers and their representations in base-2 are listed as follows: base-10 base-2 1 1 3 11 5 101 7 111 9 1001 Their sum = 1 + 3 + 5 + 7 + 9 = 25. ``` **Example 2:** ``` **Input:** k = 3, n = 7 **Output:** 499 **Explanation: **The 7 smallest 3-mirror numbers are and their representations in base-3 are listed as follows: base-10 base-3 1 1 2 2 4 11 8 22 121 11111 151 12121 212 21212 Their sum = 1 + 2 + 4 + 8 + 121 + 151 + 212 = 499. ``` **Example 3:** ``` **Input:** k = 7, n = 17 **Output:** 20379000 **Explanation:** The 17 smallest 7-mirror numbers are: 1, 2, 3, 4, 5, 6, 8, 121, 171, 242, 292, 16561, 65656, 2137312, 4602064, 6597956, 6958596 ``` **Constraints:** `2 <= k <= 9` `1 <= n <= 30`",
        "test_case": [
            {
                "label": "Example 1",
                "input": "k = 2, n = 5",
                "output": "25 Explanation: The 5 smallest 2-mirror numbers and their representations in base-2 are listed as follows:\n  base-10    base-2\n    1          1\n    3          11\n    5          101\n    7          111\n    9          1001\nTheir sum = 1 + 3 + 5 + 7 + 9 = 25."
            },
            {
                "label": "Example 2",
                "input": "k = 3, n = 7",
                "output": "499 Explanation: The 7 smallest 3-mirror numbers are and their representations in base-3 are listed as follows:\n  base-10    base-3\n    1          1\n    2          2\n    4          11\n    8          22\n    121        11111\n    151        12121\n    212        21212\nTheir sum = 1 + 2 + 4 + 8 + 121 + 151 + 212 = 499."
            },
            {
                "label": "Example 3",
                "input": "k = 7, n = 17",
                "output": "20379000 Explanation: The 17 smallest 7-mirror numbers are:\n1, 2, 3, 4, 5, 6, 8, 121, 171, 242, 292, 16561, 65656, 2137312, 4602064, 6597956, 6958596"
            }
        ],
        "elixir_template": "defmodule Solution do\n  @spec k_mirror(k :: integer, n :: integer) :: integer\n  def k_mirror(k, n) do\n    \n  end\nend",
        "erlang_template": "-spec k_mirror(K :: integer(), N :: integer()) -> integer().\nk_mirror(K, N) ->\n  .",
        "scala_template": "object Solution {\n    def kMirror(k: Int, n: Int): Long = {\n        \n    }\n}"
    },
    {
        "id": 2201,
        "name": "valid-arrangement-of-pairs",
        "difficulty": "Hard",
        "link": "https://leetcode.com/problems/valid-arrangement-of-pairs/",
        "task_description": "You are given a **0-indexed** 2D integer array `pairs` where `pairs[i] = [starti, endi]`. An arrangement of `pairs` is **valid** if for every index `i` where `1 <= i < pairs.length`, we have `endi-1 == starti`. Return _**any** valid arrangement of _`pairs`. **Note:** The inputs will be generated such that there exists a valid arrangement of `pairs`. **Example 1:** ``` **Input:** pairs = [[5,1],[4,5],[11,9],[9,4]] **Output:** [[11,9],[9,4],[4,5],[5,1]] **Explanation: **This is a valid arrangement since endi-1 always equals starti. end0 = 9 == 9 = start1 end1 = 4 == 4 = start2 end2 = 5 == 5 = start3 ``` **Example 2:** ``` **Input:** pairs = [[1,3],[3,2],[2,1]] **Output:** [[1,3],[3,2],[2,1]] **Explanation:** This is a valid arrangement since endi-1 always equals starti. end0 = 3 == 3 = start1 end1 = 2 == 2 = start2 The arrangements [[2,1],[1,3],[3,2]] and [[3,2],[2,1],[1,3]] are also valid. ``` **Example 3:** ``` **Input:** pairs = [[1,2],[1,3],[2,1]] **Output:** [[1,2],[2,1],[1,3]] **Explanation:** This is a valid arrangement since endi-1 always equals starti. end0 = 2 == 2 = start1 end1 = 1 == 1 = start2 ``` **Constraints:** `1 <= pairs.length <= 105` `pairs[i].length == 2` `0 <= starti, endi <= 109` `starti != endi` No two pairs are exactly the same. There **exists** a valid arrangement of `pairs`.",
        "test_case": [
            {
                "label": "Example 1",
                "input": "pairs = [[5,1],[4,5],[11,9],[9,4]]",
                "output": "[[11,9],[9,4],[4,5],[5,1]] Explanation: This is a valid arrangement since end i-1 always equals start i .\nend 0 = 9 == 9 = start 1 end 1 = 4 == 4 = start 2 end 2 = 5 == 5 = start 3"
            },
            {
                "label": "Example 2",
                "input": "pairs = [[1,3],[3,2],[2,1]]",
                "output": "[[1,3],[3,2],[2,1]] Explanation: This is a valid arrangement since end i-1 always equals start i .\nend 0 = 3 == 3 = start 1 end 1 = 2 == 2 = start 2 The arrangements [[2,1],[1,3],[3,2]] and [[3,2],[2,1],[1,3]] are also valid."
            },
            {
                "label": "Example 3",
                "input": "pairs = [[1,2],[1,3],[2,1]]",
                "output": "[[1,2],[2,1],[1,3]] Explanation: This is a valid arrangement since end i-1 always equals start i .\nend 0 = 2 == 2 = start 1 end 1 = 1 == 1 = start 2"
            }
        ],
        "elixir_template": "defmodule Solution do\n  @spec valid_arrangement(pairs :: [[integer]]) :: [[integer]]\n  def valid_arrangement(pairs) do\n    \n  end\nend",
        "erlang_template": "-spec valid_arrangement(Pairs :: [[integer()]]) -> [[integer()]].\nvalid_arrangement(Pairs) ->\n  .",
        "scala_template": "object Solution {\n    def validArrangement(pairs: Array[Array[Int]]): Array[Array[Int]] = {\n        \n    }\n}"
    },
    {
        "id": 2200,
        "name": "stamping-the-grid",
        "difficulty": "Hard",
        "link": "https://leetcode.com/problems/stamping-the-grid/",
        "task_description": "You are given an `m x n` binary matrix `grid` where each cell is either `0` (empty) or `1` (occupied). You are then given stamps of size `stampHeight x stampWidth`. We want to fit the stamps such that they follow the given **restrictions** and **requirements**: Cover all the **empty** cells. Do not cover any of the **occupied** cells. We can put as **many** stamps as we want. Stamps can **overlap** with each other. Stamps are not allowed to be **rotated**. Stamps must stay completely **inside** the grid. Return `true` _if it is possible to fit the stamps while following the given restrictions and requirements. Otherwise, return_ `false`. **Example 1:** ``` **Input:** grid = [[1,0,0,0],[1,0,0,0],[1,0,0,0],[1,0,0,0],[1,0,0,0]], stampHeight = 4, stampWidth = 3 **Output:** true **Explanation:** We have two overlapping stamps (labeled 1 and 2 in the image) that are able to cover all the empty cells. ``` **Example 2:** ``` **Input:** grid = [[1,0,0,0],[0,1,0,0],[0,0,1,0],[0,0,0,1]], stampHeight = 2, stampWidth = 2 **Output:** false **Explanation:** There is no way to fit the stamps onto all the empty cells without the stamps going outside the grid. ``` **Constraints:** `m == grid.length` `n == grid[r].length` `1 <= m, n <= 105` `1 <= m * n <= 2 * 105` `grid[r][c]` is either `0` or `1`. `1 <= stampHeight, stampWidth <= 105`",
        "test_case": [
            {
                "label": "Example 1",
                "input": "grid = [[1,0,0,0],[1,0,0,0],[1,0,0,0],[1,0,0,0],[1,0,0,0]], stampHeight = 4, stampWidth = 3",
                "output": "true Explanation: We have two overlapping stamps (labeled 1 and 2 in the image) that are able to cover all the empty cells."
            },
            {
                "label": "Example 2",
                "input": "grid = [[1,0,0,0],[0,1,0,0],[0,0,1,0],[0,0,0,1]], stampHeight = 2, stampWidth = 2",
                "output": "false Explanation: There is no way to fit the stamps onto all the empty cells without the stamps going outside the grid. Constraints: m == grid.length n == grid[r].length 1 <= m, n <= 10 5 1 <= m * n <= 2 * 10 5 grid[r][c] is either 0 or 1 . 1 <= stampHeight, stampWidth <= 10 5"
            }
        ],
        "elixir_template": "defmodule Solution do\n  @spec possible_to_stamp(grid :: [[integer]], stamp_height :: integer, stamp_width :: integer) :: boolean\n  def possible_to_stamp(grid, stamp_height, stamp_width) do\n    \n  end\nend",
        "erlang_template": "-spec possible_to_stamp(Grid :: [[integer()]], StampHeight :: integer(), StampWidth :: integer()) -> boolean().\npossible_to_stamp(Grid, StampHeight, StampWidth) ->\n  .",
        "scala_template": "object Solution {\n    def possibleToStamp(grid: Array[Array[Int]], stampHeight: Int, stampWidth: Int): Boolean = {\n        \n    }\n}"
    },
    {
        "id": 2199,
        "name": "two-furthest-houses-with-different-colors",
        "difficulty": "Easy",
        "link": "https://leetcode.com/problems/two-furthest-houses-with-different-colors/",
        "task_description": "There are `n` houses evenly lined up on the street, and each house is beautifully painted. You are given a **0-indexed** integer array `colors` of length `n`, where `colors[i]` represents the color of the `ith` house. Return _the **maximum** distance between **two** houses with **different** colors_. The distance between the `ith` and `jth` houses is `abs(i - j)`, where `abs(x)` is the **absolute value** of `x`. **Example 1:** ``` **Input:** colors = [**1**,1,1,**6**,1,1,1] **Output:** 3 **Explanation:** In the above image, color 1 is blue, and color 6 is red. The furthest two houses with different colors are house 0 and house 3. House 0 has color 1, and house 3 has color 6. The distance between them is abs(0 - 3) = 3. Note that houses 3 and 6 can also produce the optimal answer. ``` **Example 2:** ``` **Input:** colors = [**1**,8,3,8,**3**] **Output:** 4 **Explanation:** In the above image, color 1 is blue, color 8 is yellow, and color 3 is green. The furthest two houses with different colors are house 0 and house 4. House 0 has color 1, and house 4 has color 3. The distance between them is abs(0 - 4) = 4. ``` **Example 3:** ``` **Input:** colors = [**0**,**1**] **Output:** 1 **Explanation:** The furthest two houses with different colors are house 0 and house 1. House 0 has color 0, and house 1 has color 1. The distance between them is abs(0 - 1) = 1. ``` **Constraints:** `n == colors.length` `2 <= n <= 100` `0 <= colors[i] <= 100` Test data are generated such that **at least** two houses have different colors.",
        "test_case": [
            {
                "label": "Example 1",
                "input": "colors = [ 1 ,1,1, 6 ,1,1,1]",
                "output": "3 Explanation: In the above image, color 1 is blue, and color 6 is red.\nThe furthest two houses with different colors are house 0 and house 3.\nHouse 0 has color 1, and house 3 has color 6. The distance between them is abs(0 - 3) = 3.\nNote that houses 3 and 6 can also produce the optimal answer."
            },
            {
                "label": "Example 2",
                "input": "colors = [ 1 ,8,3,8, 3 ]",
                "output": "4 Explanation: In the above image, color 1 is blue, color 8 is yellow, and color 3 is green.\nThe furthest two houses with different colors are house 0 and house 4.\nHouse 0 has color 1, and house 4 has color 3. The distance between them is abs(0 - 4) = 4."
            },
            {
                "label": "Example 3",
                "input": "colors = [ 0 , 1 ]",
                "output": "1 Explanation: The furthest two houses with different colors are house 0 and house 1.\nHouse 0 has color 0, and house 1 has color 1. The distance between them is abs(0 - 1) = 1. Constraints: n ==\u00a0colors.length 2 <= n <= 100 0 <= colors[i] <= 100 Test data are generated such that at least two houses have different colors."
            }
        ],
        "elixir_template": "defmodule Solution do\n  @spec max_distance(colors :: [integer]) :: integer\n  def max_distance(colors) do\n    \n  end\nend",
        "erlang_template": "-spec max_distance(Colors :: [integer()]) -> integer().\nmax_distance(Colors) ->\n  .",
        "scala_template": "object Solution {\n    def maxDistance(colors: Array[Int]): Int = {\n        \n    }\n}"
    },
    {
        "id": 2198,
        "name": "process-restricted-friend-requests",
        "difficulty": "Hard",
        "link": "https://leetcode.com/problems/process-restricted-friend-requests/",
        "task_description": "You are given an integer `n` indicating the number of people in a network. Each person is labeled from `0` to `n - 1`. You are also given a **0-indexed** 2D integer array `restrictions`, where `restrictions[i] = [xi, yi]` means that person `xi` and person `yi` **cannot **become **friends**,** **either **directly** or **indirectly** through other people. Initially, no one is friends with each other. You are given a list of friend requests as a **0-indexed** 2D integer array `requests`, where `requests[j] = [uj, vj]` is a friend request between person `uj` and person `vj`. A friend request is **successful **if `uj` and `vj` can be **friends**. Each friend request is processed in the given order (i.e., `requests[j]` occurs before `requests[j + 1]`), and upon a successful request, `uj` and `vj` **become direct friends** for all future friend requests. Return _a **boolean array** _`result`,_ where each _`result[j]`_ is _`true`_ if the _`jth`_ friend request is **successful** or _`false`_ if it is not_. **Note:** If `uj` and `vj` are already direct friends, the request is still **successful**. **Example 1:** ``` **Input:** n = 3, restrictions = [[0,1]], requests = [[0,2],[2,1]] **Output:** [true,false] **Explanation: **Request 0: Person 0 and person 2 can be friends, so they become direct friends. Request 1: Person 2 and person 1 cannot be friends since person 0 and person 1 would be indirect friends (1--2--0). ``` **Example 2:** ``` **Input:** n = 3, restrictions = [[0,1]], requests = [[1,2],[0,2]] **Output:** [true,false] **Explanation: **Request 0: Person 1 and person 2 can be friends, so they become direct friends. Request 1: Person 0 and person 2 cannot be friends since person 0 and person 1 would be indirect friends (0--2--1). ``` **Example 3:** ``` **Input:** n = 5, restrictions = [[0,1],[1,2],[2,3]], requests = [[0,4],[1,2],[3,1],[3,4]] **Output:** [true,false,true,false] **Explanation: **Request 0: Person 0 and person 4 can be friends, so they become direct friends. Request 1: Person 1 and person 2 cannot be friends since they are directly restricted. Request 2: Person 3 and person 1 can be friends, so they become direct friends. Request 3: Person 3 and person 4 cannot be friends since person 0 and person 1 would be indirect friends (0--4--3--1). ``` **Constraints:** `2 <= n <= 1000` `0 <= restrictions.length <= 1000` `restrictions[i].length == 2` `0 <= xi, yi <= n - 1` `xi != yi` `1 <= requests.length <= 1000` `requests[j].length == 2` `0 <= uj, vj <= n - 1` `uj != vj`",
        "test_case": [
            {
                "label": "Example 1",
                "input": "n = 3, restrictions = [[0,1]], requests = [[0,2],[2,1]]",
                "output": "[true,false] Explanation: Request 0: Person 0 and person 2 can be friends, so they become direct friends. \nRequest 1: Person 2 and person 1 cannot be friends since person 0 and person 1 would be indirect friends (1--2--0)."
            },
            {
                "label": "Example 2",
                "input": "n = 3, restrictions = [[0,1]], requests = [[1,2],[0,2]]",
                "output": "[true,false] Explanation: Request 0: Person 1 and person 2 can be friends, so they become direct friends.\nRequest 1: Person 0 and person 2 cannot be friends since person 0 and person 1 would be indirect friends (0--2--1)."
            },
            {
                "label": "Example 3",
                "input": "n = 5, restrictions = [[0,1],[1,2],[2,3]], requests = [[0,4],[1,2],[3,1],[3,4]]",
                "output": "[true,false,true,false] Explanation: Request 0: Person 0 and person 4 can be friends, so they become direct friends.\nRequest 1: Person 1 and person 2 cannot be friends since they are directly restricted.\nRequest 2: Person 3 and person 1 can be friends, so they become direct friends.\nRequest 3: Person 3 and person 4 cannot be friends since person 0 and person 1 would be indirect friends (0--4--3--1)."
            }
        ],
        "elixir_template": "defmodule Solution do\n  @spec friend_requests(n :: integer, restrictions :: [[integer]], requests :: [[integer]]) :: [boolean]\n  def friend_requests(n, restrictions, requests) do\n    \n  end\nend",
        "erlang_template": "-spec friend_requests(N :: integer(), Restrictions :: [[integer()]], Requests :: [[integer()]]) -> [boolean()].\nfriend_requests(N, Restrictions, Requests) ->\n  .",
        "scala_template": "object Solution {\n    def friendRequests(n: Int, restrictions: Array[Array[Int]], requests: Array[Array[Int]]): Array[Boolean] = {\n        \n    }\n}"
    },
    {
        "id": 2197,
        "name": "decode-the-slanted-ciphertext",
        "difficulty": "Medium",
        "link": "https://leetcode.com/problems/decode-the-slanted-ciphertext/",
        "task_description": "A string `originalText` is encoded using a **slanted transposition cipher** to a string `encodedText` with the help of a matrix having a **fixed number of rows** `rows`. `originalText` is placed first in a top-left to bottom-right manner. The blue cells are filled first, followed by the red cells, then the yellow cells, and so on, until we reach the end of `originalText`. The arrow indicates the order in which the cells are filled. All empty cells are filled with `' '`. The number of columns is chosen such that the rightmost column will **not be empty** after filling in `originalText`. `encodedText` is then formed by appending all characters of the matrix in a row-wise fashion. The characters in the blue cells are appended first to `encodedText`, then the red cells, and so on, and finally the yellow cells. The arrow indicates the order in which the cells are accessed. For example, if `originalText = \"cipher\"` and `rows = 3`, then we encode it in the following manner: The blue arrows depict how `originalText` is placed in the matrix, and the red arrows denote the order in which `encodedText` is formed. In the above example, `encodedText = \"ch ie pr\"`. Given the encoded string `encodedText` and number of rows `rows`, return _the original string_ `originalText`. **Note:** `originalText` **does not** have any trailing spaces `' '`. The test cases are generated such that there is only one possible `originalText`. **Example 1:** ``` **Input:** encodedText = \"ch ie pr\", rows = 3 **Output:** \"cipher\" **Explanation:** This is the same example described in the problem description. ``` **Example 2:** ``` **Input:** encodedText = \"iveo eed l te olc\", rows = 4 **Output:** \"i love leetcode\" **Explanation:** The figure above denotes the matrix that was used to encode originalText. The blue arrows show how we can find originalText from encodedText. ``` **Example 3:** ``` **Input:** encodedText = \"coding\", rows = 1 **Output:** \"coding\" **Explanation:** Since there is only 1 row, both originalText and encodedText are the same. ``` **Constraints:** `0 <= encodedText.length <= 106` `encodedText` consists of lowercase English letters and `' '` only. `encodedText` is a valid encoding of some `originalText` that **does not** have trailing spaces. `1 <= rows <= 1000` The testcases are generated such that there is **only one** possible `originalText`.",
        "test_case": [
            {
                "label": "Example 1",
                "input": "encodedText = \"ch   ie   pr\", rows = 3",
                "output": "\"cipher\" Explanation: This is the same example described in the problem description."
            },
            {
                "label": "Example 2",
                "input": "encodedText = \"iveo    eed   l te   olc\", rows = 4",
                "output": "\"i love leetcode\" Explanation: The figure above denotes the matrix that was used to encode originalText. \nThe blue arrows show how we can find originalText from encodedText."
            },
            {
                "label": "Example 3",
                "input": "encodedText = \"coding\", rows = 1",
                "output": "\"coding\" Explanation: Since there is only 1 row, both originalText and encodedText are the same."
            }
        ],
        "elixir_template": "defmodule Solution do\n  @spec decode_ciphertext(encoded_text :: String.t, rows :: integer) :: String.t\n  def decode_ciphertext(encoded_text, rows) do\n    \n  end\nend",
        "erlang_template": "-spec decode_ciphertext(EncodedText :: unicode:unicode_binary(), Rows :: integer()) -> unicode:unicode_binary().\ndecode_ciphertext(EncodedText, Rows) ->\n  .",
        "scala_template": "object Solution {\n    def decodeCiphertext(encodedText: String, rows: Int): String = {\n        \n    }\n}"
    },
    {
        "id": 2196,
        "name": "reverse-nodes-in-even-length-groups",
        "difficulty": "Medium",
        "link": "https://leetcode.com/problems/reverse-nodes-in-even-length-groups/",
        "task_description": "You are given the `head` of a linked list. The nodes in the linked list are **sequentially** assigned to **non-empty** groups whose lengths form the sequence of the natural numbers (`1, 2, 3, 4, ...`). The **length** of a group is the number of nodes assigned to it. In other words, The `1st` node is assigned to the first group. The `2nd` and the `3rd` nodes are assigned to the second group. The `4th`, `5th`, and `6th` nodes are assigned to the third group, and so on. Note that the length of the last group may be less than or equal to `1 + the length of the second to last group`. **Reverse** the nodes in each group with an **even** length, and return _the_ `head` _of the modified linked list_. **Example 1:** ``` **Input:** head = [5,2,6,3,9,1,7,3,8,4] **Output:** [5,6,2,3,9,1,4,8,3,7] **Explanation:** - The length of the first group is 1, which is odd, hence no reversal occurs. - The length of the second group is 2, which is even, hence the nodes are reversed. - The length of the third group is 3, which is odd, hence no reversal occurs. - The length of the last group is 4, which is even, hence the nodes are reversed. ``` **Example 2:** ``` **Input:** head = [1,1,0,6] **Output:** [1,0,1,6] **Explanation:** - The length of the first group is 1. No reversal occurs. - The length of the second group is 2. The nodes are reversed. - The length of the last group is 1. No reversal occurs. ``` **Example 3:** ``` **Input:** head = [1,1,0,6,5] **Output:** [1,0,1,5,6] **Explanation:** - The length of the first group is 1. No reversal occurs. - The length of the second group is 2. The nodes are reversed. - The length of the last group is 2. The nodes are reversed. ``` **Constraints:** The number of nodes in the list is in the range `[1, 105]`. `0 <= Node.val <= 105`",
        "test_case": [
            {
                "label": "Example 1",
                "input": "head = [5,2,6,3,9,1,7,3,8,4]",
                "output": "[5,6,2,3,9,1,4,8,3,7] Explanation: - The length of the first group is 1, which is odd, hence no reversal occurs.\n- The length of the second group is 2, which is even, hence the nodes are reversed.\n- The length of the third group is 3, which is odd, hence no reversal occurs.\n- The length of the last group is 4, which is even, hence the nodes are reversed."
            },
            {
                "label": "Example 2",
                "input": "head = [1,1,0,6]",
                "output": "[1,0,1,6] Explanation: - The length of the first group is 1. No reversal occurs.\n- The length of the second group is 2. The nodes are reversed.\n- The length of the last group is 1. No reversal occurs."
            },
            {
                "label": "Example 3",
                "input": "head = [1,1,0,6,5]",
                "output": "[1,0,1,5,6] Explanation: - The length of the first group is 1. No reversal occurs.\n- The length of the second group is 2. The nodes are reversed.\n- The length of the last group is 2. The nodes are reversed. Constraints: The number of nodes in the list is in the range [1, 10 5 ] . 0 <= Node.val <= 10 5"
            }
        ],
        "elixir_template": "# Definition for singly-linked list.\n#\n# defmodule ListNode do\n#   @type t :: %__MODULE__{\n#           val: integer,\n#           next: ListNode.t() | nil\n#         }\n#   defstruct val: 0, next: nil\n# end\n\ndefmodule Solution do\n  @spec reverse_even_length_groups(head :: ListNode.t | nil) :: ListNode.t | nil\n  def reverse_even_length_groups(head) do\n    \n  end\nend",
        "erlang_template": "%% Definition for singly-linked list.\n%%\n%% -record(list_node, {val = 0 :: integer(),\n%%                     next = null :: 'null' | #list_node{}}).\n\n-spec reverse_even_length_groups(Head :: #list_node{} | null) -> #list_node{} | null.\nreverse_even_length_groups(Head) ->\n  .",
        "scala_template": "/**\n * Definition for singly-linked list.\n * class ListNode(_x: Int = 0, _next: ListNode = null) {\n *   var next: ListNode = _next\n *   var x: Int = _x\n * }\n */\nobject Solution {\n    def reverseEvenLengthGroups(head: ListNode): ListNode = {\n        \n    }\n}"
    },
    {
        "id": 2195,
        "name": "time-needed-to-buy-tickets",
        "difficulty": "Easy",
        "link": "https://leetcode.com/problems/time-needed-to-buy-tickets/",
        "task_description": "There are `n` people in a line queuing to buy tickets, where the `0th` person is at the **front** of the line and the `(n - 1)th` person is at the **back** of the line. You are given a **0-indexed** integer array `tickets` of length `n` where the number of tickets that the `ith` person would like to buy is `tickets[i]`. Each person takes **exactly 1 second** to buy a ticket. A person can only buy **1 ticket at a time** and has to go back to **the end** of the line (which happens **instantaneously**) in order to buy more tickets. If a person does not have any tickets left to buy, the person will **leave **the line. Return the **time taken** for the person **initially** at position **k**** **(0-indexed) to finish buying tickets. **Example 1:** **Input:** tickets = [2,3,2], k = 2 **Output:** 6 **Explanation:** The queue starts as [2,3,2], where the kth person is underlined. After the person at the front has bought a ticket, the queue becomes [3,2,1] at 1 second. Continuing this process, the queue becomes [2,1,2] at 2 seconds. Continuing this process, the queue becomes [1,2,1] at 3 seconds. Continuing this process, the queue becomes [2,1] at 4 seconds. Note: the person at the front left the queue. Continuing this process, the queue becomes [1,1] at 5 seconds. Continuing this process, the queue becomes [1] at 6 seconds. The kth person has bought all their tickets, so return 6. **Example 2:** **Input:** tickets = [5,1,1,1], k = 0 **Output:** 8 **Explanation:** The queue starts as [5,1,1,1], where the kth person is underlined. After the person at the front has bought a ticket, the queue becomes [1,1,1,4] at 1 second. Continuing this process for 3 seconds, the queue becomes [4] at 4 seconds. Continuing this process for 4 seconds, the queue becomes [] at 8 seconds. The kth person has bought all their tickets, so return 8. **Constraints:** `n == tickets.length` `1 <= n <= 100` `1 <= tickets[i] <= 100` `0 <= k < n`",
        "test_case": [
            {
                "label": "Example 1",
                "input": "tickets = [2,3,2], k = 2",
                "output": "6 Explanation: The queue starts as [2,3, 2 ], where the kth person is underlined. After the person at the front has bought a ticket, the queue becomes [3, 2 ,1] at 1 second. Continuing this process, the queue becomes [ 2 ,1,2] at 2 seconds. Continuing this process, the queue becomes [1,2, 1 ] at 3 seconds. Continuing this process, the queue becomes [2, 1 ] at 4 seconds. Note: the person at the front left the queue. Continuing this process, the queue becomes [ 1 ,1] at 5 seconds. Continuing this process, the queue becomes [1] at 6 seconds. The kth person has bought all their tickets, so return 6."
            },
            {
                "label": "Example 2",
                "input": "tickets = [5,1,1,1], k = 0",
                "output": "8 Explanation: The queue starts as [ 5 ,1,1,1], where the kth person is underlined. After the person at the front has bought a ticket, the queue becomes [1,1,1, 4 ] at 1 second. Continuing this process for 3 seconds, the queue becomes [ 4] at 4 seconds. Continuing this process for 4 seconds, the queue becomes [] at 8 seconds. The kth person has bought all their tickets, so return 8. Constraints: n == tickets.length 1 <= n <= 100 1 <= tickets[i] <= 100 0 <= k < n"
            }
        ],
        "elixir_template": "defmodule Solution do\n  @spec time_required_to_buy(tickets :: [integer], k :: integer) :: integer\n  def time_required_to_buy(tickets, k) do\n    \n  end\nend",
        "erlang_template": "-spec time_required_to_buy(Tickets :: [integer()], K :: integer()) -> integer().\ntime_required_to_buy(Tickets, K) ->\n  .",
        "scala_template": "object Solution {\n    def timeRequiredToBuy(tickets: Array[Int], k: Int): Int = {\n        \n    }\n}"
    },
    {
        "id": 2193,
        "name": "count-fertile-pyramids-in-a-land",
        "difficulty": "Hard",
        "link": "https://leetcode.com/problems/count-fertile-pyramids-in-a-land/",
        "task_description": "A farmer has a **rectangular grid** of land with `m` rows and `n` columns that can be divided into unit cells. Each cell is either **fertile** (represented by a `1`) or **barren** (represented by a `0`). All cells outside the grid are considered barren. A **pyramidal plot** of land can be defined as a set of cells with the following criteria: The number of cells in the set has to be **greater than **`1` and all cells must be **fertile**. The **apex** of a pyramid is the **topmost** cell of the pyramid. The **height** of a pyramid is the number of rows it covers. Let `(r, c)` be the apex of the pyramid, and its height be `h`. Then, the plot comprises of cells `(i, j)` where `r <= i <= r + h - 1` **and** `c - (i - r) <= j <= c + (i - r)`. An **inverse pyramidal plot** of land can be defined as a set of cells with similar criteria: The number of cells in the set has to be **greater than **`1` and all cells must be **fertile**. The **apex** of an inverse pyramid is the **bottommost** cell of the inverse pyramid. The **height** of an inverse pyramid is the number of rows it covers. Let `(r, c)` be the apex of the pyramid, and its height be `h`. Then, the plot comprises of cells `(i, j)` where `r - h + 1 <= i <= r` **and** `c - (r - i) <= j <= c + (r - i)`. Some examples of valid and invalid pyramidal (and inverse pyramidal) plots are shown below. Black cells indicate fertile cells. Given a **0-indexed** `m x n` binary matrix `grid` representing the farmland, return _the **total number** of pyramidal and inverse pyramidal plots that can be found in_ `grid`. **Example 1:** ``` **Input:** grid = [[0,1,1,0],[1,1,1,1]] **Output:** 2 **Explanation:** The 2 possible pyramidal plots are shown in blue and red respectively. There are no inverse pyramidal plots in this grid. Hence total number of pyramidal and inverse pyramidal plots is 2 + 0 = 2. ``` **Example 2:** ``` **Input:** grid = [[1,1,1],[1,1,1]] **Output:** 2 **Explanation:** The pyramidal plot is shown in blue, and the inverse pyramidal plot is shown in red. Hence the total number of plots is 1 + 1 = 2. ``` **Example 3:** ``` **Input:** grid = [[1,1,1,1,0],[1,1,1,1,1],[1,1,1,1,1],[0,1,0,0,1]] **Output:** 13 **Explanation:** There are 7 pyramidal plots, 3 of which are shown in the 2nd and 3rd figures. There are 6 inverse pyramidal plots, 2 of which are shown in the last figure. The total number of plots is 7 + 6 = 13. ``` **Constraints:** `m == grid.length` `n == grid[i].length` `1 <= m, n <= 1000` `1 <= m * n <= 105` `grid[i][j]` is either `0` or `1`.",
        "test_case": [
            {
                "label": "Example 1",
                "input": "grid = [[0,1,1,0],[1,1,1,1]]",
                "output": "2 Explanation: The 2 possible pyramidal plots are shown in blue and red respectively.\nThere are no inverse pyramidal plots in this grid. \nHence total number of pyramidal and inverse pyramidal plots is 2 + 0 = 2."
            },
            {
                "label": "Example 2",
                "input": "grid = [[1,1,1],[1,1,1]]",
                "output": "2 Explanation: The pyramidal plot is shown in blue, and the inverse pyramidal plot is shown in red. \nHence the total number of plots is 1 + 1 = 2."
            },
            {
                "label": "Example 3",
                "input": "grid = [[1,1,1,1,0],[1,1,1,1,1],[1,1,1,1,1],[0,1,0,0,1]]",
                "output": "13 Explanation: There are 7 pyramidal plots, 3 of which are shown in the 2nd and 3rd figures.\nThere are 6 inverse pyramidal plots, 2 of which are shown in the last figure.\nThe total number of plots is 7 + 6 = 13. Constraints: m == grid.length n == grid[i].length 1 <= m, n <= 1000 1 <= m * n <= 10 5 grid[i][j] is either 0 or 1 ."
            }
        ],
        "elixir_template": "defmodule Solution do\n  @spec count_pyramids(grid :: [[integer]]) :: integer\n  def count_pyramids(grid) do\n    \n  end\nend",
        "erlang_template": "-spec count_pyramids(Grid :: [[integer()]]) -> integer().\ncount_pyramids(Grid) ->\n  .",
        "scala_template": "object Solution {\n    def countPyramids(grid: Array[Array[Int]]): Int = {\n        \n    }\n}"
    },
    {
        "id": 2192,
        "name": "minimum-cost-homecoming-of-a-robot-in-a-grid",
        "difficulty": "Medium",
        "link": "https://leetcode.com/problems/minimum-cost-homecoming-of-a-robot-in-a-grid/",
        "task_description": "There is an `m x n` grid, where `(0, 0)` is the top-left cell and `(m - 1, n - 1)` is the bottom-right cell. You are given an integer array `startPos` where `startPos = [startrow, startcol]` indicates that **initially**, a **robot** is at the cell `(startrow, startcol)`. You are also given an integer array `homePos` where `homePos = [homerow, homecol]` indicates that its **home** is at the cell `(homerow, homecol)`. The robot needs to go to its home. It can move one cell in four directions: **left**, **right**, **up**, or **down**, and it can not move outside the boundary. Every move incurs some cost. You are further given two **0-indexed** integer arrays: `rowCosts` of length `m` and `colCosts` of length `n`. If the robot moves **up** or **down** into a cell whose **row** is `r`, then this move costs `rowCosts[r]`. If the robot moves **left** or **right** into a cell whose **column** is `c`, then this move costs `colCosts[c]`. Return _the **minimum total cost** for this robot to return home_. **Example 1:** ``` **Input:** startPos = [1, 0], homePos = [2, 3], rowCosts = [5, 4, 3], colCosts = [8, 2, 6, 7] **Output:** 18 **Explanation:** One optimal path is that: Starting from (1, 0) -> It goes down to (**2**, 0). This move costs rowCosts[2] = 3. -> It goes right to (2, **1**). This move costs colCosts[1] = 2. -> It goes right to (2, **2**). This move costs colCosts[2] = 6. -> It goes right to (2, **3**). This move costs colCosts[3] = 7. The total cost is 3 + 2 + 6 + 7 = 18 ``` **Example 2:** ``` **Input:** startPos = [0, 0], homePos = [0, 0], rowCosts = [5], colCosts = [26] **Output:** 0 **Explanation:** The robot is already at its home. Since no moves occur, the total cost is 0. ``` **Constraints:** `m == rowCosts.length` `n == colCosts.length` `1 <= m, n <= 105` `0 <= rowCosts[r], colCosts[c] <= 104` `startPos.length == 2` `homePos.length == 2` `0 <= startrow, homerow < m` `0 <= startcol, homecol < n`",
        "test_case": [
            {
                "label": "Example 1",
                "input": "startPos = [1, 0], homePos = [2, 3], rowCosts = [5, 4, 3], colCosts = [8, 2, 6, 7]",
                "output": "18 Explanation: One optimal path is that:\nStarting from (1, 0)\n-> It goes down to ( 2 , 0). This move costs rowCosts[2] = 3.\n-> It goes right to (2, 1 ). This move costs colCosts[1] = 2.\n-> It goes right to (2, 2 ). This move costs colCosts[2] = 6.\n-> It goes right to (2, 3 ). This move costs colCosts[3] = 7.\nThe total cost is 3 + 2 + 6 + 7 = 18"
            },
            {
                "label": "Example 2",
                "input": "startPos = [0, 0], homePos = [0, 0], rowCosts = [5], colCosts = [26]",
                "output": "0 Explanation: The robot is already at its home. Since no moves occur, the total cost is 0. Constraints: m == rowCosts.length n == colCosts.length 1 <= m, n <= 10 5 0 <= rowCosts[r], colCosts[c] <= 10 4 startPos.length == 2 homePos.length == 2 0 <= start row , home row < m 0 <= start col , home col < n"
            }
        ],
        "elixir_template": "defmodule Solution do\n  @spec min_cost(start_pos :: [integer], home_pos :: [integer], row_costs :: [integer], col_costs :: [integer]) :: integer\n  def min_cost(start_pos, home_pos, row_costs, col_costs) do\n    \n  end\nend",
        "erlang_template": "-spec min_cost(StartPos :: [integer()], HomePos :: [integer()], RowCosts :: [integer()], ColCosts :: [integer()]) -> integer().\nmin_cost(StartPos, HomePos, RowCosts, ColCosts) ->\n  .",
        "scala_template": "object Solution {\n    def minCost(startPos: Array[Int], homePos: Array[Int], rowCosts: Array[Int], colCosts: Array[Int]): Int = {\n        \n    }\n}"
    },
    {
        "id": 2191,
        "name": "minimum-number-of-food-buckets-to-feed-the-hamsters",
        "difficulty": "Medium",
        "link": "https://leetcode.com/problems/minimum-number-of-food-buckets-to-feed-the-hamsters/",
        "task_description": "You are given a **0-indexed** string `hamsters` where `hamsters[i]` is either: `'H'` indicating that there is a hamster at index `i`, or `'.'` indicating that index `i` is empty. You will add some number of food buckets at the empty indices in order to feed the hamsters. A hamster can be fed if there is at least one food bucket to its left or to its right. More formally, a hamster at index `i` can be fed if you place a food bucket at index `i - 1` **and/or** at index `i + 1`. Return _the minimum number of food buckets you should **place at empty indices** to feed all the hamsters or _`-1`_ if it is impossible to feed all of them_. **Example 1:** ``` **Input:** hamsters = \"H..H\" **Output:** 2 **Explanation:** We place two food buckets at indices 1 and 2. It can be shown that if we place only one food bucket, one of the hamsters will not be fed. ``` **Example 2:** ``` **Input:** hamsters = \".H.H.\" **Output:** 1 **Explanation:** We place one food bucket at index 2. ``` **Example 3:** ``` **Input:** hamsters = \".HHH.\" **Output:** -1 **Explanation:** If we place a food bucket at every empty index as shown, the hamster at index 2 will not be able to eat. ``` **Constraints:** `1 <= hamsters.length <= 105` `hamsters[i]` is either`'H'` or `'.'`.",
        "test_case": [
            {
                "label": "Example 1",
                "input": "hamsters = \"H..H\"",
                "output": "2 Explanation: We place two food buckets at indices 1 and 2.\nIt can be shown that if we place only one food bucket, one of the hamsters will not be fed."
            },
            {
                "label": "Example 2",
                "input": "hamsters = \".H.H.\"",
                "output": "1 Explanation: We place one food bucket at index 2."
            },
            {
                "label": "Example 3",
                "input": "hamsters = \".HHH.\"",
                "output": "-1 Explanation: If we place a food bucket at every empty index as shown, the hamster at index 2 will not be able to eat."
            }
        ],
        "elixir_template": "defmodule Solution do\n  @spec minimum_buckets(hamsters :: String.t) :: integer\n  def minimum_buckets(hamsters) do\n    \n  end\nend",
        "erlang_template": "-spec minimum_buckets(Hamsters :: unicode:unicode_binary()) -> integer().\nminimum_buckets(Hamsters) ->\n  .",
        "scala_template": "object Solution {\n    def minimumBuckets(hamsters: String): Int = {\n        \n    }\n}"
    },
    {
        "id": 2190,
        "name": "count-common-words-with-one-occurrence",
        "difficulty": "Easy",
        "link": "https://leetcode.com/problems/count-common-words-with-one-occurrence/",
        "task_description": "Given two string arrays `words1` and `words2`, return _the number of strings that appear **exactly once** in each of the two arrays._ **Example 1:** ``` **Input:** words1 = [\"leetcode\",\"is\",\"amazing\",\"as\",\"is\"], words2 = [\"amazing\",\"leetcode\",\"is\"] **Output:** 2 **Explanation:** - \"leetcode\" appears exactly once in each of the two arrays. We count this string. - \"amazing\" appears exactly once in each of the two arrays. We count this string. - \"is\" appears in each of the two arrays, but there are 2 occurrences of it in words1. We do not count this string. - \"as\" appears once in words1, but does not appear in words2. We do not count this string. Thus, there are 2 strings that appear exactly once in each of the two arrays. ``` **Example 2:** ``` **Input:** words1 = [\"b\",\"bb\",\"bbb\"], words2 = [\"a\",\"aa\",\"aaa\"] **Output:** 0 **Explanation:** There are no strings that appear in each of the two arrays. ``` **Example 3:** ``` **Input:** words1 = [\"a\",\"ab\"], words2 = [\"a\",\"a\",\"a\",\"ab\"] **Output:** 1 **Explanation:** The only string that appears exactly once in each of the two arrays is \"ab\". ``` **Constraints:** `1 <= words1.length, words2.length <= 1000` `1 <= words1[i].length, words2[j].length <= 30` `words1[i]` and `words2[j]` consists only of lowercase English letters.",
        "test_case": [
            {
                "label": "Example 1",
                "input": "words1 = [\"leetcode\",\"is\",\"amazing\",\"as\",\"is\"], words2 = [\"amazing\",\"leetcode\",\"is\"]",
                "output": "2 Explanation: - \"leetcode\" appears exactly once in each of the two arrays. We count this string.\n- \"amazing\" appears exactly once in each of the two arrays. We count this string.\n- \"is\" appears in each of the two arrays, but there are 2 occurrences of it in words1. We do not count this string.\n- \"as\" appears once in words1, but does not appear in words2. We do not count this string.\nThus, there are 2 strings that appear exactly once in each of the two arrays."
            },
            {
                "label": "Example 2",
                "input": "words1 = [\"b\",\"bb\",\"bbb\"], words2 = [\"a\",\"aa\",\"aaa\"]",
                "output": "0 Explanation: There are no strings that appear in each of the two arrays."
            },
            {
                "label": "Example 3",
                "input": "words1 = [\"a\",\"ab\"], words2 = [\"a\",\"a\",\"a\",\"ab\"]",
                "output": "1 Explanation: The only string that appears exactly once in each of the two arrays is \"ab\"."
            }
        ],
        "elixir_template": "defmodule Solution do\n  @spec count_words(words1 :: [String.t], words2 :: [String.t]) :: integer\n  def count_words(words1, words2) do\n    \n  end\nend",
        "erlang_template": "-spec count_words(Words1 :: [unicode:unicode_binary()], Words2 :: [unicode:unicode_binary()]) -> integer().\ncount_words(Words1, Words2) ->\n  .",
        "scala_template": "object Solution {\n    def countWords(words1: Array[String], words2: Array[String]): Int = {\n        \n    }\n}"
    },
    {
        "id": 2189,
        "name": "maximum-path-quality-of-a-graph",
        "difficulty": "Hard",
        "link": "https://leetcode.com/problems/maximum-path-quality-of-a-graph/",
        "task_description": "There is an **undirected** graph with `n` nodes numbered from `0` to `n - 1` (**inclusive**). You are given a **0-indexed** integer array `values` where `values[i]` is the **value **of the `ith` node. You are also given a **0-indexed** 2D integer array `edges`, where each `edges[j] = [uj, vj, timej]` indicates that there is an undirected edge between the nodes `uj` and `vj`, and it takes `timej` seconds to travel between the two nodes. Finally, you are given an integer `maxTime`. A **valid** **path** in the graph is any path that starts at node `0`, ends at node `0`, and takes **at most** `maxTime` seconds to complete. You may visit the same node multiple times. The **quality** of a valid path is the **sum** of the values of the **unique nodes** visited in the path (each node's value is added **at most once** to the sum). Return _the **maximum** quality of a valid path_. **Note:** There are **at most four** edges connected to each node. **Example 1:** ``` **Input:** values = [0,32,10,43], edges = [[0,1,10],[1,2,15],[0,3,10]], maxTime = 49 **Output:** 75 **Explanation:** One possible path is 0 -> 1 -> 0 -> 3 -> 0. The total time taken is 10 + 10 + 10 + 10 = 40 <= 49. The nodes visited are 0, 1, and 3, giving a maximal path quality of 0 + 32 + 43 = 75. ``` **Example 2:** ``` **Input:** values = [5,10,15,20], edges = [[0,1,10],[1,2,10],[0,3,10]], maxTime = 30 **Output:** 25 **Explanation:** One possible path is 0 -> 3 -> 0. The total time taken is 10 + 10 = 20 <= 30. The nodes visited are 0 and 3, giving a maximal path quality of 5 + 20 = 25. ``` **Example 3:** ``` **Input:** values = [1,2,3,4], edges = [[0,1,10],[1,2,11],[2,3,12],[1,3,13]], maxTime = 50 **Output:** 7 **Explanation:** One possible path is 0 -> 1 -> 3 -> 1 -> 0. The total time taken is 10 + 13 + 13 + 10 = 46 <= 50. The nodes visited are 0, 1, and 3, giving a maximal path quality of 1 + 2 + 4 = 7. ``` **Constraints:** `n == values.length` `1 <= n <= 1000` `0 <= values[i] <= 108` `0 <= edges.length <= 2000` `edges[j].length == 3 ` `0 <= uj < vj <= n - 1` `10 <= timej, maxTime <= 100` All the pairs `[uj, vj]` are **unique**. There are **at most four** edges connected to each node. The graph may not be connected.",
        "test_case": [
            {
                "label": "Example 1",
                "input": "values = [0,32,10,43], edges = [[0,1,10],[1,2,15],[0,3,10]], maxTime = 49",
                "output": "75 Explanation: One possible path is 0 -> 1 -> 0 -> 3 -> 0. The total time taken is 10 + 10 + 10 + 10 = 40 <= 49.\nThe nodes visited are 0, 1, and 3, giving a maximal path quality of 0 + 32 + 43 = 75."
            },
            {
                "label": "Example 2",
                "input": "values = [5,10,15,20], edges = [[0,1,10],[1,2,10],[0,3,10]], maxTime = 30",
                "output": "25 Explanation: One possible path is 0 -> 3 -> 0. The total time taken is 10 + 10 = 20 <= 30.\nThe nodes visited are 0 and 3, giving a maximal path quality of 5 + 20 = 25."
            },
            {
                "label": "Example 3",
                "input": "values = [1,2,3,4], edges = [[0,1,10],[1,2,11],[2,3,12],[1,3,13]], maxTime = 50",
                "output": "7 Explanation: One possible path is 0 -> 1 -> 3 -> 1 -> 0. The total time taken is 10 + 13 + 13 + 10 = 46 <= 50.\nThe nodes visited are 0, 1, and 3, giving a maximal path quality of 1 + 2 + 4 = 7. Constraints: n == values.length 1 <= n <= 1000 0 <= values[i] <= 10 8 0 <= edges.length <= 2000 edges[j].length == 3 0 <= u j < v j <= n - 1 10 <= time j , maxTime <= 100 All the pairs [u j , v j ] are unique . There are at most four edges connected to each node. The graph may not be connected."
            }
        ],
        "elixir_template": "defmodule Solution do\n  @spec maximal_path_quality(values :: [integer], edges :: [[integer]], max_time :: integer) :: integer\n  def maximal_path_quality(values, edges, max_time) do\n    \n  end\nend",
        "erlang_template": "-spec maximal_path_quality(Values :: [integer()], Edges :: [[integer()]], MaxTime :: integer()) -> integer().\nmaximal_path_quality(Values, Edges, MaxTime) ->\n  .",
        "scala_template": "object Solution {\n    def maximalPathQuality(values: Array[Int], edges: Array[Array[Int]], maxTime: Int): Int = {\n        \n    }\n}"
    },
    {
        "id": 2188,
        "name": "minimized-maximum-of-products-distributed-to-any-store",
        "difficulty": "Medium",
        "link": "https://leetcode.com/problems/minimized-maximum-of-products-distributed-to-any-store/",
        "task_description": "You are given an integer `n` indicating there are `n` specialty retail stores. There are `m` product types of varying amounts, which are given as a **0-indexed** integer array `quantities`, where `quantities[i]` represents the number of products of the `ith` product type. You need to distribute **all products** to the retail stores following these rules: A store can only be given **at most one product type** but can be given **any** amount of it. After distribution, each store will have been given some number of products (possibly `0`). Let `x` represent the maximum number of products given to any store. You want `x` to be as small as possible, i.e., you want to **minimize** the **maximum** number of products that are given to any store. Return _the minimum possible_ `x`. **Example 1:** ``` **Input:** n = 6, quantities = [11,6] **Output:** 3 **Explanation:** One optimal way is: - The 11 products of type 0 are distributed to the first four stores in these amounts: 2, 3, 3, 3 - The 6 products of type 1 are distributed to the other two stores in these amounts: 3, 3 The maximum number of products given to any store is max(2, 3, 3, 3, 3, 3) = 3. ``` **Example 2:** ``` **Input:** n = 7, quantities = [15,10,10] **Output:** 5 **Explanation:** One optimal way is: - The 15 products of type 0 are distributed to the first three stores in these amounts: 5, 5, 5 - The 10 products of type 1 are distributed to the next two stores in these amounts: 5, 5 - The 10 products of type 2 are distributed to the last two stores in these amounts: 5, 5 The maximum number of products given to any store is max(5, 5, 5, 5, 5, 5, 5) = 5. ``` **Example 3:** ``` **Input:** n = 1, quantities = [100000] **Output:** 100000 **Explanation:** The only optimal way is: - The 100000 products of type 0 are distributed to the only store. The maximum number of products given to any store is max(100000) = 100000. ``` **Constraints:** `m == quantities.length` `1 <= m <= n <= 105` `1 <= quantities[i] <= 105`",
        "test_case": [
            {
                "label": "Example 1",
                "input": "n = 6, quantities = [11,6]",
                "output": "3 Explanation: One optimal way is:\n- The 11 products of type 0 are distributed to the first four stores in these amounts: 2, 3, 3, 3\n- The 6 products of type 1 are distributed to the other two stores in these amounts: 3, 3\nThe maximum number of products given to any store is max(2, 3, 3, 3, 3, 3) = 3."
            },
            {
                "label": "Example 2",
                "input": "n = 7, quantities = [15,10,10]",
                "output": "5 Explanation: One optimal way is:\n- The 15 products of type 0 are distributed to the first three stores in these amounts: 5, 5, 5\n- The 10 products of type 1 are distributed to the next two stores in these amounts: 5, 5\n- The 10 products of type 2 are distributed to the last two stores in these amounts: 5, 5\nThe maximum number of products given to any store is max(5, 5, 5, 5, 5, 5, 5) = 5."
            },
            {
                "label": "Example 3",
                "input": "n = 1, quantities = [100000]",
                "output": "100000 Explanation: The only optimal way is:\n- The 100000 products of type 0 are distributed to the only store.\nThe maximum number of products given to any store is max(100000) = 100000. Constraints: m == quantities.length 1 <= m <= n <= 10 5 1 <= quantities[i] <= 10 5"
            }
        ],
        "elixir_template": "defmodule Solution do\n  @spec minimized_maximum(n :: integer, quantities :: [integer]) :: integer\n  def minimized_maximum(n, quantities) do\n    \n  end\nend",
        "erlang_template": "-spec minimized_maximum(N :: integer(), Quantities :: [integer()]) -> integer().\nminimized_maximum(N, Quantities) ->\n  .",
        "scala_template": "object Solution {\n    def minimizedMaximum(n: Int, quantities: Array[Int]): Int = {\n        \n    }\n}"
    },
    {
        "id": 2187,
        "name": "vowels-of-all-substrings",
        "difficulty": "Medium",
        "link": "https://leetcode.com/problems/vowels-of-all-substrings/",
        "task_description": "Given a string `word`, return _the **sum of the number of vowels** (_`'a'`, `'e'`_,_ `'i'`_,_ `'o'`_, and_ `'u'`_)_ _in every substring of _`word`. A **substring** is a contiguous (non-empty) sequence of characters within a string. **Note:** Due to the large constraints, the answer may not fit in a signed 32-bit integer. Please be careful during the calculations. **Example 1:** ``` **Input:** word = \"aba\" **Output:** 6 **Explanation:** All possible substrings are: \"a\", \"ab\", \"aba\", \"b\", \"ba\", and \"a\". - \"b\" has 0 vowels in it - \"a\", \"ab\", \"ba\", and \"a\" have 1 vowel each - \"aba\" has 2 vowels in it Hence, the total sum of vowels = 0 + 1 + 1 + 1 + 1 + 2 = 6. ``` **Example 2:** ``` **Input:** word = \"abc\" **Output:** 3 **Explanation:** All possible substrings are: \"a\", \"ab\", \"abc\", \"b\", \"bc\", and \"c\". - \"a\", \"ab\", and \"abc\" have 1 vowel each - \"b\", \"bc\", and \"c\" have 0 vowels each Hence, the total sum of vowels = 1 + 1 + 1 + 0 + 0 + 0 = 3. ``` **Example 3:** ``` **Input:** word = \"ltcd\" **Output:** 0 **Explanation:** There are no vowels in any substring of \"ltcd\". ``` **Constraints:** `1 <= word.length <= 105` `word` consists of lowercase English letters.",
        "test_case": [
            {
                "label": "Example 1",
                "input": "word = \"aba\"",
                "output": "6 Explanation: All possible substrings are: \"a\", \"ab\", \"aba\", \"b\", \"ba\", and \"a\".\n- \"b\" has 0 vowels in it\n- \"a\", \"ab\", \"ba\", and \"a\" have 1 vowel each\n- \"aba\" has 2 vowels in it\nHence, the total sum of vowels = 0 + 1 + 1 + 1 + 1 + 2 = 6."
            },
            {
                "label": "Example 2",
                "input": "word = \"abc\"",
                "output": "3 Explanation: All possible substrings are: \"a\", \"ab\", \"abc\", \"b\", \"bc\", and \"c\".\n- \"a\", \"ab\", and \"abc\" have 1 vowel each\n- \"b\", \"bc\", and \"c\" have 0 vowels each\nHence, the total sum of vowels = 1 + 1 + 1 + 0 + 0 + 0 = 3."
            },
            {
                "label": "Example 3",
                "input": "word = \"ltcd\"",
                "output": "0 Explanation: There are no vowels in any substring of \"ltcd\"."
            }
        ],
        "elixir_template": "defmodule Solution do\n  @spec count_vowels(word :: String.t) :: integer\n  def count_vowels(word) do\n    \n  end\nend",
        "erlang_template": "-spec count_vowels(Word :: unicode:unicode_binary()) -> integer().\ncount_vowels(Word) ->\n  .",
        "scala_template": "object Solution {\n    def countVowels(word: String): Long = {\n        \n    }\n}"
    },
    {
        "id": 2186,
        "name": "count-vowel-substrings-of-a-string",
        "difficulty": "Easy",
        "link": "https://leetcode.com/problems/count-vowel-substrings-of-a-string/",
        "task_description": "A **substring** is a contiguous (non-empty) sequence of characters within a string. A **vowel substring** is a substring that **only** consists of vowels (`'a'`, `'e'`, `'i'`, `'o'`, and `'u'`) and has **all five** vowels present in it. Given a string `word`, return _the number of **vowel substrings** in_ `word`. **Example 1:** ``` **Input:** word = \"aeiouu\" **Output:** 2 **Explanation:** The vowel substrings of word are as follows (underlined): - \"**aeiou**u\" - \"**aeiouu**\" ``` **Example 2:** ``` **Input:** word = \"unicornarihan\" **Output:** 0 **Explanation:** Not all 5 vowels are present, so there are no vowel substrings. ``` **Example 3:** ``` **Input:** word = \"cuaieuouac\" **Output:** 7 **Explanation:** The vowel substrings of word are as follows (underlined): - \"c**uaieuo**uac\" - \"c**uaieuou**ac\" - \"c**uaieuoua**c\" - \"cu**aieuo**uac\" - \"cu**aieuou**ac\" - \"cu**aieuoua**c\" - \"cua**ieuoua**c\" ``` **Constraints:** `1 <= word.length <= 100` `word` consists of lowercase English letters only.",
        "test_case": [
            {
                "label": "Example 1",
                "input": "word = \"aeiouu\"",
                "output": "2 Explanation: The vowel substrings of word are as follows (underlined):\n- \" aeiou u\"\n- \" aeiouu \""
            },
            {
                "label": "Example 2",
                "input": "word = \"unicornarihan\"",
                "output": "0 Explanation: Not all 5 vowels are present, so there are no vowel substrings."
            },
            {
                "label": "Example 3",
                "input": "word = \"cuaieuouac\"",
                "output": "7 Explanation: The vowel substrings of word are as follows (underlined):\n- \"c uaieuo uac\"\n- \"c uaieuou ac\"\n- \"c uaieuoua c\"\n- \"cu aieuo uac\"\n- \"cu aieuou ac\"\n- \"cu aieuoua c\"\n- \"cua ieuoua c\""
            }
        ],
        "elixir_template": "defmodule Solution do\n  @spec count_vowel_substrings(word :: String.t) :: integer\n  def count_vowel_substrings(word) do\n    \n  end\nend",
        "erlang_template": "-spec count_vowel_substrings(Word :: unicode:unicode_binary()) -> integer().\ncount_vowel_substrings(Word) ->\n  .",
        "scala_template": "object Solution {\n    def countVowelSubstrings(word: String): Int = {\n        \n    }\n}"
    },
    {
        "id": 2184,
        "name": "check-if-an-original-string-exists-given-two-encoded-strings",
        "difficulty": "Hard",
        "link": "https://leetcode.com/problems/check-if-an-original-string-exists-given-two-encoded-strings/",
        "task_description": "An original string, consisting of lowercase English letters, can be encoded by the following steps: Arbitrarily **split** it into a **sequence** of some number of **non-empty** substrings. Arbitrarily choose some elements (possibly none) of the sequence, and **replace** each with **its length** (as a numeric string). **Concatenate** the sequence as the encoded string. For example, **one way** to encode an original string `\"abcdefghijklmnop\"` might be: Split it as a sequence: `[\"ab\", \"cdefghijklmn\", \"o\", \"p\"]`. Choose the second and third elements to be replaced by their lengths, respectively. The sequence becomes `[\"ab\", \"12\", \"1\", \"p\"]`. Concatenate the elements of the sequence to get the encoded string: `\"ab121p\"`. Given two encoded strings `s1` and `s2`, consisting of lowercase English letters and digits `1-9` (inclusive), return `true`_ if there exists an original string that could be encoded as **both** _`s1`_ and _`s2`_. Otherwise, return _`false`. **Note**: The test cases are generated such that the number of consecutive digits in `s1` and `s2` does not exceed `3`. **Example 1:** ``` **Input:** s1 = \"internationalization\", s2 = \"i18n\" **Output:** true **Explanation:** It is possible that \"internationalization\" was the original string. - \"internationalization\" -> Split: [\"internationalization\"] -> Do not replace any element -> Concatenate: \"internationalization\", which is s1. - \"internationalization\" -> Split: [\"i\", \"nternationalizatio\", \"n\"] -> Replace: [\"i\", \"18\", \"n\"] -> Concatenate: \"i18n\", which is s2 ``` **Example 2:** ``` **Input:** s1 = \"l123e\", s2 = \"44\" **Output:** true **Explanation:** It is possible that \"leetcode\" was the original string. - \"leetcode\" -> Split: [\"l\", \"e\", \"et\", \"cod\", \"e\"] -> Replace: [\"l\", \"1\", \"2\", \"3\", \"e\"] -> Concatenate: \"l123e\", which is s1. - \"leetcode\" -> Split: [\"leet\", \"code\"] -> Replace: [\"4\", \"4\"] -> Concatenate: \"44\", which is s2. ``` **Example 3:** ``` **Input:** s1 = \"a5b\", s2 = \"c5b\" **Output:** false **Explanation:** It is impossible. - The original string encoded as s1 must start with the letter 'a'. - The original string encoded as s2 must start with the letter 'c'. ``` **Constraints:** `1 <= s1.length, s2.length <= 40` `s1` and `s2` consist of digits `1-9` (inclusive), and lowercase English letters only. The number of consecutive digits in `s1` and `s2` does not exceed `3`.",
        "test_case": [
            {
                "label": "Example 1",
                "input": "s1 = \"internationalization\", s2 = \"i18n\"",
                "output": "true Explanation: It is possible that \"internationalization\" was the original string.\n- \"internationalization\" \n  -> Split:       [\"internationalization\"]\n  -> Do not replace any element\n  -> Concatenate:  \"internationalization\", which is s1.\n- \"internationalization\"\n  -> Split:       [\"i\", \"nternationalizatio\", \"n\"]\n  -> Replace:     [\"i\", \"18\",                 \"n\"]\n  -> Concatenate:  \"i18n\", which is s2"
            },
            {
                "label": "Example 2",
                "input": "s1 = \"l123e\", s2 = \"44\"",
                "output": "true Explanation: It is possible that \"leetcode\" was the original string.\n- \"leetcode\" \n  -> Split:      [\"l\", \"e\", \"et\", \"cod\", \"e\"]\n  -> Replace:    [\"l\", \"1\", \"2\",  \"3\",   \"e\"]\n  -> Concatenate: \"l123e\", which is s1.\n- \"leetcode\" \n  -> Split:      [\"leet\", \"code\"]\n  -> Replace:    [\"4\",    \"4\"]\n  -> Concatenate: \"44\", which is s2."
            },
            {
                "label": "Example 3",
                "input": "s1 = \"a5b\", s2 = \"c5b\"",
                "output": "false Explanation: It is impossible.\n- The original string encoded as s1 must start with the letter 'a'.\n- The original string encoded as s2 must start with the letter 'c'."
            }
        ],
        "elixir_template": "defmodule Solution do\n  @spec possibly_equals(s1 :: String.t, s2 :: String.t) :: boolean\n  def possibly_equals(s1, s2) do\n    \n  end\nend",
        "erlang_template": "-spec possibly_equals(S1 :: unicode:unicode_binary(), S2 :: unicode:unicode_binary()) -> boolean().\npossibly_equals(S1, S2) ->\n  .",
        "scala_template": "object Solution {\n    def possiblyEquals(s1: String, s2: String): Boolean = {\n        \n    }\n}"
    },
    {
        "id": 2183,
        "name": "minimum-operations-to-convert-number",
        "difficulty": "Medium",
        "link": "https://leetcode.com/problems/minimum-operations-to-convert-number/",
        "task_description": "You are given a **0-indexed** integer array `nums` containing **distinct** numbers, an integer `start`, and an integer `goal`. There is an integer `x` that is initially set to `start`, and you want to perform operations on `x` such that it is converted to `goal`. You can perform the following operation repeatedly on the number `x`: If `0 <= x <= 1000`, then for any index `i` in the array (`0 <= i < nums.length`), you can set `x` to any of the following: `x + nums[i]` `x - nums[i]` `x ^ nums[i]` (bitwise-XOR) Note that you can use each `nums[i]` any number of times in any order. Operations that set `x` to be out of the range `0 <= x <= 1000` are valid, but no more operations can be done afterward. Return _the **minimum** number of operations needed to convert _`x = start`_ into _`goal`_, and _`-1`_ if it is not possible_. **Example 1:** ``` **Input:** nums = [2,4,12], start = 2, goal = 12 **Output:** 2 **Explanation:** We can go from 2 \u2192 14 \u2192 12 with the following 2 operations. - 2 + 12 = 14 - 14 - 2 = 12 ``` **Example 2:** ``` **Input:** nums = [3,5,7], start = 0, goal = -4 **Output:** 2 **Explanation:** We can go from 0 \u2192 3 \u2192 -4 with the following 2 operations. - 0 + 3 = 3 - 3 - 7 = -4 Note that the last operation sets x out of the range 0 <= x <= 1000, which is valid. ``` **Example 3:** ``` **Input:** nums = [2,8,16], start = 0, goal = 1 **Output:** -1 **Explanation:** There is no way to convert 0 into 1. ``` **Constraints:** `1 <= nums.length <= 1000` `-109 <= nums[i], goal <= 109` `0 <= start <= 1000` `start != goal` All the integers in `nums` are distinct.",
        "test_case": [
            {
                "label": "Example 1",
                "input": "nums = [2,4,12], start = 2, goal = 12",
                "output": "2 Explanation: We can go from 2 \u2192 14 \u2192 12 with the following 2 operations.\n- 2 + 12 = 14\n- 14 - 2 = 12"
            },
            {
                "label": "Example 2",
                "input": "nums = [3,5,7], start = 0, goal = -4",
                "output": "2 Explanation: We can go from 0 \u2192 3 \u2192 -4 with the following 2 operations. \n- 0 + 3 = 3\n- 3 - 7 = -4\nNote that the last operation sets x out of the range 0 <= x <= 1000, which is valid."
            },
            {
                "label": "Example 3",
                "input": "nums = [2,8,16], start = 0, goal = 1",
                "output": "-1 Explanation: There is no way to convert 0 into 1."
            }
        ],
        "elixir_template": "defmodule Solution do\n  @spec minimum_operations(nums :: [integer], start :: integer, goal :: integer) :: integer\n  def minimum_operations(nums, start, goal) do\n    \n  end\nend",
        "erlang_template": "-spec minimum_operations(Nums :: [integer()], Start :: integer(), Goal :: integer()) -> integer().\nminimum_operations(Nums, Start, Goal) ->\n  .",
        "scala_template": "object Solution {\n    def minimumOperations(nums: Array[Int], start: Int, goal: Int): Int = {\n        \n    }\n}"
    },
    {
        "id": 2182,
        "name": "find-the-minimum-and-maximum-number-of-nodes-between-critical-points",
        "difficulty": "Medium",
        "link": "https://leetcode.com/problems/find-the-minimum-and-maximum-number-of-nodes-between-critical-points/",
        "task_description": "A **critical point** in a linked list is defined as **either** a **local maxima** or a **local minima**. A node is a **local maxima** if the current node has a value **strictly greater** than the previous node and the next node. A node is a **local minima** if the current node has a value **strictly smaller** than the previous node and the next node. Note that a node can only be a local maxima/minima if there exists **both** a previous node and a next node. Given a linked list `head`, return _an array of length 2 containing _`[minDistance, maxDistance]`_ where _`minDistance`_ is the **minimum distance** between **any two distinct** critical points and _`maxDistance`_ is the **maximum distance** between **any two distinct** critical points. If there are **fewer** than two critical points, return _`[-1, -1]`. **Example 1:** ``` **Input:** head = [3,1] **Output:** [-1,-1] **Explanation:** There are no critical points in [3,1]. ``` **Example 2:** ``` **Input:** head = [5,3,1,2,5,1,2] **Output:** [1,3] **Explanation:** There are three critical points: - [5,3,**1**,2,5,1,2]: The third node is a local minima because 1 is less than 3 and 2. - [5,3,1,2,**5**,1,2]: The fifth node is a local maxima because 5 is greater than 2 and 1. - [5,3,1,2,5,**1**,2]: The sixth node is a local minima because 1 is less than 5 and 2. The minimum distance is between the fifth and the sixth node. minDistance = 6 - 5 = 1. The maximum distance is between the third and the sixth node. maxDistance = 6 - 3 = 3. ``` **Example 3:** ``` **Input:** head = [1,3,2,2,3,2,2,2,7] **Output:** [3,3] **Explanation:** There are two critical points: - [1,**3**,2,2,3,2,2,2,7]: The second node is a local maxima because 3 is greater than 1 and 2. - [1,3,2,2,**3**,2,2,2,7]: The fifth node is a local maxima because 3 is greater than 2 and 2. Both the minimum and maximum distances are between the second and the fifth node. Thus, minDistance and maxDistance is 5 - 2 = 3. Note that the last node is not considered a local maxima because it does not have a next node. ``` **Constraints:** The number of nodes in the list is in the range `[2, 105]`. `1 <= Node.val <= 105`",
        "test_case": [
            {
                "label": "Example 1",
                "input": "head = [3,1]",
                "output": "[-1,-1] Explanation: There are no critical points in [3,1]."
            },
            {
                "label": "Example 2",
                "input": "head = [5,3,1,2,5,1,2]",
                "output": "[1,3] Explanation: There are three critical points:\n- [5,3, 1 ,2,5,1,2]: The third node is a local minima because 1 is less than 3 and 2.\n- [5,3,1,2, 5 ,1,2]: The fifth node is a local maxima because 5 is greater than 2 and 1.\n- [5,3,1,2,5, 1 ,2]: The sixth node is a local minima because 1 is less than 5 and 2.\nThe minimum distance is between the fifth and the sixth node. minDistance = 6 - 5 = 1.\nThe maximum distance is between the third and the sixth node. maxDistance = 6 - 3 = 3."
            },
            {
                "label": "Example 3",
                "input": "head = [1,3,2,2,3,2,2,2,7]",
                "output": "[3,3] Explanation: There are two critical points:\n- [1, 3 ,2,2,3,2,2,2,7]: The second node is a local maxima because 3 is greater than 1 and 2.\n- [1,3,2,2, 3 ,2,2,2,7]: The fifth node is a local maxima because 3 is greater than 2 and 2.\nBoth the minimum and maximum distances are between the second and the fifth node.\nThus, minDistance and maxDistance is 5 - 2 = 3.\nNote that the last node is not considered a local maxima because it does not have a next node. Constraints: The number of nodes in the list is in the range [2, 10 5 ] . 1 <= Node.val <= 10 5"
            }
        ],
        "elixir_template": "# Definition for singly-linked list.\n#\n# defmodule ListNode do\n#   @type t :: %__MODULE__{\n#           val: integer,\n#           next: ListNode.t() | nil\n#         }\n#   defstruct val: 0, next: nil\n# end\n\ndefmodule Solution do\n  @spec nodes_between_critical_points(head :: ListNode.t | nil) :: [integer]\n  def nodes_between_critical_points(head) do\n    \n  end\nend",
        "erlang_template": "%% Definition for singly-linked list.\n%%\n%% -record(list_node, {val = 0 :: integer(),\n%%                     next = null :: 'null' | #list_node{}}).\n\n-spec nodes_between_critical_points(Head :: #list_node{} | null) -> [integer()].\nnodes_between_critical_points(Head) ->\n  .",
        "scala_template": "/**\n * Definition for singly-linked list.\n * class ListNode(_x: Int = 0, _next: ListNode = null) {\n *   var next: ListNode = _next\n *   var x: Int = _x\n * }\n */\nobject Solution {\n    def nodesBetweenCriticalPoints(head: ListNode): Array[Int] = {\n        \n    }\n}"
    },
    {
        "id": 2181,
        "name": "smallest-index-with-equal-value",
        "difficulty": "Easy",
        "link": "https://leetcode.com/problems/smallest-index-with-equal-value/",
        "task_description": "Given a **0-indexed** integer array `nums`, return _the **smallest** index _`i`_ of _`nums`_ such that _`i mod 10 == nums[i]`_, or _`-1`_ if such index does not exist_. `x mod y` denotes the **remainder** when `x` is divided by `y`. **Example 1:** ``` **Input:** nums = [0,1,2] **Output:** 0 **Explanation:** i=0: 0 mod 10 = 0 == nums[0]. i=1: 1 mod 10 = 1 == nums[1]. i=2: 2 mod 10 = 2 == nums[2]. All indices have i mod 10 == nums[i], so we return the smallest index 0. ``` **Example 2:** ``` **Input:** nums = [4,3,2,1] **Output:** 2 **Explanation:** i=0: 0 mod 10 = 0 != nums[0]. i=1: 1 mod 10 = 1 != nums[1]. i=2: 2 mod 10 = 2 == nums[2]. i=3: 3 mod 10 = 3 != nums[3]. 2 is the only index which has i mod 10 == nums[i]. ``` **Example 3:** ``` **Input:** nums = [1,2,3,4,5,6,7,8,9,0] **Output:** -1 **Explanation:** No index satisfies i mod 10 == nums[i]. ``` **Constraints:** `1 <= nums.length <= 100` `0 <= nums[i] <= 9`",
        "test_case": [
            {
                "label": "Example 1",
                "input": "nums = [0,1,2]",
                "output": "0 Explanation: i=0: 0 mod 10 = 0 == nums[0].\ni=1: 1 mod 10 = 1 == nums[1].\ni=2: 2 mod 10 = 2 == nums[2].\nAll indices have i mod 10 == nums[i], so we return the smallest index 0."
            },
            {
                "label": "Example 2",
                "input": "nums = [4,3,2,1]",
                "output": "2 Explanation: i=0: 0 mod 10 = 0 != nums[0].\ni=1: 1 mod 10 = 1 != nums[1].\ni=2: 2 mod 10 = 2 == nums[2].\ni=3: 3 mod 10 = 3 != nums[3].\n2 is the only index which has i mod 10 == nums[i]."
            },
            {
                "label": "Example 3",
                "input": "nums = [1,2,3,4,5,6,7,8,9,0]",
                "output": "-1 Explanation: No index satisfies i mod 10 == nums[i]."
            }
        ],
        "elixir_template": "defmodule Solution do\n  @spec smallest_equal(nums :: [integer]) :: integer\n  def smallest_equal(nums) do\n    \n  end\nend",
        "erlang_template": "-spec smallest_equal(Nums :: [integer()]) -> integer().\nsmallest_equal(Nums) ->\n  .",
        "scala_template": "object Solution {\n    def smallestEqual(nums: Array[Int]): Int = {\n        \n    }\n}"
    },
    {
        "id": 2180,
        "name": "maximum-number-of-tasks-you-can-assign",
        "difficulty": "Hard",
        "link": "https://leetcode.com/problems/maximum-number-of-tasks-you-can-assign/",
        "task_description": "You have `n` tasks and `m` workers. Each task has a strength requirement stored in a **0-indexed** integer array `tasks`, with the `ith` task requiring `tasks[i]` strength to complete. The strength of each worker is stored in a **0-indexed** integer array `workers`, with the `jth` worker having `workers[j]` strength. Each worker can only be assigned to a **single** task and must have a strength **greater than or equal** to the task's strength requirement (i.e., `workers[j] >= tasks[i]`). Additionally, you have `pills` magical pills that will **increase a worker's strength** by `strength`. You can decide which workers receive the magical pills, however, you may only give each worker **at most one** magical pill. Given the **0-indexed **integer arrays `tasks` and `workers` and the integers `pills` and `strength`, return _the **maximum** number of tasks that can be completed._ **Example 1:** ``` **Input:** tasks = [**3**,**2**,**1**], workers = [**0**,**3**,**3**], pills = 1, strength = 1 **Output:** 3 **Explanation:** We can assign the magical pill and tasks as follows: - Give the magical pill to worker 0. - Assign worker 0 to task 2 (0 + 1 >= 1) - Assign worker 1 to task 1 (3 >= 2) - Assign worker 2 to task 0 (3 >= 3) ``` **Example 2:** ``` **Input:** tasks = [**5**,4], workers = [**0**,0,0], pills = 1, strength = 5 **Output:** 1 **Explanation:** We can assign the magical pill and tasks as follows: - Give the magical pill to worker 0. - Assign worker 0 to task 0 (0 + 5 >= 5) ``` **Example 3:** ``` **Input:** tasks = [**10**,**15**,30], workers = [**0**,**10**,10,10,10], pills = 3, strength = 10 **Output:** 2 **Explanation:** We can assign the magical pills and tasks as follows: - Give the magical pill to worker 0 and worker 1. - Assign worker 0 to task 0 (0 + 10 >= 10) - Assign worker 1 to task 1 (10 + 10 >= 15) The last pill is not given because it will not make any worker strong enough for the last task. ``` **Constraints:** `n == tasks.length` `m == workers.length` `1 <= n, m <= 5 * 104` `0 <= pills <= m` `0 <= tasks[i], workers[j], strength <= 109`",
        "test_case": [
            {
                "label": "Example 1",
                "input": "tasks = [ 3 , 2 , 1 ], workers = [ 0 , 3 , 3 ], pills = 1, strength = 1",
                "output": "3 Explanation: We can assign the magical pill and tasks as follows:\n- Give the magical pill to worker 0.\n- Assign worker 0 to task 2 (0 + 1 >= 1)\n- Assign worker 1 to task 1 (3 >= 2)\n- Assign worker 2 to task 0 (3 >= 3)"
            },
            {
                "label": "Example 2",
                "input": "tasks = [ 5 ,4], workers = [ 0 ,0,0], pills = 1, strength = 5",
                "output": "1 Explanation: We can assign the magical pill and tasks as follows:\n- Give the magical pill to worker 0.\n- Assign worker 0 to task 0 (0 + 5 >= 5)"
            },
            {
                "label": "Example 3",
                "input": "tasks = [ 10 , 15 ,30], workers = [ 0 , 10 ,10,10,10], pills = 3, strength = 10",
                "output": "2 Explanation: We can assign the magical pills and tasks as follows:\n- Give the magical pill to worker 0 and worker 1.\n- Assign worker 0 to task 0 (0 + 10 >= 10)\n- Assign worker 1 to task 1 (10 + 10 >= 15)\nThe last pill is not given because it will not make any worker strong enough for the last task. Constraints: n == tasks.length m == workers.length 1 <= n, m <= 5 * 10 4 0 <= pills <= m 0 <= tasks[i], workers[j], strength <= 10 9"
            }
        ],
        "elixir_template": "defmodule Solution do\n  @spec max_task_assign(tasks :: [integer], workers :: [integer], pills :: integer, strength :: integer) :: integer\n  def max_task_assign(tasks, workers, pills, strength) do\n    \n  end\nend",
        "erlang_template": "-spec max_task_assign(Tasks :: [integer()], Workers :: [integer()], Pills :: integer(), Strength :: integer()) -> integer().\nmax_task_assign(Tasks, Workers, Pills, Strength) ->\n  .",
        "scala_template": "object Solution {\n    def maxTaskAssign(tasks: Array[Int], workers: Array[Int], pills: Int, strength: Int): Int = {\n        \n    }\n}"
    },
    {
        "id": 2179,
        "name": "most-beautiful-item-for-each-query",
        "difficulty": "Medium",
        "link": "https://leetcode.com/problems/most-beautiful-item-for-each-query/",
        "task_description": "You are given a 2D integer array `items` where `items[i] = [pricei, beautyi]` denotes the **price** and **beauty** of an item respectively. You are also given a **0-indexed** integer array `queries`. For each `queries[j]`, you want to determine the **maximum beauty** of an item whose **price** is **less than or equal** to `queries[j]`. If no such item exists, then the answer to this query is `0`. Return _an array _`answer`_ of the same length as _`queries`_ where _`answer[j]`_ is the answer to the _`jth`_ query_. **Example 1:** ``` **Input:** items = [[1,2],[3,2],[2,4],[5,6],[3,5]], queries = [1,2,3,4,5,6] **Output:** [2,4,5,5,6,6] **Explanation:** - For queries[0]=1, [1,2] is the only item which has price <= 1. Hence, the answer for this query is 2. - For queries[1]=2, the items which can be considered are [1,2] and [2,4]. The maximum beauty among them is 4. - For queries[2]=3 and queries[3]=4, the items which can be considered are [1,2], [3,2], [2,4], and [3,5]. The maximum beauty among them is 5. - For queries[4]=5 and queries[5]=6, all items can be considered. Hence, the answer for them is the maximum beauty of all items, i.e., 6. ``` **Example 2:** ``` **Input:** items = [[1,2],[1,2],[1,3],[1,4]], queries = [1] **Output:** [4] **Explanation:** The price of every item is equal to 1, so we choose the item with the maximum beauty 4. Note that multiple items can have the same price and/or beauty. ``` **Example 3:** ``` **Input:** items = [[10,1000]], queries = [5] **Output:** [0] **Explanation:** No item has a price less than or equal to 5, so no item can be chosen. Hence, the answer to the query is 0. ``` **Constraints:** `1 <= items.length, queries.length <= 105` `items[i].length == 2` `1 <= pricei, beautyi, queries[j] <= 109`",
        "test_case": [
            {
                "label": "Example 1",
                "input": "items = [[1,2],[3,2],[2,4],[5,6],[3,5]], queries = [1,2,3,4,5,6]",
                "output": "[2,4,5,5,6,6] Explanation: - For queries[0]=1, [1,2] is the only item which has price <= 1. Hence, the answer for this query is 2.\n- For queries[1]=2, the items which can be considered are [1,2] and [2,4]. \n  The maximum beauty among them is 4.\n- For queries[2]=3 and queries[3]=4, the items which can be considered are [1,2], [3,2], [2,4], and [3,5].\n  The maximum beauty among them is 5.\n- For queries[4]=5 and queries[5]=6, all items can be considered.\n  Hence, the answer for them is the maximum beauty of all items, i.e., 6."
            },
            {
                "label": "Example 2",
                "input": "items = [[1,2],[1,2],[1,3],[1,4]], queries = [1]",
                "output": "[4] Explanation: The price of every item is equal to 1, so we choose the item with the maximum beauty 4. \nNote that multiple items can have the same price and/or beauty."
            },
            {
                "label": "Example 3",
                "input": "items = [[10,1000]], queries = [5]",
                "output": "[0] Explanation: No item has a price less than or equal to 5, so no item can be chosen.\nHence, the answer to the query is 0."
            }
        ],
        "elixir_template": "defmodule Solution do\n  @spec maximum_beauty(items :: [[integer]], queries :: [integer]) :: [integer]\n  def maximum_beauty(items, queries) do\n    \n  end\nend",
        "erlang_template": "-spec maximum_beauty(Items :: [[integer()]], Queries :: [integer()]) -> [integer()].\nmaximum_beauty(Items, Queries) ->\n  .",
        "scala_template": "object Solution {\n    def maximumBeauty(items: Array[Array[Int]], queries: Array[Int]): Array[Int] = {\n        \n    }\n}"
    },
    {
        "id": 2178,
        "name": "walking-robot-simulation-ii",
        "difficulty": "Medium",
        "link": "https://leetcode.com/problems/walking-robot-simulation-ii/",
        "task_description": "A `width x height` grid is on an XY-plane with the **bottom-left** cell at `(0, 0)` and the **top-right** cell at `(width - 1, height - 1)`. The grid is aligned with the four cardinal directions (`\"North\"`, `\"East\"`, `\"South\"`, and `\"West\"`). A robot is **initially** at cell `(0, 0)` facing direction `\"East\"`. The robot can be instructed to move for a specific number of **steps**. For each step, it does the following. Attempts to move **forward one** cell in the direction it is facing. If the cell the robot is **moving to** is **out of bounds**, the robot instead **turns** 90 degrees **counterclockwise** and retries the step. After the robot finishes moving the number of steps required, it stops and awaits the next instruction. Implement the `Robot` class: `Robot(int width, int height)` Initializes the `width x height` grid with the robot at `(0, 0)` facing `\"East\"`. `void step(int num)` Instructs the robot to move forward `num` steps. `int[] getPos()` Returns the current cell the robot is at, as an array of length 2, `[x, y]`. `String getDir()` Returns the current direction of the robot, `\"North\"`, `\"East\"`, `\"South\"`, or `\"West\"`. **Example 1:** ``` **Input** [\"Robot\", \"step\", \"step\", \"getPos\", \"getDir\", \"step\", \"step\", \"step\", \"getPos\", \"getDir\"] [[6, 3], [2], [2], [], [], [2], [1], [4], [], []] **Output** [null, null, null, [4, 0], \"East\", null, null, null, [1, 2], \"West\"] **Explanation** Robot robot = new Robot(6, 3); // Initialize the grid and the robot at (0, 0) facing East. robot.step(2); // It moves two steps East to (2, 0), and faces East. robot.step(2); // It moves two steps East to (4, 0), and faces East. robot.getPos(); // return [4, 0] robot.getDir(); // return \"East\" robot.step(2); // It moves one step East to (5, 0), and faces East. // Moving the next step East would be out of bounds, so it turns and faces North. // Then, it moves one step North to (5, 1), and faces North. robot.step(1); // It moves one step North to (5, 2), and faces **North** (not West). robot.step(4); // Moving the next step North would be out of bounds, so it turns and faces West. // Then, it moves four steps West to (1, 2), and faces West. robot.getPos(); // return [1, 2] robot.getDir(); // return \"West\" ``` **Constraints:** `2 <= width, height <= 100` `1 <= num <= 105` At most `104` calls **in total** will be made to `step`, `getPos`, and `getDir`.",
        "test_case": [],
        "elixir_template": "defmodule Robot do\n  @spec init_(width :: integer, height :: integer) :: any\n  def init_(width, height) do\n    \n  end\n\n  @spec step(num :: integer) :: any\n  def step(num) do\n    \n  end\n\n  @spec get_pos() :: [integer]\n  def get_pos() do\n    \n  end\n\n  @spec get_dir() :: String.t\n  def get_dir() do\n    \n  end\nend\n\n# Your functions will be called as such:\n# Robot.init_(width, height)\n# Robot.step(num)\n# param_2 = Robot.get_pos()\n# param_3 = Robot.get_dir()\n\n# Robot.init_ will be called before every test case, in which you can do some necessary initializations.",
        "erlang_template": "-spec robot_init_(Width :: integer(), Height :: integer()) -> any().\nrobot_init_(Width, Height) ->\n  .\n\n-spec robot_step(Num :: integer()) -> any().\nrobot_step(Num) ->\n  .\n\n-spec robot_get_pos() -> [integer()].\nrobot_get_pos() ->\n  .\n\n-spec robot_get_dir() -> unicode:unicode_binary().\nrobot_get_dir() ->\n  .\n\n\n%% Your functions will be called as such:\n%% robot_init_(Width, Height),\n%% robot_step(Num),\n%% Param_2 = robot_get_pos(),\n%% Param_3 = robot_get_dir(),\n\n%% robot_init_ will be called before every test case, in which you can do some necessary initializations.",
        "scala_template": "class Robot(_width: Int, _height: Int) {\n\n    def step(num: Int): Unit = {\n        \n    }\n\n    def getPos(): Array[Int] = {\n        \n    }\n\n    def getDir(): String = {\n        \n    }\n\n}\n\n/**\n * Your Robot object will be instantiated and called as such:\n * val obj = new Robot(width, height)\n * obj.step(num)\n * val param_2 = obj.getPos()\n * val param_3 = obj.getDir()\n */"
    },
    {
        "id": 2177,
        "name": "check-whether-two-strings-are-almost-equivalent",
        "difficulty": "Easy",
        "link": "https://leetcode.com/problems/check-whether-two-strings-are-almost-equivalent/",
        "task_description": "Two strings `word1` and `word2` are considered **almost equivalent** if the differences between the frequencies of each letter from `'a'` to `'z'` between `word1` and `word2` is **at most** `3`. Given two strings `word1` and `word2`, each of length `n`, return `true` _if _`word1` _and_ `word2` _are **almost equivalent**, or_ `false` _otherwise_. The **frequency** of a letter `x` is the number of times it occurs in the string. **Example 1:** ``` **Input:** word1 = \"aaaa\", word2 = \"bccb\" **Output:** false **Explanation:** There are 4 'a's in \"aaaa\" but 0 'a's in \"bccb\". The difference is 4, which is more than the allowed 3. ``` **Example 2:** ``` **Input:** word1 = \"abcdeef\", word2 = \"abaaacc\" **Output:** true **Explanation:** The differences between the frequencies of each letter in word1 and word2 are at most 3: - 'a' appears 1 time in word1 and 4 times in word2. The difference is 3. - 'b' appears 1 time in word1 and 1 time in word2. The difference is 0. - 'c' appears 1 time in word1 and 2 times in word2. The difference is 1. - 'd' appears 1 time in word1 and 0 times in word2. The difference is 1. - 'e' appears 2 times in word1 and 0 times in word2. The difference is 2. - 'f' appears 1 time in word1 and 0 times in word2. The difference is 1. ``` **Example 3:** ``` **Input:** word1 = \"cccddabba\", word2 = \"babababab\" **Output:** true **Explanation:** The differences between the frequencies of each letter in word1 and word2 are at most 3: - 'a' appears 2 times in word1 and 4 times in word2. The difference is 2. - 'b' appears 2 times in word1 and 5 times in word2. The difference is 3. - 'c' appears 3 times in word1 and 0 times in word2. The difference is 3. - 'd' appears 2 times in word1 and 0 times in word2. The difference is 2. ``` **Constraints:** `n == word1.length == word2.length` `1 <= n <= 100` `word1` and `word2` consist only of lowercase English letters.",
        "test_case": [
            {
                "label": "Example 1",
                "input": "word1 = \"aaaa\", word2 = \"bccb\"",
                "output": "false Explanation: There are 4 'a's in \"aaaa\" but 0 'a's in \"bccb\".\nThe difference is 4, which is more than the allowed 3."
            },
            {
                "label": "Example 2",
                "input": "word1 = \"abcdeef\", word2 = \"abaaacc\"",
                "output": "true Explanation: The differences between the frequencies of each letter in word1 and word2 are at most 3:\n- 'a' appears 1 time in word1 and 4 times in word2. The difference is 3.\n- 'b' appears 1 time in word1 and 1 time in word2. The difference is 0.\n- 'c' appears 1 time in word1 and 2 times in word2. The difference is 1.\n- 'd' appears 1 time in word1 and 0 times in word2. The difference is 1.\n- 'e' appears 2 times in word1 and 0 times in word2. The difference is 2.\n- 'f' appears 1 time in word1 and 0 times in word2. The difference is 1."
            },
            {
                "label": "Example 3",
                "input": "word1 = \"cccddabba\", word2 = \"babababab\"",
                "output": "true Explanation: The differences between the frequencies of each letter in word1 and word2 are at most 3:\n- 'a' appears 2 times in word1 and 4 times in word2. The difference is 2.\n- 'b' appears 2 times in word1 and 5 times in word2. The difference is 3.\n- 'c' appears 3 times in word1 and 0 times in word2. The difference is 3.\n- 'd' appears 2 times in word1 and 0 times in word2. The difference is 2. Constraints: n == word1.length == word2.length 1 <= n <= 100 word1 and word2 consist only of lowercase English letters."
            }
        ],
        "elixir_template": "defmodule Solution do\n  @spec check_almost_equivalent(word1 :: String.t, word2 :: String.t) :: boolean\n  def check_almost_equivalent(word1, word2) do\n    \n  end\nend",
        "erlang_template": "-spec check_almost_equivalent(Word1 :: unicode:unicode_binary(), Word2 :: unicode:unicode_binary()) -> boolean().\ncheck_almost_equivalent(Word1, Word2) ->\n  .",
        "scala_template": "object Solution {\n    def checkAlmostEquivalent(word1: String, word2: String): Boolean = {\n        \n    }\n}"
    },
    {
        "id": 2176,
        "name": "parallel-courses-iii",
        "difficulty": "Hard",
        "link": "https://leetcode.com/problems/parallel-courses-iii/",
        "task_description": "You are given an integer `n`, which indicates that there are `n` courses labeled from `1` to `n`. You are also given a 2D integer array `relations` where `relations[j] = [prevCoursej, nextCoursej]` denotes that course `prevCoursej` has to be completed **before** course `nextCoursej` (prerequisite relationship). Furthermore, you are given a **0-indexed** integer array `time` where `time[i]` denotes how many **months** it takes to complete the `(i+1)th` course. You must find the **minimum** number of months needed to complete all the courses following these rules: You may start taking a course at **any time** if the prerequisites are met. **Any number of courses** can be taken at the **same time**. Return _the **minimum** number of months needed to complete all the courses_. **Note:** The test cases are generated such that it is possible to complete every course (i.e., the graph is a directed acyclic graph). **Example 1:** **** ``` **Input:** n = 3, relations = [[1,3],[2,3]], time = [3,2,5] **Output:** 8 **Explanation:** The figure above represents the given graph and the time required to complete each course. We start course 1 and course 2 simultaneously at month 0. Course 1 takes 3 months and course 2 takes 2 months to complete respectively. Thus, the earliest time we can start course 3 is at month 3, and the total time required is 3 + 5 = 8 months. ``` **Example 2:** **** ``` **Input:** n = 5, relations = [[1,5],[2,5],[3,5],[3,4],[4,5]], time = [1,2,3,4,5] **Output:** 12 **Explanation:** The figure above represents the given graph and the time required to complete each course. You can start courses 1, 2, and 3 at month 0. You can complete them after 1, 2, and 3 months respectively. Course 4 can be taken only after course 3 is completed, i.e., after 3 months. It is completed after 3 + 4 = 7 months. Course 5 can be taken only after courses 1, 2, 3, and 4 have been completed, i.e., after max(1,2,3,7) = 7 months. Thus, the minimum time needed to complete all the courses is 7 + 5 = 12 months. ``` **Constraints:** `1 <= n <= 5 * 104` `0 <= relations.length <= min(n * (n - 1) / 2, 5 * 104)` `relations[j].length == 2` `1 <= prevCoursej, nextCoursej <= n` `prevCoursej != nextCoursej` All the pairs `[prevCoursej, nextCoursej]` are **unique**. `time.length == n` `1 <= time[i] <= 104` The given graph is a directed acyclic graph.",
        "test_case": [
            {
                "label": "Example 1",
                "input": "n = 3, relations = [[1,3],[2,3]], time = [3,2,5]",
                "output": "8 Explanation: The figure above represents the given graph and the time required to complete each course. \nWe start course 1 and course 2 simultaneously at month 0.\nCourse 1 takes 3 months and course 2 takes 2 months to complete respectively.\nThus, the earliest time we can start course 3 is at month 3, and the total time required is 3 + 5 = 8 months."
            },
            {
                "label": "Example 2",
                "input": "n = 5, relations = [[1,5],[2,5],[3,5],[3,4],[4,5]], time = [1,2,3,4,5]",
                "output": "12 Explanation: The figure above represents the given graph and the time required to complete each course.\nYou can start courses 1, 2, and 3 at month 0.\nYou can complete them after 1, 2, and 3 months respectively.\nCourse 4 can be taken only after course 3 is completed, i.e., after 3 months. It is completed after 3 + 4 = 7 months.\nCourse 5 can be taken only after courses 1, 2, 3, and 4 have been completed, i.e., after max(1,2,3,7) = 7 months.\nThus, the minimum time needed to complete all the courses is 7 + 5 = 12 months."
            }
        ],
        "elixir_template": "defmodule Solution do\n  @spec minimum_time(n :: integer, relations :: [[integer]], time :: [integer]) :: integer\n  def minimum_time(n, relations, time) do\n    \n  end\nend",
        "erlang_template": "-spec minimum_time(N :: integer(), Relations :: [[integer()]], Time :: [integer()]) -> integer().\nminimum_time(N, Relations, Time) ->\n  .",
        "scala_template": "object Solution {\n    def minimumTime(n: Int, relations: Array[Array[Int]], time: Array[Int]): Int = {\n        \n    }\n}"
    },
    {
        "id": 2175,
        "name": "count-nodes-with-the-highest-score",
        "difficulty": "Medium",
        "link": "https://leetcode.com/problems/count-nodes-with-the-highest-score/",
        "task_description": "There is a **binary** tree rooted at `0` consisting of `n` nodes. The nodes are labeled from `0` to `n - 1`. You are given a **0-indexed** integer array `parents` representing the tree, where `parents[i]` is the parent of node `i`. Since node `0` is the root, `parents[0] == -1`. Each node has a **score**. To find the score of a node, consider if the node and the edges connected to it were **removed**. The tree would become one or more **non-empty** subtrees. The **size** of a subtree is the number of the nodes in it. The **score** of the node is the **product of the sizes** of all those subtrees. Return _the **number** of nodes that have the **highest score**_. **Example 1:** ``` **Input:** parents = [-1,2,0,2,0] **Output:** 3 **Explanation:** - The score of node 0 is: 3 * 1 = 3 - The score of node 1 is: 4 = 4 - The score of node 2 is: 1 * 1 * 2 = 2 - The score of node 3 is: 4 = 4 - The score of node 4 is: 4 = 4 The highest score is 4, and three nodes (node 1, node 3, and node 4) have the highest score. ``` **Example 2:** ``` **Input:** parents = [-1,2,0] **Output:** 2 **Explanation:** - The score of node 0 is: 2 = 2 - The score of node 1 is: 2 = 2 - The score of node 2 is: 1 * 1 = 1 The highest score is 2, and two nodes (node 0 and node 1) have the highest score. ``` **Constraints:** `n == parents.length` `2 <= n <= 105` `parents[0] == -1` `0 <= parents[i] <= n - 1` for `i != 0` `parents` represents a valid binary tree.",
        "test_case": [
            {
                "label": "Example 1",
                "input": "parents = [-1,2,0,2,0]",
                "output": "3 Explanation: - The score of node 0 is: 3 * 1 = 3\n- The score of node 1 is: 4 = 4\n- The score of node 2 is: 1 * 1 * 2 = 2\n- The score of node 3 is: 4 = 4\n- The score of node 4 is: 4 = 4\nThe highest score is 4, and three nodes (node 1, node 3, and node 4) have the highest score."
            },
            {
                "label": "Example 2",
                "input": "parents = [-1,2,0]",
                "output": "2 Explanation: - The score of node 0 is: 2 = 2\n- The score of node 1 is: 2 = 2\n- The score of node 2 is: 1 * 1 = 1\nThe highest score is 2, and two nodes (node 0 and node 1) have the highest score. Constraints: n == parents.length 2 <= n <= 10 5 parents[0] == -1 0 <= parents[i] <= n - 1 for i != 0 parents represents a valid binary tree."
            }
        ],
        "elixir_template": "defmodule Solution do\n  @spec count_highest_score_nodes(parents :: [integer]) :: integer\n  def count_highest_score_nodes(parents) do\n    \n  end\nend",
        "erlang_template": "-spec count_highest_score_nodes(Parents :: [integer()]) -> integer().\ncount_highest_score_nodes(Parents) ->\n  .",
        "scala_template": "object Solution {\n    def countHighestScoreNodes(parents: Array[Int]): Int = {\n        \n    }\n}"
    },
    {
        "id": 2174,
        "name": "next-greater-numerically-balanced-number",
        "difficulty": "Medium",
        "link": "https://leetcode.com/problems/next-greater-numerically-balanced-number/",
        "task_description": "An integer `x` is **numerically balanced** if for every digit `d` in the number `x`, there are **exactly** `d` occurrences of that digit in `x`. Given an integer `n`, return _the **smallest numerically balanced** number **strictly greater** than _`n`_._ **Example 1:** ``` **Input:** n = 1 **Output:** 22 **Explanation:** 22 is numerically balanced since: - The digit 2 occurs 2 times. It is also the smallest numerically balanced number strictly greater than 1. ``` **Example 2:** ``` **Input:** n = 1000 **Output:** 1333 **Explanation:** 1333 is numerically balanced since: - The digit 1 occurs 1 time. - The digit 3 occurs 3 times. It is also the smallest numerically balanced number strictly greater than 1000. Note that 1022 cannot be the answer because 0 appeared more than 0 times. ``` **Example 3:** ``` **Input:** n = 3000 **Output:** 3133 **Explanation:** 3133 is numerically balanced since: - The digit 1 occurs 1 time. - The digit 3 occurs 3 times. It is also the smallest numerically balanced number strictly greater than 3000. ``` **Constraints:** `0 <= n <= 106`",
        "test_case": [
            {
                "label": "Example 1",
                "input": "n = 1",
                "output": "22 Explanation: 22 is numerically balanced since:\n- The digit 2 occurs 2 times. \nIt is also the smallest numerically balanced number strictly greater than 1."
            },
            {
                "label": "Example 2",
                "input": "n = 1000",
                "output": "1333 Explanation: 1333 is numerically balanced since:\n- The digit 1 occurs 1 time.\n- The digit 3 occurs 3 times. \nIt is also the smallest numerically balanced number strictly greater than 1000.\nNote that 1022 cannot be the answer because 0 appeared more than 0 times."
            },
            {
                "label": "Example 3",
                "input": "n = 3000",
                "output": "3133 Explanation: 3133 is numerically balanced since:\n- The digit 1 occurs 1 time.\n- The digit 3 occurs 3 times.\nIt is also the smallest numerically balanced number strictly greater than 3000."
            }
        ],
        "elixir_template": "defmodule Solution do\n  @spec next_beautiful_number(n :: integer) :: integer\n  def next_beautiful_number(n) do\n    \n  end\nend",
        "erlang_template": "-spec next_beautiful_number(N :: integer()) -> integer().\nnext_beautiful_number(N) ->\n  .",
        "scala_template": "object Solution {\n    def nextBeautifulNumber(n: Int): Int = {\n        \n    }\n}"
    },
    {
        "id": 2173,
        "name": "number-of-valid-words-in-a-sentence",
        "difficulty": "Easy",
        "link": "https://leetcode.com/problems/number-of-valid-words-in-a-sentence/",
        "task_description": "A sentence consists of lowercase letters (`'a'` to `'z'`), digits (`'0'` to `'9'`), hyphens (`'-'`), punctuation marks (`'!'`, `'.'`, and `','`), and spaces (`' '`) only. Each sentence can be broken down into **one or more tokens** separated by one or more spaces `' '`. A token is a valid word if **all three** of the following are true: It only contains lowercase letters, hyphens, and/or punctuation (**no** digits). There is **at most one** hyphen `'-'`. If present, it **must** be surrounded by lowercase characters (`\"a-b\"` is valid, but `\"-ab\"` and `\"ab-\"` are not valid). There is **at most one** punctuation mark. If present, it **must** be at the **end** of the token (`\"ab,\"`, `\"cd!\"`, and `\".\"` are valid, but `\"a!b\"` and `\"c.,\"` are not valid). Examples of valid words include `\"a-b.\"`, `\"afad\"`, `\"ba-c\"`, `\"a!\"`, and `\"!\"`. Given a string `sentence`, return _the **number** of valid words in _`sentence`. **Example 1:** ``` **Input:** sentence = \"cat and dog\" **Output:** 3 **Explanation:** The valid words in the sentence are \"cat\", \"and\", and \"dog\". ``` **Example 2:** ``` **Input:** sentence = \"!this 1-s b8d!\" **Output:** 0 **Explanation:** There are no valid words in the sentence. \"!this\" is invalid because it starts with a punctuation mark. \"1-s\" and \"b8d\" are invalid because they contain digits. ``` **Example 3:** ``` **Input:** sentence = \"alice and bob are playing stone-game10\" **Output:** 5 **Explanation:** The valid words in the sentence are \"alice\", \"and\", \"bob\", \"are\", and \"playing\". \"stone-game10\" is invalid because it contains digits. ``` **Constraints:** `1 <= sentence.length <= 1000` `sentence` only contains lowercase English letters, digits, `' '`, `'-'`, `'!'`, `'.'`, and `','`. There will be at least `1` token.",
        "test_case": [
            {
                "label": "Example 1",
                "input": "sentence = \" cat and dog \"",
                "output": "3 Explanation: The valid words in the sentence are \"cat\", \"and\", and \"dog\"."
            },
            {
                "label": "Example 2",
                "input": "sentence = \"!this  1-s b8d!\"",
                "output": "0 Explanation: There are no valid words in the sentence.\n\"!this\" is invalid because it starts with a punctuation mark.\n\"1-s\" and \"b8d\" are invalid because they contain digits."
            },
            {
                "label": "Example 3",
                "input": "sentence = \" alice and bob are playing stone-game10\"",
                "output": "5 Explanation: The valid words in the sentence are \"alice\", \"and\", \"bob\", \"are\", and \"playing\".\n\"stone-game10\" is invalid because it contains digits."
            }
        ],
        "elixir_template": "defmodule Solution do\n  @spec count_valid_words(sentence :: String.t) :: integer\n  def count_valid_words(sentence) do\n    \n  end\nend",
        "erlang_template": "-spec count_valid_words(Sentence :: unicode:unicode_binary()) -> integer().\ncount_valid_words(Sentence) ->\n  .",
        "scala_template": "object Solution {\n    def countValidWords(sentence: String): Int = {\n        \n    }\n}"
    },
    {
        "id": 2171,
        "name": "second-minimum-time-to-reach-destination",
        "difficulty": "Hard",
        "link": "https://leetcode.com/problems/second-minimum-time-to-reach-destination/",
        "task_description": "A city is represented as a **bi-directional connected** graph with `n` vertices where each vertex is labeled from `1` to `n` (**inclusive**). The edges in the graph are represented as a 2D integer array `edges`, where each `edges[i] = [ui, vi]` denotes a bi-directional edge between vertex `ui` and vertex `vi`. Every vertex pair is connected by **at most one** edge, and no vertex has an edge to itself. The time taken to traverse any edge is `time` minutes. Each vertex has a traffic signal which changes its color from **green** to **red** and vice versa every `change` minutes. All signals change **at the same time**. You can enter a vertex at **any time**, but can leave a vertex **only when the signal is green**. You **cannot wait **at a vertex if the signal is **green**. The **second minimum value** is defined as the smallest value** strictly larger **than the minimum value. For example the second minimum value of `[2, 3, 4]` is `3`, and the second minimum value of `[2, 2, 4]` is `4`. Given `n`, `edges`, `time`, and `change`, return _the **second minimum time** it will take to go from vertex _`1`_ to vertex _`n`. **Notes:** You can go through any vertex **any** number of times, **including** `1` and `n`. You can assume that when the journey **starts**, all signals have just turned **green**. **Example 1:** ``` **Input:** n = 5, edges = [[1,2],[1,3],[1,4],[3,4],[4,5]], time = 3, change = 5 **Output:** 13 **Explanation:** The figure on the left shows the given graph. The blue path in the figure on the right is the minimum time path. The time taken is: - Start at 1, time elapsed=0 - 1 -> 4: 3 minutes, time elapsed=3 - 4 -> 5: 3 minutes, time elapsed=6 Hence the minimum time needed is 6 minutes. The red path shows the path to get the second minimum time. - Start at 1, time elapsed=0 - 1 -> 3: 3 minutes, time elapsed=3 - 3 -> 4: 3 minutes, time elapsed=6 - Wait at 4 for 4 minutes, time elapsed=10 - 4 -> 5: 3 minutes, time elapsed=13 Hence the second minimum time is 13 minutes. ``` **Example 2:** ``` **Input:** n = 2, edges = [[1,2]], time = 3, change = 2 **Output:** 11 **Explanation:** The minimum time path is 1 -> 2 with time = 3 minutes. The second minimum time path is 1 -> 2 -> 1 -> 2 with time = 11 minutes. ``` **Constraints:** `2 <= n <= 104` `n - 1 <= edges.length <= min(2 * 104, n * (n - 1) / 2)` `edges[i].length == 2` `1 <= ui, vi <= n` `ui != vi` There are no duplicate edges. Each vertex can be reached directly or indirectly from every other vertex. `1 <= time, change <= 103`",
        "test_case": [
            {
                "label": "Example 1",
                "input": "n = 5, edges = [[1,2],[1,3],[1,4],[3,4],[4,5]], time = 3, change = 5",
                "output": "13 Explanation: The figure on the left shows the given graph.\nThe blue path in the figure on the right is the minimum time path.\nThe time taken is:\n- Start at 1, time elapsed=0\n- 1 -> 4: 3 minutes, time elapsed=3\n- 4 -> 5: 3 minutes, time elapsed=6\nHence the minimum time needed is 6 minutes.\n\nThe red path shows the path to get the second minimum time.\n- Start at 1, time elapsed=0\n- 1 -> 3: 3 minutes, time elapsed=3\n- 3 -> 4: 3 minutes, time elapsed=6\n- Wait at 4 for 4 minutes, time elapsed=10\n- 4 -> 5: 3 minutes, time elapsed=13\nHence the second minimum time is 13 minutes."
            },
            {
                "label": "Example 2",
                "input": "n = 2, edges = [[1,2]], time = 3, change = 2",
                "output": "11 Explanation: The minimum time path is 1 -> 2 with time = 3 minutes.\nThe second minimum time path is 1 -> 2 -> 1 -> 2 with time = 11 minutes."
            }
        ],
        "elixir_template": "defmodule Solution do\n  @spec second_minimum(n :: integer, edges :: [[integer]], time :: integer, change :: integer) :: integer\n  def second_minimum(n, edges, time, change) do\n    \n  end\nend",
        "erlang_template": "-spec second_minimum(N :: integer(), Edges :: [[integer()]], Time :: integer(), Change :: integer()) -> integer().\nsecond_minimum(N, Edges, Time, Change) ->\n  .",
        "scala_template": "object Solution {\n    def secondMinimum(n: Int, edges: Array[Array[Int]], time: Int, change: Int): Int = {\n        \n    }\n}"
    },
    {
        "id": 2170,
        "name": "count-number-of-maximum-bitwise-or-subsets",
        "difficulty": "Medium",
        "link": "https://leetcode.com/problems/count-number-of-maximum-bitwise-or-subsets/",
        "task_description": "Given an integer array `nums`, find the **maximum** possible **bitwise OR** of a subset of `nums` and return _the **number of different non-empty subsets** with the maximum bitwise OR_. An array `a` is a **subset** of an array `b` if `a` can be obtained from `b` by deleting some (possibly zero) elements of `b`. Two subsets are considered **different** if the indices of the elements chosen are different. The bitwise OR of an array `a` is equal to `a[0] **OR** a[1] **OR** ... **OR** a[a.length - 1]` (**0-indexed**). **Example 1:** ``` **Input:** nums = [3,1] **Output:** 2 **Explanation:** The maximum possible bitwise OR of a subset is 3. There are 2 subsets with a bitwise OR of 3: - [3] - [3,1] ``` **Example 2:** ``` **Input:** nums = [2,2,2] **Output:** 7 **Explanation:** All non-empty subsets of [2,2,2] have a bitwise OR of 2. There are 23 - 1 = 7 total subsets. ``` **Example 3:** ``` **Input:** nums = [3,2,1,5] **Output:** 6 **Explanation:** The maximum possible bitwise OR of a subset is 7. There are 6 subsets with a bitwise OR of 7: - [3,5] - [3,1,5] - [3,2,5] - [3,2,1,5] - [2,5] - [2,1,5] ``` **Constraints:** `1 <= nums.length <= 16` `1 <= nums[i] <= 105`",
        "test_case": [
            {
                "label": "Example 1",
                "input": "nums = [3,1]",
                "output": "2 Explanation: The maximum possible bitwise OR of a subset is 3. There are 2 subsets with a bitwise OR of 3:\n- [3]\n- [3,1]"
            },
            {
                "label": "Example 2",
                "input": "nums = [2,2,2]",
                "output": "7 Explanation: All non-empty subsets of [2,2,2] have a bitwise OR of 2. There are 2 3 - 1 = 7 total subsets."
            },
            {
                "label": "Example 3",
                "input": "nums = [3,2,1,5]",
                "output": "6 Explanation: The maximum possible bitwise OR of a subset is 7. There are 6 subsets with a bitwise OR of 7:\n- [3,5]\n- [3,1,5]\n- [3,2,5]\n- [3,2,1,5]\n- [2,5]\n- [2,1,5]"
            }
        ],
        "elixir_template": "defmodule Solution do\n  @spec count_max_or_subsets(nums :: [integer]) :: integer\n  def count_max_or_subsets(nums) do\n    \n  end\nend",
        "erlang_template": "-spec count_max_or_subsets(Nums :: [integer()]) -> integer().\ncount_max_or_subsets(Nums) ->\n  .",
        "scala_template": "object Solution {\n    def countMaxOrSubsets(nums: Array[Int]): Int = {\n        \n    }\n}"
    },
    {
        "id": 2169,
        "name": "simple-bank-system",
        "difficulty": "Medium",
        "link": "https://leetcode.com/problems/simple-bank-system/",
        "task_description": "You have been tasked with writing a program for a popular bank that will automate all its incoming transactions (transfer, deposit, and withdraw). The bank has `n` accounts numbered from `1` to `n`. The initial balance of each account is stored in a **0-indexed** integer array `balance`, with the `(i + 1)th` account having an initial balance of `balance[i]`. Execute all the **valid** transactions. A transaction is **valid** if: The given account number(s) are between `1` and `n`, and The amount of money withdrawn or transferred from is **less than or equal** to the balance of the account. Implement the `Bank` class: `Bank(long[] balance)` Initializes the object with the **0-indexed** integer array `balance`. `boolean transfer(int account1, int account2, long money)` Transfers `money` dollars from the account numbered `account1` to the account numbered `account2`. Return `true` if the transaction was successful, `false` otherwise. `boolean deposit(int account, long money)` Deposit `money` dollars into the account numbered `account`. Return `true` if the transaction was successful, `false` otherwise. `boolean withdraw(int account, long money)` Withdraw `money` dollars from the account numbered `account`. Return `true` if the transaction was successful, `false` otherwise. **Example 1:** ``` **Input** [\"Bank\", \"withdraw\", \"transfer\", \"deposit\", \"transfer\", \"withdraw\"] [[[10, 100, 20, 50, 30]], [3, 10], [5, 1, 20], [5, 20], [3, 4, 15], [10, 50]] **Output** [null, true, true, true, false, false] **Explanation** Bank bank = new Bank([10, 100, 20, 50, 30]); bank.withdraw(3, 10); // return true, account 3 has a balance of $20, so it is valid to withdraw $10. // Account 3 has $20 - $10 = $10. bank.transfer(5, 1, 20); // return true, account 5 has a balance of $30, so it is valid to transfer $20. // Account 5 has $30 - $20 = $10, and account 1 has $10 + $20 = $30. bank.deposit(5, 20); // return true, it is valid to deposit $20 to account 5. // Account 5 has $10 + $20 = $30. bank.transfer(3, 4, 15); // return false, the current balance of account 3 is $10, // so it is invalid to transfer $15 from it. bank.withdraw(10, 50); // return false, it is invalid because account 10 does not exist. ``` **Constraints:** `n == balance.length` `1 <= n, account, account1, account2 <= 105` `0 <= balance[i], money <= 1012` At most `104` calls will be made to **each** function `transfer`, `deposit`, `withdraw`.",
        "test_case": [],
        "elixir_template": "defmodule Bank do\n  @spec init_(balance :: [integer]) :: any\n  def init_(balance) do\n    \n  end\n\n  @spec transfer(account1 :: integer, account2 :: integer, money :: integer) :: boolean\n  def transfer(account1, account2, money) do\n    \n  end\n\n  @spec deposit(account :: integer, money :: integer) :: boolean\n  def deposit(account, money) do\n    \n  end\n\n  @spec withdraw(account :: integer, money :: integer) :: boolean\n  def withdraw(account, money) do\n    \n  end\nend\n\n# Your functions will be called as such:\n# Bank.init_(balance)\n# param_1 = Bank.transfer(account1, account2, money)\n# param_2 = Bank.deposit(account, money)\n# param_3 = Bank.withdraw(account, money)\n\n# Bank.init_ will be called before every test case, in which you can do some necessary initializations.",
        "erlang_template": "-spec bank_init_(Balance :: [integer()]) -> any().\nbank_init_(Balance) ->\n  .\n\n-spec bank_transfer(Account1 :: integer(), Account2 :: integer(), Money :: integer()) -> boolean().\nbank_transfer(Account1, Account2, Money) ->\n  .\n\n-spec bank_deposit(Account :: integer(), Money :: integer()) -> boolean().\nbank_deposit(Account, Money) ->\n  .\n\n-spec bank_withdraw(Account :: integer(), Money :: integer()) -> boolean().\nbank_withdraw(Account, Money) ->\n  .\n\n\n%% Your functions will be called as such:\n%% bank_init_(Balance),\n%% Param_1 = bank_transfer(Account1, Account2, Money),\n%% Param_2 = bank_deposit(Account, Money),\n%% Param_3 = bank_withdraw(Account, Money),\n\n%% bank_init_ will be called before every test case, in which you can do some necessary initializations.",
        "scala_template": "class Bank(_balance: Array[Long]) {\n\n    def transfer(account1: Int, account2: Int, money: Long): Boolean = {\n        \n    }\n\n    def deposit(account: Int, money: Long): Boolean = {\n        \n    }\n\n    def withdraw(account: Int, money: Long): Boolean = {\n        \n    }\n\n}\n\n/**\n * Your Bank object will be instantiated and called as such:\n * val obj = new Bank(balance)\n * val param_1 = obj.transfer(account1,account2,money)\n * val param_2 = obj.deposit(account,money)\n * val param_3 = obj.withdraw(account,money)\n */"
    },
    {
        "id": 2168,
        "name": "check-if-numbers-are-ascending-in-a-sentence",
        "difficulty": "Easy",
        "link": "https://leetcode.com/problems/check-if-numbers-are-ascending-in-a-sentence/",
        "task_description": "A sentence is a list of **tokens** separated by a **single** space with no leading or trailing spaces. Every token is either a **positive number** consisting of digits `0-9` with no leading zeros, or a **word** consisting of lowercase English letters. For example, `\"a puppy has 2 eyes 4 legs\"` is a sentence with seven tokens: `\"2\"` and `\"4\"` are numbers and the other tokens such as `\"puppy\"` are words. Given a string `s` representing a sentence, you need to check if **all** the numbers in `s` are **strictly increasing** from left to right (i.e., other than the last number, **each** number is **strictly smaller** than the number on its **right** in `s`). Return `true`_ if so, or _`false`_ otherwise_. **Example 1:** ``` **Input:** s = \"1 box has 3 blue 4 red 6 green and 12 yellow marbles\" **Output:** true **Explanation:** The numbers in s are: 1, 3, 4, 6, 12. They are strictly increasing from left to right: 1 < 3 < 4 < 6 < 12. ``` **Example 2:** ``` **Input:** s = \"hello world 5 x 5\" **Output:** false **Explanation:** The numbers in s are: **5**, **5**. They are not strictly increasing. ``` **Example 3:** ``` **Input:** s = \"sunset is at 7 51 pm overnight lows will be in the low 50 and 60 s\" **Output:** false **Explanation:** The numbers in s are: 7, **51**, **50**, 60. They are not strictly increasing. ``` **Constraints:** `3 <= s.length <= 200` `s` consists of lowercase English letters, spaces, and digits from `0` to `9`, inclusive. The number of tokens in `s` is between `2` and `100`, inclusive. The tokens in `s` are separated by a single space. There are at least **two** numbers in `s`. Each number in `s` is a **positive** number **less** than `100`, with no leading zeros. `s` contains no leading or trailing spaces.",
        "test_case": [
            {
                "label": "Example 1",
                "input": "s = \"1 box has 3 blue 4 red 6 green and 12 yellow marbles\"",
                "output": "true Explanation: The numbers in s are: 1, 3, 4, 6, 12.\nThey are strictly increasing from left to right: 1 < 3 < 4 < 6 < 12."
            },
            {
                "label": "Example 2",
                "input": "s = \"hello world 5 x 5\"",
                "output": "false Explanation: The numbers in s are: 5 , 5 . They are not strictly increasing."
            },
            {
                "label": "Example 3",
                "input": "s = \"sunset is at 7 51 pm overnight lows will be in the low 50 and 60 s\"",
                "output": "false Explanation: The numbers in s are: 7, 51 , 50 , 60. They are not strictly increasing."
            }
        ],
        "elixir_template": "defmodule Solution do\n  @spec are_numbers_ascending(s :: String.t) :: boolean\n  def are_numbers_ascending(s) do\n    \n  end\nend",
        "erlang_template": "-spec are_numbers_ascending(S :: unicode:unicode_binary()) -> boolean().\nare_numbers_ascending(S) ->\n  .",
        "scala_template": "object Solution {\n    def areNumbersAscending(s: String): Boolean = {\n        \n    }\n}"
    },
    {
        "id": 2166,
        "name": "number-of-valid-move-combinations-on-chessboard",
        "difficulty": "Hard",
        "link": "https://leetcode.com/problems/number-of-valid-move-combinations-on-chessboard/",
        "task_description": "There is an `8 x 8` chessboard containing `n` pieces (rooks, queens, or bishops). You are given a string array `pieces` of length `n`, where `pieces[i]` describes the type (rook, queen, or bishop) of the `ith` piece. In addition, you are given a 2D integer array `positions` also of length `n`, where `positions[i] = [ri, ci]` indicates that the `ith` piece is currently at the **1-based** coordinate `(ri, ci)` on the chessboard. When making a **move** for a piece, you choose a **destination** square that the piece will travel toward and stop on. A rook can only travel **horizontally or vertically** from `(r, c)` to the direction of `(r+1, c)`, `(r-1, c)`, `(r, c+1)`, or `(r, c-1)`. A queen can only travel **horizontally, vertically, or diagonally** from `(r, c)` to the direction of `(r+1, c)`, `(r-1, c)`, `(r, c+1)`, `(r, c-1)`, `(r+1, c+1)`, `(r+1, c-1)`, `(r-1, c+1)`, `(r-1, c-1)`. A bishop can only travel **diagonally** from `(r, c)` to the direction of `(r+1, c+1)`, `(r+1, c-1)`, `(r-1, c+1)`, `(r-1, c-1)`. You must make a **move** for every piece on the board simultaneously. A **move combination** consists of all the **moves** performed on all the given pieces. Every second, each piece will instantaneously travel **one square** towards their destination if they are not already at it. All pieces start traveling at the `0th` second. A move combination is **invalid** if, at a given time, **two or more** pieces occupy the same square. Return _the number of **valid** move combinations_\u200b\u200b\u200b\u200b\u200b. **Notes:** **No two pieces** will start in the** same** square. You may choose the square a piece is already on as its **destination**. If two pieces are **directly adjacent** to each other, it is valid for them to **move past each other** and swap positions in one second. **Example 1:** ``` **Input:** pieces = [\"rook\"], positions = [[1,1]] **Output:** 15 **Explanation:** The image above shows the possible squares the piece can move to. ``` **Example 2:** ``` **Input:** pieces = [\"queen\"], positions = [[1,1]] **Output:** 22 **Explanation:** The image above shows the possible squares the piece can move to. ``` **Example 3:** ``` **Input:** pieces = [\"bishop\"], positions = [[4,3]] **Output:** 12 **Explanation:** The image above shows the possible squares the piece can move to. ``` **Constraints:** `n == pieces.length ` `n == positions.length` `1 <= n <= 4` `pieces` only contains the strings `\"rook\"`, `\"queen\"`, and `\"bishop\"`. There will be at most one queen on the chessboard. `1 <= ri, ci <= 8` Each `positions[i]` is distinct.",
        "test_case": [
            {
                "label": "Example 1",
                "input": "pieces = [\"rook\"], positions = [[1,1]]",
                "output": "15 Explanation: The image above shows the possible squares the piece can move to."
            },
            {
                "label": "Example 2",
                "input": "pieces = [\"queen\"], positions = [[1,1]]",
                "output": "22 Explanation: The image above shows the possible squares the piece can move to."
            },
            {
                "label": "Example 3",
                "input": "pieces = [\"bishop\"], positions = [[4,3]]",
                "output": "12 Explanation: The image above shows the possible squares the piece can move to. Constraints: n == pieces.length n == positions.length 1 <= n <= 4 pieces only contains the strings \"rook\" , \"queen\" , and \"bishop\" . There will be at most one queen on the chessboard. 1 <= r i , c i <= 8 Each positions[i] is distinct."
            }
        ],
        "elixir_template": "defmodule Solution do\n  @spec count_combinations(pieces :: [String.t], positions :: [[integer]]) :: integer\n  def count_combinations(pieces, positions) do\n    \n  end\nend",
        "erlang_template": "-spec count_combinations(Pieces :: [unicode:unicode_binary()], Positions :: [[integer()]]) -> integer().\ncount_combinations(Pieces, Positions) ->\n  .",
        "scala_template": "object Solution {\n    def countCombinations(pieces: Array[String], positions: Array[Array[Int]]): Int = {\n        \n    }\n}"
    },
    {
        "id": 2165,
        "name": "plates-between-candles",
        "difficulty": "Medium",
        "link": "https://leetcode.com/problems/plates-between-candles/",
        "task_description": "There is a long table with a line of plates and candles arranged on top of it. You are given a **0-indexed** string `s` consisting of characters `'*'` and `'|'` only, where a `'*'` represents a **plate** and a `'|'` represents a **candle**. You are also given a **0-indexed** 2D integer array `queries` where `queries[i] = [lefti, righti]` denotes the **substring** `s[lefti...righti]` (**inclusive**). For each query, you need to find the **number** of plates **between candles** that are **in the substring**. A plate is considered **between candles** if there is at least one candle to its left **and** at least one candle to its right **in the substring**. For example, `s = \"||**||**|*\"`, and a query `[3, 8]` denotes the substring `\"*||******|\"`. The number of plates between candles in this substring is `2`, as each of the two plates has at least one candle **in the substring** to its left **and** right. Return _an integer array_ `answer` _where_ `answer[i]` _is the answer to the_ `ith` _query_. **Example 1:** ``` **Input:** s = \"**|**|***|\", queries = [[2,5],[5,9]] **Output:** [2,3] **Explanation:** - queries[0] has two plates between candles. - queries[1] has three plates between candles. ``` **Example 2:** ``` **Input:** s = \"***|**|*****|**||**|*\", queries = [[1,17],[4,5],[14,17],[5,11],[15,16]] **Output:** [9,0,0,0,0] **Explanation:** - queries[0] has nine plates between candles. - The other queries have zero plates between candles. ``` **Constraints:** `3 <= s.length <= 105` `s` consists of `'*'` and `'|'` characters. `1 <= queries.length <= 105` `queries[i].length == 2` `0 <= lefti <= righti < s.length`",
        "test_case": [
            {
                "label": "Example 1",
                "input": "s = \"**|**|***|\", queries = [[2,5],[5,9]]",
                "output": "[2,3] Explanation: - queries[0] has two plates between candles.\n- queries[1] has three plates between candles."
            },
            {
                "label": "Example 2",
                "input": "s = \"***|**|*****|**||**|*\", queries = [[1,17],[4,5],[14,17],[5,11],[15,16]]",
                "output": "[9,0,0,0,0] Explanation: - queries[0] has nine plates between candles.\n- The other queries have zero plates between candles."
            }
        ],
        "elixir_template": "defmodule Solution do\n  @spec plates_between_candles(s :: String.t, queries :: [[integer]]) :: [integer]\n  def plates_between_candles(s, queries) do\n    \n  end\nend",
        "erlang_template": "-spec plates_between_candles(S :: unicode:unicode_binary(), Queries :: [[integer()]]) -> [integer()].\nplates_between_candles(S, Queries) ->\n  .",
        "scala_template": "object Solution {\n    def platesBetweenCandles(s: String, queries: Array[Array[Int]]): Array[Int] = {\n        \n    }\n}"
    },
    {
        "id": 2164,
        "name": "two-best-non-overlapping-events",
        "difficulty": "Medium",
        "link": "https://leetcode.com/problems/two-best-non-overlapping-events/",
        "task_description": "You are given a **0-indexed** 2D integer array of `events` where `events[i] = [startTimei, endTimei, valuei]`. The `ith` event starts at `startTimei` and ends at `endTimei`, and if you attend this event, you will receive a value of `valuei`. You can choose **at most** **two** **non-overlapping** events to attend such that the sum of their values is **maximized**. Return _this **maximum** sum._ Note that the start time and end time is **inclusive**: that is, you cannot attend two events where one of them starts and the other ends at the same time. More specifically, if you attend an event with end time `t`, the next event must start at or after `t + 1`. **Example 1:** ``` **Input:** events = [[1,3,2],[4,5,2],[2,4,3]] **Output:** 4 **Explanation: **Choose the green events, 0 and 1 for a sum of 2 + 2 = 4. ``` **Example 2:** ``` **Input:** events = [[1,3,2],[4,5,2],[1,5,5]] **Output:** 5 **Explanation: **Choose event 2 for a sum of 5. ``` **Example 3:** ``` **Input:** events = [[1,5,3],[1,5,1],[6,6,5]] **Output:** 8 **Explanation: **Choose events 0 and 2 for a sum of 3 + 5 = 8. ``` **Constraints:** `2 <= events.length <= 105` `events[i].length == 3` `1 <= startTimei <= endTimei <= 109` `1 <= valuei <= 106`",
        "test_case": [
            {
                "label": "Example 1",
                "input": "events = [[1,3,2],[4,5,2],[2,4,3]]",
                "output": "4 Explanation: Choose the green events, 0 and 1 for a sum of 2 + 2 = 4."
            },
            {
                "label": "Example 2",
                "input": "events = [[1,3,2],[4,5,2],[1,5,5]]",
                "output": "5 Explanation: Choose event 2 for a sum of 5."
            },
            {
                "label": "Example 3",
                "input": "events = [[1,5,3],[1,5,1],[6,6,5]]",
                "output": "8 Explanation: Choose events 0 and 2 for a sum of 3 + 5 = 8."
            }
        ],
        "elixir_template": "defmodule Solution do\n  @spec max_two_events(events :: [[integer]]) :: integer\n  def max_two_events(events) do\n    \n  end\nend",
        "erlang_template": "-spec max_two_events(Events :: [[integer()]]) -> integer().\nmax_two_events(Events) ->\n  .",
        "scala_template": "object Solution {\n    def maxTwoEvents(events: Array[Array[Int]]): Int = {\n        \n    }\n}"
    },
    {
        "id": 2163,
        "name": "kth-distinct-string-in-an-array",
        "difficulty": "Easy",
        "link": "https://leetcode.com/problems/kth-distinct-string-in-an-array/",
        "task_description": "A **distinct string** is a string that is present only **once** in an array. Given an array of strings `arr`, and an integer `k`, return _the _`kth`_ **distinct string** present in _`arr`. If there are **fewer** than `k` distinct strings, return _an **empty string **_`\"\"`. Note that the strings are considered in the **order in which they appear** in the array. **Example 1:** ``` **Input:** arr = [\"d\",\"b\",\"c\",\"b\",\"c\",\"a\"], k = 2 **Output:** \"a\" **Explanation:** The only distinct strings in arr are \"d\" and \"a\". \"d\" appears 1st, so it is the 1st distinct string. \"a\" appears 2nd, so it is the 2nd distinct string. Since k == 2, \"a\" is returned. ``` **Example 2:** ``` **Input:** arr = [\"aaa\",\"aa\",\"a\"], k = 1 **Output:** \"aaa\" **Explanation:** All strings in arr are distinct, so the 1st string \"aaa\" is returned. ``` **Example 3:** ``` **Input:** arr = [\"a\",\"b\",\"a\"], k = 3 **Output:** \"\" **Explanation:** The only distinct string is \"b\". Since there are fewer than 3 distinct strings, we return an empty string \"\". ``` **Constraints:** `1 <= k <= arr.length <= 1000` `1 <= arr[i].length <= 5` `arr[i]` consists of lowercase English letters.",
        "test_case": [
            {
                "label": "Example 1",
                "input": "arr = [\"d\",\"b\",\"c\",\"b\",\"c\",\"a\"], k = 2",
                "output": "\"a\" Explanation: The only distinct strings in arr are \"d\" and \"a\".\n\"d\" appears 1 st , so it is the 1 st distinct string.\n\"a\" appears 2 nd , so it is the 2 nd distinct string.\nSince k == 2, \"a\" is returned."
            },
            {
                "label": "Example 2",
                "input": "arr = [\"aaa\",\"aa\",\"a\"], k = 1",
                "output": "\"aaa\" Explanation: All strings in arr are distinct, so the 1 st string \"aaa\" is returned."
            },
            {
                "label": "Example 3",
                "input": "arr = [\"a\",\"b\",\"a\"], k = 3",
                "output": "\"\" Explanation: The only distinct string is \"b\". Since there are fewer than 3 distinct strings, we return an empty string \"\"."
            }
        ],
        "elixir_template": "defmodule Solution do\n  @spec kth_distinct(arr :: [String.t], k :: integer) :: String.t\n  def kth_distinct(arr, k) do\n    \n  end\nend",
        "erlang_template": "-spec kth_distinct(Arr :: [unicode:unicode_binary()], K :: integer()) -> unicode:unicode_binary().\nkth_distinct(Arr, K) ->\n  .",
        "scala_template": "object Solution {\n    def kthDistinct(arr: Array[String], k: Int): String = {\n        \n    }\n}"
    },
    {
        "id": 2162,
        "name": "partition-array-into-two-arrays-to-minimize-sum-difference",
        "difficulty": "Hard",
        "link": "https://leetcode.com/problems/partition-array-into-two-arrays-to-minimize-sum-difference/",
        "task_description": "You are given an integer array `nums` of `2 * n` integers. You need to partition `nums` into **two** arrays of length `n` to **minimize the absolute difference** of the **sums** of the arrays. To partition `nums`, put each element of `nums` into **one** of the two arrays. Return _the **minimum** possible absolute difference_. **Example 1:** ``` **Input:** nums = [3,9,7,3] **Output:** 2 **Explanation:** One optimal partition is: [3,9] and [7,3]. The absolute difference between the sums of the arrays is abs((3 + 9) - (7 + 3)) = 2. ``` **Example 2:** ``` **Input:** nums = [-36,36] **Output:** 72 **Explanation:** One optimal partition is: [-36] and [36]. The absolute difference between the sums of the arrays is abs((-36) - (36)) = 72. ``` **Example 3:** ``` **Input:** nums = [2,-1,0,4,-2,-9] **Output:** 0 **Explanation:** One optimal partition is: [2,4,-9] and [-1,0,-2]. The absolute difference between the sums of the arrays is abs((2 + 4 + -9) - (-1 + 0 + -2)) = 0. ``` **Constraints:** `1 <= n <= 15` `nums.length == 2 * n` `-107 <= nums[i] <= 107`",
        "test_case": [
            {
                "label": "Example 1",
                "input": "nums = [3,9,7,3]",
                "output": "2 Explanation: One optimal partition is: [3,9] and [7,3].\nThe absolute difference between the sums of the arrays is abs((3 + 9) - (7 + 3)) = 2."
            },
            {
                "label": "Example 2",
                "input": "nums = [-36,36]",
                "output": "72 Explanation: One optimal partition is: [-36] and [36].\nThe absolute difference between the sums of the arrays is abs((-36) - (36)) = 72."
            },
            {
                "label": "Example 3",
                "input": "nums = [2,-1,0,4,-2,-9]",
                "output": "0 Explanation: One optimal partition is: [2,4,-9] and [-1,0,-2].\nThe absolute difference between the sums of the arrays is abs((2 + 4 + -9) - (-1 + 0 + -2)) = 0."
            }
        ],
        "elixir_template": "defmodule Solution do\n  @spec minimum_difference(nums :: [integer]) :: integer\n  def minimum_difference(nums) do\n    \n  end\nend",
        "erlang_template": "-spec minimum_difference(Nums :: [integer()]) -> integer().\nminimum_difference(Nums) ->\n  .",
        "scala_template": "object Solution {\n    def minimumDifference(nums: Array[Int]): Int = {\n        \n    }\n}"
    },
    {
        "id": 2161,
        "name": "stock-price-fluctuation",
        "difficulty": "Medium",
        "link": "https://leetcode.com/problems/stock-price-fluctuation/",
        "task_description": "You are given a stream of **records** about a particular stock. Each record contains a **timestamp** and the corresponding **price** of the stock at that timestamp. Unfortunately due to the volatile nature of the stock market, the records do not come in order. Even worse, some records may be incorrect. Another record with the same timestamp may appear later in the stream **correcting** the price of the previous wrong record. Design an algorithm that: **Updates** the price of the stock at a particular timestamp, **correcting** the price from any previous records at the timestamp. Finds the **latest price** of the stock based on the current records. The **latest price** is the price at the latest timestamp recorded. Finds the **maximum price** the stock has been based on the current records. Finds the **minimum price** the stock has been based on the current records. Implement the `StockPrice` class: `StockPrice()` Initializes the object with no price records. `void update(int timestamp, int price)` Updates the `price` of the stock at the given `timestamp`. `int current()` Returns the **latest price** of the stock. `int maximum()` Returns the **maximum price** of the stock. `int minimum()` Returns the **minimum price** of the stock. **Example 1:** ``` **Input** [\"StockPrice\", \"update\", \"update\", \"current\", \"maximum\", \"update\", \"maximum\", \"update\", \"minimum\"] [[], [1, 10], [2, 5], [], [], [1, 3], [], [4, 2], []] **Output** [null, null, null, 5, 10, null, 5, null, 2] **Explanation** StockPrice stockPrice = new StockPrice(); stockPrice.update(1, 10); // Timestamps are [1] with corresponding prices [10]. stockPrice.update(2, 5); // Timestamps are [1,2] with corresponding prices [10,5]. stockPrice.current(); // return 5, the latest timestamp is 2 with the price being 5. stockPrice.maximum(); // return 10, the maximum price is 10 at timestamp 1. stockPrice.update(1, 3); // The previous timestamp 1 had the wrong price, so it is updated to 3. // Timestamps are [1,2] with corresponding prices [3,5]. stockPrice.maximum(); // return 5, the maximum price is 5 after the correction. stockPrice.update(4, 2); // Timestamps are [1,2,4] with corresponding prices [3,5,2]. stockPrice.minimum(); // return 2, the minimum price is 2 at timestamp 4. ``` **Constraints:** `1 <= timestamp, price <= 109` At most `105` calls will be made **in total** to `update`, `current`, `maximum`, and `minimum`. `current`, `maximum`, and `minimum` will be called **only after** `update` has been called **at least once**.",
        "test_case": [],
        "elixir_template": "defmodule StockPrice do\n  @spec init_() :: any\n  def init_() do\n    \n  end\n\n  @spec update(timestamp :: integer, price :: integer) :: any\n  def update(timestamp, price) do\n    \n  end\n\n  @spec current() :: integer\n  def current() do\n    \n  end\n\n  @spec maximum() :: integer\n  def maximum() do\n    \n  end\n\n  @spec minimum() :: integer\n  def minimum() do\n    \n  end\nend\n\n# Your functions will be called as such:\n# StockPrice.init_()\n# StockPrice.update(timestamp, price)\n# param_2 = StockPrice.current()\n# param_3 = StockPrice.maximum()\n# param_4 = StockPrice.minimum()\n\n# StockPrice.init_ will be called before every test case, in which you can do some necessary initializations.",
        "erlang_template": "-spec stock_price_init_() -> any().\nstock_price_init_() ->\n  .\n\n-spec stock_price_update(Timestamp :: integer(), Price :: integer()) -> any().\nstock_price_update(Timestamp, Price) ->\n  .\n\n-spec stock_price_current() -> integer().\nstock_price_current() ->\n  .\n\n-spec stock_price_maximum() -> integer().\nstock_price_maximum() ->\n  .\n\n-spec stock_price_minimum() -> integer().\nstock_price_minimum() ->\n  .\n\n\n%% Your functions will be called as such:\n%% stock_price_init_(),\n%% stock_price_update(Timestamp, Price),\n%% Param_2 = stock_price_current(),\n%% Param_3 = stock_price_maximum(),\n%% Param_4 = stock_price_minimum(),\n\n%% stock_price_init_ will be called before every test case, in which you can do some necessary initializations.",
        "scala_template": "class StockPrice() {\n\n    def update(timestamp: Int, price: Int): Unit = {\n        \n    }\n\n    def current(): Int = {\n        \n    }\n\n    def maximum(): Int = {\n        \n    }\n\n    def minimum(): Int = {\n        \n    }\n\n}\n\n/**\n * Your StockPrice object will be instantiated and called as such:\n * val obj = new StockPrice()\n * obj.update(timestamp,price)\n * val param_2 = obj.current()\n * val param_3 = obj.maximum()\n * val param_4 = obj.minimum()\n */"
    },
    {
        "id": 2160,
        "name": "minimum-operations-to-make-a-uni-value-grid",
        "difficulty": "Medium",
        "link": "https://leetcode.com/problems/minimum-operations-to-make-a-uni-value-grid/",
        "task_description": "You are given a 2D integer `grid` of size `m x n` and an integer `x`. In one operation, you can **add** `x` to or **subtract** `x` from any element in the `grid`. A **uni-value grid** is a grid where all the elements of it are equal. Return _the **minimum** number of operations to make the grid **uni-value**_. If it is not possible, return `-1`. **Example 1:** ``` **Input:** grid = [[2,4],[6,8]], x = 2 **Output:** 4 **Explanation:** We can make every element equal to 4 by doing the following: - Add x to 2 once. - Subtract x from 6 once. - Subtract x from 8 twice. A total of 4 operations were used. ``` **Example 2:** ``` **Input:** grid = [[1,5],[2,3]], x = 1 **Output:** 5 **Explanation:** We can make every element equal to 3. ``` **Example 3:** ``` **Input:** grid = [[1,2],[3,4]], x = 2 **Output:** -1 **Explanation:** It is impossible to make every element equal. ``` **Constraints:** `m == grid.length` `n == grid[i].length` `1 <= m, n <= 105` `1 <= m * n <= 105` `1 <= x, grid[i][j] <= 104`",
        "test_case": [
            {
                "label": "Example 1",
                "input": "grid = [[2,4],[6,8]], x = 2",
                "output": "4 Explanation: We can make every element equal to 4 by doing the following: \n- Add x to 2 once.\n- Subtract x from 6 once.\n- Subtract x from 8 twice.\nA total of 4 operations were used."
            },
            {
                "label": "Example 2",
                "input": "grid = [[1,5],[2,3]], x = 1",
                "output": "5 Explanation: We can make every element equal to 3."
            },
            {
                "label": "Example 3",
                "input": "grid = [[1,2],[3,4]], x = 2",
                "output": "-1 Explanation: It is impossible to make every element equal. Constraints: m == grid.length n == grid[i].length 1 <= m, n <= 10 5 1 <= m * n <= 10 5 1 <= x, grid[i][j] <= 10 4"
            }
        ],
        "elixir_template": "defmodule Solution do\n  @spec min_operations(grid :: [[integer]], x :: integer) :: integer\n  def min_operations(grid, x) do\n    \n  end\nend",
        "erlang_template": "-spec min_operations(Grid :: [[integer()]], X :: integer()) -> integer().\nmin_operations(Grid, X) ->\n  .",
        "scala_template": "object Solution {\n    def minOperations(grid: Array[Array[Int]], x: Int): Int = {\n        \n    }\n}"
    },
    {
        "id": 2159,
        "name": "two-out-of-three",
        "difficulty": "Easy",
        "link": "https://leetcode.com/problems/two-out-of-three/",
        "task_description": "Given three integer arrays `nums1`, `nums2`, and `nums3`, return _a **distinct** array containing all the values that are present in **at least two** out of the three arrays. You may return the values in **any** order_. **Example 1:** ``` **Input:** nums1 = [1,1,3,2], nums2 = [2,3], nums3 = [3] **Output:** [3,2] **Explanation:** The values that are present in at least two arrays are: - 3, in all three arrays. - 2, in nums1 and nums2. ``` **Example 2:** ``` **Input:** nums1 = [3,1], nums2 = [2,3], nums3 = [1,2] **Output:** [2,3,1] **Explanation:** The values that are present in at least two arrays are: - 2, in nums2 and nums3. - 3, in nums1 and nums2. - 1, in nums1 and nums3. ``` **Example 3:** ``` **Input:** nums1 = [1,2,2], nums2 = [4,3,3], nums3 = [5] **Output:** [] **Explanation:** No value is present in at least two arrays. ``` **Constraints:** `1 <= nums1.length, nums2.length, nums3.length <= 100` `1 <= nums1[i], nums2[j], nums3[k] <= 100`",
        "test_case": [
            {
                "label": "Example 1",
                "input": "nums1 = [1,1,3,2], nums2 = [2,3], nums3 = [3]",
                "output": "[3,2] Explanation: The values that are present in at least two arrays are:\n- 3, in all three arrays.\n- 2, in nums1 and nums2."
            },
            {
                "label": "Example 2",
                "input": "nums1 = [3,1], nums2 = [2,3], nums3 = [1,2]",
                "output": "[2,3,1] Explanation: The values that are present in at least two arrays are:\n- 2, in nums2 and nums3.\n- 3, in nums1 and nums2.\n- 1, in nums1 and nums3."
            },
            {
                "label": "Example 3",
                "input": "nums1 = [1,2,2], nums2 = [4,3,3], nums3 = [5]",
                "output": "[] Explanation: No value is present in at least two arrays."
            }
        ],
        "elixir_template": "defmodule Solution do\n  @spec two_out_of_three(nums1 :: [integer], nums2 :: [integer], nums3 :: [integer]) :: [integer]\n  def two_out_of_three(nums1, nums2, nums3) do\n    \n  end\nend",
        "erlang_template": "-spec two_out_of_three(Nums1 :: [integer()], Nums2 :: [integer()], Nums3 :: [integer()]) -> [integer()].\ntwo_out_of_three(Nums1, Nums2, Nums3) ->\n  .",
        "scala_template": "object Solution {\n    def twoOutOfThree(nums1: Array[Int], nums2: Array[Int], nums3: Array[Int]): List[Int] = {\n        \n    }\n}"
    },
    {
        "id": 2157,
        "name": "smallest-k-length-subsequence-with-occurrences-of-a-letter",
        "difficulty": "Hard",
        "link": "https://leetcode.com/problems/smallest-k-length-subsequence-with-occurrences-of-a-letter/",
        "task_description": "You are given a string `s`, an integer `k`, a letter `letter`, and an integer `repetition`. Return _the **lexicographically smallest** subsequence of_ `s`_ of length_ `k` _that has the letter_ `letter` _appear **at least**_ `repetition` _times_. The test cases are generated so that the `letter` appears in `s` **at least** `repetition` times. A **subsequence** is a string that can be derived from another string by deleting some or no characters without changing the order of the remaining characters. A string `a` is **lexicographically smaller** than a string `b` if in the first position where `a` and `b` differ, string `a` has a letter that appears earlier in the alphabet than the corresponding letter in `b`. **Example 1:** ``` **Input:** s = \"leet\", k = 3, letter = \"e\", repetition = 1 **Output:** \"eet\" **Explanation:** There are four subsequences of length 3 that have the letter 'e' appear at least 1 time: - \"lee\" (from \"**lee**t\") - \"let\" (from \"**le**e**t**\") - \"let\" (from \"**l**e**et**\") - \"eet\" (from \"l**eet**\") The lexicographically smallest subsequence among them is \"eet\". ``` **Example 2:** ``` **Input:** s = \"leetcode\", k = 4, letter = \"e\", repetition = 2 **Output:** \"ecde\" **Explanation:** \"ecde\" is the lexicographically smallest subsequence of length 4 that has the letter \"e\" appear at least 2 times. ``` **Example 3:** ``` **Input:** s = \"bb\", k = 2, letter = \"b\", repetition = 2 **Output:** \"bb\" **Explanation:** \"bb\" is the only subsequence of length 2 that has the letter \"b\" appear at least 2 times. ``` **Constraints:** `1 <= repetition <= k <= s.length <= 5 * 104` `s` consists of lowercase English letters. `letter` is a lowercase English letter, and appears in `s` at least `repetition` times.",
        "test_case": [
            {
                "label": "Example 1",
                "input": "s = \"leet\", k = 3, letter = \"e\", repetition = 1",
                "output": "\"eet\" Explanation: There are four subsequences of length 3 that have the letter 'e' appear at least 1 time:\n- \"lee\" (from \" lee t\")\n- \"let\" (from \" le e t \")\n- \"let\" (from \" l e et \")\n- \"eet\" (from \"l eet \")\nThe lexicographically smallest subsequence among them is \"eet\"."
            },
            {
                "label": "Example 2",
                "input": "s = \"leetcode\", k = 4, letter = \"e\", repetition = 2",
                "output": "\"ecde\" Explanation: \"ecde\" is the lexicographically smallest subsequence of length 4 that has the letter \"e\" appear at least 2 times."
            },
            {
                "label": "Example 3",
                "input": "s = \"bb\", k = 2, letter = \"b\", repetition = 2",
                "output": "\"bb\" Explanation: \"bb\" is the only subsequence of length 2 that has the letter \"b\" appear at least 2 times."
            }
        ],
        "elixir_template": "defmodule Solution do\n  @spec smallest_subsequence(s :: String.t, k :: integer, letter :: char, repetition :: integer) :: String.t\n  def smallest_subsequence(s, k, letter, repetition) do\n    \n  end\nend",
        "erlang_template": "-spec smallest_subsequence(S :: unicode:unicode_binary(), K :: integer(), Letter :: char(), Repetition :: integer()) -> unicode:unicode_binary().\nsmallest_subsequence(S, K, Letter, Repetition) ->\n  .",
        "scala_template": "object Solution {\n    def smallestSubsequence(s: String, k: Int, letter: Char, repetition: Int): String = {\n        \n    }\n}"
    },
    {
        "id": 2156,
        "name": "stone-game-ix",
        "difficulty": "Medium",
        "link": "https://leetcode.com/problems/stone-game-ix/",
        "task_description": "Alice and Bob continue their games with stones. There is a row of n stones, and each stone has an associated value. You are given an integer array `stones`, where `stones[i]` is the **value** of the `ith` stone. Alice and Bob take turns, with **Alice** starting first. On each turn, the player may remove any stone from `stones`. The player who removes a stone **loses** if the **sum** of the values of **all removed stones** is divisible by `3`. Bob will win automatically if there are no remaining stones (even if it is Alice's turn). Assuming both players play **optimally**, return `true` _if Alice wins and_ `false` _if Bob wins_. **Example 1:** ``` **Input:** stones = [2,1] **Output:** true **Explanation:** The game will be played as follows: - Turn 1: Alice can remove either stone. - Turn 2: Bob removes the remaining stone. The sum of the removed stones is 1 + 2 = 3 and is divisible by 3. Therefore, Bob loses and Alice wins the game. ``` **Example 2:** ``` **Input:** stones = [2] **Output:** false **Explanation:** Alice will remove the only stone, and the sum of the values on the removed stones is 2. Since all the stones are removed and the sum of values is not divisible by 3, Bob wins the game. ``` **Example 3:** ``` **Input:** stones = [5,1,2,4,3] **Output:** false **Explanation:** Bob will always win. One possible way for Bob to win is shown below: - Turn 1: Alice can remove the second stone with value 1. Sum of removed stones = 1. - Turn 2: Bob removes the fifth stone with value 3. Sum of removed stones = 1 + 3 = 4. - Turn 3: Alices removes the fourth stone with value 4. Sum of removed stones = 1 + 3 + 4 = 8. - Turn 4: Bob removes the third stone with value 2. Sum of removed stones = 1 + 3 + 4 + 2 = 10. - Turn 5: Alice removes the first stone with value 5. Sum of removed stones = 1 + 3 + 4 + 2 + 5 = 15. Alice loses the game because the sum of the removed stones (15) is divisible by 3. Bob wins the game. ``` **Constraints:** `1 <= stones.length <= 105` `1 <= stones[i] <= 104`",
        "test_case": [
            {
                "label": "Example 1",
                "input": "stones = [2,1]",
                "output": "true Explanation: The game will be played as follows:\n- Turn 1: Alice can remove either stone.\n- Turn 2: Bob removes the remaining stone. \nThe sum of the removed stones is 1 + 2 = 3 and is divisible by 3. Therefore, Bob loses and Alice wins the game."
            },
            {
                "label": "Example 2",
                "input": "stones = [2]",
                "output": "false Explanation: Alice will remove the only stone, and the sum of the values on the removed stones is 2. \nSince all the stones are removed and the sum of values is not divisible by 3, Bob wins the game."
            },
            {
                "label": "Example 3",
                "input": "stones = [5,1,2,4,3]",
                "output": "false Explanation: Bob will always win. One possible way for Bob to win is shown below:\n- Turn 1: Alice can remove the second stone with value 1. Sum of removed stones = 1.\n- Turn 2: Bob removes the fifth stone with value 3. Sum of removed stones = 1 + 3 = 4.\n- Turn 3: Alices removes the fourth stone with value 4. Sum of removed stones = 1 + 3 + 4 = 8.\n- Turn 4: Bob removes the third stone with value 2. Sum of removed stones = 1 + 3 + 4 + 2 = 10.\n- Turn 5: Alice removes the first stone with value 5. Sum of removed stones = 1 + 3 + 4 + 2 + 5 = 15.\nAlice loses the game because the sum of the removed stones (15) is divisible by 3. Bob wins the game."
            }
        ],
        "elixir_template": "defmodule Solution do\n  @spec stone_game_ix(stones :: [integer]) :: boolean\n  def stone_game_ix(stones) do\n    \n  end\nend",
        "erlang_template": "-spec stone_game_ix(Stones :: [integer()]) -> boolean().\nstone_game_ix(Stones) ->\n  .",
        "scala_template": "object Solution {\n    def stoneGameIX(stones: Array[Int]): Boolean = {\n        \n    }\n}"
    },
    {
        "id": 2155,
        "name": "find-missing-observations",
        "difficulty": "Medium",
        "link": "https://leetcode.com/problems/find-missing-observations/",
        "task_description": "You have observations of `n + m` **6-sided** dice rolls with each face numbered from `1` to `6`. `n` of the observations went missing, and you only have the observations of `m` rolls. Fortunately, you have also calculated the **average value** of the `n + m` rolls. You are given an integer array `rolls` of length `m` where `rolls[i]` is the value of the `ith` observation. You are also given the two integers `mean` and `n`. Return _an array of length _`n`_ containing the missing observations such that the **average value **of the _`n + m`_ rolls is **exactly** _`mean`. If there are multiple valid answers, return _any of them_. If no such array exists, return _an empty array_. The **average value** of a set of `k` numbers is the sum of the numbers divided by `k`. Note that `mean` is an integer, so the sum of the `n + m` rolls should be divisible by `n + m`. **Example 1:** ``` **Input:** rolls = [3,2,4,3], mean = 4, n = 2 **Output:** [6,6] **Explanation:** The mean of all n + m rolls is (3 + 2 + 4 + 3 + 6 + 6) / 6 = 4. ``` **Example 2:** ``` **Input:** rolls = [1,5,6], mean = 3, n = 4 **Output:** [2,3,2,2] **Explanation:** The mean of all n + m rolls is (1 + 5 + 6 + 2 + 3 + 2 + 2) / 7 = 3. ``` **Example 3:** ``` **Input:** rolls = [1,2,3,4], mean = 6, n = 4 **Output:** [] **Explanation:** It is impossible for the mean to be 6 no matter what the 4 missing rolls are. ``` **Constraints:** `m == rolls.length` `1 <= n, m <= 105` `1 <= rolls[i], mean <= 6`",
        "test_case": [
            {
                "label": "Example 1",
                "input": "rolls = [3,2,4,3], mean = 4, n = 2",
                "output": "[6,6] Explanation: The mean of all n + m rolls is (3 + 2 + 4 + 3 + 6 + 6) / 6 = 4."
            },
            {
                "label": "Example 2",
                "input": "rolls = [1,5,6], mean = 3, n = 4",
                "output": "[2,3,2,2] Explanation: The mean of all n + m rolls is (1 + 5 + 6 + 2 + 3 + 2 + 2) / 7 = 3."
            },
            {
                "label": "Example 3",
                "input": "rolls = [1,2,3,4], mean = 6, n = 4",
                "output": "[] Explanation: It is impossible for the mean to be 6 no matter what the 4 missing rolls are. Constraints: m == rolls.length 1 <= n, m <= 10 5 1 <= rolls[i], mean <= 6"
            }
        ],
        "elixir_template": "defmodule Solution do\n  @spec missing_rolls(rolls :: [integer], mean :: integer, n :: integer) :: [integer]\n  def missing_rolls(rolls, mean, n) do\n    \n  end\nend",
        "erlang_template": "-spec missing_rolls(Rolls :: [integer()], Mean :: integer(), N :: integer()) -> [integer()].\nmissing_rolls(Rolls, Mean, N) ->\n  .",
        "scala_template": "object Solution {\n    def missingRolls(rolls: Array[Int], mean: Int, n: Int): Array[Int] = {\n        \n    }\n}"
    },
    {
        "id": 2154,
        "name": "minimum-moves-to-convert-string",
        "difficulty": "Easy",
        "link": "https://leetcode.com/problems/minimum-moves-to-convert-string/",
        "task_description": "You are given a string `s` consisting of `n` characters which are either `'X'` or `'O'`. A **move** is defined as selecting **three** **consecutive characters** of `s` and converting them to `'O'`. Note that if a move is applied to the character `'O'`, it will stay the **same**. Return _the **minimum** number of moves required so that all the characters of _`s`_ are converted to _`'O'`. **Example 1:** ``` **Input:** s = \"XXX\" **Output:** 1 **Explanation:** XXX -> OOO We select all the 3 characters and convert them in one move. ``` **Example 2:** ``` **Input:** s = \"XXOX\" **Output:** 2 **Explanation:** XXOX -> OOOX -> OOOO We select the first 3 characters in the first move, and convert them to `'O'`. Then we select the last 3 characters and convert them so that the final string contains all `'O'`s. ``` **Example 3:** ``` **Input:** s = \"OOOO\" **Output:** 0 **Explanation:** There are no `'X's` in `s` to convert. ``` **Constraints:** `3 <= s.length <= 1000` `s[i]` is either `'X'` or `'O'`.",
        "test_case": [
            {
                "label": "Example 1",
                "input": "s = \"XXX\"",
                "output": "1 Explanation: XXX -> OOO\nWe select all the 3 characters and convert them in one move."
            },
            {
                "label": "Example 2",
                "input": "s = \"XXOX\"",
                "output": "2 Explanation: XXO X -> O OOX -> OOOO\nWe select the first 3 characters in the first move, and convert them to 'O' .\nThen we select the last 3 characters and convert them so that the final string contains all 'O' s."
            },
            {
                "label": "Example 3",
                "input": "s = \"OOOO\"",
                "output": "0 Explanation: There are no 'X's in s to convert."
            }
        ],
        "elixir_template": "defmodule Solution do\n  @spec minimum_moves(s :: String.t) :: integer\n  def minimum_moves(s) do\n    \n  end\nend",
        "erlang_template": "-spec minimum_moves(S :: unicode:unicode_binary()) -> integer().\nminimum_moves(S) ->\n  .",
        "scala_template": "object Solution {\n    def minimumMoves(s: String): Int = {\n        \n    }\n}"
    },
    {
        "id": 2151,
        "name": "the-time-when-the-network-becomes-idle",
        "difficulty": "Medium",
        "link": "https://leetcode.com/problems/the-time-when-the-network-becomes-idle/",
        "task_description": "There is a network of `n` servers, labeled from `0` to `n - 1`. You are given a 2D integer array `edges`, where `edges[i] = [ui, vi]` indicates there is a message channel between servers `ui` and `vi`, and they can pass **any** number of messages to **each other** directly in **one** second. You are also given a **0-indexed** integer array `patience` of length `n`. All servers are **connected**, i.e., a message can be passed from one server to any other server(s) directly or indirectly through the message channels. The server labeled `0` is the **master** server. The rest are **data** servers. Each data server needs to send its message to the master server for processing and wait for a reply. Messages move between servers **optimally**, so every message takes the **least amount of time** to arrive at the master server. The master server will process all newly arrived messages **instantly** and send a reply to the originating server via the **reversed path** the message had gone through. At the beginning of second `0`, each data server sends its message to be processed. Starting from second `1`, at the **beginning** of **every** second, each data server will check if it has received a reply to the message it sent (including any newly arrived replies) from the master server: If it has not, it will **resend** the message periodically. The data server `i` will resend the message every `patience[i]` second(s), i.e., the data server `i` will resend the message if `patience[i]` second(s) have **elapsed** since the **last** time the message was sent from this server. Otherwise, **no more resending** will occur from this server. The network becomes **idle** when there are **no** messages passing between servers or arriving at servers. Return _the **earliest second** starting from which the network becomes **idle**_. **Example 1:** ``` **Input:** edges = [[0,1],[1,2]], patience = [0,2,1] **Output:** 8 **Explanation:** At (the beginning of) second 0, - Data server 1 sends its message (denoted 1A) to the master server. - Data server 2 sends its message (denoted 2A) to the master server. At second 1, - Message 1A arrives at the master server. Master server processes message 1A instantly and sends a reply 1A back. - Server 1 has not received any reply. 1 second (1 < patience[1] = 2) elapsed since this server has sent the message, therefore it does not resend the message. - Server 2 has not received any reply. 1 second (1 == patience[2] = 1) elapsed since this server has sent the message, therefore it resends the message (denoted 2B). At second 2, - The reply 1A arrives at server 1. No more resending will occur from server 1. - Message 2A arrives at the master server. Master server processes message 2A instantly and sends a reply 2A back. - Server 2 resends the message (denoted 2C). ... At second 4, - The reply 2A arrives at server 2. No more resending will occur from server 2. ... At second 7, reply 2D arrives at server 2. Starting from the beginning of the second 8, there are no messages passing between servers or arriving at servers. This is the time when the network becomes idle. ``` **Example 2:** ``` **Input:** edges = [[0,1],[0,2],[1,2]], patience = [0,10,10] **Output:** 3 **Explanation:** Data servers 1 and 2 receive a reply back at the beginning of second 2. From the beginning of the second 3, the network becomes idle. ``` **Constraints:** `n == patience.length` `2 <= n <= 105` `patience[0] == 0` `1 <= patience[i] <= 105` for `1 <= i < n` `1 <= edges.length <= min(105, n * (n - 1) / 2)` `edges[i].length == 2` `0 <= ui, vi < n` `ui != vi` There are no duplicate edges. Each server can directly or indirectly reach another server.",
        "test_case": [
            {
                "label": "Example 1",
                "input": "edges = [[0,1],[1,2]], patience = [0,2,1]",
                "output": "8 Explanation: At (the beginning of) second 0,\n- Data server 1 sends its message (denoted 1A) to the master server.\n- Data server 2 sends its message (denoted 2A) to the master server.\n\nAt second 1,\n- Message 1A arrives at the master server. Master server processes message 1A instantly and sends a reply 1A back.\n- Server 1 has not received any reply. 1 second (1 < patience[1] = 2) elapsed since this server has sent the message, therefore it does not resend the message.\n- Server 2 has not received any reply. 1 second (1 == patience[2] = 1) elapsed since this server has sent the message, therefore it resends the message (denoted 2B).\n\nAt second 2,\n- The reply 1A arrives at server 1. No more resending will occur from server 1.\n- Message 2A arrives at the master server. Master server processes message 2A instantly and sends a reply 2A back.\n- Server 2 resends the message (denoted 2C).\n...\nAt second 4,\n- The reply 2A arrives at server 2. No more resending will occur from server 2.\n...\nAt second 7, reply 2D arrives at server 2.\n\nStarting from the beginning of the second 8, there are no messages passing between servers or arriving at servers.\nThis is the time when the network becomes idle."
            },
            {
                "label": "Example 2",
                "input": "edges = [[0,1],[0,2],[1,2]], patience = [0,10,10]",
                "output": "3 Explanation: Data servers 1 and 2 receive a reply back at the beginning of second 2.\nFrom the beginning of the second 3, the network becomes idle. Constraints: n == patience.length 2 <= n <= 10 5 patience[0] == 0 1 <= patience[i] <= 10 5 for 1 <= i < n 1 <= edges.length <= min(10 5 , n * (n - 1) / 2) edges[i].length == 2 0 <= u i , v i < n u i != v i There are no duplicate edges. Each server can directly or indirectly reach another server."
            }
        ],
        "elixir_template": "defmodule Solution do\n  @spec network_becomes_idle(edges :: [[integer]], patience :: [integer]) :: integer\n  def network_becomes_idle(edges, patience) do\n    \n  end\nend",
        "erlang_template": "-spec network_becomes_idle(Edges :: [[integer()]], Patience :: [integer()]) -> integer().\nnetwork_becomes_idle(Edges, Patience) ->\n  .",
        "scala_template": "object Solution {\n    def networkBecomesIdle(edges: Array[Array[Int]], patience: Array[Int]): Int = {\n        \n    }\n}"
    },
    {
        "id": 2150,
        "name": "kth-smallest-product-of-two-sorted-arrays",
        "difficulty": "Hard",
        "link": "https://leetcode.com/problems/kth-smallest-product-of-two-sorted-arrays/",
        "task_description": "Given two **sorted 0-indexed** integer arrays `nums1` and `nums2` as well as an integer `k`, return _the _`kth`_ (**1-based**) smallest product of _`nums1[i] * nums2[j]`_ where _`0 <= i < nums1.length`_ and _`0 <= j < nums2.length`. **Example 1:** ``` **Input:** nums1 = [2,5], nums2 = [3,4], k = 2 **Output:** 8 **Explanation:** The 2 smallest products are: - nums1[0] * nums2[0] = 2 * 3 = 6 - nums1[0] * nums2[1] = 2 * 4 = 8 The 2nd smallest product is 8. ``` **Example 2:** ``` **Input:** nums1 = [-4,-2,0,3], nums2 = [2,4], k = 6 **Output:** 0 **Explanation:** The 6 smallest products are: - nums1[0] * nums2[1] = (-4) * 4 = -16 - nums1[0] * nums2[0] = (-4) * 2 = -8 - nums1[1] * nums2[1] = (-2) * 4 = -8 - nums1[1] * nums2[0] = (-2) * 2 = -4 - nums1[2] * nums2[0] = 0 * 2 = 0 - nums1[2] * nums2[1] = 0 * 4 = 0 The 6th smallest product is 0. ``` **Example 3:** ``` **Input:** nums1 = [-2,-1,0,1,2], nums2 = [-3,-1,2,4,5], k = 3 **Output:** -6 **Explanation:** The 3 smallest products are: - nums1[0] * nums2[4] = (-2) * 5 = -10 - nums1[0] * nums2[3] = (-2) * 4 = -8 - nums1[4] * nums2[0] = 2 * (-3) = -6 The 3rd smallest product is -6. ``` **Constraints:** `1 <= nums1.length, nums2.length <= 5 * 104` `-105 <= nums1[i], nums2[j] <= 105` `1 <= k <= nums1.length * nums2.length` `nums1` and `nums2` are sorted.",
        "test_case": [
            {
                "label": "Example 1",
                "input": "nums1 = [2,5], nums2 = [3,4], k = 2",
                "output": "8 Explanation: The 2 smallest products are:\n- nums1[0] * nums2[0] = 2 * 3 = 6\n- nums1[0] * nums2[1] = 2 * 4 = 8\nThe 2 nd smallest product is 8."
            },
            {
                "label": "Example 2",
                "input": "nums1 = [-4,-2,0,3], nums2 = [2,4], k = 6",
                "output": "0 Explanation: The 6 smallest products are:\n- nums1[0] * nums2[1] = (-4) * 4 = -16\n- nums1[0] * nums2[0] = (-4) * 2 = -8\n- nums1[1] * nums2[1] = (-2) * 4 = -8\n- nums1[1] * nums2[0] = (-2) * 2 = -4\n- nums1[2] * nums2[0] = 0 * 2 = 0\n- nums1[2] * nums2[1] = 0 * 4 = 0\nThe 6 th smallest product is 0."
            },
            {
                "label": "Example 3",
                "input": "nums1 = [-2,-1,0,1,2], nums2 = [-3,-1,2,4,5], k = 3",
                "output": "-6 Explanation: The 3 smallest products are:\n- nums1[0] * nums2[4] = (-2) * 5 = -10\n- nums1[0] * nums2[3] = (-2) * 4 = -8\n- nums1[4] * nums2[0] = 2 * (-3) = -6\nThe 3 rd smallest product is -6."
            }
        ],
        "elixir_template": "defmodule Solution do\n  @spec kth_smallest_product(nums1 :: [integer], nums2 :: [integer], k :: integer) :: integer\n  def kth_smallest_product(nums1, nums2, k) do\n    \n  end\nend",
        "erlang_template": "-spec kth_smallest_product(Nums1 :: [integer()], Nums2 :: [integer()], K :: integer()) -> integer().\nkth_smallest_product(Nums1, Nums2, K) ->\n  .",
        "scala_template": "object Solution {\n    def kthSmallestProduct(nums1: Array[Int], nums2: Array[Int], k: Long): Long = {\n        \n    }\n}"
    },
    {
        "id": 2149,
        "name": "remove-colored-pieces-if-both-neighbors-are-the-same-color",
        "difficulty": "Medium",
        "link": "https://leetcode.com/problems/remove-colored-pieces-if-both-neighbors-are-the-same-color/",
        "task_description": "There are `n` pieces arranged in a line, and each piece is colored either by `'A'` or by `'B'`. You are given a string `colors` of length `n` where `colors[i]` is the color of the `ith` piece. Alice and Bob are playing a game where they take **alternating turns** removing pieces from the line. In this game, Alice moves** first**. Alice is only allowed to remove a piece colored `'A'` if **both its neighbors** are also colored `'A'`. She is **not allowed** to remove pieces that are colored `'B'`. Bob is only allowed to remove a piece colored `'B'` if **both its neighbors** are also colored `'B'`. He is **not allowed** to remove pieces that are colored `'A'`. Alice and Bob **cannot** remove pieces from the edge of the line. If a player cannot make a move on their turn, that player **loses** and the other player **wins**. Assuming Alice and Bob play optimally, return `true`_ if Alice wins, or return _`false`_ if Bob wins_. **Example 1:** ``` **Input:** colors = \"AAABABB\" **Output:** true **Explanation:** AAABABB -> AABABB Alice moves first. She removes the second 'A' from the left since that is the only 'A' whose neighbors are both 'A'. Now it's Bob's turn. Bob cannot make a move on his turn since there are no 'B's whose neighbors are both 'B'. Thus, Alice wins, so return true. ``` **Example 2:** ``` **Input:** colors = \"AA\" **Output:** false **Explanation:** Alice has her turn first. There are only two 'A's and both are on the edge of the line, so she cannot move on her turn. Thus, Bob wins, so return false. ``` **Example 3:** ``` **Input:** colors = \"ABBBBBBBAAA\" **Output:** false **Explanation:** ABBBBBBBAAA -> ABBBBBBBAA Alice moves first. Her only option is to remove the second to last 'A' from the right. ABBBBBBBAA -> ABBBBBBAA Next is Bob's turn. He has many options for which 'B' piece to remove. He can pick any. On Alice's second turn, she has no more pieces that she can remove. Thus, Bob wins, so return false. ``` **Constraints:** `1 <= colors.length <= 105` `colors` consists of only the letters `'A'` and `'B'`",
        "test_case": [
            {
                "label": "Example 1",
                "input": "colors = \"AAABABB\"",
                "output": "true Explanation: A A ABABB -> AABABB\nAlice moves first.\nShe removes the second 'A' from the left since that is the only 'A' whose neighbors are both 'A'.\n\nNow it's Bob's turn.\nBob cannot make a move on his turn since there are no 'B's whose neighbors are both 'B'.\nThus, Alice wins, so return true."
            },
            {
                "label": "Example 2",
                "input": "colors = \"AA\"",
                "output": "false Explanation: Alice has her turn first.\nThere are only two 'A's and both are on the edge of the line, so she cannot move on her turn.\nThus, Bob wins, so return false."
            },
            {
                "label": "Example 3",
                "input": "colors = \"ABBBBBBBAAA\"",
                "output": "false Explanation: ABBBBBBBA A A -> ABBBBBBBAA\nAlice moves first.\nHer only option is to remove the second to last 'A' from the right.\n\nABBBB B BBAA -> ABBBBBBAA\nNext is Bob's turn.\nHe has many options for which 'B' piece to remove. He can pick any.\n\nOn Alice's second turn, she has no more pieces that she can remove.\nThus, Bob wins, so return false."
            }
        ],
        "elixir_template": "defmodule Solution do\n  @spec winner_of_game(colors :: String.t) :: boolean\n  def winner_of_game(colors) do\n    \n  end\nend",
        "erlang_template": "-spec winner_of_game(Colors :: unicode:unicode_binary()) -> boolean().\nwinner_of_game(Colors) ->\n  .",
        "scala_template": "object Solution {\n    def winnerOfGame(colors: String): Boolean = {\n        \n    }\n}"
    },
    {
        "id": 2148,
        "name": "minimum-number-of-moves-to-seat-everyone",
        "difficulty": "Easy",
        "link": "https://leetcode.com/problems/minimum-number-of-moves-to-seat-everyone/",
        "task_description": "There are `n` **availabe **seats and `n` students **standing** in a room. You are given an array `seats` of length `n`, where `seats[i]` is the position of the `ith` seat. You are also given the array `students` of length `n`, where `students[j]` is the position of the `jth` student. You may perform the following move any number of times: Increase or decrease the position of the `ith` student by `1` (i.e., moving the `ith` student from position `x` to `x + 1` or `x - 1`) Return _the **minimum number of moves** required to move each student to a seat__ such that no two students are in the same seat._ Note that there may be **multiple** seats or students in the **same **position at the beginning. **Example 1:** ``` **Input:** seats = [3,1,5], students = [2,7,4] **Output:** 4 **Explanation:** The students are moved as follows: - The first student is moved from position 2 to position 1 using 1 move. - The second student is moved from position 7 to position 5 using 2 moves. - The third student is moved from position 4 to position 3 using 1 move. In total, 1 + 2 + 1 = 4 moves were used. ``` **Example 2:** ``` **Input:** seats = [4,1,5,9], students = [1,3,2,6] **Output:** 7 **Explanation:** The students are moved as follows: - The first student is not moved. - The second student is moved from position 3 to position 4 using 1 move. - The third student is moved from position 2 to position 5 using 3 moves. - The fourth student is moved from position 6 to position 9 using 3 moves. In total, 0 + 1 + 3 + 3 = 7 moves were used. ``` **Example 3:** ``` **Input:** seats = [2,2,6,6], students = [1,3,2,6] **Output:** 4 **Explanation:** Note that there are two seats at position 2 and two seats at position 6. The students are moved as follows: - The first student is moved from position 1 to position 2 using 1 move. - The second student is moved from position 3 to position 6 using 3 moves. - The third student is not moved. - The fourth student is not moved. In total, 1 + 3 + 0 + 0 = 4 moves were used. ``` **Constraints:** `n == seats.length == students.length` `1 <= n <= 100` `1 <= seats[i], students[j] <= 100`",
        "test_case": [
            {
                "label": "Example 1",
                "input": "seats = [3,1,5], students = [2,7,4]",
                "output": "4 Explanation: The students are moved as follows:\n- The first student is moved from position 2 to position 1 using 1 move.\n- The second student is moved from position 7 to position 5 using 2 moves.\n- The third student is moved from position 4 to position 3 using 1 move.\nIn total, 1 + 2 + 1 = 4 moves were used."
            },
            {
                "label": "Example 2",
                "input": "seats = [4,1,5,9], students = [1,3,2,6]",
                "output": "7 Explanation: The students are moved as follows:\n- The first student is not moved.\n- The second student is moved from position 3 to position 4 using 1 move.\n- The third student is moved from position 2 to position 5 using 3 moves.\n- The fourth student is moved from position 6 to position 9 using 3 moves.\nIn total, 0 + 1 + 3 + 3 = 7 moves were used."
            },
            {
                "label": "Example 3",
                "input": "seats = [2,2,6,6], students = [1,3,2,6]",
                "output": "4 Explanation: Note that there are two seats at position 2 and two seats at position 6.\nThe students are moved as follows:\n- The first student is moved from position 1 to position 2 using 1 move.\n- The second student is moved from position 3 to position 6 using 3 moves.\n- The third student is not moved.\n- The fourth student is not moved.\nIn total, 1 + 3 + 0 + 0 = 4 moves were used. Constraints: n == seats.length == students.length 1 <= n <= 100 1 <= seats[i], students[j] <= 100"
            }
        ],
        "elixir_template": "defmodule Solution do\n  @spec min_moves_to_seat(seats :: [integer], students :: [integer]) :: integer\n  def min_moves_to_seat(seats, students) do\n    \n  end\nend",
        "erlang_template": "-spec min_moves_to_seat(Seats :: [integer()], Students :: [integer()]) -> integer().\nmin_moves_to_seat(Seats, Students) ->\n  .",
        "scala_template": "object Solution {\n    def minMovesToSeat(seats: Array[Int], students: Array[Int]): Int = {\n        \n    }\n}"
    },
    {
        "id": 2147,
        "name": "the-score-of-students-solving-math-expression",
        "difficulty": "Hard",
        "link": "https://leetcode.com/problems/the-score-of-students-solving-math-expression/",
        "task_description": "You are given a string `s` that contains digits `0-9`, addition symbols `'+'`, and multiplication symbols `'*'` **only**, representing a **valid** math expression of **single digit numbers** (e.g., `3+5*2`). This expression was given to `n` elementary school students. The students were instructed to get the answer of the expression by following this **order of operations**: Compute **multiplication**, reading from **left to right**; Then, Compute **addition**, reading from **left to right**. You are given an integer array `answers` of length `n`, which are the submitted answers of the students in no particular order. You are asked to grade the `answers`, by following these **rules**: If an answer **equals** the correct answer of the expression, this student will be rewarded `5` points; Otherwise, if the answer **could be interpreted** as if the student applied the operators **in the wrong order** but had **correct arithmetic**, this student will be rewarded `2` points; Otherwise, this student will be rewarded `0` points. Return _the sum of the points of the students_. **Example 1:** ``` **Input:** s = \"7+3*1*2\", answers = [20,13,42] **Output:** 7 **Explanation:** As illustrated above, the correct answer of the expression is 13, therefore one student is rewarded 5 points: [20,**13**,42] A student might have applied the operators in this wrong order: ((7+3)*1)*2 = 20. Therefore one student is rewarded 2 points: [**20**,13,42] The points for the students are: [2,5,0]. The sum of the points is 2+5+0=7. ``` **Example 2:** ``` **Input:** s = \"3+5*2\", answers = [13,0,10,13,13,16,16] **Output:** 19 **Explanation:** The correct answer of the expression is 13, therefore three students are rewarded 5 points each: [**13**,0,10,**13**,**13**,16,16] A student might have applied the operators in this wrong order: ((3+5)*2 = 16. Therefore two students are rewarded 2 points: [13,0,10,13,13,**16**,**16**] The points for the students are: [5,0,0,5,5,2,2]. The sum of the points is 5+0+0+5+5+2+2=19. ``` **Example 3:** ``` **Input:** s = \"6+0*1\", answers = [12,9,6,4,8,6] **Output:** 10 **Explanation:** The correct answer of the expression is 6. If a student had incorrectly done (6+0)*1, the answer would also be 6. By the rules of grading, the students will still be rewarded 5 points (as they got the correct answer), not 2 points. The points for the students are: [0,0,5,0,0,5]. The sum of the points is 10. ``` **Constraints:** `3 <= s.length <= 31` `s` represents a valid expression that contains only digits `0-9`, `'+'`, and `'*'` only. All the integer operands in the expression are in the **inclusive** range `[0, 9]`. `1 <=` The count of all operators (`'+'` and `'*'`) in the math expression `<= 15` Test data are generated such that the correct answer of the expression is in the range of `[0, 1000]`. `n == answers.length` `1 <= n <= 104` `0 <= answers[i] <= 1000`",
        "test_case": [
            {
                "label": "Example 1",
                "input": "s = \"7+3*1*2\", answers = [20,13,42]",
                "output": "7 Explanation: As illustrated above, the correct answer of the expression is 13, therefore one student is rewarded 5 points: [20, 13 ,42]\nA student might have applied the operators in this wrong order: ((7+3)*1)*2 = 20. Therefore one student is rewarded 2 points: [ 20 ,13,42]\nThe points for the students are: [2,5,0]. The sum of the points is 2+5+0=7."
            },
            {
                "label": "Example 2",
                "input": "s = \"3+5*2\", answers = [13,0,10,13,13,16,16]",
                "output": "19 Explanation: The correct answer of the expression is 13, therefore three students are rewarded 5 points each: [ 13 ,0,10, 13 , 13 ,16,16]\nA student might have applied the operators in this wrong order: ((3+5)*2 = 16. Therefore two students are rewarded 2 points: [13,0,10,13,13, 16 , 16 ]\nThe points for the students are: [5,0,0,5,5,2,2]. The sum of the points is 5+0+0+5+5+2+2=19."
            },
            {
                "label": "Example 3",
                "input": "s = \"6+0*1\", answers = [12,9,6,4,8,6]",
                "output": "10 Explanation: The correct answer of the expression is 6.\nIf a student had incorrectly done (6+0)*1, the answer would also be 6.\nBy the rules of grading, the students will still be rewarded 5 points (as they got the correct answer), not 2 points.\nThe points for the students are: [0,0,5,0,0,5]. The sum of the points is 10."
            }
        ],
        "elixir_template": "defmodule Solution do\n  @spec score_of_students(s :: String.t, answers :: [integer]) :: integer\n  def score_of_students(s, answers) do\n    \n  end\nend",
        "erlang_template": "-spec score_of_students(S :: unicode:unicode_binary(), Answers :: [integer()]) -> integer().\nscore_of_students(S, Answers) ->\n  .",
        "scala_template": "object Solution {\n    def scoreOfStudents(s: String, answers: Array[Int]): Int = {\n        \n    }\n}"
    },
    {
        "id": 2146,
        "name": "check-if-word-can-be-placed-in-crossword",
        "difficulty": "Medium",
        "link": "https://leetcode.com/problems/check-if-word-can-be-placed-in-crossword/",
        "task_description": "You are given an `m x n` matrix `board`, representing the** current **state of a crossword puzzle. The crossword contains lowercase English letters (from solved words), `' '` to represent any **empty **cells, and `'#'` to represent any **blocked** cells. A word can be placed** horizontally** (left to right **or** right to left) or **vertically** (top to bottom **or** bottom to top) in the board if: It does not occupy a cell containing the character `'#'`. The cell each letter is placed in must either be `' '` (empty) or **match** the letter already on the `board`. There must not be any empty cells `' '` or other lowercase letters **directly left or right**** **of the word if the word was placed **horizontally**. There must not be any empty cells `' '` or other lowercase letters **directly above or below** the word if the word was placed **vertically**. Given a string `word`, return `true`_ if _`word`_ can be placed in _`board`_, or _`false`_ **otherwise**_. **Example 1:** ``` **Input:** board = [[\"#\", \" \", \"#\"], [\" \", \" \", \"#\"], [\"#\", \"c\", \" \"]], word = \"abc\" **Output:** true **Explanation:** The word \"abc\" can be placed as shown above (top to bottom). ``` **Example 2:** ``` **Input:** board = [[\" \", \"#\", \"a\"], [\" \", \"#\", \"c\"], [\" \", \"#\", \"a\"]], word = \"ac\" **Output:** false **Explanation:** It is impossible to place the word because there will always be a space/letter above or below it. ``` **Example 3:** ``` **Input:** board = [[\"#\", \" \", \"#\"], [\" \", \" \", \"#\"], [\"#\", \" \", \"c\"]], word = \"ca\" **Output:** true **Explanation:** The word \"ca\" can be placed as shown above (right to left). ``` **Constraints:** `m == board.length` `n == board[i].length` `1 <= m * n <= 2 * 105` `board[i][j]` will be `' '`, `'#'`, or a lowercase English letter. `1 <= word.length <= max(m, n)` `word` will contain only lowercase English letters.",
        "test_case": [
            {
                "label": "Example 1",
                "input": "board = [[\"#\", \" \", \"#\"], [\" \", \" \", \"#\"], [\"#\", \"c\", \" \"]], word = \"abc\"",
                "output": "true Explanation: The word \"abc\" can be placed as shown above (top to bottom)."
            },
            {
                "label": "Example 2",
                "input": "board = [[\" \", \"#\", \"a\"], [\" \", \"#\", \"c\"], [\" \", \"#\", \"a\"]], word = \"ac\"",
                "output": "false Explanation: It is impossible to place the word because there will always be a space/letter above or below it."
            },
            {
                "label": "Example 3",
                "input": "board = [[\"#\", \" \", \"#\"], [\" \", \" \", \"#\"], [\"#\", \" \", \"c\"]], word = \"ca\"",
                "output": "true Explanation: The word \"ca\" can be placed as shown above (right to left). Constraints: m == board.length n == board[i].length 1 <= m * n <= 2 * 10 5 board[i][j] will be ' ' , '#' , or a lowercase English letter. 1 <= word.length <= max(m, n) word will contain only lowercase English letters."
            }
        ],
        "elixir_template": "defmodule Solution do\n  @spec place_word_in_crossword(board :: [[char]], word :: String.t) :: boolean\n  def place_word_in_crossword(board, word) do\n    \n  end\nend",
        "erlang_template": "-spec place_word_in_crossword(Board :: [[char()]], Word :: unicode:unicode_binary()) -> boolean().\nplace_word_in_crossword(Board, Word) ->\n  .",
        "scala_template": "object Solution {\n    def placeWordInCrossword(board: Array[Array[Char]], word: String): Boolean = {\n        \n    }\n}"
    },
    {
        "id": 2145,
        "name": "grid-game",
        "difficulty": "Medium",
        "link": "https://leetcode.com/problems/grid-game/",
        "task_description": "You are given a **0-indexed** 2D array `grid` of size `2 x n`, where `grid[r][c]` represents the number of points at position `(r, c)` on the matrix. Two robots are playing a game on this matrix. Both robots initially start at `(0, 0)` and want to reach `(1, n-1)`. Each robot may only move to the **right** (`(r, c)` to `(r, c + 1)`) or **down **(`(r, c)` to `(r + 1, c)`). At the start of the game, the **first** robot moves from `(0, 0)` to `(1, n-1)`, collecting all the points from the cells on its path. For all cells `(r, c)` traversed on the path, `grid[r][c]` is set to `0`. Then, the **second** robot moves from `(0, 0)` to `(1, n-1)`, collecting the points on its path. Note that their paths may intersect with one another. The **first** robot wants to **minimize** the number of points collected by the **second** robot. In contrast, the **second **robot wants to **maximize** the number of points it collects. If both robots play **optimally**, return _the number of points collected by the **second** robot._ **Example 1:** ``` **Input:** grid = [[2,5,4],[1,5,1]] **Output:** 4 **Explanation:** The optimal path taken by the first robot is shown in red, and the optimal path taken by the second robot is shown in blue. The cells visited by the first robot are set to 0. The second robot will collect 0 + 0 + 4 + 0 = 4 points. ``` **Example 2:** ``` **Input:** grid = [[3,3,1],[8,5,2]] **Output:** 4 **Explanation:** The optimal path taken by the first robot is shown in red, and the optimal path taken by the second robot is shown in blue. The cells visited by the first robot are set to 0. The second robot will collect 0 + 3 + 1 + 0 = 4 points. ``` **Example 3:** ``` **Input:** grid = [[1,3,1,15],[1,3,3,1]] **Output:** 7 **Explanation: **The optimal path taken by the first robot is shown in red, and the optimal path taken by the second robot is shown in blue. The cells visited by the first robot are set to 0. The second robot will collect 0 + 1 + 3 + 3 + 0 = 7 points. ``` **Constraints:** `grid.length == 2` `n == grid[r].length` `1 <= n <= 5 * 104` `1 <= grid[r][c] <= 105`",
        "test_case": [
            {
                "label": "Example 1",
                "input": "grid = [[2,5,4],[1,5,1]]",
                "output": "4 Explanation: The optimal path taken by the first robot is shown in red, and the optimal path taken by the second robot is shown in blue.\nThe cells visited by the first robot are set to 0.\nThe second robot will collect 0 + 0 + 4 + 0 = 4 points."
            },
            {
                "label": "Example 2",
                "input": "grid = [[3,3,1],[8,5,2]]",
                "output": "4 Explanation: The optimal path taken by the first robot is shown in red, and the optimal path taken by the second robot is shown in blue.\nThe cells visited by the first robot are set to 0.\nThe second robot will collect 0 + 3 + 1 + 0 = 4 points."
            },
            {
                "label": "Example 3",
                "input": "grid = [[1,3,1,15],[1,3,3,1]]",
                "output": "7 Explanation: The optimal path taken by the first robot is shown in red, and the optimal path taken by the second robot is shown in blue.\nThe cells visited by the first robot are set to 0.\nThe second robot will collect 0 + 1 + 3 + 3 + 0 = 7 points. Constraints: grid.length == 2 n == grid[r].length 1 <= n <= 5 * 10 4 1 <= grid[r][c] <= 10 5"
            }
        ],
        "elixir_template": "defmodule Solution do\n  @spec grid_game(grid :: [[integer]]) :: integer\n  def grid_game(grid) do\n    \n  end\nend",
        "erlang_template": "-spec grid_game(Grid :: [[integer()]]) -> integer().\ngrid_game(Grid) ->\n  .",
        "scala_template": "object Solution {\n    def gridGame(grid: Array[Array[Int]]): Long = {\n        \n    }\n}"
    },
    {
        "id": 2144,
        "name": "maximum-difference-between-increasing-elements",
        "difficulty": "Easy",
        "link": "https://leetcode.com/problems/maximum-difference-between-increasing-elements/",
        "task_description": "Given a **0-indexed** integer array `nums` of size `n`, find the **maximum difference** between `nums[i]` and `nums[j]` (i.e., `nums[j] - nums[i]`), such that `0 <= i < j < n` and `nums[i] < nums[j]`. Return _the **maximum difference**. _If no such `i` and `j` exists, return `-1`. **Example 1:** ``` **Input:** nums = [7,**1**,**5**,4] **Output:** 4 **Explanation:** The maximum difference occurs with i = 1 and j = 2, nums[j] - nums[i] = 5 - 1 = 4. Note that with i = 1 and j = 0, the difference nums[j] - nums[i] = 7 - 1 = 6, but i > j, so it is not valid. ``` **Example 2:** ``` **Input:** nums = [9,4,3,2] **Output:** -1 **Explanation:** There is no i and j such that i < j and nums[i] < nums[j]. ``` **Example 3:** ``` **Input:** nums = [**1**,5,2,**10**] **Output:** 9 **Explanation:** The maximum difference occurs with i = 0 and j = 3, nums[j] - nums[i] = 10 - 1 = 9. ``` **Constraints:** `n == nums.length` `2 <= n <= 1000` `1 <= nums[i] <= 109`",
        "test_case": [
            {
                "label": "Example 1",
                "input": "nums = [7, 1 , 5 ,4]",
                "output": "4 Explanation: The maximum difference occurs with i = 1 and j = 2, nums[j] - nums[i] = 5 - 1 = 4.\nNote that with i = 1 and j = 0, the difference nums[j] - nums[i] = 7 - 1 = 6, but i > j, so it is not valid."
            },
            {
                "label": "Example 2",
                "input": "nums = [9,4,3,2]",
                "output": "-1 Explanation: There is no i and j such that i < j and nums[i] < nums[j]."
            },
            {
                "label": "Example 3",
                "input": "nums = [ 1 ,5,2, 10 ]",
                "output": "9 Explanation: The maximum difference occurs with i = 0 and j = 3, nums[j] - nums[i] = 10 - 1 = 9. Constraints: n == nums.length 2 <= n <= 1000 1 <= nums[i] <= 10 9"
            }
        ],
        "elixir_template": "defmodule Solution do\n  @spec maximum_difference(nums :: [integer]) :: integer\n  def maximum_difference(nums) do\n    \n  end\nend",
        "erlang_template": "-spec maximum_difference(Nums :: [integer()]) -> integer().\nmaximum_difference(Nums) ->\n  .",
        "scala_template": "object Solution {\n    def maximumDifference(nums: Array[Int]): Int = {\n        \n    }\n}"
    },
    {
        "id": 2140,
        "name": "longest-subsequence-repeated-k-times",
        "difficulty": "Hard",
        "link": "https://leetcode.com/problems/longest-subsequence-repeated-k-times/",
        "task_description": "You are given a string `s` of length `n`, and an integer `k`. You are tasked to find the **longest subsequence repeated** `k` times in string `s`. A **subsequence** is a string that can be derived from another string by deleting some or no characters without changing the order of the remaining characters. A subsequence `seq` is **repeated** `k` times in the string `s` if `seq * k` is a subsequence of `s`, where `seq * k` represents a string constructed by concatenating `seq` `k` times. For example, `\"bba\"` is repeated `2` times in the string `\"bababcba\"`, because the string `\"bbabba\"`, constructed by concatenating `\"bba\"` `2` times, is a subsequence of the string `\"**b**a**bab**c**ba**\"`. Return _the **longest subsequence repeated** _`k`_ times in string _`s`_. If multiple such subsequences are found, return the **lexicographically largest** one. If there is no such subsequence, return an **empty** string_. **Example 1:** ``` **Input:** s = \"letsleetcode\", k = 2 **Output:** \"let\" **Explanation:** There are two longest subsequences repeated 2 times: \"let\" and \"ete\". \"let\" is the lexicographically largest one. ``` **Example 2:** ``` **Input:** s = \"bb\", k = 2 **Output:** \"b\" **Explanation:** The longest subsequence repeated 2 times is \"b\". ``` **Example 3:** ``` **Input:** s = \"ab\", k = 2 **Output:** \"\" **Explanation:** There is no subsequence repeated 2 times. Empty string is returned. ``` **Constraints:** `n == s.length` `2 <= n, k <= 2000` `2 <= n < k * 8` `s` consists of lowercase English letters.",
        "test_case": [
            {
                "label": "Example 1",
                "input": "s = \"letsleetcode\", k = 2",
                "output": "\"let\" Explanation: There are two longest subsequences repeated 2 times: \"let\" and \"ete\".\n\"let\" is the lexicographically largest one."
            },
            {
                "label": "Example 2",
                "input": "s = \"bb\", k = 2",
                "output": "\"b\" Explanation: The longest subsequence repeated 2 times is \"b\"."
            },
            {
                "label": "Example 3",
                "input": "s = \"ab\", k = 2",
                "output": "\"\" Explanation: There is no subsequence repeated 2 times. Empty string is returned. Constraints: n == s.length 2 <= n, k <= 2000 2 <= n < k * 8 s consists of lowercase English letters."
            }
        ],
        "elixir_template": "defmodule Solution do\n  @spec longest_subsequence_repeated_k(s :: String.t, k :: integer) :: String.t\n  def longest_subsequence_repeated_k(s, k) do\n    \n  end\nend",
        "erlang_template": "-spec longest_subsequence_repeated_k(S :: unicode:unicode_binary(), K :: integer()) -> unicode:unicode_binary().\nlongest_subsequence_repeated_k(S, K) ->\n  .",
        "scala_template": "object Solution {\n    def longestSubsequenceRepeatedK(s: String, k: Int): String = {\n        \n    }\n}"
    },
    {
        "id": 2139,
        "name": "detect-squares",
        "difficulty": "Medium",
        "link": "https://leetcode.com/problems/detect-squares/",
        "task_description": "You are given a stream of points on the X-Y plane. Design an algorithm that: **Adds** new points from the stream into a data structure. **Duplicate** points are allowed and should be treated as different points. Given a query point, **counts** the number of ways to choose three points from the data structure such that the three points and the query point form an **axis-aligned square** with **positive area**. An **axis-aligned square** is a square whose edges are all the same length and are either parallel or perpendicular to the x-axis and y-axis. Implement the `DetectSquares` class: `DetectSquares()` Initializes the object with an empty data structure. `void add(int[] point)` Adds a new point `point = [x, y]` to the data structure. `int count(int[] point)` Counts the number of ways to form **axis-aligned squares** with point `point = [x, y]` as described above. **Example 1:** ``` **Input** [\"DetectSquares\", \"add\", \"add\", \"add\", \"count\", \"count\", \"add\", \"count\"] [[], [[3, 10]], [[11, 2]], [[3, 2]], [[11, 10]], [[14, 8]], [[11, 2]], [[11, 10]]] **Output** [null, null, null, null, 1, 0, null, 2] **Explanation** DetectSquares detectSquares = new DetectSquares(); detectSquares.add([3, 10]); detectSquares.add([11, 2]); detectSquares.add([3, 2]); detectSquares.count([11, 10]); // return 1. You can choose: // - The first, second, and third points detectSquares.count([14, 8]); // return 0. The query point cannot form a square with any points in the data structure. detectSquares.add([11, 2]); // Adding duplicate points is allowed. detectSquares.count([11, 10]); // return 2. You can choose: // - The first, second, and third points // - The first, third, and fourth points ``` **Constraints:** `point.length == 2` `0 <= x, y <= 1000` At most `3000` calls **in total** will be made to `add` and `count`.",
        "test_case": [],
        "elixir_template": "defmodule DetectSquares do\n  @spec init_() :: any\n  def init_() do\n    \n  end\n\n  @spec add(point :: [integer]) :: any\n  def add(point) do\n    \n  end\n\n  @spec count(point :: [integer]) :: integer\n  def count(point) do\n    \n  end\nend\n\n# Your functions will be called as such:\n# DetectSquares.init_()\n# DetectSquares.add(point)\n# param_2 = DetectSquares.count(point)\n\n# DetectSquares.init_ will be called before every test case, in which you can do some necessary initializations.",
        "erlang_template": "-spec detect_squares_init_() -> any().\ndetect_squares_init_() ->\n  .\n\n-spec detect_squares_add(Point :: [integer()]) -> any().\ndetect_squares_add(Point) ->\n  .\n\n-spec detect_squares_count(Point :: [integer()]) -> integer().\ndetect_squares_count(Point) ->\n  .\n\n\n%% Your functions will be called as such:\n%% detect_squares_init_(),\n%% detect_squares_add(Point),\n%% Param_2 = detect_squares_count(Point),\n\n%% detect_squares_init_ will be called before every test case, in which you can do some necessary initializations.",
        "scala_template": "class DetectSquares() {\n\n    def add(point: Array[Int]): Unit = {\n        \n    }\n\n    def count(point: Array[Int]): Int = {\n        \n    }\n\n}\n\n/**\n * Your DetectSquares object will be instantiated and called as such:\n * val obj = new DetectSquares()\n * obj.add(point)\n * val param_2 = obj.count(point)\n */"
    },
    {
        "id": 2138,
        "name": "sum-of-beauty-in-the-array",
        "difficulty": "Medium",
        "link": "https://leetcode.com/problems/sum-of-beauty-in-the-array/",
        "task_description": "You are given a **0-indexed** integer array `nums`. For each index `i` (`1 <= i <= nums.length - 2`) the **beauty** of `nums[i]` equals: `2`, if `nums[j] < nums[i] < nums[k]`, for **all** `0 <= j < i` and for **all** `i < k <= nums.length - 1`. `1`, if `nums[i - 1] < nums[i] < nums[i + 1]`, and the previous condition is not satisfied. `0`, if none of the previous conditions holds. Return_ the **sum of beauty** of all _`nums[i]`_ where _`1 <= i <= nums.length - 2`. **Example 1:** ``` **Input:** nums = [1,2,3] **Output:** 2 **Explanation:** For each index i in the range 1 <= i <= 1: - The beauty of nums[1] equals 2. ``` **Example 2:** ``` **Input:** nums = [2,4,6,4] **Output:** 1 **Explanation:** For each index i in the range 1 <= i <= 2: - The beauty of nums[1] equals 1. - The beauty of nums[2] equals 0. ``` **Example 3:** ``` **Input:** nums = [3,2,1] **Output:** 0 **Explanation:** For each index i in the range 1 <= i <= 1: - The beauty of nums[1] equals 0. ``` **Constraints:** `3 <= nums.length <= 105` `1 <= nums[i] <= 105`",
        "test_case": [
            {
                "label": "Example 1",
                "input": "nums = [1,2,3]",
                "output": "2 Explanation: For each index i in the range 1 <= i <= 1:\n- The beauty of nums[1] equals 2."
            },
            {
                "label": "Example 2",
                "input": "nums = [2,4,6,4]",
                "output": "1 Explanation: For each index i in the range 1 <= i <= 2:\n- The beauty of nums[1] equals 1.\n- The beauty of nums[2] equals 0."
            },
            {
                "label": "Example 3",
                "input": "nums = [3,2,1]",
                "output": "0 Explanation: For each index i in the range 1 <= i <= 1:\n- The beauty of nums[1] equals 0."
            }
        ],
        "elixir_template": "defmodule Solution do\n  @spec sum_of_beauties(nums :: [integer]) :: integer\n  def sum_of_beauties(nums) do\n    \n  end\nend",
        "erlang_template": "-spec sum_of_beauties(Nums :: [integer()]) -> integer().\nsum_of_beauties(Nums) ->\n  .",
        "scala_template": "object Solution {\n    def sumOfBeauties(nums: Array[Int]): Int = {\n        \n    }\n}"
    },
    {
        "id": 2137,
        "name": "final-value-of-variable-after-performing-operations",
        "difficulty": "Easy",
        "link": "https://leetcode.com/problems/final-value-of-variable-after-performing-operations/",
        "task_description": "There is a programming language with only **four** operations and **one** variable `X`: `++X` and `X++` **increments** the value of the variable `X` by `1`. `--X` and `X--` **decrements** the value of the variable `X` by `1`. Initially, the value of `X` is `0`. Given an array of strings `operations` containing a list of operations, return _the **final **value of _`X` _after performing all the operations_. **Example 1:** ``` **Input:** operations = [\"--X\",\"X++\",\"X++\"] **Output:** 1 **Explanation:** The operations are performed as follows: Initially, X = 0. --X: X is decremented by 1, X = 0 - 1 = -1. X++: X is incremented by 1, X = -1 + 1 = 0. X++: X is incremented by 1, X = 0 + 1 = 1. ``` **Example 2:** ``` **Input:** operations = [\"++X\",\"++X\",\"X++\"] **Output:** 3 **Explanation: **The operations are performed as follows: Initially, X = 0. ++X: X is incremented by 1, X = 0 + 1 = 1. ++X: X is incremented by 1, X = 1 + 1 = 2. X++: X is incremented by 1, X = 2 + 1 = 3. ``` **Example 3:** ``` **Input:** operations = [\"X++\",\"++X\",\"--X\",\"X--\"] **Output:** 0 **Explanation:** The operations are performed as follows: Initially, X = 0. X++: X is incremented by 1, X = 0 + 1 = 1. ++X: X is incremented by 1, X = 1 + 1 = 2. --X: X is decremented by 1, X = 2 - 1 = 1. X--: X is decremented by 1, X = 1 - 1 = 0. ``` **Constraints:** `1 <= operations.length <= 100` `operations[i]` will be either `\"++X\"`, `\"X++\"`, `\"--X\"`, or `\"X--\"`.",
        "test_case": [
            {
                "label": "Example 1",
                "input": "operations = [\"--X\",\"X++\",\"X++\"]",
                "output": "1 Explanation: The operations are performed as follows:\nInitially, X = 0.\n--X: X is decremented by 1, X =  0 - 1 = -1.\nX++: X is incremented by 1, X = -1 + 1 =  0.\nX++: X is incremented by 1, X =  0 + 1 =  1."
            },
            {
                "label": "Example 2",
                "input": "operations = [\"++X\",\"++X\",\"X++\"]",
                "output": "3 Explanation: The operations are performed as follows:\nInitially, X = 0.\n++X: X is incremented by 1, X = 0 + 1 = 1.\n++X: X is incremented by 1, X = 1 + 1 = 2.\nX++: X is incremented by 1, X = 2 + 1 = 3."
            },
            {
                "label": "Example 3",
                "input": "operations = [\"X++\",\"++X\",\"--X\",\"X--\"]",
                "output": "0 Explanation: The operations are performed as follows:\nInitially, X = 0.\nX++: X is incremented by 1, X = 0 + 1 = 1.\n++X: X is incremented by 1, X = 1 + 1 = 2.\n--X: X is decremented by 1, X = 2 - 1 = 1.\nX--: X is decremented by 1, X = 1 - 1 = 0."
            }
        ],
        "elixir_template": "defmodule Solution do\n  @spec final_value_after_operations(operations :: [String.t]) :: integer\n  def final_value_after_operations(operations) do\n    \n  end\nend",
        "erlang_template": "-spec final_value_after_operations(Operations :: [unicode:unicode_binary()]) -> integer().\nfinal_value_after_operations(Operations) ->\n  .",
        "scala_template": "object Solution {\n    def finalValueAfterOperations(operations: Array[String]): Int = {\n        \n    }\n}"
    },
    {
        "id": 2135,
        "name": "maximum-number-of-ways-to-partition-an-array",
        "difficulty": "Hard",
        "link": "https://leetcode.com/problems/maximum-number-of-ways-to-partition-an-array/",
        "task_description": "You are given a **0-indexed** integer array `nums` of length `n`. The number of ways to **partition** `nums` is the number of `pivot` indices that satisfy both conditions: `1 <= pivot < n` `nums[0] + nums[1] + ... + nums[pivot - 1] == nums[pivot] + nums[pivot + 1] + ... + nums[n - 1]` You are also given an integer `k`. You can choose to change the value of **one** element of `nums` to `k`, or to leave the array **unchanged**. Return _the **maximum** possible number of ways to **partition** _`nums`_ to satisfy both conditions after changing **at most** one element_. **Example 1:** ``` **Input:** nums = [2,-1,2], k = 3 **Output:** 1 **Explanation:** One optimal approach is to change nums[0] to k. The array becomes [**3**,-1,2]. There is one way to partition the array: - For pivot = 2, we have the partition [3,-1 | 2]: 3 + -1 == 2. ``` **Example 2:** ``` **Input:** nums = [0,0,0], k = 1 **Output:** 2 **Explanation:** The optimal approach is to leave the array unchanged. There are two ways to partition the array: - For pivot = 1, we have the partition [0 | 0,0]: 0 == 0 + 0. - For pivot = 2, we have the partition [0,0 | 0]: 0 + 0 == 0. ``` **Example 3:** ``` **Input:** nums = [22,4,-25,-20,-15,15,-16,7,19,-10,0,-13,-14], k = -33 **Output:** 4 **Explanation:** One optimal approach is to change nums[2] to k. The array becomes [22,4,**-33**,-20,-15,15,-16,7,19,-10,0,-13,-14]. There are four ways to partition the array. ``` **Constraints:** `n == nums.length` `2 <= n <= 105` `-105 <= k, nums[i] <= 105`",
        "test_case": [
            {
                "label": "Example 1",
                "input": "nums = [2,-1,2], k = 3",
                "output": "1 Explanation: One optimal approach is to change nums[0] to k. The array becomes [ 3 ,-1,2].\nThere is one way to partition the array:\n- For pivot = 2, we have the partition [3,-1 | 2]: 3 + -1 == 2."
            },
            {
                "label": "Example 2",
                "input": "nums = [0,0,0], k = 1",
                "output": "2 Explanation: The optimal approach is to leave the array unchanged.\nThere are two ways to partition the array:\n- For pivot = 1, we have the partition [0 | 0,0]: 0 == 0 + 0.\n- For pivot = 2, we have the partition [0,0 | 0]: 0 + 0 == 0."
            },
            {
                "label": "Example 3",
                "input": "nums = [22,4,-25,-20,-15,15,-16,7,19,-10,0,-13,-14], k = -33",
                "output": "4 Explanation: One optimal approach is to change nums[2] to k. The array becomes [22,4, -33 ,-20,-15,15,-16,7,19,-10,0,-13,-14].\nThere are four ways to partition the array. Constraints: n == nums.length 2 <= n <= 10 5 -10 5 <= k, nums[i] <= 10 5"
            }
        ],
        "elixir_template": "defmodule Solution do\n  @spec ways_to_partition(nums :: [integer], k :: integer) :: integer\n  def ways_to_partition(nums, k) do\n    \n  end\nend",
        "erlang_template": "-spec ways_to_partition(Nums :: [integer()], K :: integer()) -> integer().\nways_to_partition(Nums, K) ->\n  .",
        "scala_template": "object Solution {\n    def waysToPartition(nums: Array[Int], k: Int): Int = {\n        \n    }\n}"
    },
    {
        "id": 2134,
        "name": "maximize-the-confusion-of-an-exam",
        "difficulty": "Medium",
        "link": "https://leetcode.com/problems/maximize-the-confusion-of-an-exam/",
        "task_description": "A teacher is writing a test with `n` true/false questions, with `'T'` denoting true and `'F'` denoting false. He wants to confuse the students by **maximizing** the number of **consecutive** questions with the **same** answer (multiple trues or multiple falses in a row). You are given a string `answerKey`, where `answerKey[i]` is the original answer to the `ith` question. In addition, you are given an integer `k`, the maximum number of times you may perform the following operation: Change the answer key for any question to `'T'` or `'F'` (i.e., set `answerKey[i]` to `'T'` or `'F'`). Return _the **maximum** number of consecutive_ `'T'`s or `'F'`s _in the answer key after performing the operation at most_ `k` _times_. **Example 1:** ``` **Input:** answerKey = \"TTFF\", k = 2 **Output:** 4 **Explanation:** We can replace both the 'F's with 'T's to make answerKey = \"TTTT\". There are four consecutive 'T's. ``` **Example 2:** ``` **Input:** answerKey = \"TFFT\", k = 1 **Output:** 3 **Explanation:** We can replace the first 'T' with an 'F' to make answerKey = \"FFFT\". Alternatively, we can replace the second 'T' with an 'F' to make answerKey = \"TFFF\". In both cases, there are three consecutive 'F's. ``` **Example 3:** ``` **Input:** answerKey = \"TTFTTFTT\", k = 1 **Output:** 5 **Explanation:** We can replace the first 'F' to make answerKey = \"TTTTTFTT\" Alternatively, we can replace the second 'F' to make answerKey = \"TTFTTTTT\". In both cases, there are five consecutive 'T's. ``` **Constraints:** `n == answerKey.length` `1 <= n <= 5 * 104` `answerKey[i]` is either `'T'` or `'F'` `1 <= k <= n`",
        "test_case": [
            {
                "label": "Example 1",
                "input": "answerKey = \"TTFF\", k = 2",
                "output": "4 Explanation: We can replace both the 'F's with 'T's to make answerKey = \" TTTT \".\nThere are four consecutive 'T's."
            },
            {
                "label": "Example 2",
                "input": "answerKey = \"TFFT\", k = 1",
                "output": "3 Explanation: We can replace the first 'T' with an 'F' to make answerKey = \" FFF T\".\nAlternatively, we can replace the second 'T' with an 'F' to make answerKey = \"T FFF \".\nIn both cases, there are three consecutive 'F's."
            },
            {
                "label": "Example 3",
                "input": "answerKey = \"TTFTTFTT\", k = 1",
                "output": "5 Explanation: We can replace the first 'F' to make answerKey = \" TTTTT FTT\"\nAlternatively, we can replace the second 'F' to make answerKey = \"TTF TTTTT \". \nIn both cases, there are five consecutive 'T's. Constraints: n == answerKey.length 1 <= n <= 5 * 10 4 answerKey[i] is either 'T' or 'F' 1 <= k <= n"
            }
        ],
        "elixir_template": "defmodule Solution do\n  @spec max_consecutive_answers(answer_key :: String.t, k :: integer) :: integer\n  def max_consecutive_answers(answer_key, k) do\n    \n  end\nend",
        "erlang_template": "-spec max_consecutive_answers(AnswerKey :: unicode:unicode_binary(), K :: integer()) -> integer().\nmax_consecutive_answers(AnswerKey, K) ->\n  .",
        "scala_template": "object Solution {\n    def maxConsecutiveAnswers(answerKey: String, k: Int): Int = {\n        \n    }\n}"
    },
    {
        "id": 2133,
        "name": "number-of-pairs-of-strings-with-concatenation-equal-to-target",
        "difficulty": "Medium",
        "link": "https://leetcode.com/problems/number-of-pairs-of-strings-with-concatenation-equal-to-target/",
        "task_description": "Given an array of **digit** strings `nums` and a **digit** string `target`, return _the number of pairs of indices _`(i, j)`_ (where _`i != j`_) such that the **concatenation** of _`nums[i] + nums[j]`_ equals _`target`. **Example 1:** ``` **Input:** nums = [\"777\",\"7\",\"77\",\"77\"], target = \"7777\" **Output:** 4 **Explanation:** Valid pairs are: - (0, 1): \"777\" + \"7\" - (1, 0): \"7\" + \"777\" - (2, 3): \"77\" + \"77\" - (3, 2): \"77\" + \"77\" ``` **Example 2:** ``` **Input:** nums = [\"123\",\"4\",\"12\",\"34\"], target = \"1234\" **Output:** 2 **Explanation:** Valid pairs are: - (0, 1): \"123\" + \"4\" - (2, 3): \"12\" + \"34\" ``` **Example 3:** ``` **Input:** nums = [\"1\",\"1\",\"1\"], target = \"11\" **Output:** 6 **Explanation:** Valid pairs are: - (0, 1): \"1\" + \"1\" - (1, 0): \"1\" + \"1\" - (0, 2): \"1\" + \"1\" - (2, 0): \"1\" + \"1\" - (1, 2): \"1\" + \"1\" - (2, 1): \"1\" + \"1\" ``` **Constraints:** `2 <= nums.length <= 100` `1 <= nums[i].length <= 100` `2 <= target.length <= 100` `nums[i]` and `target` consist of digits. `nums[i]` and `target` do not have leading zeros.",
        "test_case": [
            {
                "label": "Example 1",
                "input": "nums = [\"777\",\"7\",\"77\",\"77\"], target = \"7777\"",
                "output": "4 Explanation: Valid pairs are:\n- (0, 1): \"777\" + \"7\"\n- (1, 0): \"7\" + \"777\"\n- (2, 3): \"77\" + \"77\"\n- (3, 2): \"77\" + \"77\""
            },
            {
                "label": "Example 2",
                "input": "nums = [\"123\",\"4\",\"12\",\"34\"], target = \"1234\"",
                "output": "2 Explanation: Valid pairs are:\n- (0, 1): \"123\" + \"4\"\n- (2, 3): \"12\" + \"34\""
            },
            {
                "label": "Example 3",
                "input": "nums = [\"1\",\"1\",\"1\"], target = \"11\"",
                "output": "6 Explanation: Valid pairs are:\n- (0, 1): \"1\" + \"1\"\n- (1, 0): \"1\" + \"1\"\n- (0, 2): \"1\" + \"1\"\n- (2, 0): \"1\" + \"1\"\n- (1, 2): \"1\" + \"1\"\n- (2, 1): \"1\" + \"1\""
            }
        ],
        "elixir_template": "defmodule Solution do\n  @spec num_of_pairs(nums :: [String.t], target :: String.t) :: integer\n  def num_of_pairs(nums, target) do\n    \n  end\nend",
        "erlang_template": "-spec num_of_pairs(Nums :: [unicode:unicode_binary()], Target :: unicode:unicode_binary()) -> integer().\nnum_of_pairs(Nums, Target) ->\n  .",
        "scala_template": "object Solution {\n    def numOfPairs(nums: Array[String], target: String): Int = {\n        \n    }\n}"
    },
    {
        "id": 2132,
        "name": "convert-1d-array-into-2d-array",
        "difficulty": "Easy",
        "link": "https://leetcode.com/problems/convert-1d-array-into-2d-array/",
        "task_description": "You are given a **0-indexed** 1-dimensional (1D) integer array `original`, and two integers, `m` and `n`. You are tasked with creating a 2-dimensional (2D) array with ` m` rows and `n` columns using **all** the elements from `original`. The elements from indices `0` to `n - 1` (**inclusive**) of `original` should form the first row of the constructed 2D array, the elements from indices `n` to `2 * n - 1` (**inclusive**) should form the second row of the constructed 2D array, and so on. Return _an _`m x n`_ 2D array constructed according to the above procedure, or an empty 2D array if it is impossible_. **Example 1:** ``` **Input:** original = [1,2,3,4], m = 2, n = 2 **Output:** [[1,2],[3,4]] **Explanation:** The constructed 2D array should contain 2 rows and 2 columns. The first group of n=2 elements in original, [1,2], becomes the first row in the constructed 2D array. The second group of n=2 elements in original, [3,4], becomes the second row in the constructed 2D array. ``` **Example 2:** ``` **Input:** original = [1,2,3], m = 1, n = 3 **Output:** [[1,2,3]] **Explanation:** The constructed 2D array should contain 1 row and 3 columns. Put all three elements in original into the first row of the constructed 2D array. ``` **Example 3:** ``` **Input:** original = [1,2], m = 1, n = 1 **Output:** [] **Explanation:** There are 2 elements in original. It is impossible to fit 2 elements in a 1x1 2D array, so return an empty 2D array. ``` **Constraints:** `1 <= original.length <= 5 * 104` `1 <= original[i] <= 105` `1 <= m, n <= 4 * 104`",
        "test_case": [
            {
                "label": "Example 1",
                "input": "original = [1,2,3,4], m = 2, n = 2",
                "output": "[[1,2],[3,4]] Explanation: The constructed 2D array should contain 2 rows and 2 columns.\nThe first group of n=2 elements in original, [1,2], becomes the first row in the constructed 2D array.\nThe second group of n=2 elements in original, [3,4], becomes the second row in the constructed 2D array."
            },
            {
                "label": "Example 2",
                "input": "original = [1,2,3], m = 1, n = 3",
                "output": "[[1,2,3]] Explanation: The constructed 2D array should contain 1 row and 3 columns.\nPut all three elements in original into the first row of the constructed 2D array."
            },
            {
                "label": "Example 3",
                "input": "original = [1,2], m = 1, n = 1",
                "output": "[] Explanation: There are 2 elements in original.\nIt is impossible to fit 2 elements in a 1x1 2D array, so return an empty 2D array."
            }
        ],
        "elixir_template": "defmodule Solution do\n  @spec construct2_d_array(original :: [integer], m :: integer, n :: integer) :: [[integer]]\n  def construct2_d_array(original, m, n) do\n    \n  end\nend",
        "erlang_template": "-spec construct2_d_array(Original :: [integer()], M :: integer(), N :: integer()) -> [[integer()]].\nconstruct2_d_array(Original, M, N) ->\n  .",
        "scala_template": "object Solution {\n    def construct2DArray(original: Array[Int], m: Int, n: Int): Array[Array[Int]] = {\n        \n    }\n}"
    },
    {
        "id": 2131,
        "name": "smallest-missing-genetic-value-in-each-subtree",
        "difficulty": "Hard",
        "link": "https://leetcode.com/problems/smallest-missing-genetic-value-in-each-subtree/",
        "task_description": "There is a **family tree** rooted at `0` consisting of `n` nodes numbered `0` to `n - 1`. You are given a **0-indexed** integer array `parents`, where `parents[i]` is the parent for node `i`. Since node `0` is the **root**, `parents[0] == -1`. There are `105` genetic values, each represented by an integer in the **inclusive** range `[1, 105]`. You are given a **0-indexed** integer array `nums`, where `nums[i]` is a **distinct **genetic value for node `i`. Return _an array _`ans`_ of length _`n`_ where _`ans[i]`_ is_ _the **smallest** genetic value that is **missing** from the subtree rooted at node_ `i`. The **subtree** rooted at a node `x` contains node `x` and all of its **descendant** nodes. **Example 1:** ``` **Input:** parents = [-1,0,0,2], nums = [1,2,3,4] **Output:** [5,1,1,1] **Explanation:** The answer for each subtree is calculated as follows: - 0: The subtree contains nodes [0,1,2,3] with values [1,2,3,4]. 5 is the smallest missing value. - 1: The subtree contains only node 1 with value 2. 1 is the smallest missing value. - 2: The subtree contains nodes [2,3] with values [3,4]. 1 is the smallest missing value. - 3: The subtree contains only node 3 with value 4. 1 is the smallest missing value. ``` **Example 2:** ``` **Input:** parents = [-1,0,1,0,3,3], nums = [5,4,6,2,1,3] **Output:** [7,1,1,4,2,1] **Explanation:** The answer for each subtree is calculated as follows: - 0: The subtree contains nodes [0,1,2,3,4,5] with values [5,4,6,2,1,3]. 7 is the smallest missing value. - 1: The subtree contains nodes [1,2] with values [4,6]. 1 is the smallest missing value. - 2: The subtree contains only node 2 with value 6. 1 is the smallest missing value. - 3: The subtree contains nodes [3,4,5] with values [2,1,3]. 4 is the smallest missing value. - 4: The subtree contains only node 4 with value 1. 2 is the smallest missing value. - 5: The subtree contains only node 5 with value 3. 1 is the smallest missing value. ``` **Example 3:** ``` **Input:** parents = [-1,2,3,0,2,4,1], nums = [2,3,4,5,6,7,8] **Output:** [1,1,1,1,1,1,1] **Explanation:** The value 1 is missing from all the subtrees. ``` **Constraints:** `n == parents.length == nums.length` `2 <= n <= 105` `0 <= parents[i] <= n - 1` for `i != 0` `parents[0] == -1` `parents` represents a valid tree. `1 <= nums[i] <= 105` Each `nums[i]` is distinct.",
        "test_case": [
            {
                "label": "Example 1",
                "input": "parents = [-1,0,0,2], nums = [1,2,3,4]",
                "output": "[5,1,1,1] Explanation: The answer for each subtree is calculated as follows:\n- 0: The subtree contains nodes [0,1,2,3] with values [1,2,3,4]. 5 is the smallest missing value.\n- 1: The subtree contains only node 1 with value 2. 1 is the smallest missing value.\n- 2: The subtree contains nodes [2,3] with values [3,4]. 1 is the smallest missing value.\n- 3: The subtree contains only node 3 with value 4. 1 is the smallest missing value."
            },
            {
                "label": "Example 2",
                "input": "parents = [-1,0,1,0,3,3], nums = [5,4,6,2,1,3]",
                "output": "[7,1,1,4,2,1] Explanation: The answer for each subtree is calculated as follows:\n- 0: The subtree contains nodes [0,1,2,3,4,5] with values [5,4,6,2,1,3]. 7 is the smallest missing value.\n- 1: The subtree contains nodes [1,2] with values [4,6]. 1 is the smallest missing value.\n- 2: The subtree contains only node 2 with value 6. 1 is the smallest missing value.\n- 3: The subtree contains nodes [3,4,5] with values [2,1,3]. 4 is the smallest missing value.\n- 4: The subtree contains only node 4 with value 1. 2 is the smallest missing value.\n- 5: The subtree contains only node 5 with value 3. 1 is the smallest missing value."
            },
            {
                "label": "Example 3",
                "input": "parents = [-1,2,3,0,2,4,1], nums = [2,3,4,5,6,7,8]",
                "output": "[1,1,1,1,1,1,1] Explanation: The value 1 is missing from all the subtrees. Constraints: n == parents.length == nums.length 2 <= n <= 10 5 0 <= parents[i] <= n - 1 for i != 0 parents[0] == -1 parents represents a valid tree. 1 <= nums[i] <= 10 5 Each nums[i] is distinct."
            }
        ],
        "elixir_template": "defmodule Solution do\n  @spec smallest_missing_value_subtree(parents :: [integer], nums :: [integer]) :: [integer]\n  def smallest_missing_value_subtree(parents, nums) do\n    \n  end\nend",
        "erlang_template": "-spec smallest_missing_value_subtree(Parents :: [integer()], Nums :: [integer()]) -> [integer()].\nsmallest_missing_value_subtree(Parents, Nums) ->\n  .",
        "scala_template": "object Solution {\n    def smallestMissingValueSubtree(parents: Array[Int], nums: Array[Int]): Array[Int] = {\n        \n    }\n}"
    },
    {
        "id": 2130,
        "name": "maximum-product-of-the-length-of-two-palindromic-subsequences",
        "difficulty": "Medium",
        "link": "https://leetcode.com/problems/maximum-product-of-the-length-of-two-palindromic-subsequences/",
        "task_description": "Given a string `s`, find two **disjoint palindromic subsequences** of `s` such that the **product** of their lengths is **maximized**. The two subsequences are **disjoint** if they do not both pick a character at the same index. Return _the **maximum** possible **product** of the lengths of the two palindromic subsequences_. A **subsequence** is a string that can be derived from another string by deleting some or no characters without changing the order of the remaining characters. A string is **palindromic** if it reads the same forward and backward. **Example 1:** ``` **Input:** s = \"leetcodecom\" **Output:** 9 **Explanation**: An optimal solution is to choose \"ete\" for the 1st subsequence and \"cdc\" for the 2nd subsequence. The product of their lengths is: 3 * 3 = 9. ``` **Example 2:** ``` **Input:** s = \"bb\" **Output:** 1 **Explanation**: An optimal solution is to choose \"b\" (the first character) for the 1st subsequence and \"b\" (the second character) for the 2nd subsequence. The product of their lengths is: 1 * 1 = 1. ``` **Example 3:** ``` **Input:** s = \"accbcaxxcxx\" **Output:** 25 **Explanation**: An optimal solution is to choose \"accca\" for the 1st subsequence and \"xxcxx\" for the 2nd subsequence. The product of their lengths is: 5 * 5 = 25. ``` **Constraints:** `2 <= s.length <= 12` `s` consists of lowercase English letters only.",
        "test_case": [
            {
                "label": "Example 1",
                "input": "s = \"leetcodecom\"",
                "output": "9 Explanation : An optimal solution is to choose \"ete\" for the 1 st subsequence and \"cdc\" for the 2 nd subsequence.\nThe product of their lengths is: 3 * 3 = 9."
            },
            {
                "label": "Example 2",
                "input": "s = \"bb\"",
                "output": "1 Explanation : An optimal solution is to choose \"b\" (the first character) for the 1 st subsequence and \"b\" (the second character) for the 2 nd subsequence.\nThe product of their lengths is: 1 * 1 = 1."
            },
            {
                "label": "Example 3",
                "input": "s = \"accbcaxxcxx\"",
                "output": "25 Explanation : An optimal solution is to choose \"accca\" for the 1 st subsequence and \"xxcxx\" for the 2 nd subsequence.\nThe product of their lengths is: 5 * 5 = 25."
            }
        ],
        "elixir_template": "defmodule Solution do\n  @spec max_product(s :: String.t) :: integer\n  def max_product(s) do\n    \n  end\nend",
        "erlang_template": "-spec max_product(S :: unicode:unicode_binary()) -> integer().\nmax_product(S) ->\n  .",
        "scala_template": "object Solution {\n    def maxProduct(s: String): Int = {\n        \n    }\n}"
    },
    {
        "id": 2129,
        "name": "number-of-pairs-of-interchangeable-rectangles",
        "difficulty": "Medium",
        "link": "https://leetcode.com/problems/number-of-pairs-of-interchangeable-rectangles/",
        "task_description": "You are given `n` rectangles represented by a **0-indexed** 2D integer array `rectangles`, where `rectangles[i] = [widthi, heighti]` denotes the width and height of the `ith` rectangle. Two rectangles `i` and `j` (`i < j`) are considered **interchangeable** if they have the **same** width-to-height ratio. More formally, two rectangles are **interchangeable** if `widthi/heighti == widthj/heightj` (using decimal division, not integer division). Return _the **number** of pairs of **interchangeable** rectangles in _`rectangles`. **Example 1:** ``` **Input:** rectangles = [[4,8],[3,6],[10,20],[15,30]] **Output:** 6 **Explanation:** The following are the interchangeable pairs of rectangles by index (0-indexed): - Rectangle 0 with rectangle 1: 4/8 == 3/6. - Rectangle 0 with rectangle 2: 4/8 == 10/20. - Rectangle 0 with rectangle 3: 4/8 == 15/30. - Rectangle 1 with rectangle 2: 3/6 == 10/20. - Rectangle 1 with rectangle 3: 3/6 == 15/30. - Rectangle 2 with rectangle 3: 10/20 == 15/30. ``` **Example 2:** ``` **Input:** rectangles = [[4,5],[7,8]] **Output:** 0 **Explanation:** There are no interchangeable pairs of rectangles. ``` **Constraints:** `n == rectangles.length` `1 <= n <= 105` `rectangles[i].length == 2` `1 <= widthi, heighti <= 105`",
        "test_case": [
            {
                "label": "Example 1",
                "input": "rectangles = [[4,8],[3,6],[10,20],[15,30]]",
                "output": "6 Explanation: The following are the interchangeable pairs of rectangles by index (0-indexed):\n- Rectangle 0 with rectangle 1: 4/8 == 3/6.\n- Rectangle 0 with rectangle 2: 4/8 == 10/20.\n- Rectangle 0 with rectangle 3: 4/8 == 15/30.\n- Rectangle 1 with rectangle 2: 3/6 == 10/20.\n- Rectangle 1 with rectangle 3: 3/6 == 15/30.\n- Rectangle 2 with rectangle 3: 10/20 == 15/30."
            },
            {
                "label": "Example 2",
                "input": "rectangles = [[4,5],[7,8]]",
                "output": "0 Explanation: There are no interchangeable pairs of rectangles. Constraints: n == rectangles.length 1 <= n <= 10 5 rectangles[i].length == 2 1 <= width i , height i <= 10 5"
            }
        ],
        "elixir_template": "defmodule Solution do\n  @spec interchangeable_rectangles(rectangles :: [[integer]]) :: integer\n  def interchangeable_rectangles(rectangles) do\n    \n  end\nend",
        "erlang_template": "-spec interchangeable_rectangles(Rectangles :: [[integer()]]) -> integer().\ninterchangeable_rectangles(Rectangles) ->\n  .",
        "scala_template": "object Solution {\n    def interchangeableRectangles(rectangles: Array[Array[Int]]): Long = {\n        \n    }\n}"
    },
    {
        "id": 2128,
        "name": "reverse-prefix-of-word",
        "difficulty": "Easy",
        "link": "https://leetcode.com/problems/reverse-prefix-of-word/",
        "task_description": "Given a **0-indexed** string `word` and a character `ch`, **reverse** the segment of `word` that starts at index `0` and ends at the index of the **first occurrence** of `ch` (**inclusive**). If the character `ch` does not exist in `word`, do nothing. For example, if `word = \"abcdefd\"` and `ch = \"d\"`, then you should **reverse** the segment that starts at `0` and ends at `3` (**inclusive**). The resulting string will be `\"dcbaefd\"`. Return _the resulting string_. **Example 1:** ``` **Input:** word = \"abcdefd\", ch = \"d\" **Output:** \"dcbaefd\" **Explanation:** The first occurrence of \"d\" is at index 3. Reverse the part of word from 0 to 3 (inclusive), the resulting string is \"dcbaefd\". ``` **Example 2:** ``` **Input:** word = \"xyxzxe\", ch = \"z\" **Output:** \"zxyxxe\" **Explanation:** The first and only occurrence of \"z\" is at index 3. Reverse the part of word from 0 to 3 (inclusive), the resulting string is \"zxyxxe\". ``` **Example 3:** ``` **Input:** word = \"abcd\", ch = \"z\" **Output:** \"abcd\" **Explanation:** \"z\" does not exist in word. You should not do any reverse operation, the resulting string is \"abcd\". ``` **Constraints:** `1 <= word.length <= 250` `word` consists of lowercase English letters. `ch` is a lowercase English letter.",
        "test_case": [
            {
                "label": "Example 1",
                "input": "word = \" abcd efd\", ch = \"d\"",
                "output": "\" dcba efd\" Explanation: The first occurrence of \"d\" is at index 3. \nReverse the part of word from 0 to 3 (inclusive), the resulting string is \"dcbaefd\"."
            },
            {
                "label": "Example 2",
                "input": "word = \" xyxz xe\", ch = \"z\"",
                "output": "\" zxyx xe\" Explanation: The first and only occurrence of \"z\" is at index 3.\nReverse the part of word from 0 to 3 (inclusive), the resulting string is \"zxyxxe\"."
            },
            {
                "label": "Example 3",
                "input": "word = \"abcd\", ch = \"z\"",
                "output": "\"abcd\" Explanation: \"z\" does not exist in word.\nYou should not do any reverse operation, the resulting string is \"abcd\"."
            }
        ],
        "elixir_template": "defmodule Solution do\n  @spec reverse_prefix(word :: String.t, ch :: char) :: String.t\n  def reverse_prefix(word, ch) do\n    \n  end\nend",
        "erlang_template": "-spec reverse_prefix(Word :: unicode:unicode_binary(), Ch :: char()) -> unicode:unicode_binary().\nreverse_prefix(Word, Ch) ->\n  .",
        "scala_template": "object Solution {\n    def reversePrefix(word: String, ch: Char): String = {\n        \n    }\n}"
    },
    {
        "id": 2125,
        "name": "gcd-sort-of-an-array",
        "difficulty": "Hard",
        "link": "https://leetcode.com/problems/gcd-sort-of-an-array/",
        "task_description": "You are given an integer array `nums`, and you can perform the following operation **any** number of times on `nums`: Swap the positions of two elements `nums[i]` and `nums[j]` if `gcd(nums[i], nums[j]) > 1` where `gcd(nums[i], nums[j])` is the **greatest common divisor** of `nums[i]` and `nums[j]`. Return `true` _if it is possible to sort _`nums`_ in **non-decreasing** order using the above swap method, or _`false`_ otherwise._ **Example 1:** ``` **Input:** nums = [7,21,3] **Output:** true **Explanation:** We can sort [7,21,3] by performing the following operations: - Swap 7 and 21 because gcd(7,21) = 7. nums = [**21**,**7**,3] - Swap 21 and 3 because gcd(21,3) = 3. nums = [**3**,7,**21**] ``` **Example 2:** ``` **Input:** nums = [5,2,6,2] **Output:** false **Explanation:** It is impossible to sort the array because 5 cannot be swapped with any other element. ``` **Example 3:** ``` **Input:** nums = [10,5,9,3,15] **Output:** true We can sort [10,5,9,3,15] by performing the following operations: - Swap 10 and 15 because gcd(10,15) = 5. nums = [**15**,5,9,3,**10**] - Swap 15 and 3 because gcd(15,3) = 3. nums = [**3**,5,9,**15**,10] - Swap 10 and 15 because gcd(10,15) = 5. nums = [3,5,9,**10**,**15**] ``` **Constraints:** `1 <= nums.length <= 3 * 104` `2 <= nums[i] <= 105`",
        "test_case": [
            {
                "label": "Example 1",
                "input": "nums = [7,21,3]",
                "output": "true Explanation: We can sort [7,21,3] by performing the following operations:\n- Swap 7 and 21 because gcd(7,21) = 7. nums = [ 21 , 7 ,3]\n- Swap 21 and 3 because gcd(21,3) = 3. nums = [ 3 ,7, 21 ]"
            },
            {
                "label": "Example 2",
                "input": "nums = [5,2,6,2]",
                "output": "false Explanation: It is impossible to sort the array because 5 cannot be swapped with any other element."
            },
            {
                "label": "Example 3",
                "input": "nums = [10,5,9,3,15]",
                "output": "true\nWe can sort [10,5,9,3,15] by performing the following operations:\n- Swap 10 and 15 because gcd(10,15) = 5. nums = [ 15 ,5,9,3, 10 ]\n- Swap 15 and 3 because gcd(15,3) = 3. nums = [ 3 ,5,9, 15 ,10]\n- Swap 10 and 15 because gcd(10,15) = 5. nums = [3,5,9, 10 , 15 ]"
            }
        ],
        "elixir_template": "defmodule Solution do\n  @spec gcd_sort(nums :: [integer]) :: boolean\n  def gcd_sort(nums) do\n    \n  end\nend",
        "erlang_template": "-spec gcd_sort(Nums :: [integer()]) -> boolean().\ngcd_sort(Nums) ->\n  .",
        "scala_template": "object Solution {\n    def gcdSort(nums: Array[Int]): Boolean = {\n        \n    }\n}"
    },
    {
        "id": 2124,
        "name": "first-day-where-you-have-been-in-all-the-rooms",
        "difficulty": "Medium",
        "link": "https://leetcode.com/problems/first-day-where-you-have-been-in-all-the-rooms/",
        "task_description": "There are `n` rooms you need to visit, labeled from `0` to `n - 1`. Each day is labeled, starting from `0`. You will go in and visit one room a day. Initially on day `0`, you visit room `0`. The **order** you visit the rooms for the coming days is determined by the following **rules** and a given **0-indexed** array `nextVisit` of length `n`: Assuming that on a day, you visit room `i`, if you have been in room `i` an **odd** number of times (**including** the current visit), on the **next** day you will visit a room with a **lower or equal room number** specified by `nextVisit[i]` where `0 <= nextVisit[i] <= i`; if you have been in room `i` an **even** number of times (**including** the current visit), on the **next** day you will visit room `(i + 1) mod n`. Return _the label of the **first** day where you have been in **all** the rooms_. It can be shown that such a day exists. Since the answer may be very large, return it **modulo** `109 + 7`. **Example 1:** ``` **Input:** nextVisit = [0,0] **Output:** 2 **Explanation:** - On day 0, you visit room 0. The total times you have been in room 0 is 1, which is odd. On the next day you will visit room nextVisit[0] = 0 - On day 1, you visit room 0, The total times you have been in room 0 is 2, which is even. On the next day you will visit room (0 + 1) mod 2 = 1 - On day 2, you visit room 1. This is the first day where you have been in all the rooms. ``` **Example 2:** ``` **Input:** nextVisit = [0,0,2] **Output:** 6 **Explanation:** Your room visiting order for each day is: [0,0,1,0,0,1,2,...]. Day 6 is the first day where you have been in all the rooms. ``` **Example 3:** ``` **Input:** nextVisit = [0,1,2,0] **Output:** 6 **Explanation:** Your room visiting order for each day is: [0,0,1,1,2,2,3,...]. Day 6 is the first day where you have been in all the rooms. ``` **Constraints:** `n == nextVisit.length` `2 <= n <= 105` `0 <= nextVisit[i] <= i`",
        "test_case": [
            {
                "label": "Example 1",
                "input": "nextVisit = [0,0]",
                "output": "2 Explanation: - On day 0, you visit room 0. The total times you have been in room 0 is 1, which is odd.\n\u00a0 On the next day you will visit room nextVisit[0] = 0\n- On day 1, you visit room 0, The total times you have been in room 0 is 2, which is even.\n\u00a0 On the next day you will visit room (0 + 1) mod 2 = 1\n- On day 2, you visit room 1. This is the first day where you have been in all the rooms."
            },
            {
                "label": "Example 2",
                "input": "nextVisit = [0,0,2]",
                "output": "6 Explanation: Your room visiting order for each day is: [0,0,1,0,0,1,2,...].\nDay 6 is the first day where you have been in all the rooms."
            },
            {
                "label": "Example 3",
                "input": "nextVisit = [0,1,2,0]",
                "output": "6 Explanation: Your room visiting order for each day is: [0,0,1,1,2,2,3,...].\nDay 6 is the first day where you have been in all the rooms. Constraints: n == nextVisit.length 2 <= n <= 10 5 0 <= nextVisit[i] <= i"
            }
        ],
        "elixir_template": "defmodule Solution do\n  @spec first_day_been_in_all_rooms(next_visit :: [integer]) :: integer\n  def first_day_been_in_all_rooms(next_visit) do\n    \n  end\nend",
        "erlang_template": "-spec first_day_been_in_all_rooms(NextVisit :: [integer()]) -> integer().\nfirst_day_been_in_all_rooms(NextVisit) ->\n  .",
        "scala_template": "object Solution {\n    def firstDayBeenInAllRooms(nextVisit: Array[Int]): Int = {\n        \n    }\n}"
    },
    {
        "id": 2123,
        "name": "the-number-of-weak-characters-in-the-game",
        "difficulty": "Medium",
        "link": "https://leetcode.com/problems/the-number-of-weak-characters-in-the-game/",
        "task_description": "You are playing a game that contains multiple characters, and each of the characters has **two** main properties: **attack** and **defense**. You are given a 2D integer array `properties` where `properties[i] = [attacki, defensei]` represents the properties of the `ith` character in the game. A character is said to be **weak** if any other character has **both** attack and defense levels **strictly greater** than this character's attack and defense levels. More formally, a character `i` is said to be **weak** if there exists another character `j` where `attackj > attacki` and `defensej > defensei`. Return _the number of **weak** characters_. **Example 1:** ``` **Input:** properties = [[5,5],[6,3],[3,6]] **Output:** 0 **Explanation:** No character has strictly greater attack and defense than the other. ``` **Example 2:** ``` **Input:** properties = [[2,2],[3,3]] **Output:** 1 **Explanation:** The first character is weak because the second character has a strictly greater attack and defense. ``` **Example 3:** ``` **Input:** properties = [[1,5],[10,4],[4,3]] **Output:** 1 **Explanation:** The third character is weak because the second character has a strictly greater attack and defense. ``` **Constraints:** `2 <= properties.length <= 105` `properties[i].length == 2` `1 <= attacki, defensei <= 105`",
        "test_case": [
            {
                "label": "Example 1",
                "input": "properties = [[5,5],[6,3],[3,6]]",
                "output": "0 Explanation: No character has strictly greater attack and defense than the other."
            },
            {
                "label": "Example 2",
                "input": "properties = [[2,2],[3,3]]",
                "output": "1 Explanation: The first character is weak because the second character has a strictly greater attack and defense."
            },
            {
                "label": "Example 3",
                "input": "properties = [[1,5],[10,4],[4,3]]",
                "output": "1 Explanation: The third character is weak because the second character has a strictly greater attack and defense."
            }
        ],
        "elixir_template": "defmodule Solution do\n  @spec number_of_weak_characters(properties :: [[integer]]) :: integer\n  def number_of_weak_characters(properties) do\n    \n  end\nend",
        "erlang_template": "-spec number_of_weak_characters(Properties :: [[integer()]]) -> integer().\nnumber_of_weak_characters(Properties) ->\n  .",
        "scala_template": "object Solution {\n    def numberOfWeakCharacters(properties: Array[Array[Int]]): Int = {\n        \n    }\n}"
    },
    {
        "id": 2122,
        "name": "count-special-quadruplets",
        "difficulty": "Easy",
        "link": "https://leetcode.com/problems/count-special-quadruplets/",
        "task_description": "Given a **0-indexed** integer array `nums`, return _the number of **distinct** quadruplets_ `(a, b, c, d)` _such that:_ `nums[a] + nums[b] + nums[c] == nums[d]`, and `a < b < c < d` **Example 1:** ``` **Input:** nums = [1,2,3,6] **Output:** 1 **Explanation:** The only quadruplet that satisfies the requirement is (0, 1, 2, 3) because 1 + 2 + 3 == 6. ``` **Example 2:** ``` **Input:** nums = [3,3,6,4,5] **Output:** 0 **Explanation:** There are no such quadruplets in [3,3,6,4,5]. ``` **Example 3:** ``` **Input:** nums = [1,1,1,3,5] **Output:** 4 **Explanation:** The 4 quadruplets that satisfy the requirement are: - (0, 1, 2, 3): 1 + 1 + 1 == 3 - (0, 1, 3, 4): 1 + 1 + 3 == 5 - (0, 2, 3, 4): 1 + 1 + 3 == 5 - (1, 2, 3, 4): 1 + 1 + 3 == 5 ``` **Constraints:** `4 <= nums.length <= 50` `1 <= nums[i] <= 100`",
        "test_case": [
            {
                "label": "Example 1",
                "input": "nums = [1,2,3,6]",
                "output": "1 Explanation: The only quadruplet that satisfies the requirement is (0, 1, 2, 3) because 1 + 2 + 3 == 6."
            },
            {
                "label": "Example 2",
                "input": "nums = [3,3,6,4,5]",
                "output": "0 Explanation: There are no such quadruplets in [3,3,6,4,5]."
            },
            {
                "label": "Example 3",
                "input": "nums = [1,1,1,3,5]",
                "output": "4 Explanation: The 4 quadruplets that satisfy the requirement are:\n- (0, 1, 2, 3): 1 + 1 + 1 == 3\n- (0, 1, 3, 4): 1 + 1 + 3 == 5\n- (0, 2, 3, 4): 1 + 1 + 3 == 5\n- (1, 2, 3, 4): 1 + 1 + 3 == 5"
            }
        ],
        "elixir_template": "defmodule Solution do\n  @spec count_quadruplets(nums :: [integer]) :: integer\n  def count_quadruplets(nums) do\n    \n  end\nend",
        "erlang_template": "-spec count_quadruplets(Nums :: [integer()]) -> integer().\ncount_quadruplets(Nums) ->\n  .",
        "scala_template": "object Solution {\n    def countQuadruplets(nums: Array[Int]): Int = {\n        \n    }\n}"
    },
    {
        "id": 2121,
        "name": "find-if-path-exists-in-graph",
        "difficulty": "Easy",
        "link": "https://leetcode.com/problems/find-if-path-exists-in-graph/",
        "task_description": "There is a **bi-directional** graph with `n` vertices, where each vertex is labeled from `0` to `n - 1` (**inclusive**). The edges in the graph are represented as a 2D integer array `edges`, where each `edges[i] = [ui, vi]` denotes a bi-directional edge between vertex `ui` and vertex `vi`. Every vertex pair is connected by **at most one** edge, and no vertex has an edge to itself. You want to determine if there is a **valid path** that exists from vertex `source` to vertex `destination`. Given `edges` and the integers `n`, `source`, and `destination`, return `true`_ if there is a **valid path** from _`source`_ to _`destination`_, or _`false`_ otherwise__._ **Example 1:** ``` **Input:** n = 3, edges = [[0,1],[1,2],[2,0]], source = 0, destination = 2 **Output:** true **Explanation:** There are two paths from vertex 0 to vertex 2: - 0 \u2192 1 \u2192 2 - 0 \u2192 2 ``` **Example 2:** ``` **Input:** n = 6, edges = [[0,1],[0,2],[3,5],[5,4],[4,3]], source = 0, destination = 5 **Output:** false **Explanation:** There is no path from vertex 0 to vertex 5. ``` **Constraints:** `1 <= n <= 2 * 105` `0 <= edges.length <= 2 * 105` `edges[i].length == 2` `0 <= ui, vi <= n - 1` `ui != vi` `0 <= source, destination <= n - 1` There are no duplicate edges. There are no self edges.",
        "test_case": [
            {
                "label": "Example 1",
                "input": "n = 3, edges = [[0,1],[1,2],[2,0]], source = 0, destination = 2",
                "output": "true Explanation: There are two paths from vertex 0 to vertex 2:\n- 0 \u2192 1 \u2192 2\n- 0 \u2192 2"
            },
            {
                "label": "Example 2",
                "input": "n = 6, edges = [[0,1],[0,2],[3,5],[5,4],[4,3]], source = 0, destination = 5",
                "output": "false Explanation: There is no path from vertex 0 to vertex 5."
            }
        ],
        "elixir_template": "defmodule Solution do\n  @spec valid_path(n :: integer, edges :: [[integer]], source :: integer, destination :: integer) :: boolean\n  def valid_path(n, edges, source, destination) do\n    \n  end\nend",
        "erlang_template": "-spec valid_path(N :: integer(), Edges :: [[integer()]], Source :: integer(), Destination :: integer()) -> boolean().\nvalid_path(N, Edges, Source, Destination) ->\n  .",
        "scala_template": "object Solution {\n    def validPath(n: Int, edges: Array[Array[Int]], source: Int, destination: Int): Boolean = {\n        \n    }\n}"
    },
    {
        "id": 2119,
        "name": "minimum-number-of-operations-to-make-array-continuous",
        "difficulty": "Hard",
        "link": "https://leetcode.com/problems/minimum-number-of-operations-to-make-array-continuous/",
        "task_description": "You are given an integer array `nums`. In one operation, you can replace **any** element in `nums` with **any** integer. `nums` is considered **continuous** if both of the following conditions are fulfilled: All elements in `nums` are **unique**. The difference between the **maximum** element and the **minimum** element in `nums` equals `nums.length - 1`. For example, `nums = [4, 2, 5, 3]` is **continuous**, but `nums = [1, 2, 3, 5, 6]` is **not continuous**. Return _the **minimum** number of operations to make _`nums`_ _**_continuous_**. **Example 1:** ``` **Input:** nums = [4,2,5,3] **Output:** 0 **Explanation:** nums is already continuous. ``` **Example 2:** ``` **Input:** nums = [1,2,3,5,6] **Output:** 1 **Explanation:** One possible solution is to change the last element to 4. The resulting array is [1,2,3,5,4], which is continuous. ``` **Example 3:** ``` **Input:** nums = [1,10,100,1000] **Output:** 3 **Explanation:** One possible solution is to: - Change the second element to 2. - Change the third element to 3. - Change the fourth element to 4. The resulting array is [1,2,3,4], which is continuous. ``` **Constraints:** `1 <= nums.length <= 105` `1 <= nums[i] <= 109`",
        "test_case": [
            {
                "label": "Example 1",
                "input": "nums = [4,2,5,3]",
                "output": "0 Explanation: nums is already continuous."
            },
            {
                "label": "Example 2",
                "input": "nums = [1,2,3,5,6]",
                "output": "1 Explanation: One possible solution is to change the last element to 4.\nThe resulting array is [1,2,3,5,4], which is continuous."
            },
            {
                "label": "Example 3",
                "input": "nums = [1,10,100,1000]",
                "output": "3 Explanation: One possible solution is to:\n- Change the second element to 2.\n- Change the third element to 3.\n- Change the fourth element to 4.\nThe resulting array is [1,2,3,4], which is continuous."
            }
        ],
        "elixir_template": "defmodule Solution do\n  @spec min_operations(nums :: [integer]) :: integer\n  def min_operations(nums) do\n    \n  end\nend",
        "erlang_template": "-spec min_operations(Nums :: [integer()]) -> integer().\nmin_operations(Nums) ->\n  .",
        "scala_template": "object Solution {\n    def minOperations(nums: Array[Int]): Int = {\n        \n    }\n}"
    },
    {
        "id": 2118,
        "name": "maximum-earnings-from-taxi",
        "difficulty": "Medium",
        "link": "https://leetcode.com/problems/maximum-earnings-from-taxi/",
        "task_description": "There are `n` points on a road you are driving your taxi on. The `n` points on the road are labeled from `1` to `n` in the direction you are going, and you want to drive from point `1` to point `n` to make money by picking up passengers. You cannot change the direction of the taxi. The passengers are represented by a **0-indexed** 2D integer array `rides`, where `rides[i] = [starti, endi, tipi]` denotes the `ith` passenger requesting a ride from point `starti` to point `endi` who is willing to give a `tipi` dollar tip. For** each **passenger `i` you pick up, you **earn** `endi - starti + tipi` dollars. You may only drive at most one passenger at a time. Given `n` and `rides`, return _the **maximum** number of dollars you can earn by picking up the passengers optimally._ **Note:** You may drop off a passenger and pick up a different passenger at the same point. **Example 1:** ``` **Input:** n = 5, rides = [[2,5,4],[1,5,1]] **Output:** 7 **Explanation:** We can pick up passenger 0 to earn 5 - 2 + 4 = 7 dollars. ``` **Example 2:** ``` **Input:** n = 20, rides = [[1,6,1],[3,10,2],[10,12,3],[11,12,2],[12,15,2],[13,18,1]] **Output:** 20 **Explanation:** We will pick up the following passengers: - Drive passenger 1 from point 3 to point 10 for a profit of 10 - 3 + 2 = 9 dollars. - Drive passenger 2 from point 10 to point 12 for a profit of 12 - 10 + 3 = 5 dollars. - Drive passenger 5 from point 13 to point 18 for a profit of 18 - 13 + 1 = 6 dollars. We earn 9 + 5 + 6 = 20 dollars in total. ``` **Constraints:** `1 <= n <= 105` `1 <= rides.length <= 3 * 104` `rides[i].length == 3` `1 <= starti < endi <= n` `1 <= tipi <= 105`",
        "test_case": [
            {
                "label": "Example 1",
                "input": "n = 5, rides = [ [2,5,4] ,[1,5,1]]",
                "output": "7 Explanation: We can pick up passenger 0 to earn 5 - 2 + 4 = 7 dollars."
            },
            {
                "label": "Example 2",
                "input": "n = 20, rides = [[1,6,1], [3,10,2] , [10,12,3] ,[11,12,2],[12,15,2], [13,18,1] ]",
                "output": "20 Explanation: We will pick up the following passengers:\n- Drive passenger 1 from point 3 to point 10 for a profit of 10 - 3 + 2 = 9 dollars.\n- Drive passenger 2 from point 10 to point 12 for a profit of 12 - 10 + 3 = 5 dollars.\n- Drive passenger 5 from point 13 to point 18 for a profit of 18 - 13 + 1 = 6 dollars.\nWe earn 9 + 5 + 6 = 20 dollars in total."
            }
        ],
        "elixir_template": "defmodule Solution do\n  @spec max_taxi_earnings(n :: integer, rides :: [[integer]]) :: integer\n  def max_taxi_earnings(n, rides) do\n    \n  end\nend",
        "erlang_template": "-spec max_taxi_earnings(N :: integer(), Rides :: [[integer()]]) -> integer().\nmax_taxi_earnings(N, Rides) ->\n  .",
        "scala_template": "object Solution {\n    def maxTaxiEarnings(n: Int, rides: Array[Array[Int]]): Long = {\n        \n    }\n}"
    },
    {
        "id": 2117,
        "name": "find-original-array-from-doubled-array",
        "difficulty": "Medium",
        "link": "https://leetcode.com/problems/find-original-array-from-doubled-array/",
        "task_description": "An integer array `original` is transformed into a **doubled** array `changed` by appending **twice the value** of every element in `original`, and then randomly **shuffling** the resulting array. Given an array `changed`, return `original`_ if _`changed`_ is a **doubled** array. If _`changed`_ is not a **doubled** array, return an empty array. The elements in_ `original` _may be returned in **any** order_. **Example 1:** ``` **Input:** changed = [1,3,4,2,6,8] **Output:** [1,3,4] **Explanation:** One possible original array could be [1,3,4]: - Twice the value of 1 is 1 * 2 = 2. - Twice the value of 3 is 3 * 2 = 6. - Twice the value of 4 is 4 * 2 = 8. Other original arrays could be [4,3,1] or [3,1,4]. ``` **Example 2:** ``` **Input:** changed = [6,3,0,1] **Output:** [] **Explanation:** changed is not a doubled array. ``` **Example 3:** ``` **Input:** changed = [1] **Output:** [] **Explanation:** changed is not a doubled array. ``` **Constraints:** `1 <= changed.length <= 105` `0 <= changed[i] <= 105`",
        "test_case": [
            {
                "label": "Example 1",
                "input": "changed = [1,3,4,2,6,8]",
                "output": "[1,3,4] Explanation: One possible original array could be [1,3,4]:\n- Twice the value of 1 is 1 * 2 = 2.\n- Twice the value of 3 is 3 * 2 = 6.\n- Twice the value of 4 is 4 * 2 = 8.\nOther original arrays could be [4,3,1] or [3,1,4]."
            },
            {
                "label": "Example 2",
                "input": "changed = [6,3,0,1]",
                "output": "[] Explanation: changed is not a doubled array."
            },
            {
                "label": "Example 3",
                "input": "changed = [1]",
                "output": "[] Explanation: changed is not a doubled array."
            }
        ],
        "elixir_template": "defmodule Solution do\n  @spec find_original_array(changed :: [integer]) :: [integer]\n  def find_original_array(changed) do\n    \n  end\nend",
        "erlang_template": "-spec find_original_array(Changed :: [integer()]) -> [integer()].\nfind_original_array(Changed) ->\n  .",
        "scala_template": "object Solution {\n    def findOriginalArray(changed: Array[Int]): Array[Int] = {\n        \n    }\n}"
    },
    {
        "id": 2116,
        "name": "count-number-of-pairs-with-absolute-difference-k",
        "difficulty": "Easy",
        "link": "https://leetcode.com/problems/count-number-of-pairs-with-absolute-difference-k/",
        "task_description": "Given an integer array `nums` and an integer `k`, return _the number of pairs_ `(i, j)` _where_ `i < j` _such that_ `|nums[i] - nums[j]| == k`. The value of `|x|` is defined as: `x` if `x >= 0`. `-x` if `x < 0`. **Example 1:** ``` **Input:** nums = [1,2,2,1], k = 1 **Output:** 4 **Explanation:** The pairs with an absolute difference of 1 are: - [**1**,**2**,2,1] - [**1**,2,**2**,1] - [1,**2**,2,**1**] - [1,2,**2**,**1**] ``` **Example 2:** ``` **Input:** nums = [1,3], k = 3 **Output:** 0 **Explanation:** There are no pairs with an absolute difference of 3. ``` **Example 3:** ``` **Input:** nums = [3,2,1,5,4], k = 2 **Output:** 3 Explanation: The pairs with an absolute difference of 2 are: - [**3**,2,**1**,5,4] - [**3**,2,1,**5**,4] - [3,**2**,1,5,**4**] ``` **Constraints:** `1 <= nums.length <= 200` `1 <= nums[i] <= 100` `1 <= k <= 99`",
        "test_case": [
            {
                "label": "Example 1",
                "input": "nums = [1,2,2,1], k = 1",
                "output": "4 Explanation: The pairs with an absolute difference of 1 are:\n- [ 1 , 2 ,2,1]\n- [ 1 ,2, 2 ,1]\n- [1, 2 ,2, 1 ]\n- [1,2, 2 , 1 ]"
            },
            {
                "label": "Example 2",
                "input": "nums = [1,3], k = 3",
                "output": "0 Explanation: There are no pairs with an absolute difference of 3."
            },
            {
                "label": "Example 3",
                "input": "nums = [3,2,1,5,4], k = 2",
                "output": "3 Explanation: The pairs with an absolute difference of 2 are:\n- [ 3 ,2, 1 ,5,4]\n- [ 3 ,2,1, 5 ,4]\n- [3, 2 ,1,5, 4 ]"
            }
        ],
        "elixir_template": "defmodule Solution do\n  @spec count_k_difference(nums :: [integer], k :: integer) :: integer\n  def count_k_difference(nums, k) do\n    \n  end\nend",
        "erlang_template": "-spec count_k_difference(Nums :: [integer()], K :: integer()) -> integer().\ncount_k_difference(Nums, K) ->\n  .",
        "scala_template": "object Solution {\n    def countKDifference(nums: Array[Int], k: Int): Int = {\n        \n    }\n}"
    },
    {
        "id": 2115,
        "name": "number-of-unique-good-subsequences",
        "difficulty": "Hard",
        "link": "https://leetcode.com/problems/number-of-unique-good-subsequences/",
        "task_description": "You are given a binary string `binary`. A **subsequence** of `binary` is considered **good** if it is **not empty** and has **no leading zeros** (with the exception of `\"0\"`). Find the number of **unique good subsequences** of `binary`. For example, if `binary = \"001\"`, then all the **good** subsequences are `[\"0\", \"0\", \"1\"]`, so the **unique** good subsequences are `\"0\"` and `\"1\"`. Note that subsequences `\"00\"`, `\"01\"`, and `\"001\"` are not good because they have leading zeros. Return _the number of **unique good subsequences** of _`binary`. Since the answer may be very large, return it **modulo** `109 + 7`. A **subsequence** is a sequence that can be derived from another sequence by deleting some or no elements without changing the order of the remaining elements. **Example 1:** ``` **Input:** binary = \"001\" **Output:** 2 **Explanation:** The good subsequences of binary are [\"0\", \"0\", \"1\"]. The unique good subsequences are \"0\" and \"1\". ``` **Example 2:** ``` **Input:** binary = \"11\" **Output:** 2 **Explanation:** The good subsequences of binary are [\"1\", \"1\", \"11\"]. The unique good subsequences are \"1\" and \"11\". ``` **Example 3:** ``` **Input:** binary = \"101\" **Output:** 5 **Explanation:** The good subsequences of binary are [\"1\", \"0\", \"1\", \"10\", \"11\", \"101\"]. The unique good subsequences are \"0\", \"1\", \"10\", \"11\", and \"101\". ``` **Constraints:** `1 <= binary.length <= 105` `binary` consists of only `'0'`s and `'1'`s.",
        "test_case": [
            {
                "label": "Example 1",
                "input": "binary = \"001\"",
                "output": "2 Explanation: The good subsequences of binary are [\"0\", \"0\", \"1\"].\nThe unique good subsequences are \"0\" and \"1\"."
            },
            {
                "label": "Example 2",
                "input": "binary = \"11\"",
                "output": "2 Explanation: The good subsequences of binary are [\"1\", \"1\", \"11\"].\nThe unique good subsequences are \"1\" and \"11\"."
            },
            {
                "label": "Example 3",
                "input": "binary = \"101\"",
                "output": "5 Explanation: The good subsequences of binary are [\"1\", \"0\", \"1\", \"10\", \"11\", \"101\"]. \nThe unique good subsequences are \"0\", \"1\", \"10\", \"11\", and \"101\"."
            }
        ],
        "elixir_template": "defmodule Solution do\n  @spec number_of_unique_good_subsequences(binary :: String.t) :: integer\n  def number_of_unique_good_subsequences(binary) do\n    \n  end\nend",
        "erlang_template": "-spec number_of_unique_good_subsequences(Binary :: unicode:unicode_binary()) -> integer().\nnumber_of_unique_good_subsequences(Binary) ->\n  .",
        "scala_template": "object Solution {\n    def numberOfUniqueGoodSubsequences(binary: String): Int = {\n        \n    }\n}"
    },
    {
        "id": 2114,
        "name": "minimum-number-of-work-sessions-to-finish-the-tasks",
        "difficulty": "Medium",
        "link": "https://leetcode.com/problems/minimum-number-of-work-sessions-to-finish-the-tasks/",
        "task_description": "There are `n` tasks assigned to you. The task times are represented as an integer array `tasks` of length `n`, where the `ith` task takes `tasks[i]` hours to finish. A **work session** is when you work for **at most** `sessionTime` consecutive hours and then take a break. You should finish the given tasks in a way that satisfies the following conditions: If you start a task in a work session, you must complete it in the **same** work session. You can start a new task **immediately** after finishing the previous one. You may complete the tasks in **any order**. Given `tasks` and `sessionTime`, return _the **minimum** number of **work sessions** needed to finish all the tasks following the conditions above._ The tests are generated such that `sessionTime` is **greater** than or **equal** to the **maximum** element in `tasks[i]`. **Example 1:** ``` **Input:** tasks = [1,2,3], sessionTime = 3 **Output:** 2 **Explanation:** You can finish the tasks in two work sessions. - First work session: finish the first and the second tasks in 1 + 2 = 3 hours. - Second work session: finish the third task in 3 hours. ``` **Example 2:** ``` **Input:** tasks = [3,1,3,1,1], sessionTime = 8 **Output:** 2 **Explanation:** You can finish the tasks in two work sessions. - First work session: finish all the tasks except the last one in 3 + 1 + 3 + 1 = 8 hours. - Second work session: finish the last task in 1 hour. ``` **Example 3:** ``` **Input:** tasks = [1,2,3,4,5], sessionTime = 15 **Output:** 1 **Explanation:** You can finish all the tasks in one work session. ``` **Constraints:** `n == tasks.length` `1 <= n <= 14` `1 <= tasks[i] <= 10` `max(tasks[i]) <= sessionTime <= 15`",
        "test_case": [
            {
                "label": "Example 1",
                "input": "tasks = [1,2,3], sessionTime = 3",
                "output": "2 Explanation: You can finish the tasks in two work sessions.\n- First work session: finish the first and the second tasks in 1 + 2 = 3 hours.\n- Second work session: finish the third task in 3 hours."
            },
            {
                "label": "Example 2",
                "input": "tasks = [3,1,3,1,1], sessionTime = 8",
                "output": "2 Explanation: You can finish the tasks in two work sessions.\n- First work session: finish all the tasks except the last one in 3 + 1 + 3 + 1 = 8 hours.\n- Second work session: finish the last task in 1 hour."
            },
            {
                "label": "Example 3",
                "input": "tasks = [1,2,3,4,5], sessionTime = 15",
                "output": "1 Explanation: You can finish all the tasks in one work session. Constraints: n == tasks.length 1 <= n <= 14 1 <= tasks[i] <= 10 max(tasks[i]) <= sessionTime <= 15"
            }
        ],
        "elixir_template": "defmodule Solution do\n  @spec min_sessions(tasks :: [integer], session_time :: integer) :: integer\n  def min_sessions(tasks, session_time) do\n    \n  end\nend",
        "erlang_template": "-spec min_sessions(Tasks :: [integer()], SessionTime :: integer()) -> integer().\nmin_sessions(Tasks, SessionTime) ->\n  .",
        "scala_template": "object Solution {\n    def minSessions(tasks: Array[Int], sessionTime: Int): Int = {\n        \n    }\n}"
    },
    {
        "id": 2113,
        "name": "find-the-kth-largest-integer-in-the-array",
        "difficulty": "Medium",
        "link": "https://leetcode.com/problems/find-the-kth-largest-integer-in-the-array/",
        "task_description": "You are given an array of strings `nums` and an integer `k`. Each string in `nums` represents an integer without leading zeros. Return _the string that represents the _`kth`_** largest integer** in _`nums`. **Note**: Duplicate numbers should be counted distinctly. For example, if `nums` is `[\"1\",\"2\",\"2\"]`, `\"2\"` is the first largest integer, `\"2\"` is the second-largest integer, and `\"1\"` is the third-largest integer. **Example 1:** ``` **Input:** nums = [\"3\",\"6\",\"7\",\"10\"], k = 4 **Output:** \"3\" **Explanation:** The numbers in nums sorted in non-decreasing order are [\"3\",\"6\",\"7\",\"10\"]. The 4th largest integer in nums is \"3\". ``` **Example 2:** ``` **Input:** nums = [\"2\",\"21\",\"12\",\"1\"], k = 3 **Output:** \"2\" **Explanation:** The numbers in nums sorted in non-decreasing order are [\"1\",\"2\",\"12\",\"21\"]. The 3rd largest integer in nums is \"2\". ``` **Example 3:** ``` **Input:** nums = [\"0\",\"0\"], k = 2 **Output:** \"0\" **Explanation:** The numbers in nums sorted in non-decreasing order are [\"0\",\"0\"]. The 2nd largest integer in nums is \"0\". ``` **Constraints:** `1 <= k <= nums.length <= 104` `1 <= nums[i].length <= 100` `nums[i]` consists of only digits. `nums[i]` will not have any leading zeros.",
        "test_case": [
            {
                "label": "Example 1",
                "input": "nums = [\"3\",\"6\",\"7\",\"10\"], k = 4",
                "output": "\"3\" Explanation: The numbers in nums sorted in non-decreasing order are [\"3\",\"6\",\"7\",\"10\"].\nThe 4 th largest integer in nums is \"3\"."
            },
            {
                "label": "Example 2",
                "input": "nums = [\"2\",\"21\",\"12\",\"1\"], k = 3",
                "output": "\"2\" Explanation: The numbers in nums sorted in non-decreasing order are [\"1\",\"2\",\"12\",\"21\"].\nThe 3 rd largest integer in nums is \"2\"."
            },
            {
                "label": "Example 3",
                "input": "nums = [\"0\",\"0\"], k = 2",
                "output": "\"0\" Explanation: The numbers in nums sorted in non-decreasing order are [\"0\",\"0\"].\nThe 2 nd largest integer in nums is \"0\"."
            }
        ],
        "elixir_template": "defmodule Solution do\n  @spec kth_largest_number(nums :: [String.t], k :: integer) :: String.t\n  def kth_largest_number(nums, k) do\n    \n  end\nend",
        "erlang_template": "-spec kth_largest_number(Nums :: [unicode:unicode_binary()], K :: integer()) -> unicode:unicode_binary().\nkth_largest_number(Nums, K) ->\n  .",
        "scala_template": "object Solution {\n    def kthLargestNumber(nums: Array[String], k: Int): String = {\n        \n    }\n}"
    },
    {
        "id": 2112,
        "name": "minimum-difference-between-highest-and-lowest-of-k-scores",
        "difficulty": "Easy",
        "link": "https://leetcode.com/problems/minimum-difference-between-highest-and-lowest-of-k-scores/",
        "task_description": "You are given a **0-indexed** integer array `nums`, where `nums[i]` represents the score of the `ith` student. You are also given an integer `k`. Pick the scores of any `k` students from the array so that the **difference** between the **highest** and the **lowest** of the `k` scores is **minimized**. Return _the **minimum** possible difference_. **Example 1:** ``` **Input:** nums = [90], k = 1 **Output:** 0 **Explanation:** There is one way to pick score(s) of one student: - [**90**]. The difference between the highest and lowest score is 90 - 90 = 0. The minimum possible difference is 0. ``` **Example 2:** ``` **Input:** nums = [9,4,1,7], k = 2 **Output:** 2 **Explanation:** There are six ways to pick score(s) of two students: - [**9**,**4**,1,7]. The difference between the highest and lowest score is 9 - 4 = 5. - [**9**,4,**1**,7]. The difference between the highest and lowest score is 9 - 1 = 8. - [**9**,4,1,**7**]. The difference between the highest and lowest score is 9 - 7 = 2. - [9,**4**,**1**,7]. The difference between the highest and lowest score is 4 - 1 = 3. - [9,**4**,1,**7**]. The difference between the highest and lowest score is 7 - 4 = 3. - [9,4,**1**,**7**]. The difference between the highest and lowest score is 7 - 1 = 6. The minimum possible difference is 2. ``` **Constraints:** `1 <= k <= nums.length <= 1000` `0 <= nums[i] <= 105`",
        "test_case": [
            {
                "label": "Example 1",
                "input": "nums = [90], k = 1",
                "output": "0 Explanation: There is one way to pick score(s) of one student:\n- [ 90 ]. The difference between the highest and lowest score is 90 - 90 = 0.\nThe minimum possible difference is 0."
            },
            {
                "label": "Example 2",
                "input": "nums = [9,4,1,7], k = 2",
                "output": "2 Explanation: There are six ways to pick score(s) of two students:\n- [ 9 , 4 ,1,7]. The difference between the highest and lowest score is 9 - 4 = 5.\n- [ 9 ,4, 1 ,7]. The difference between the highest and lowest score is 9 - 1 = 8.\n- [ 9 ,4,1, 7 ]. The difference between the highest and lowest score is 9 - 7 = 2.\n- [9, 4 , 1 ,7]. The difference between the highest and lowest score is 4 - 1 = 3.\n- [9, 4 ,1, 7 ]. The difference between the highest and lowest score is 7 - 4 = 3.\n- [9,4, 1 , 7 ]. The difference between the highest and lowest score is 7 - 1 = 6.\nThe minimum possible difference is 2."
            }
        ],
        "elixir_template": "defmodule Solution do\n  @spec minimum_difference(nums :: [integer], k :: integer) :: integer\n  def minimum_difference(nums, k) do\n    \n  end\nend",
        "erlang_template": "-spec minimum_difference(Nums :: [integer()], K :: integer()) -> integer().\nminimum_difference(Nums, K) ->\n  .",
        "scala_template": "object Solution {\n    def minimumDifference(nums: Array[Int], k: Int): Int = {\n        \n    }\n}"
    },
    {
        "id": 2109,
        "name": "find-array-given-subset-sums",
        "difficulty": "Hard",
        "link": "https://leetcode.com/problems/find-array-given-subset-sums/",
        "task_description": "You are given an integer `n` representing the length of an unknown array that you are trying to recover. You are also given an array `sums` containing the values of all `2n` **subset sums** of the unknown array (in no particular order). Return _the array _`ans`_ of length _`n`_ representing the unknown array. If **multiple** answers exist, return **any** of them_. An array `sub` is a **subset** of an array `arr` if `sub` can be obtained from `arr` by deleting some (possibly zero or all) elements of `arr`. The sum of the elements in `sub` is one possible **subset sum** of `arr`. The sum of an empty array is considered to be `0`. **Note:** Test cases are generated such that there will **always** be at least one correct answer. **Example 1:** ``` **Input:** n = 3, sums = [-3,-2,-1,0,0,1,2,3] **Output:** [1,2,-3] **Explanation: **[1,2,-3] is able to achieve the given subset sums: - []: sum is 0 - [1]: sum is 1 - [2]: sum is 2 - [1,2]: sum is 3 - [-3]: sum is -3 - [1,-3]: sum is -2 - [2,-3]: sum is -1 - [1,2,-3]: sum is 0 Note that any permutation of [1,2,-3] and also any permutation of [-1,-2,3] will also be accepted. ``` **Example 2:** ``` **Input:** n = 2, sums = [0,0,0,0] **Output:** [0,0] **Explanation:** The only correct answer is [0,0]. ``` **Example 3:** ``` **Input:** n = 4, sums = [0,0,5,5,4,-1,4,9,9,-1,4,3,4,8,3,8] **Output:** [0,-1,4,5] **Explanation:** [0,-1,4,5] is able to achieve the given subset sums. ``` **Constraints:** `1 <= n <= 15` `sums.length == 2n` `-104 <= sums[i] <= 104`",
        "test_case": [
            {
                "label": "Example 1",
                "input": "n = 3, sums = [-3,-2,-1,0,0,1,2,3]",
                "output": "[1,2,-3] Explanation: [1,2,-3] is able to achieve the given subset sums:\n- []: sum is 0\n- [1]: sum is 1\n- [2]: sum is 2\n- [1,2]: sum is 3\n- [-3]: sum is -3\n- [1,-3]: sum is -2\n- [2,-3]: sum is -1\n- [1,2,-3]: sum is 0\nNote that any permutation of [1,2,-3] and also any permutation of [-1,-2,3] will also be accepted."
            },
            {
                "label": "Example 2",
                "input": "n = 2, sums = [0,0,0,0]",
                "output": "[0,0] Explanation: The only correct answer is [0,0]."
            },
            {
                "label": "Example 3",
                "input": "n = 4, sums = [0,0,5,5,4,-1,4,9,9,-1,4,3,4,8,3,8]",
                "output": "[0,-1,4,5] Explanation: [0,-1,4,5] is able to achieve the given subset sums."
            }
        ],
        "elixir_template": "defmodule Solution do\n  @spec recover_array(n :: integer, sums :: [integer]) :: [integer]\n  def recover_array(n, sums) do\n    \n  end\nend",
        "erlang_template": "-spec recover_array(N :: integer(), Sums :: [integer()]) -> [integer()].\nrecover_array(N, Sums) ->\n  .",
        "scala_template": "object Solution {\n    def recoverArray(n: Int, sums: Array[Int]): Array[Int] = {\n        \n    }\n}"
    },
    {
        "id": 2108,
        "name": "minimize-the-difference-between-target-and-chosen-elements",
        "difficulty": "Medium",
        "link": "https://leetcode.com/problems/minimize-the-difference-between-target-and-chosen-elements/",
        "task_description": "You are given an `m x n` integer matrix `mat` and an integer `target`. Choose one integer from **each row** in the matrix such that the **absolute difference** between `target` and the **sum** of the chosen elements is **minimized**. Return _the **minimum absolute difference**_. The **absolute difference** between two numbers `a` and `b` is the absolute value of `a - b`. **Example 1:** ``` **Input:** mat = [[1,2,3],[4,5,6],[7,8,9]], target = 13 **Output:** 0 **Explanation:** One possible choice is to: - Choose 1 from the first row. - Choose 5 from the second row. - Choose 7 from the third row. The sum of the chosen elements is 13, which equals the target, so the absolute difference is 0. ``` **Example 2:** ``` **Input:** mat = [[1],[2],[3]], target = 100 **Output:** 94 **Explanation:** The best possible choice is to: - Choose 1 from the first row. - Choose 2 from the second row. - Choose 3 from the third row. The sum of the chosen elements is 6, and the absolute difference is 94. ``` **Example 3:** ``` **Input:** mat = [[1,2,9,8,7]], target = 6 **Output:** 1 **Explanation:** The best choice is to choose 7 from the first row. The absolute difference is 1. ``` **Constraints:** `m == mat.length` `n == mat[i].length` `1 <= m, n <= 70` `1 <= mat[i][j] <= 70` `1 <= target <= 800`",
        "test_case": [
            {
                "label": "Example 1",
                "input": "mat = [[1,2,3],[4,5,6],[7,8,9]], target = 13",
                "output": "0 Explanation: One possible choice is to:\n- Choose 1 from the first row.\n- Choose 5 from the second row.\n- Choose 7 from the third row.\nThe sum of the chosen elements is 13, which equals the target, so the absolute difference is 0."
            },
            {
                "label": "Example 2",
                "input": "mat = [[1],[2],[3]], target = 100",
                "output": "94 Explanation: The best possible choice is to:\n- Choose 1 from the first row.\n- Choose 2 from the second row.\n- Choose 3 from the third row.\nThe sum of the chosen elements is 6, and the absolute difference is 94."
            },
            {
                "label": "Example 3",
                "input": "mat = [[1,2,9,8,7]], target = 6",
                "output": "1 Explanation: The best choice is to choose 7 from the first row.\nThe absolute difference is 1. Constraints: m == mat.length n == mat[i].length 1 <= m, n <= 70 1 <= mat[i][j] <= 70 1 <= target <= 800"
            }
        ],
        "elixir_template": "defmodule Solution do\n  @spec minimize_the_difference(mat :: [[integer]], target :: integer) :: integer\n  def minimize_the_difference(mat, target) do\n    \n  end\nend",
        "erlang_template": "-spec minimize_the_difference(Mat :: [[integer()]], Target :: integer()) -> integer().\nminimize_the_difference(Mat, Target) ->\n  .",
        "scala_template": "object Solution {\n    def minimizeTheDifference(mat: Array[Array[Int]], target: Int): Int = {\n        \n    }\n}"
    },
    {
        "id": 2107,
        "name": "find-unique-binary-string",
        "difficulty": "Medium",
        "link": "https://leetcode.com/problems/find-unique-binary-string/",
        "task_description": "Given an array of strings `nums` containing `n` **unique** binary strings each of length `n`, return _a binary string of length _`n`_ that **does not appear** in _`nums`_. If there are multiple answers, you may return **any** of them_. **Example 1:** ``` **Input:** nums = [\"01\",\"10\"] **Output:** \"11\" **Explanation:** \"11\" does not appear in nums. \"00\" would also be correct. ``` **Example 2:** ``` **Input:** nums = [\"00\",\"01\"] **Output:** \"11\" **Explanation:** \"11\" does not appear in nums. \"10\" would also be correct. ``` **Example 3:** ``` **Input:** nums = [\"111\",\"011\",\"001\"] **Output:** \"101\" **Explanation:** \"101\" does not appear in nums. \"000\", \"010\", \"100\", and \"110\" would also be correct. ``` **Constraints:** `n == nums.length` `1 <= n <= 16` `nums[i].length == n` `nums[i] `is either `'0'` or `'1'`. All the strings of `nums` are **unique**.",
        "test_case": [
            {
                "label": "Example 1",
                "input": "nums = [\"01\",\"10\"]",
                "output": "\"11\" Explanation: \"11\" does not appear in nums. \"00\" would also be correct."
            },
            {
                "label": "Example 2",
                "input": "nums = [\"00\",\"01\"]",
                "output": "\"11\" Explanation: \"11\" does not appear in nums. \"10\" would also be correct."
            },
            {
                "label": "Example 3",
                "input": "nums = [\"111\",\"011\",\"001\"]",
                "output": "\"101\" Explanation: \"101\" does not appear in nums. \"000\", \"010\", \"100\", and \"110\" would also be correct. Constraints: n == nums.length 1 <= n <= 16 nums[i].length == n nums[i] is either '0' or '1' . All the strings of nums are unique ."
            }
        ],
        "elixir_template": "defmodule Solution do\n  @spec find_different_binary_string(nums :: [String.t]) :: String.t\n  def find_different_binary_string(nums) do\n    \n  end\nend",
        "erlang_template": "-spec find_different_binary_string(Nums :: [unicode:unicode_binary()]) -> unicode:unicode_binary().\nfind_different_binary_string(Nums) ->\n  .",
        "scala_template": "object Solution {\n    def findDifferentBinaryString(nums: Array[String]): String = {\n        \n    }\n}"
    },
    {
        "id": 2106,
        "name": "find-greatest-common-divisor-of-array",
        "difficulty": "Easy",
        "link": "https://leetcode.com/problems/find-greatest-common-divisor-of-array/",
        "task_description": "Given an integer array `nums`, return** **_the **greatest common divisor** of the smallest number and largest number in _`nums`. The **greatest common divisor** of two numbers is the largest positive integer that evenly divides both numbers. **Example 1:** ``` **Input:** nums = [2,5,6,9,10] **Output:** 2 **Explanation:** The smallest number in nums is 2. The largest number in nums is 10. The greatest common divisor of 2 and 10 is 2. ``` **Example 2:** ``` **Input:** nums = [7,5,6,8,3] **Output:** 1 **Explanation:** The smallest number in nums is 3. The largest number in nums is 8. The greatest common divisor of 3 and 8 is 1. ``` **Example 3:** ``` **Input:** nums = [3,3] **Output:** 3 **Explanation:** The smallest number in nums is 3. The largest number in nums is 3. The greatest common divisor of 3 and 3 is 3. ``` **Constraints:** `2 <= nums.length <= 1000` `1 <= nums[i] <= 1000`",
        "test_case": [
            {
                "label": "Example 1",
                "input": "nums = [2,5,6,9,10]",
                "output": "2 Explanation: The smallest number in nums is 2.\nThe largest number in nums is 10.\nThe greatest common divisor of 2 and 10 is 2."
            },
            {
                "label": "Example 2",
                "input": "nums = [7,5,6,8,3]",
                "output": "1 Explanation: The smallest number in nums is 3.\nThe largest number in nums is 8.\nThe greatest common divisor of 3 and 8 is 1."
            },
            {
                "label": "Example 3",
                "input": "nums = [3,3]",
                "output": "3 Explanation: The smallest number in nums is 3.\nThe largest number in nums is 3.\nThe greatest common divisor of 3 and 3 is 3."
            }
        ],
        "elixir_template": "defmodule Solution do\n  @spec find_gcd(nums :: [integer]) :: integer\n  def find_gcd(nums) do\n    \n  end\nend",
        "erlang_template": "-spec find_gcd(Nums :: [integer()]) -> integer().\nfind_gcd(Nums) ->\n  .",
        "scala_template": "object Solution {\n    def findGCD(nums: Array[Int]): Int = {\n        \n    }\n}"
    },
    {
        "id": 2105,
        "name": "the-number-of-good-subsets",
        "difficulty": "Hard",
        "link": "https://leetcode.com/problems/the-number-of-good-subsets/",
        "task_description": "You are given an integer array `nums`. We call a subset of `nums` **good** if its product can be represented as a product of one or more **distinct prime** numbers. For example, if `nums = [1, 2, 3, 4]`: `[2, 3]`, `[1, 2, 3]`, and `[1, 3]` are **good** subsets with products `6 = 2*3`, `6 = 2*3`, and `3 = 3` respectively. `[1, 4]` and `[4]` are not **good** subsets with products `4 = 2*2` and `4 = 2*2` respectively. Return _the number of different **good** subsets in _`nums`_ **modulo** _`109 + 7`. A **subset** of `nums` is any array that can be obtained by deleting some (possibly none or all) elements from `nums`. Two subsets are different if and only if the chosen indices to delete are different. **Example 1:** ``` **Input:** nums = [1,2,3,4] **Output:** 6 **Explanation:** The good subsets are: - [1,2]: product is 2, which is the product of distinct prime 2. - [1,2,3]: product is 6, which is the product of distinct primes 2 and 3. - [1,3]: product is 3, which is the product of distinct prime 3. - [2]: product is 2, which is the product of distinct prime 2. - [2,3]: product is 6, which is the product of distinct primes 2 and 3. - [3]: product is 3, which is the product of distinct prime 3. ``` **Example 2:** ``` **Input:** nums = [4,2,3,15] **Output:** 5 **Explanation:** The good subsets are: - [2]: product is 2, which is the product of distinct prime 2. - [2,3]: product is 6, which is the product of distinct primes 2 and 3. - [2,15]: product is 30, which is the product of distinct primes 2, 3, and 5. - [3]: product is 3, which is the product of distinct prime 3. - [15]: product is 15, which is the product of distinct primes 3 and 5. ``` **Constraints:** `1 <= nums.length <= 105` `1 <= nums[i] <= 30`",
        "test_case": [
            {
                "label": "Example 1",
                "input": "nums = [1,2,3,4]",
                "output": "6 Explanation: The good subsets are:\n- [1,2]: product is 2, which is the product of distinct prime 2.\n- [1,2,3]: product is 6, which is the product of distinct primes 2 and 3.\n- [1,3]: product is 3, which is the product of distinct prime 3.\n- [2]: product is 2, which is the product of distinct prime 2.\n- [2,3]: product is 6, which is the product of distinct primes 2 and 3.\n- [3]: product is 3, which is the product of distinct prime 3."
            },
            {
                "label": "Example 2",
                "input": "nums = [4,2,3,15]",
                "output": "5 Explanation: The good subsets are:\n- [2]: product is 2, which is the product of distinct prime 2.\n- [2,3]: product is 6, which is the product of distinct primes 2 and 3.\n- [2,15]: product is 30, which is the product of distinct primes 2, 3, and 5.\n- [3]: product is 3, which is the product of distinct prime 3.\n- [15]: product is 15, which is the product of distinct primes 3 and 5."
            }
        ],
        "elixir_template": "defmodule Solution do\n  @spec number_of_good_subsets(nums :: [integer]) :: integer\n  def number_of_good_subsets(nums) do\n    \n  end\nend",
        "erlang_template": "-spec number_of_good_subsets(Nums :: [integer()]) -> integer().\nnumber_of_good_subsets(Nums) ->\n  .",
        "scala_template": "object Solution {\n    def numberOfGoodSubsets(nums: Array[Int]): Int = {\n        \n    }\n}"
    },
    {
        "id": 2104,
        "name": "operations-on-tree",
        "difficulty": "Medium",
        "link": "https://leetcode.com/problems/operations-on-tree/",
        "task_description": "You are given a tree with `n` nodes numbered from `0` to `n - 1` in the form of a parent array `parent` where `parent[i]` is the parent of the `ith` node. The root of the tree is node `0`, so `parent[0] = -1` since it has no parent. You want to design a data structure that allows users to lock, unlock, and upgrade nodes in the tree. The data structure should support the following functions: **Lock:** **Locks** the given node for the given user and prevents other users from locking the same node. You may only lock a node using this function if the node is unlocked. **Unlock: Unlocks** the given node for the given user. You may only unlock a node using this function if it is currently locked by the same user. Upgrade**: Locks** the given node for the given user and **unlocks** all of its descendants **regardless** of who locked it. You may only upgrade a node if **all** 3 conditions are true: The node is unlocked, It has at least one locked descendant (by **any** user), and It does not have any locked ancestors. Implement the `LockingTree` class: `LockingTree(int[] parent)` initializes the data structure with the parent array. `lock(int num, int user)` returns `true` if it is possible for the user with id `user` to lock the node `num`, or `false` otherwise. If it is possible, the node `num` will become** locked** by the user with id `user`. `unlock(int num, int user)` returns `true` if it is possible for the user with id `user` to unlock the node `num`, or `false` otherwise. If it is possible, the node `num` will become **unlocked**. `upgrade(int num, int user)` returns `true` if it is possible for the user with id `user` to upgrade the node `num`, or `false` otherwise. If it is possible, the node `num` will be **upgraded**. **Example 1:** ``` **Input** [\"LockingTree\", \"lock\", \"unlock\", \"unlock\", \"lock\", \"upgrade\", \"lock\"] [[[-1, 0, 0, 1, 1, 2, 2]], [2, 2], [2, 3], [2, 2], [4, 5], [0, 1], [0, 1]] **Output** [null, true, false, true, true, true, false] **Explanation** LockingTree lockingTree = new LockingTree([-1, 0, 0, 1, 1, 2, 2]); lockingTree.lock(2, 2); // return true because node 2 is unlocked. // Node 2 will now be locked by user 2. lockingTree.unlock(2, 3); // return false because user 3 cannot unlock a node locked by user 2. lockingTree.unlock(2, 2); // return true because node 2 was previously locked by user 2. // Node 2 will now be unlocked. lockingTree.lock(4, 5); // return true because node 4 is unlocked. // Node 4 will now be locked by user 5. lockingTree.upgrade(0, 1); // return true because node 0 is unlocked and has at least one locked descendant (node 4). // Node 0 will now be locked by user 1 and node 4 will now be unlocked. lockingTree.lock(0, 1); // return false because node 0 is already locked. ``` **Constraints:** `n == parent.length` `2 <= n <= 2000` `0 <= parent[i] <= n - 1` for `i != 0` `parent[0] == -1` `0 <= num <= n - 1` `1 <= user <= 104` `parent` represents a valid tree. At most `2000` calls **in total** will be made to `lock`, `unlock`, and `upgrade`.",
        "test_case": [],
        "elixir_template": "defmodule LockingTree do\n  @spec init_(parent :: [integer]) :: any\n  def init_(parent) do\n    \n  end\n\n  @spec lock(num :: integer, user :: integer) :: boolean\n  def lock(num, user) do\n    \n  end\n\n  @spec unlock(num :: integer, user :: integer) :: boolean\n  def unlock(num, user) do\n    \n  end\n\n  @spec upgrade(num :: integer, user :: integer) :: boolean\n  def upgrade(num, user) do\n    \n  end\nend\n\n# Your functions will be called as such:\n# LockingTree.init_(parent)\n# param_1 = LockingTree.lock(num, user)\n# param_2 = LockingTree.unlock(num, user)\n# param_3 = LockingTree.upgrade(num, user)\n\n# LockingTree.init_ will be called before every test case, in which you can do some necessary initializations.",
        "erlang_template": "-spec locking_tree_init_(Parent :: [integer()]) -> any().\nlocking_tree_init_(Parent) ->\n  .\n\n-spec locking_tree_lock(Num :: integer(), User :: integer()) -> boolean().\nlocking_tree_lock(Num, User) ->\n  .\n\n-spec locking_tree_unlock(Num :: integer(), User :: integer()) -> boolean().\nlocking_tree_unlock(Num, User) ->\n  .\n\n-spec locking_tree_upgrade(Num :: integer(), User :: integer()) -> boolean().\nlocking_tree_upgrade(Num, User) ->\n  .\n\n\n%% Your functions will be called as such:\n%% locking_tree_init_(Parent),\n%% Param_1 = locking_tree_lock(Num, User),\n%% Param_2 = locking_tree_unlock(Num, User),\n%% Param_3 = locking_tree_upgrade(Num, User),\n\n%% locking_tree_init_ will be called before every test case, in which you can do some necessary initializations.",
        "scala_template": "class LockingTree(_parent: Array[Int]) {\n\n    def lock(num: Int, user: Int): Boolean = {\n        \n    }\n\n    def unlock(num: Int, user: Int): Boolean = {\n        \n    }\n\n    def upgrade(num: Int, user: Int): Boolean = {\n        \n    }\n\n}\n\n/**\n * Your LockingTree object will be instantiated and called as such:\n * val obj = new LockingTree(parent)\n * val param_1 = obj.lock(num,user)\n * val param_2 = obj.unlock(num,user)\n * val param_3 = obj.upgrade(num,user)\n */"
    },
    {
        "id": 2103,
        "name": "find-all-groups-of-farmland",
        "difficulty": "Medium",
        "link": "https://leetcode.com/problems/find-all-groups-of-farmland/",
        "task_description": "You are given a **0-indexed** `m x n` binary matrix `land` where a `0` represents a hectare of forested land and a `1` represents a hectare of farmland. To keep the land organized, there are designated rectangular areas of hectares that consist **entirely** of farmland. These rectangular areas are called **groups**. No two groups are adjacent, meaning farmland in one group is **not** four-directionally adjacent to another farmland in a different group. `land` can be represented by a coordinate system where the top left corner of `land` is `(0, 0)` and the bottom right corner of `land` is `(m-1, n-1)`. Find the coordinates of the top left and bottom right corner of each **group** of farmland. A **group** of farmland with a top left corner at `(r1, c1)` and a bottom right corner at `(r2, c2)` is represented by the 4-length array `[r1, c1, r2, c2].` Return _a 2D array containing the 4-length arrays described above for each **group** of farmland in _`land`_. If there are no groups of farmland, return an empty array. You may return the answer in **any order**_. **Example 1:** ``` **Input:** land = [[1,0,0],[0,1,1],[0,1,1]] **Output:** [[0,0,0,0],[1,1,2,2]] **Explanation:** The first group has a top left corner at land[0][0] and a bottom right corner at land[0][0]. The second group has a top left corner at land[1][1] and a bottom right corner at land[2][2]. ``` **Example 2:** ``` **Input:** land = [[1,1],[1,1]] **Output:** [[0,0,1,1]] **Explanation:** The first group has a top left corner at land[0][0] and a bottom right corner at land[1][1]. ``` **Example 3:** ``` **Input:** land = [[0]] **Output:** [] **Explanation:** There are no groups of farmland. ``` **Constraints:** `m == land.length` `n == land[i].length` `1 <= m, n <= 300` `land` consists of only `0`'s and `1`'s. Groups of farmland are **rectangular** in shape.",
        "test_case": [
            {
                "label": "Example 1",
                "input": "land = [[1,0,0],[0,1,1],[0,1,1]]",
                "output": "[[0,0,0,0],[1,1,2,2]] Explanation: The first group has a top left corner at land[0][0] and a bottom right corner at land[0][0].\nThe second group has a top left corner at land[1][1] and a bottom right corner at land[2][2]."
            },
            {
                "label": "Example 2",
                "input": "land = [[1,1],[1,1]]",
                "output": "[[0,0,1,1]] Explanation: The first group has a top left corner at land[0][0] and a bottom right corner at land[1][1]."
            },
            {
                "label": "Example 3",
                "input": "land = [[0]]",
                "output": "[] Explanation: There are no groups of farmland. Constraints: m == land.length n == land[i].length 1 <= m, n <= 300 land consists of only 0 's and 1 's. Groups of farmland are rectangular in shape."
            }
        ],
        "elixir_template": "defmodule Solution do\n  @spec find_farmland(land :: [[integer]]) :: [[integer]]\n  def find_farmland(land) do\n    \n  end\nend",
        "erlang_template": "-spec find_farmland(Land :: [[integer()]]) -> [[integer()]].\nfind_farmland(Land) ->\n  .",
        "scala_template": "object Solution {\n    def findFarmland(land: Array[Array[Int]]): Array[Array[Int]] = {\n        \n    }\n}"
    },
    {
        "id": 2102,
        "name": "find-the-middle-index-in-array",
        "difficulty": "Easy",
        "link": "https://leetcode.com/problems/find-the-middle-index-in-array/",
        "task_description": "Given a **0-indexed** integer array `nums`, find the **leftmost** `middleIndex` (i.e., the smallest amongst all the possible ones). A `middleIndex` is an index where `nums[0] + nums[1] + ... + nums[middleIndex-1] == nums[middleIndex+1] + nums[middleIndex+2] + ... + nums[nums.length-1]`. If `middleIndex == 0`, the left side sum is considered to be `0`. Similarly, if `middleIndex == nums.length - 1`, the right side sum is considered to be `0`. Return _the **leftmost** _`middleIndex`_ that satisfies the condition, or _`-1`_ if there is no such index_. **Example 1:** ``` **Input:** nums = [2,3,-1,8,4] **Output:** 3 **Explanation:** The sum of the numbers before index 3 is: 2 + 3 + -1 = 4 The sum of the numbers after index 3 is: 4 = 4 ``` **Example 2:** ``` **Input:** nums = [1,-1,4] **Output:** 2 **Explanation:** The sum of the numbers before index 2 is: 1 + -1 = 0 The sum of the numbers after index 2 is: 0 ``` **Example 3:** ``` **Input:** nums = [2,5] **Output:** -1 **Explanation:** There is no valid middleIndex. ``` **Constraints:** `1 <= nums.length <= 100` `-1000 <= nums[i] <= 1000` **Note:** This question is the same as 724: https://leetcode.com/problems/find-pivot-index/",
        "test_case": [
            {
                "label": "Example 1",
                "input": "nums = [2,3,-1, 8 ,4]",
                "output": "3 Explanation: The sum of the numbers before index 3 is: 2 + 3 + -1 = 4\nThe sum of the numbers after index 3 is: 4 = 4"
            },
            {
                "label": "Example 2",
                "input": "nums = [1,-1, 4 ]",
                "output": "2 Explanation: The sum of the numbers before index 2 is: 1 + -1 = 0\nThe sum of the numbers after index 2 is: 0"
            },
            {
                "label": "Example 3",
                "input": "nums = [2,5]",
                "output": "-1 Explanation: There is no valid middleIndex."
            }
        ],
        "elixir_template": "defmodule Solution do\n  @spec find_middle_index(nums :: [integer]) :: integer\n  def find_middle_index(nums) do\n    \n  end\nend",
        "erlang_template": "-spec find_middle_index(Nums :: [integer()]) -> integer().\nfind_middle_index(Nums) ->\n  .",
        "scala_template": "object Solution {\n    def findMiddleIndex(nums: Array[Int]): Int = {\n        \n    }\n}"
    },
    {
        "id": 2101,
        "name": "last-day-where-you-can-still-cross",
        "difficulty": "Hard",
        "link": "https://leetcode.com/problems/last-day-where-you-can-still-cross/",
        "task_description": "There is a **1-based** binary matrix where `0` represents land and `1` represents water. You are given integers `row` and `col` representing the number of rows and columns in the matrix, respectively. Initially on day `0`, the **entire** matrix is **land**. However, each day a new cell becomes flooded with **water**. You are given a **1-based** 2D array `cells`, where `cells[i] = [ri, ci]` represents that on the `ith` day, the cell on the `rith` row and `cith` column (**1-based** coordinates) will be covered with **water** (i.e., changed to `1`). You want to find the **last** day that it is possible to walk from the **top** to the **bottom** by only walking on land cells. You can start from **any** cell in the top row and end at **any** cell in the bottom row. You can only travel in the** four** cardinal directions (left, right, up, and down). Return _the **last** day where it is possible to walk from the **top** to the **bottom** by only walking on land cells_. **Example 1:** ``` **Input:** row = 2, col = 2, cells = [[1,1],[2,1],[1,2],[2,2]] **Output:** 2 **Explanation:** The above image depicts how the matrix changes each day starting from day 0. The last day where it is possible to cross from top to bottom is on day 2. ``` **Example 2:** ``` **Input:** row = 2, col = 2, cells = [[1,1],[1,2],[2,1],[2,2]] **Output:** 1 **Explanation:** The above image depicts how the matrix changes each day starting from day 0. The last day where it is possible to cross from top to bottom is on day 1. ``` **Example 3:** ``` **Input:** row = 3, col = 3, cells = [[1,2],[2,1],[3,3],[2,2],[1,1],[1,3],[2,3],[3,2],[3,1]] **Output:** 3 **Explanation:** The above image depicts how the matrix changes each day starting from day 0. The last day where it is possible to cross from top to bottom is on day 3. ``` **Constraints:** `2 <= row, col <= 2 * 104` `4 <= row * col <= 2 * 104` `cells.length == row * col` `1 <= ri <= row` `1 <= ci <= col` All the values of `cells` are **unique**.",
        "test_case": [
            {
                "label": "Example 1",
                "input": "row = 2, col = 2, cells = [[1,1],[2,1],[1,2],[2,2]]",
                "output": "2 Explanation: The above image depicts how the matrix changes each day starting from day 0.\nThe last day where it is possible to cross from top to bottom is on day 2."
            },
            {
                "label": "Example 2",
                "input": "row = 2, col = 2, cells = [[1,1],[1,2],[2,1],[2,2]]",
                "output": "1 Explanation: The above image depicts how the matrix changes each day starting from day 0.\nThe last day where it is possible to cross from top to bottom is on day 1."
            },
            {
                "label": "Example 3",
                "input": "row = 3, col = 3, cells = [[1,2],[2,1],[3,3],[2,2],[1,1],[1,3],[2,3],[3,2],[3,1]]",
                "output": "3 Explanation: The above image depicts how the matrix changes each day starting from day 0.\nThe last day where it is possible to cross from top to bottom is on day 3."
            }
        ],
        "elixir_template": "defmodule Solution do\n  @spec latest_day_to_cross(row :: integer, col :: integer, cells :: [[integer]]) :: integer\n  def latest_day_to_cross(row, col, cells) do\n    \n  end\nend",
        "erlang_template": "-spec latest_day_to_cross(Row :: integer(), Col :: integer(), Cells :: [[integer()]]) -> integer().\nlatest_day_to_cross(Row, Col, Cells) ->\n  .",
        "scala_template": "object Solution {\n    def latestDayToCross(row: Int, col: Int, cells: Array[Array[Int]]): Int = {\n        \n    }\n}"
    },
    {
        "id": 2100,
        "name": "minimum-non-zero-product-of-the-array-elements",
        "difficulty": "Medium",
        "link": "https://leetcode.com/problems/minimum-non-zero-product-of-the-array-elements/",
        "task_description": "You are given a positive integer `p`. Consider an array `nums` (**1-indexed**) that consists of the integers in the **inclusive** range `[1, 2p - 1]` in their binary representations. You are allowed to do the following operation **any** number of times: Choose two elements `x` and `y` from `nums`. Choose a bit in `x` and swap it with its corresponding bit in `y`. Corresponding bit refers to the bit that is in the **same position** in the other integer. For example, if `x = 1101` and `y = 0011`, after swapping the `2nd` bit from the right, we have `x = 1111` and `y = 0001`. Find the **minimum non-zero** product of `nums` after performing the above operation **any** number of times. Return _this product__ **modulo** _`109 + 7`. **Note:** The answer should be the minimum product **before** the modulo operation is done. **Example 1:** ``` **Input:** p = 1 **Output:** 1 **Explanation:** nums = [1]. There is only one element, so the product equals that element. ``` **Example 2:** ``` **Input:** p = 2 **Output:** 6 **Explanation:** nums = [01, 10, 11]. Any swap would either make the product 0 or stay the same. Thus, the array product of 1 * 2 * 3 = 6 is already minimized. ``` **Example 3:** ``` **Input:** p = 3 **Output:** 1512 **Explanation:** nums = [001, 010, 011, 100, 101, 110, 111] - In the first operation we can swap the leftmost bit of the second and fifth elements. - The resulting array is [001, 110, 011, 100, 001, 110, 111]. - In the second operation we can swap the middle bit of the third and fourth elements. - The resulting array is [001, 110, 001, 110, 001, 110, 111]. The array product is 1 * 6 * 1 * 6 * 1 * 6 * 7 = 1512, which is the minimum possible product. ``` **Constraints:** `1 <= p <= 60`",
        "test_case": [
            {
                "label": "Example 1",
                "input": "p = 1",
                "output": "1 Explanation: nums = [1].\nThere is only one element, so the product equals that element."
            },
            {
                "label": "Example 2",
                "input": "p = 2",
                "output": "6 Explanation: nums = [01, 10, 11].\nAny swap would either make the product 0 or stay the same.\nThus, the array product of 1 * 2 * 3 = 6 is already minimized."
            },
            {
                "label": "Example 3",
                "input": "p = 3",
                "output": "1512 Explanation: nums = [001, 010, 011, 100, 101, 110, 111]\n- In the first operation we can swap the leftmost bit of the second and fifth elements.\n    - The resulting array is [001, 1 10, 011, 100, 0 01, 110, 111].\n- In the second operation we can swap the middle bit of the third and fourth elements.\n    - The resulting array is [001, 110, 0 0 1, 1 1 0, 001, 110, 111].\nThe array product is 1 * 6 * 1 * 6 * 1 * 6 * 7 = 1512, which is the minimum possible product."
            }
        ],
        "elixir_template": "defmodule Solution do\n  @spec min_non_zero_product(p :: integer) :: integer\n  def min_non_zero_product(p) do\n    \n  end\nend",
        "erlang_template": "-spec min_non_zero_product(P :: integer()) -> integer().\nmin_non_zero_product(P) ->\n  .",
        "scala_template": "object Solution {\n    def minNonZeroProduct(p: Int): Int = {\n        \n    }\n}"
    },
    {
        "id": 2099,
        "name": "number-of-strings-that-appear-as-substrings-in-word",
        "difficulty": "Easy",
        "link": "https://leetcode.com/problems/number-of-strings-that-appear-as-substrings-in-word/",
        "task_description": "Given an array of strings `patterns` and a string `word`, return _the **number** of strings in _`patterns`_ that exist as a **substring** in _`word`. A **substring** is a contiguous sequence of characters within a string. **Example 1:** ``` **Input:** patterns = [\"a\",\"abc\",\"bc\",\"d\"], word = \"abc\" **Output:** 3 **Explanation:** - \"a\" appears as a substring in \"abc\". - \"abc\" appears as a substring in \"abc\". - \"bc\" appears as a substring in \"abc\". - \"d\" does not appear as a substring in \"abc\". 3 of the strings in patterns appear as a substring in word. ``` **Example 2:** ``` **Input:** patterns = [\"a\",\"b\",\"c\"], word = \"aaaaabbbbb\" **Output:** 2 **Explanation:** - \"a\" appears as a substring in \"aaaaabbbbb\". - \"b\" appears as a substring in \"aaaaabbbbb\". - \"c\" does not appear as a substring in \"aaaaabbbbb\". 2 of the strings in patterns appear as a substring in word. ``` **Example 3:** ``` **Input:** patterns = [\"a\",\"a\",\"a\"], word = \"ab\" **Output:** 3 **Explanation:** Each of the patterns appears as a substring in word \"ab\". ``` **Constraints:** `1 <= patterns.length <= 100` `1 <= patterns[i].length <= 100` `1 <= word.length <= 100` `patterns[i]` and `word` consist of lowercase English letters.",
        "test_case": [
            {
                "label": "Example 1",
                "input": "patterns = [\"a\",\"abc\",\"bc\",\"d\"], word = \"abc\"",
                "output": "3 Explanation: - \"a\" appears as a substring in \" a bc\".\n- \"abc\" appears as a substring in \" abc \".\n- \"bc\" appears as a substring in \"a bc \".\n- \"d\" does not appear as a substring in \"abc\".\n3 of the strings in patterns appear as a substring in word."
            },
            {
                "label": "Example 2",
                "input": "patterns = [\"a\",\"b\",\"c\"], word = \"aaaaabbbbb\"",
                "output": "2 Explanation: - \"a\" appears as a substring in \"a a aaabbbbb\".\n- \"b\" appears as a substring in \"aaaaabbbb b \".\n- \"c\" does not appear as a substring in \"aaaaabbbbb\".\n2 of the strings in patterns appear as a substring in word."
            },
            {
                "label": "Example 3",
                "input": "patterns = [\"a\",\"a\",\"a\"], word = \"ab\"",
                "output": "3 Explanation: Each of the patterns appears as a substring in word \" a b\"."
            }
        ],
        "elixir_template": "defmodule Solution do\n  @spec num_of_strings(patterns :: [String.t], word :: String.t) :: integer\n  def num_of_strings(patterns, word) do\n    \n  end\nend",
        "erlang_template": "-spec num_of_strings(Patterns :: [unicode:unicode_binary()], Word :: unicode:unicode_binary()) -> integer().\nnum_of_strings(Patterns, Word) ->\n  .",
        "scala_template": "object Solution {\n    def numOfStrings(patterns: Array[String], word: String): Int = {\n        \n    }\n}"
    },
    {
        "id": 2096,
        "name": "find-the-longest-valid-obstacle-course-at-each-position",
        "difficulty": "Hard",
        "link": "https://leetcode.com/problems/find-the-longest-valid-obstacle-course-at-each-position/",
        "task_description": "You want to build some obstacle courses. You are given a **0-indexed** integer array `obstacles` of length `n`, where `obstacles[i]` describes the height of the `ith` obstacle. For every index `i` between `0` and `n - 1` (**inclusive**), find the length of the **longest obstacle course** in `obstacles` such that: You choose any number of obstacles between `0` and `i` **inclusive**. You must include the `ith` obstacle in the course. You must put the chosen obstacles in the **same order** as they appear in `obstacles`. Every obstacle (except the first) is **taller** than or the **same height** as the obstacle immediately before it. Return _an array_ `ans` _of length_ `n`, _where_ `ans[i]` _is the length of the **longest obstacle course** for index_ `i`_ as described above_. **Example 1:** ``` **Input:** obstacles = [1,2,3,2] **Output:** [1,2,3,3] **Explanation:** The longest valid obstacle course at each position is: - i = 0: [1], [1] has length 1. - i = 1: [1,2], [1,2] has length 2. - i = 2: [1,2,3], [1,2,3] has length 3. - i = 3: [1,2,3,2], [1,2,2] has length 3. ``` **Example 2:** ``` **Input:** obstacles = [2,2,1] **Output:** [1,2,1] **Explanation: **The longest valid obstacle course at each position is: - i = 0: [2], [2] has length 1. - i = 1: [2,2], [2,2] has length 2. - i = 2: [2,2,1], [1] has length 1. ``` **Example 3:** ``` **Input:** obstacles = [3,1,5,6,4,2] **Output:** [1,1,2,3,2,2] **Explanation:** The longest valid obstacle course at each position is: - i = 0: [3], [3] has length 1. - i = 1: [3,1], [1] has length 1. - i = 2: [3,1,5], [3,5] has length 2. [1,5] is also valid. - i = 3: [3,1,5,6], [3,5,6] has length 3. [1,5,6] is also valid. - i = 4: [3,1,5,6,4], [3,4] has length 2. [1,4] is also valid. - i = 5: [3,1,5,6,4,2], [1,2] has length 2. ``` **Constraints:** `n == obstacles.length` `1 <= n <= 105` `1 <= obstacles[i] <= 107`",
        "test_case": [
            {
                "label": "Example 1",
                "input": "obstacles = [1,2,3,2]",
                "output": "[1,2,3,3] Explanation: The longest valid obstacle course at each position is:\n- i = 0: [ 1 ], [1] has length 1.\n- i = 1: [ 1 , 2 ], [1,2] has length 2.\n- i = 2: [ 1 , 2 , 3 ], [1,2,3] has length 3.\n- i = 3: [ 1 , 2 ,3, 2 ], [1,2,2] has length 3."
            },
            {
                "label": "Example 2",
                "input": "obstacles = [2,2,1]",
                "output": "[1,2,1] Explanation: The longest valid obstacle course at each position is:\n- i = 0: [ 2 ], [2] has length 1.\n- i = 1: [ 2 , 2 ], [2,2] has length 2.\n- i = 2: [2,2, 1 ], [1] has length 1."
            },
            {
                "label": "Example 3",
                "input": "obstacles = [3,1,5,6,4,2]",
                "output": "[1,1,2,3,2,2] Explanation: The longest valid obstacle course at each position is:\n- i = 0: [ 3 ], [3] has length 1.\n- i = 1: [3, 1 ], [1] has length 1.\n- i = 2: [ 3 ,1, 5 ], [3,5] has length 2. [1,5] is also valid.\n- i = 3: [ 3 ,1, 5 , 6 ], [3,5,6] has length 3. [1,5,6] is also valid.\n- i = 4: [ 3 ,1,5,6, 4 ], [3,4] has length 2. [1,4] is also valid.\n- i = 5: [3, 1 ,5,6,4, 2 ], [1,2] has length 2. Constraints: n == obstacles.length 1 <= n <= 10 5 1 <= obstacles[i] <= 10 7"
            }
        ],
        "elixir_template": "defmodule Solution do\n  @spec longest_obstacle_course_at_each_position(obstacles :: [integer]) :: [integer]\n  def longest_obstacle_course_at_each_position(obstacles) do\n    \n  end\nend",
        "erlang_template": "-spec longest_obstacle_course_at_each_position(Obstacles :: [integer()]) -> [integer()].\nlongest_obstacle_course_at_each_position(Obstacles) ->\n  .",
        "scala_template": "object Solution {\n    def longestObstacleCourseAtEachPosition(obstacles: Array[Int]): Array[Int] = {\n        \n    }\n}"
    },
    {
        "id": 2095,
        "name": "minimum-number-of-swaps-to-make-the-string-balanced",
        "difficulty": "Medium",
        "link": "https://leetcode.com/problems/minimum-number-of-swaps-to-make-the-string-balanced/",
        "task_description": "You are given a **0-indexed** string `s` of **even** length `n`. The string consists of **exactly** `n / 2` opening brackets `'['` and `n / 2` closing brackets `']'`. A string is called **balanced** if and only if: It is the empty string, or It can be written as `AB`, where both `A` and `B` are **balanced** strings, or It can be written as `[C]`, where `C` is a **balanced** string. You may swap the brackets at **any** two indices **any** number of times. Return _the **minimum** number of swaps to make _`s` _**balanced**_. **Example 1:** ``` **Input:** s = \"][][\" **Output:** 1 **Explanation:** You can make the string balanced by swapping index 0 with index 3. The resulting string is \"[[]]\". ``` **Example 2:** ``` **Input:** s = \"]]][[[\" **Output:** 2 **Explanation:** You can do the following to make the string balanced: - Swap index 0 with index 4. s = \"[]][][\". - Swap index 1 with index 5. s = \"[[][]]\". The resulting string is \"[[][]]\". ``` **Example 3:** ``` **Input:** s = \"[]\" **Output:** 0 **Explanation:** The string is already balanced. ``` **Constraints:** `n == s.length` `2 <= n <= 106` `n` is even. `s[i]` is either `'[' `or `']'`. The number of opening brackets `'['` equals `n / 2`, and the number of closing brackets `']'` equals `n / 2`.",
        "test_case": [
            {
                "label": "Example 1",
                "input": "s = \"][][\"",
                "output": "1 Explanation: You can make the string balanced by swapping index 0 with index 3.\nThe resulting string is \"[[]]\"."
            },
            {
                "label": "Example 2",
                "input": "s = \"]]][[[\"",
                "output": "2 Explanation: You can do the following to make the string balanced:\n- Swap index 0 with index 4. s = \"[]][][\".\n- Swap index 1 with index 5. s = \"[[][]]\".\nThe resulting string is \"[[][]]\"."
            },
            {
                "label": "Example 3",
                "input": "s = \"[]\"",
                "output": "0 Explanation: The string is already balanced. Constraints: n == s.length 2 <= n <= 10 6 n is even. s[i] is either '[' or ']' . The number of opening brackets '[' equals n / 2 , and the number of closing brackets ']' equals n / 2 ."
            }
        ],
        "elixir_template": "defmodule Solution do\n  @spec min_swaps(s :: String.t) :: integer\n  def min_swaps(s) do\n    \n  end\nend",
        "erlang_template": "-spec min_swaps(S :: unicode:unicode_binary()) -> integer().\nmin_swaps(S) ->\n  .",
        "scala_template": "object Solution {\n    def minSwaps(s: String): Int = {\n        \n    }\n}"
    },
    {
        "id": 2094,
        "name": "remove-stones-to-minimize-the-total",
        "difficulty": "Medium",
        "link": "https://leetcode.com/problems/remove-stones-to-minimize-the-total/",
        "task_description": "You are given a **0-indexed** integer array `piles`, where `piles[i]` represents the number of stones in the `ith` pile, and an integer `k`. You should apply the following operation **exactly** `k` times: Choose any `piles[i]` and **remove** `floor(piles[i] / 2)` stones from it. **Notice** that you can apply the operation on the **same** pile more than once. Return _the **minimum** possible total number of stones remaining after applying the _`k`_ operations_. `floor(x)` is the greatest integer that is **smaller** than or **equal** to `x` (i.e., rounds `x` down). **Example 1:** ``` **Input:** piles = [5,4,9], k = 2 **Output:** 12 **Explanation:** Steps of a possible scenario are: - Apply the operation on pile 2. The resulting piles are [5,4,5]. - Apply the operation on pile 0. The resulting piles are [3,4,5]. The total number of stones in [3,4,5] is 12. ``` **Example 2:** ``` **Input:** piles = [4,3,6,7], k = 3 **Output:** 12 **Explanation:** Steps of a possible scenario are: - Apply the operation on pile 2. The resulting piles are [4,3,3,7]. - Apply the operation on pile 3. The resulting piles are [4,3,3,4]. - Apply the operation on pile 0. The resulting piles are [2,3,3,4]. The total number of stones in [2,3,3,4] is 12. ``` **Constraints:** `1 <= piles.length <= 105` `1 <= piles[i] <= 104` `1 <= k <= 105`",
        "test_case": [
            {
                "label": "Example 1",
                "input": "piles = [5,4,9], k = 2",
                "output": "12 Explanation: Steps of a possible scenario are:\n- Apply the operation on pile 2. The resulting piles are [5,4, 5 ].\n- Apply the operation on pile 0. The resulting piles are [ 3 ,4,5].\nThe total number of stones in [3,4,5] is 12."
            },
            {
                "label": "Example 2",
                "input": "piles = [4,3,6,7], k = 3",
                "output": "12 Explanation: Steps of a possible scenario are:\n- Apply the operation on pile 2. The resulting piles are [4,3, 3 ,7].\n- Apply the operation on pile 3. The resulting piles are [4,3,3, 4 ].\n- Apply the operation on pile 0. The resulting piles are [ 2 ,3,3,4].\nThe total number of stones in [2,3,3,4] is 12."
            }
        ],
        "elixir_template": "defmodule Solution do\n  @spec min_stone_sum(piles :: [integer], k :: integer) :: integer\n  def min_stone_sum(piles, k) do\n    \n  end\nend",
        "erlang_template": "-spec min_stone_sum(Piles :: [integer()], K :: integer()) -> integer().\nmin_stone_sum(Piles, K) ->\n  .",
        "scala_template": "object Solution {\n    def minStoneSum(piles: Array[Int], k: Int): Int = {\n        \n    }\n}"
    },
    {
        "id": 2093,
        "name": "check-if-string-is-a-prefix-of-array",
        "difficulty": "Easy",
        "link": "https://leetcode.com/problems/check-if-string-is-a-prefix-of-array/",
        "task_description": "Given a string `s` and an array of strings `words`, determine whether `s` is a **prefix string** of `words`. A string `s` is a **prefix string** of `words` if `s` can be made by concatenating the first `k` strings in `words` for some **positive** `k` no larger than `words.length`. Return `true`_ if _`s`_ is a **prefix string** of _`words`_, or _`false`_ otherwise_. **Example 1:** ``` **Input:** s = \"iloveleetcode\", words = [\"i\",\"love\",\"leetcode\",\"apples\"] **Output:** true **Explanation:** s can be made by concatenating \"i\", \"love\", and \"leetcode\" together. ``` **Example 2:** ``` **Input:** s = \"iloveleetcode\", words = [\"apples\",\"i\",\"love\",\"leetcode\"] **Output:** false **Explanation:** It is impossible to make s using a prefix of arr. ``` **Constraints:** `1 <= words.length <= 100` `1 <= words[i].length <= 20` `1 <= s.length <= 1000` `words[i]` and `s` consist of only lowercase English letters.",
        "test_case": [
            {
                "label": "Example 1",
                "input": "s = \"iloveleetcode\", words = [\"i\",\"love\",\"leetcode\",\"apples\"]",
                "output": "true Explanation: s can be made by concatenating \"i\", \"love\", and \"leetcode\" together."
            },
            {
                "label": "Example 2",
                "input": "s = \"iloveleetcode\", words = [\"apples\",\"i\",\"love\",\"leetcode\"]",
                "output": "false Explanation: It is impossible to make s using a prefix of arr."
            }
        ],
        "elixir_template": "defmodule Solution do\n  @spec is_prefix_string(s :: String.t, words :: [String.t]) :: boolean\n  def is_prefix_string(s, words) do\n    \n  end\nend",
        "erlang_template": "-spec is_prefix_string(S :: unicode:unicode_binary(), Words :: [unicode:unicode_binary()]) -> boolean().\nis_prefix_string(S, Words) ->\n  .",
        "scala_template": "object Solution {\n    def isPrefixString(s: String, words: Array[String]): Boolean = {\n        \n    }\n}"
    },
    {
        "id": 2091,
        "name": "number-of-ways-to-separate-numbers",
        "difficulty": "Hard",
        "link": "https://leetcode.com/problems/number-of-ways-to-separate-numbers/",
        "task_description": "You wrote down many **positive** integers in a string called `num`. However, you realized that you forgot to add commas to seperate the different numbers. You remember that the list of integers was **non-decreasing** and that **no** integer had leading zeros. Return _the **number of possible lists of integers** that you could have written down to get the string _`num`. Since the answer may be large, return it **modulo** `109 + 7`. **Example 1:** ``` **Input:** num = \"327\" **Output:** 2 **Explanation:** You could have written down the numbers: 3, 27 327 ``` **Example 2:** ``` **Input:** num = \"094\" **Output:** 0 **Explanation:** No numbers can have leading zeros and all numbers must be positive. ``` **Example 3:** ``` **Input:** num = \"0\" **Output:** 0 **Explanation:** No numbers can have leading zeros and all numbers must be positive. ``` **Constraints:** `1 <= num.length <= 3500` `num` consists of digits `'0'` through `'9'`.",
        "test_case": [
            {
                "label": "Example 1",
                "input": "num = \"327\"",
                "output": "2 Explanation: You could have written down the numbers:\n3, 27\n327"
            },
            {
                "label": "Example 2",
                "input": "num = \"094\"",
                "output": "0 Explanation: No numbers can have leading zeros and all numbers must be positive."
            },
            {
                "label": "Example 3",
                "input": "num = \"0\"",
                "output": "0 Explanation: No numbers can have leading zeros and all numbers must be positive."
            }
        ],
        "elixir_template": "defmodule Solution do\n  @spec number_of_combinations(num :: String.t) :: integer\n  def number_of_combinations(num) do\n    \n  end\nend",
        "erlang_template": "-spec number_of_combinations(Num :: unicode:unicode_binary()) -> integer().\nnumber_of_combinations(Num) ->\n  .",
        "scala_template": "object Solution {\n    def numberOfCombinations(num: String): Int = {\n        \n    }\n}"
    },
    {
        "id": 2090,
        "name": "number-of-ways-to-arrive-at-destination",
        "difficulty": "Medium",
        "link": "https://leetcode.com/problems/number-of-ways-to-arrive-at-destination/",
        "task_description": "You are in a city that consists of `n` intersections numbered from `0` to `n - 1` with **bi-directional** roads between some intersections. The inputs are generated such that you can reach any intersection from any other intersection and that there is at most one road between any two intersections. You are given an integer `n` and a 2D integer array `roads` where `roads[i] = [ui, vi, timei]` means that there is a road between intersections `ui` and `vi` that takes `timei` minutes to travel. You want to know in how many ways you can travel from intersection `0` to intersection `n - 1` in the **shortest amount of time**. Return _the **number of ways** you can arrive at your destination in the **shortest amount of time**_. Since the answer may be large, return it **modulo** `109 + 7`. **Example 1:** ``` **Input:** n = 7, roads = [[0,6,7],[0,1,2],[1,2,3],[1,3,3],[6,3,3],[3,5,1],[6,5,1],[2,5,1],[0,4,5],[4,6,2]] **Output:** 4 **Explanation:** The shortest amount of time it takes to go from intersection 0 to intersection 6 is 7 minutes. The four ways to get there in 7 minutes are: - 0 \u279d 6 - 0 \u279d 4 \u279d 6 - 0 \u279d 1 \u279d 2 \u279d 5 \u279d 6 - 0 \u279d 1 \u279d 3 \u279d 5 \u279d 6 ``` **Example 2:** ``` **Input:** n = 2, roads = [[1,0,10]] **Output:** 1 **Explanation:** There is only one way to go from intersection 0 to intersection 1, and it takes 10 minutes. ``` **Constraints:** `1 <= n <= 200` `n - 1 <= roads.length <= n * (n - 1) / 2` `roads[i].length == 3` `0 <= ui, vi <= n - 1` `1 <= timei <= 109` `ui != vi` There is at most one road connecting any two intersections. You can reach any intersection from any other intersection.",
        "test_case": [
            {
                "label": "Example 1",
                "input": "n = 7, roads = [[0,6,7],[0,1,2],[1,2,3],[1,3,3],[6,3,3],[3,5,1],[6,5,1],[2,5,1],[0,4,5],[4,6,2]]",
                "output": "4 Explanation: The shortest amount of time it takes to go from intersection 0 to intersection 6 is 7 minutes.\nThe four ways to get there in 7 minutes are:\n- 0 \u279d 6\n- 0 \u279d 4 \u279d 6\n- 0 \u279d 1 \u279d 2 \u279d 5 \u279d 6\n- 0 \u279d 1 \u279d 3 \u279d 5 \u279d 6"
            },
            {
                "label": "Example 2",
                "input": "n = 2, roads = [[1,0,10]]",
                "output": "1 Explanation: There is only one way to go from intersection 0 to intersection 1, and it takes 10 minutes."
            }
        ],
        "elixir_template": "defmodule Solution do\n  @spec count_paths(n :: integer, roads :: [[integer]]) :: integer\n  def count_paths(n, roads) do\n    \n  end\nend",
        "erlang_template": "-spec count_paths(N :: integer(), Roads :: [[integer()]]) -> integer().\ncount_paths(N, Roads) ->\n  .",
        "scala_template": "object Solution {\n    def countPaths(n: Int, roads: Array[Array[Int]]): Int = {\n        \n    }\n}"
    },
    {
        "id": 2089,
        "name": "maximum-matrix-sum",
        "difficulty": "Medium",
        "link": "https://leetcode.com/problems/maximum-matrix-sum/",
        "task_description": "You are given an `n x n` integer `matrix`. You can do the following operation **any** number of times: Choose any two **adjacent** elements of `matrix` and **multiply** each of them by `-1`. Two elements are considered **adjacent** if and only if they share a **border**. Your goal is to **maximize** the summation of the matrix's elements. Return _the **maximum** sum of the matrix's elements using the operation mentioned above._ **Example 1:** ``` **Input:** matrix = [[1,-1],[-1,1]] **Output:** 4 Explanation: We can follow the following steps to reach sum equals 4: - Multiply the 2 elements in the first row by -1. - Multiply the 2 elements in the first column by -1. ``` **Example 2:** ``` **Input:** matrix = [[1,2,3],[-1,-2,-3],[1,2,3]] **Output:** 16 Explanation: We can follow the following step to reach sum equals 16: - Multiply the 2 last elements in the second row by -1. ``` **Constraints:** `n == matrix.length == matrix[i].length` `2 <= n <= 250` `-105 <= matrix[i][j] <= 105`",
        "test_case": [
            {
                "label": "Example 1",
                "input": "matrix = [[1,-1],[-1,1]]",
                "output": "4 Explanation: We can follow the following steps to reach sum equals 4:\n- Multiply the 2 elements in the first row by -1.\n- Multiply the 2 elements in the first column by -1."
            },
            {
                "label": "Example 2",
                "input": "matrix = [[1,2,3],[-1,-2,-3],[1,2,3]]",
                "output": "16 Explanation: We can follow the following step to reach sum equals 16:\n- Multiply the 2 last elements in the second row by -1. Constraints: n == matrix.length == matrix[i].length 2 <= n <= 250 -10 5 <= matrix[i][j] <= 10 5"
            }
        ],
        "elixir_template": "defmodule Solution do\n  @spec max_matrix_sum(matrix :: [[integer]]) :: integer\n  def max_matrix_sum(matrix) do\n    \n  end\nend",
        "erlang_template": "-spec max_matrix_sum(Matrix :: [[integer()]]) -> integer().\nmax_matrix_sum(Matrix) ->\n  .",
        "scala_template": "object Solution {\n    def maxMatrixSum(matrix: Array[Array[Int]]): Long = {\n        \n    }\n}"
    },
    {
        "id": 2088,
        "name": "minimum-time-to-type-word-using-special-typewriter",
        "difficulty": "Easy",
        "link": "https://leetcode.com/problems/minimum-time-to-type-word-using-special-typewriter/",
        "task_description": "There is a special typewriter with lowercase English letters `'a'` to `'z'` arranged in a **circle** with a **pointer**. A character can **only** be typed if the pointer is pointing to that character. The pointer is **initially** pointing to the character `'a'`. Each second, you may perform one of the following operations: Move the pointer one character **counterclockwise** or **clockwise**. Type the character the pointer is **currently** on. Given a string `word`, return the** minimum** number of seconds to type out the characters in `word`. **Example 1:** ``` **Input:** word = \"abc\" **Output:** 5 **Explanation: **The characters are printed as follows: - Type the character 'a' in 1 second since the pointer is initially on 'a'. - Move the pointer clockwise to 'b' in 1 second. - Type the character 'b' in 1 second. - Move the pointer clockwise to 'c' in 1 second. - Type the character 'c' in 1 second. ``` **Example 2:** ``` **Input:** word = \"bza\" **Output:** 7 **Explanation: **The characters are printed as follows: - Move the pointer clockwise to 'b' in 1 second. - Type the character 'b' in 1 second. - Move the pointer counterclockwise to 'z' in 2 seconds. - Type the character 'z' in 1 second. - Move the pointer clockwise to 'a' in 1 second. - Type the character 'a' in 1 second. ``` **Example 3:** ``` **Input:** word = \"zjpc\" **Output:** 34 **Explanation:** The characters are printed as follows: - Move the pointer counterclockwise to 'z' in 1 second. - Type the character 'z' in 1 second. - Move the pointer clockwise to 'j' in 10 seconds. - Type the character 'j' in 1 second. - Move the pointer clockwise to 'p' in 6 seconds. - Type the character 'p' in 1 second. - Move the pointer counterclockwise to 'c' in 13 seconds. - Type the character 'c' in 1 second. ``` **Constraints:** `1 <= word.length <= 100` `word` consists of lowercase English letters.",
        "test_case": [
            {
                "label": "Example 1",
                "input": "word = \"abc\"",
                "output": "5 Explanation: The characters are printed as follows:\n- Type the character 'a' in 1 second since the pointer is initially on 'a'.\n- Move the pointer clockwise to 'b' in 1 second.\n- Type the character 'b' in 1 second.\n- Move the pointer clockwise to 'c' in 1 second.\n- Type the character 'c' in 1 second."
            },
            {
                "label": "Example 2",
                "input": "word = \"bza\"",
                "output": "7 Explanation: The characters are printed as follows:\n- Move the pointer clockwise to 'b' in 1 second.\n- Type the character 'b' in 1 second.\n- Move the pointer counterclockwise to 'z' in 2 seconds.\n- Type the character 'z' in 1 second.\n- Move the pointer clockwise to 'a' in 1 second.\n- Type the character 'a' in 1 second."
            },
            {
                "label": "Example 3",
                "input": "word = \"zjpc\"",
                "output": "34 Explanation: The characters are printed as follows:\n- Move the pointer counterclockwise to 'z' in 1 second.\n- Type the character 'z' in 1 second.\n- Move the pointer clockwise to 'j' in 10 seconds.\n- Type the character 'j' in 1 second.\n- Move the pointer clockwise to 'p' in 6 seconds.\n- Type the character 'p' in 1 second.\n- Move the pointer counterclockwise to 'c' in 13 seconds.\n- Type the character 'c' in 1 second."
            }
        ],
        "elixir_template": "defmodule Solution do\n  @spec min_time_to_type(word :: String.t) :: integer\n  def min_time_to_type(word) do\n    \n  end\nend",
        "erlang_template": "-spec min_time_to_type(Word :: unicode:unicode_binary()) -> integer().\nmin_time_to_type(Word) ->\n  .",
        "scala_template": "object Solution {\n    def minTimeToType(word: String): Int = {\n        \n    }\n}"
    },
    {
        "id": 2086,
        "name": "count-number-of-special-subsequences",
        "difficulty": "Hard",
        "link": "https://leetcode.com/problems/count-number-of-special-subsequences/",
        "task_description": "A sequence is **special** if it consists of a **positive** number of `0`s, followed by a **positive** number of `1`s, then a **positive** number of `2`s. For example, `[0,1,2]` and `[0,0,1,1,1,2]` are special. In contrast, `[2,1,0]`, `[1]`, and `[0,1,2,0]` are not special. Given an array `nums` (consisting of **only** integers `0`, `1`, and `2`), return_ the **number of different subsequences** that are special_. Since the answer may be very large, **return it modulo **`109 + 7`. A **subsequence** of an array is a sequence that can be derived from the array by deleting some or no elements without changing the order of the remaining elements. Two subsequences are **different** if the **set of indices** chosen are different. **Example 1:** ``` **Input:** nums = [0,1,2,2] **Output:** 3 **Explanation:** The special subsequences are bolded [**0**,**1**,**2**,2], [**0**,**1**,2,**2**], and [**0**,**1**,**2**,**2**]. ``` **Example 2:** ``` **Input:** nums = [2,2,0,0] **Output:** 0 **Explanation:** There are no special subsequences in [2,2,0,0]. ``` **Example 3:** ``` **Input:** nums = [0,1,2,0,1,2] **Output:** 7 **Explanation:** The special subsequences are bolded: - [**0**,**1**,**2**,0,1,2] - [**0**,**1**,2,0,1,**2**] - [**0**,**1**,**2**,0,1,**2**] - [**0**,**1**,2,0,**1**,**2**] - [**0**,1,2,**0**,**1**,**2**] - [**0**,1,2,0,**1**,**2**] - [0,1,2,**0**,**1**,**2**] ``` **Constraints:** `1 <= nums.length <= 105` `0 <= nums[i] <= 2`",
        "test_case": [
            {
                "label": "Example 1",
                "input": "nums = [0,1,2,2]",
                "output": "3 Explanation: The special subsequences are bolded [ 0 , 1 , 2 ,2], [ 0 , 1 ,2, 2 ], and [ 0 , 1 , 2 , 2 ]."
            },
            {
                "label": "Example 2",
                "input": "nums = [2,2,0,0]",
                "output": "0 Explanation: There are no special subsequences in [2,2,0,0]."
            },
            {
                "label": "Example 3",
                "input": "nums = [0,1,2,0,1,2]",
                "output": "7 Explanation: The special subsequences are bolded:\n- [ 0 , 1 , 2 ,0,1,2]\n- [ 0 , 1 ,2,0,1, 2 ]\n- [ 0 , 1 , 2 ,0,1, 2 ]\n- [ 0 , 1 ,2,0, 1 , 2 ]\n- [ 0 ,1,2, 0 , 1 , 2 ]\n- [ 0 ,1,2,0, 1 , 2 ]\n- [0,1,2, 0 , 1 , 2 ]"
            }
        ],
        "elixir_template": "defmodule Solution do\n  @spec count_special_subsequences(nums :: [integer]) :: integer\n  def count_special_subsequences(nums) do\n    \n  end\nend",
        "erlang_template": "-spec count_special_subsequences(Nums :: [integer()]) -> integer().\ncount_special_subsequences(Nums) ->\n  .",
        "scala_template": "object Solution {\n    def countSpecialSubsequences(nums: Array[Int]): Int = {\n        \n    }\n}"
    },
    {
        "id": 2085,
        "name": "array-with-elements-not-equal-to-average-of-neighbors",
        "difficulty": "Medium",
        "link": "https://leetcode.com/problems/array-with-elements-not-equal-to-average-of-neighbors/",
        "task_description": "You are given a **0-indexed** array `nums` of **distinct** integers. You want to rearrange the elements in the array such that every element in the rearranged array is **not** equal to the **average** of its neighbors. More formally, the rearranged array should have the property such that for every `i` in the range `1 <= i < nums.length - 1`, `(nums[i-1] + nums[i+1]) / 2` is **not** equal to `nums[i]`. Return _**any** rearrangement of _`nums`_ that meets the requirements_. **Example 1:** ``` **Input:** nums = [1,2,3,4,5] **Output:** [1,2,4,5,3] **Explanation:** When i=1, nums[i] = 2, and the average of its neighbors is (1+4) / 2 = 2.5. When i=2, nums[i] = 4, and the average of its neighbors is (2+5) / 2 = 3.5. When i=3, nums[i] = 5, and the average of its neighbors is (4+3) / 2 = 3.5. ``` **Example 2:** ``` **Input:** nums = [6,2,0,9,7] **Output:** [9,7,6,2,0] **Explanation:** When i=1, nums[i] = 7, and the average of its neighbors is (9+6) / 2 = 7.5. When i=2, nums[i] = 6, and the average of its neighbors is (7+2) / 2 = 4.5. When i=3, nums[i] = 2, and the average of its neighbors is (6+0) / 2 = 3. ``` **Constraints:** `3 <= nums.length <= 105` `0 <= nums[i] <= 105`",
        "test_case": [
            {
                "label": "Example 1",
                "input": "nums = [1,2,3,4,5]",
                "output": "[1,2,4,5,3] Explanation: When i=1, nums[i] = 2, and the average of its neighbors is (1+4) / 2 = 2.5.\nWhen i=2, nums[i] = 4, and the average of its neighbors is (2+5) / 2 = 3.5.\nWhen i=3, nums[i] = 5, and the average of its neighbors is (4+3) / 2 = 3.5."
            },
            {
                "label": "Example 2",
                "input": "nums = [6,2,0,9,7]",
                "output": "[9,7,6,2,0] Explanation: When i=1, nums[i] = 7, and the average of its neighbors is (9+6) / 2 = 7.5.\nWhen i=2, nums[i] = 6, and the average of its neighbors is (7+2) / 2 = 4.5.\nWhen i=3, nums[i] = 2, and the average of its neighbors is (6+0) / 2 = 3."
            }
        ],
        "elixir_template": "defmodule Solution do\n  @spec rearrange_array(nums :: [integer]) :: [integer]\n  def rearrange_array(nums) do\n    \n  end\nend",
        "erlang_template": "-spec rearrange_array(Nums :: [integer()]) -> [integer()].\nrearrange_array(Nums) ->\n  .",
        "scala_template": "object Solution {\n    def rearrangeArray(nums: Array[Int]): Array[Int] = {\n        \n    }\n}"
    },
    {
        "id": 2084,
        "name": "maximum-number-of-weeks-for-which-you-can-work",
        "difficulty": "Medium",
        "link": "https://leetcode.com/problems/maximum-number-of-weeks-for-which-you-can-work/",
        "task_description": "There are `n` projects numbered from `0` to `n - 1`. You are given an integer array `milestones` where each `milestones[i]` denotes the number of milestones the `ith` project has. You can work on the projects following these two rules: Every week, you will finish **exactly one** milestone of **one** project. You **must** work every week. You **cannot** work on two milestones from the same project for two **consecutive** weeks. Once all the milestones of all the projects are finished, or if the only milestones that you can work on will cause you to violate the above rules, you will **stop working**. Note that you may not be able to finish every project's milestones due to these constraints. Return _the **maximum** number of weeks you would be able to work on the projects without violating the rules mentioned above_. **Example 1:** ``` **Input:** milestones = [1,2,3] **Output:** 6 **Explanation:** One possible scenario is: \u200b\u200b\u200b\u200b- During the 1st week, you will work on a milestone of project 0. - During the 2nd week, you will work on a milestone of project 2. - During the 3rd week, you will work on a milestone of project 1. - During the 4th week, you will work on a milestone of project 2. - During the 5th week, you will work on a milestone of project 1. - During the 6th week, you will work on a milestone of project 2. The total number of weeks is 6. ``` **Example 2:** ``` **Input:** milestones = [5,2,1] **Output:** 7 **Explanation:** One possible scenario is: - During the 1st week, you will work on a milestone of project 0. - During the 2nd week, you will work on a milestone of project 1. - During the 3rd week, you will work on a milestone of project 0. - During the 4th week, you will work on a milestone of project 1. - During the 5th week, you will work on a milestone of project 0. - During the 6th week, you will work on a milestone of project 2. - During the 7th week, you will work on a milestone of project 0. The total number of weeks is 7. Note that you cannot work on the last milestone of project 0 on 8th week because it would violate the rules. Thus, one milestone in project 0 will remain unfinished. ``` **Constraints:** `n == milestones.length` `1 <= n <= 105` `1 <= milestones[i] <= 109`",
        "test_case": [
            {
                "label": "Example 1",
                "input": "milestones = [1,2,3]",
                "output": "6 Explanation: One possible scenario is:\n\u200b\u200b\u200b\u200b- During the 1 st week, you will work on a milestone of project 0.\n- During the 2 nd week, you will work on a milestone of project 2.\n- During the 3 rd week, you will work on a milestone of project 1.\n- During the 4 th week, you will work on a milestone of project 2.\n- During the 5 th week, you will work on a milestone of project 1.\n- During the 6 th week, you will work on a milestone of project 2.\nThe total number of weeks is 6."
            },
            {
                "label": "Example 2",
                "input": "milestones = [5,2,1]",
                "output": "7 Explanation: One possible scenario is:\n- During the 1 st week, you will work on a milestone of project 0.\n- During the 2 nd week, you will work on a milestone of project 1.\n- During the 3 rd week, you will work on a milestone of project 0.\n- During the 4 th week, you will work on a milestone of project 1.\n- During the 5 th week, you will work on a milestone of project 0.\n- During the 6 th week, you will work on a milestone of project 2.\n- During the 7 th week, you will work on a milestone of project 0.\nThe total number of weeks is 7.\nNote that you cannot work on the last milestone of project 0 on 8 th week because it would violate the rules.\nThus, one milestone in project 0 will remain unfinished. Constraints: n == milestones.length 1 <= n <= 10 5 1 <= milestones[i] <= 10 9"
            }
        ],
        "elixir_template": "defmodule Solution do\n  @spec number_of_weeks(milestones :: [integer]) :: integer\n  def number_of_weeks(milestones) do\n    \n  end\nend",
        "erlang_template": "-spec number_of_weeks(Milestones :: [integer()]) -> integer().\nnumber_of_weeks(Milestones) ->\n  .",
        "scala_template": "object Solution {\n    def numberOfWeeks(milestones: Array[Int]): Long = {\n        \n    }\n}"
    },
    {
        "id": 2083,
        "name": "three-divisors",
        "difficulty": "Easy",
        "link": "https://leetcode.com/problems/three-divisors/",
        "task_description": "Given an integer `n`, return `true`_ if _`n`_ has **exactly three positive divisors**. Otherwise, return _`false`. An integer `m` is a **divisor** of `n` if there exists an integer `k` such that `n = k * m`. **Example 1:** ``` **Input:** n = 2 **Output:** false **Explantion:** 2 has only two divisors: 1 and 2. ``` **Example 2:** ``` **Input:** n = 4 **Output:** true **Explantion:** 4 has three divisors: 1, 2, and 4. ``` **Constraints:** `1 <= n <= 104`",
        "test_case": [
            {
                "label": "Example 1",
                "input": "n = 2",
                "output": "false Explantion: 2 has only two divisors: 1 and 2."
            },
            {
                "label": "Example 2",
                "input": "n = 4",
                "output": "true Explantion: 4 has three divisors: 1, 2, and 4."
            }
        ],
        "elixir_template": "defmodule Solution do\n  @spec is_three(n :: integer) :: boolean\n  def is_three(n) do\n    \n  end\nend",
        "erlang_template": "-spec is_three(N :: integer()) -> boolean().\nis_three(N) ->\n  .",
        "scala_template": "object Solution {\n    def isThree(n: Int): Boolean = {\n        \n    }\n}"
    },
    {
        "id": 2081,
        "name": "minimum-total-space-wasted-with-k-resizing-operations",
        "difficulty": "Medium",
        "link": "https://leetcode.com/problems/minimum-total-space-wasted-with-k-resizing-operations/",
        "task_description": "You are currently designing a dynamic array. You are given a **0-indexed** integer array `nums`, where `nums[i]` is the number of elements that will be in the array at time `i`. In addition, you are given an integer `k`, the **maximum** number of times you can **resize** the array (to** any** size). The size of the array at time `t`, `sizet`, must be at least `nums[t]` because there needs to be enough space in the array to hold all the elements. The **space wasted** at time `t` is defined as `sizet - nums[t]`, and the **total** space wasted is the **sum** of the space wasted across every time `t` where `0 <= t < nums.length`. Return _the **minimum** **total space wasted** if you can resize the array at most_ `k` _times_. **Note:** The array can have **any size** at the start and does** not **count towards the number of resizing operations. **Example 1:** ``` **Input:** nums = [10,20], k = 0 **Output:** 10 **Explanation:** size = [20,20]. We can set the initial size to be 20. The total wasted space is (20 - 10) + (20 - 20) = 10. ``` **Example 2:** ``` **Input:** nums = [10,20,30], k = 1 **Output:** 10 **Explanation:** size = [20,20,30]. We can set the initial size to be 20 and resize to 30 at time 2. The total wasted space is (20 - 10) + (20 - 20) + (30 - 30) = 10. ``` **Example 3:** ``` **Input:** nums = [10,20,15,30,20], k = 2 **Output:** 15 **Explanation:** size = [10,20,20,30,30]. We can set the initial size to 10, resize to 20 at time 1, and resize to 30 at time 3. The total wasted space is (10 - 10) + (20 - 20) + (20 - 15) + (30 - 30) + (30 - 20) = 15. ``` **Constraints:** `1 <= nums.length <= 200` `1 <= nums[i] <= 106` `0 <= k <= nums.length - 1`",
        "test_case": [
            {
                "label": "Example 1",
                "input": "nums = [10,20], k = 0",
                "output": "10 Explanation: size = [20,20].\nWe can set the initial size to be 20.\nThe total wasted space is (20 - 10) + (20 - 20) = 10."
            },
            {
                "label": "Example 2",
                "input": "nums = [10,20,30], k = 1",
                "output": "10 Explanation: size = [20,20,30].\nWe can set the initial size to be 20 and resize to 30 at time 2. \nThe total wasted space is (20 - 10) + (20 - 20) + (30 - 30) = 10."
            },
            {
                "label": "Example 3",
                "input": "nums = [10,20,15,30,20], k = 2",
                "output": "15 Explanation: size = [10,20,20,30,30].\nWe can set the initial size to 10, resize to 20 at time 1, and resize to 30 at time 3.\nThe total wasted space is (10 - 10) + (20 - 20) + (20 - 15) + (30 - 30) + (30 - 20) = 15."
            }
        ],
        "elixir_template": "defmodule Solution do\n  @spec min_space_wasted_k_resizing(nums :: [integer], k :: integer) :: integer\n  def min_space_wasted_k_resizing(nums, k) do\n    \n  end\nend",
        "erlang_template": "-spec min_space_wasted_k_resizing(Nums :: [integer()], K :: integer()) -> integer().\nmin_space_wasted_k_resizing(Nums, K) ->\n  .",
        "scala_template": "object Solution {\n    def minSpaceWastedKResizing(nums: Array[Int], k: Int): Int = {\n        \n    }\n}"
    },
    {
        "id": 2080,
        "name": "check-if-move-is-legal",
        "difficulty": "Medium",
        "link": "https://leetcode.com/problems/check-if-move-is-legal/",
        "task_description": "You are given a **0-indexed** `8 x 8` grid `board`, where `board[r][c]` represents the cell `(r, c)` on a game board. On the board, free cells are represented by `'.'`, white cells are represented by `'W'`, and black cells are represented by `'B'`. Each move in this game consists of choosing a free cell and changing it to the color you are playing as (either white or black). However, a move is only **legal** if, after changing it, the cell becomes the **endpoint of a good line** (horizontal, vertical, or diagonal). A **good line** is a line of **three or more cells (including the endpoints)** where the endpoints of the line are **one color**, and the remaining cells in the middle are the **opposite color** (no cells in the line are free). You can find examples for good lines in the figure below: Given two integers `rMove` and `cMove` and a character `color` representing the color you are playing as (white or black), return `true` _if changing cell _`(rMove, cMove)` _to color_ `color` _is a **legal** move, or _`false`_ if it is not legal_. **Example 1:** ``` **Input:** board = [[\".\",\".\",\".\",\"B\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\"W\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\"W\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\"W\",\".\",\".\",\".\",\".\"],[\"W\",\"B\",\"B\",\".\",\"W\",\"W\",\"W\",\"B\"],[\".\",\".\",\".\",\"B\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\"B\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\"W\",\".\",\".\",\".\",\".\"]], rMove = 4, cMove = 3, color = \"B\" **Output:** true **Explanation:** '.', 'W', and 'B' are represented by the colors blue, white, and black respectively, and cell (rMove, cMove) is marked with an 'X'. The two good lines with the chosen cell as an endpoint are annotated above with the red rectangles. ``` **Example 2:** ``` **Input:** board = [[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\".\",\"B\",\".\",\".\",\"W\",\".\",\".\",\".\"],[\".\",\".\",\"W\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\"W\",\"B\",\".\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\".\",\"B\",\"W\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\".\",\"W\",\".\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\"B\"]], rMove = 4, cMove = 4, color = \"W\" **Output:** false **Explanation:** While there are good lines with the chosen cell as a middle cell, there are no good lines with the chosen cell as an endpoint. ``` **Constraints:** `board.length == board[r].length == 8` `0 <= rMove, cMove < 8` `board[rMove][cMove] == '.'` `color` is either `'B'` or `'W'`.",
        "test_case": [
            {
                "label": "Example 1",
                "input": "board = [[\".\",\".\",\".\",\"B\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\"W\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\"W\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\"W\",\".\",\".\",\".\",\".\"],[\"W\",\"B\",\"B\",\".\",\"W\",\"W\",\"W\",\"B\"],[\".\",\".\",\".\",\"B\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\"B\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\"W\",\".\",\".\",\".\",\".\"]], rMove = 4, cMove = 3, color = \"B\"",
                "output": "true Explanation: '.', 'W', and 'B' are represented by the colors blue, white, and black respectively, and cell (rMove, cMove) is marked with an 'X'.\nThe two good lines with the chosen cell as an endpoint are annotated above with the red rectangles."
            },
            {
                "label": "Example 2",
                "input": "board = [[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\".\",\"B\",\".\",\".\",\"W\",\".\",\".\",\".\"],[\".\",\".\",\"W\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\"W\",\"B\",\".\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\".\",\"B\",\"W\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\".\",\"W\",\".\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\"B\"]], rMove = 4, cMove = 4, color = \"W\"",
                "output": "false Explanation: While there are good lines with the chosen cell as a middle cell, there are no good lines with the chosen cell as an endpoint. Constraints: board.length == board[r].length == 8 0 <= rMove, cMove < 8 board[rMove][cMove] == '.' color is either 'B' or 'W' ."
            }
        ],
        "elixir_template": "defmodule Solution do\n  @spec check_move(board :: [[char]], r_move :: integer, c_move :: integer, color :: char) :: boolean\n  def check_move(board, r_move, c_move, color) do\n    \n  end\nend",
        "erlang_template": "-spec check_move(Board :: [[char()]], RMove :: integer(), CMove :: integer(), Color :: char()) -> boolean().\ncheck_move(Board, RMove, CMove, Color) ->\n  .",
        "scala_template": "object Solution {\n    def checkMove(board: Array[Array[Char]], rMove: Int, cMove: Int, color: Char): Boolean = {\n        \n    }\n}"
    },
    {
        "id": 2079,
        "name": "delete-duplicate-folders-in-system",
        "difficulty": "Hard",
        "link": "https://leetcode.com/problems/delete-duplicate-folders-in-system/",
        "task_description": "Due to a bug, there are many duplicate folders in a file system. You are given a 2D array `paths`, where `paths[i]` is an array representing an absolute path to the `ith` folder in the file system. For example, `[\"one\", \"two\", \"three\"]` represents the path `\"/one/two/three\"`. Two folders (not necessarily on the same level) are **identical** if they contain the **same non-empty** set of identical subfolders and underlying subfolder structure. The folders **do not** need to be at the root level to be identical. If two or more folders are **identical**, then **mark** the folders as well as all their subfolders. For example, folders `\"/a\"` and `\"/b\"` in the file structure below are identical. They (as well as their subfolders) should **all** be marked: `/a` `/a/x` `/a/x/y` `/a/z` `/b` `/b/x` `/b/x/y` `/b/z` However, if the file structure also included the path `\"/b/w\"`, then the folders `\"/a\"` and `\"/b\"` would not be identical. Note that `\"/a/x\"` and `\"/b/x\"` would still be considered identical even with the added folder. Once all the identical folders and their subfolders have been marked, the file system will **delete** all of them. The file system only runs the deletion once, so any folders that become identical after the initial deletion are not deleted. Return _the 2D array _`ans` _containing the paths of the **remaining** folders after deleting all the marked folders. The paths may be returned in **any** order_. **Example 1:** ``` **Input:** paths = [[\"a\"],[\"c\"],[\"d\"],[\"a\",\"b\"],[\"c\",\"b\"],[\"d\",\"a\"]] **Output:** [[\"d\"],[\"d\",\"a\"]] **Explanation:** The file structure is as shown. Folders \"/a\" and \"/c\" (and their subfolders) are marked for deletion because they both contain an empty folder named \"b\". ``` **Example 2:** ``` **Input:** paths = [[\"a\"],[\"c\"],[\"a\",\"b\"],[\"c\",\"b\"],[\"a\",\"b\",\"x\"],[\"a\",\"b\",\"x\",\"y\"],[\"w\"],[\"w\",\"y\"]] **Output:** [[\"c\"],[\"c\",\"b\"],[\"a\"],[\"a\",\"b\"]] **Explanation: **The file structure is as shown. Folders \"/a/b/x\" and \"/w\" (and their subfolders) are marked for deletion because they both contain an empty folder named \"y\". Note that folders \"/a\" and \"/c\" are identical after the deletion, but they are not deleted because they were not marked beforehand. ``` **Example 3:** ``` **Input:** paths = [[\"a\",\"b\"],[\"c\",\"d\"],[\"c\"],[\"a\"]] **Output:** [[\"c\"],[\"c\",\"d\"],[\"a\"],[\"a\",\"b\"]] **Explanation:** All folders are unique in the file system. Note that the returned array can be in a different order as the order does not matter. ``` **Constraints:** `1 <= paths.length <= 2 * 104` `1 <= paths[i].length <= 500` `1 <= paths[i][j].length <= 10` `1 <= sum(paths[i][j].length) <= 2 * 105` `path[i][j]` consists of lowercase English letters. No two paths lead to the same folder. For any folder not at the root level, its parent folder will also be in the input.",
        "test_case": [
            {
                "label": "Example 1",
                "input": "paths = [[\"a\"],[\"c\"],[\"d\"],[\"a\",\"b\"],[\"c\",\"b\"],[\"d\",\"a\"]]",
                "output": "[[\"d\"],[\"d\",\"a\"]] Explanation: The file structure is as shown.\nFolders \"/a\" and \"/c\" (and their subfolders) are marked for deletion because they both contain an empty\nfolder named \"b\"."
            },
            {
                "label": "Example 2",
                "input": "paths = [[\"a\"],[\"c\"],[\"a\",\"b\"],[\"c\",\"b\"],[\"a\",\"b\",\"x\"],[\"a\",\"b\",\"x\",\"y\"],[\"w\"],[\"w\",\"y\"]]",
                "output": "[[\"c\"],[\"c\",\"b\"],[\"a\"],[\"a\",\"b\"]] Explanation: The file structure is as shown. \nFolders \"/a/b/x\" and \"/w\" (and their subfolders) are marked for deletion because they both contain an empty folder named \"y\".\nNote that folders \"/a\" and \"/c\" are identical after the deletion, but they are not deleted because they were not marked beforehand."
            },
            {
                "label": "Example 3",
                "input": "paths = [[\"a\",\"b\"],[\"c\",\"d\"],[\"c\"],[\"a\"]]",
                "output": "[[\"c\"],[\"c\",\"d\"],[\"a\"],[\"a\",\"b\"]] Explanation: All folders are unique in the file system.\nNote that the returned array can be in a different order as the order does not matter."
            }
        ],
        "elixir_template": "defmodule Solution do\n  @spec delete_duplicate_folder(paths :: [[String.t]]) :: [[String.t]]\n  def delete_duplicate_folder(paths) do\n    \n  end\nend",
        "erlang_template": "-spec delete_duplicate_folder(Paths :: [[unicode:unicode_binary()]]) -> [[unicode:unicode_binary()]].\ndelete_duplicate_folder(Paths) ->\n  .",
        "scala_template": "object Solution {\n    def deleteDuplicateFolder(paths: List[List[String]]): List[List[String]] = {\n        \n    }\n}"
    },
    {
        "id": 2078,
        "name": "maximum-compatibility-score-sum",
        "difficulty": "Medium",
        "link": "https://leetcode.com/problems/maximum-compatibility-score-sum/",
        "task_description": "There is a survey that consists of `n` questions where each question's answer is either `0` (no) or `1` (yes). The survey was given to `m` students numbered from `0` to `m - 1` and `m` mentors numbered from `0` to `m - 1`. The answers of the students are represented by a 2D integer array `students` where `students[i]` is an integer array that contains the answers of the `ith` student (**0-indexed**). The answers of the mentors are represented by a 2D integer array `mentors` where `mentors[j]` is an integer array that contains the answers of the `jth` mentor (**0-indexed**). Each student will be assigned to **one** mentor, and each mentor will have **one** student assigned to them. The **compatibility score** of a student-mentor pair is the number of answers that are the same for both the student and the mentor. For example, if the student's answers were `[1, 0, 1]` and the mentor's answers were `[0, 0, 1]`, then their compatibility score is 2 because only the second and the third answers are the same. You are tasked with finding the optimal student-mentor pairings to **maximize** the** sum of the compatibility scores**. Given `students` and `mentors`, return _the **maximum compatibility score sum** that can be achieved._ **Example 1:** ``` **Input:** students = [[1,1,0],[1,0,1],[0,0,1]], mentors = [[1,0,0],[0,0,1],[1,1,0]] **Output:** 8 **Explanation:** We assign students to mentors in the following way: - student 0 to mentor 2 with a compatibility score of 3. - student 1 to mentor 0 with a compatibility score of 2. - student 2 to mentor 1 with a compatibility score of 3. The compatibility score sum is 3 + 2 + 3 = 8. ``` **Example 2:** ``` **Input:** students = [[0,0],[0,0],[0,0]], mentors = [[1,1],[1,1],[1,1]] **Output:** 0 **Explanation:** The compatibility score of any student-mentor pair is 0. ``` **Constraints:** `m == students.length == mentors.length` `n == students[i].length == mentors[j].length` `1 <= m, n <= 8` `students[i][k]` is either `0` or `1`. `mentors[j][k]` is either `0` or `1`.",
        "test_case": [
            {
                "label": "Example 1",
                "input": "students = [[1,1,0],[1,0,1],[0,0,1]], mentors = [[1,0,0],[0,0,1],[1,1,0]]",
                "output": "8 Explanation: We assign students to mentors in the following way:\n- student 0 to mentor 2 with a compatibility score of 3.\n- student 1 to mentor 0 with a compatibility score of 2.\n- student 2 to mentor 1 with a compatibility score of 3.\nThe compatibility score sum is 3 + 2 + 3 = 8."
            },
            {
                "label": "Example 2",
                "input": "students = [[0,0],[0,0],[0,0]], mentors = [[1,1],[1,1],[1,1]]",
                "output": "0 Explanation: The compatibility score of any student-mentor pair is 0. Constraints: m == students.length == mentors.length n == students[i].length == mentors[j].length 1 <= m, n <= 8 students[i][k] is either 0 or 1 . mentors[j][k] is either 0 or 1 ."
            }
        ],
        "elixir_template": "defmodule Solution do\n  @spec max_compatibility_sum(students :: [[integer]], mentors :: [[integer]]) :: integer\n  def max_compatibility_sum(students, mentors) do\n    \n  end\nend",
        "erlang_template": "-spec max_compatibility_sum(Students :: [[integer()]], Mentors :: [[integer()]]) -> integer().\nmax_compatibility_sum(Students, Mentors) ->\n  .",
        "scala_template": "object Solution {\n    def maxCompatibilitySum(students: Array[Array[Int]], mentors: Array[Array[Int]]): Int = {\n        \n    }\n}"
    },
    {
        "id": 2077,
        "name": "largest-number-after-mutating-substring",
        "difficulty": "Medium",
        "link": "https://leetcode.com/problems/largest-number-after-mutating-substring/",
        "task_description": "You are given a string `num`, which represents a large integer. You are also given a **0-indexed** integer array `change` of length `10` that maps each digit `0-9` to another digit. More formally, digit `d` maps to digit `change[d]`. You may **choose** to mutate a single substring of `num`. To mutate a substring, replace each digit `num[i]` with the digit it maps to in `change` (i.e. replace `num[i]` with `change[num[i]]`). Return _a string representing the **largest** possible integer after **mutating** (or choosing not to) a **single substring** of _`num`. A **substring** is a contiguous sequence of characters within the string. **Example 1:** ``` **Input:** num = \"132\", change = [9,8,5,0,3,6,4,2,6,8] **Output:** \"832\" **Explanation:** Replace the substring \"1\": - 1 maps to change[1] = 8. Thus, \"132\" becomes \"832\". \"832\" is the largest number that can be created, so return it. ``` **Example 2:** ``` **Input:** num = \"021\", change = [9,4,3,5,7,2,1,9,0,6] **Output:** \"934\" **Explanation:** Replace the substring \"021\": - 0 maps to change[0] = 9. - 2 maps to change[2] = 3. - 1 maps to change[1] = 4. Thus, \"021\" becomes \"934\". \"934\" is the largest number that can be created, so return it. ``` **Example 3:** ``` **Input:** num = \"5\", change = [1,4,7,5,3,2,5,6,9,4] **Output:** \"5\" **Explanation:** \"5\" is already the largest number that can be created, so return it. ``` **Constraints:** `1 <= num.length <= 105` `num` consists of only digits `0-9`. `change.length == 10` `0 <= change[d] <= 9`",
        "test_case": [
            {
                "label": "Example 1",
                "input": "num = \" 1 32\", change = [9,8,5,0,3,6,4,2,6,8]",
                "output": "\" 8 32\" Explanation: Replace the substring \"1\":\n- 1 maps to change[1] = 8.\nThus, \" 1 32\" becomes \" 8 32\".\n\"832\" is the largest number that can be created, so return it."
            },
            {
                "label": "Example 2",
                "input": "num = \" 021 \", change = [9,4,3,5,7,2,1,9,0,6]",
                "output": "\" 934 \" Explanation: Replace the substring \"021\":\n- 0 maps to change[0] = 9.\n- 2 maps to change[2] = 3.\n- 1 maps to change[1] = 4.\nThus, \" 021 \" becomes \" 934 \".\n\"934\" is the largest number that can be created, so return it."
            },
            {
                "label": "Example 3",
                "input": "num = \"5\", change = [1,4,7,5,3,2,5,6,9,4]",
                "output": "\"5\" Explanation: \"5\" is already the largest number that can be created, so return it."
            }
        ],
        "elixir_template": "defmodule Solution do\n  @spec maximum_number(num :: String.t, change :: [integer]) :: String.t\n  def maximum_number(num, change) do\n    \n  end\nend",
        "erlang_template": "-spec maximum_number(Num :: unicode:unicode_binary(), Change :: [integer()]) -> unicode:unicode_binary().\nmaximum_number(Num, Change) ->\n  .",
        "scala_template": "object Solution {\n    def maximumNumber(num: String, change: Array[Int]): String = {\n        \n    }\n}"
    },
    {
        "id": 2076,
        "name": "sum-of-digits-of-string-after-convert",
        "difficulty": "Easy",
        "link": "https://leetcode.com/problems/sum-of-digits-of-string-after-convert/",
        "task_description": "You are given a string `s` consisting of lowercase English letters, and an integer `k`. Your task is to _convert_ the string into an integer by a special process, and then _transform_ it by summing its digits repeatedly `k` times. More specifically, perform the following steps: **Convert** `s` into an integer by replacing each letter with its position in the alphabet (i.e. replace `'a'` with `1`, `'b'` with `2`, ..., `'z'` with `26`). **T****ransform** the integer by replacing it with the **sum of its digits**. Repeat the **transform** operation (step 2) `k`** times** in total. For example, if `s = \"zbax\"` and `k = 2`, then the resulting integer would be `8` by the following operations: **Convert**: `\"zbax\" \u279d \"(26)(2)(1)(24)\" \u279d \"262124\" \u279d 262124` **Transform #1**: `262124 \u279d 2 + 6 + 2 + 1 + 2 + 4 \u279d 17` **Transform #2**: `17 \u279d 1 + 7 \u279d 8` Return the **resulting** **integer** after performing the **operations** described above. **Example 1:** **Input:** s = \"iiii\", k = 1 **Output:** 36 **Explanation:** The operations are as follows: - Convert: \"iiii\" \u279d \"(9)(9)(9)(9)\" \u279d \"9999\" \u279d 9999 - Transform #1: 9999 \u279d 9 + 9 + 9 + 9 \u279d 36 Thus the resulting integer is 36. **Example 2:** **Input:** s = \"leetcode\", k = 2 **Output:** 6 **Explanation:** The operations are as follows: - Convert: \"leetcode\" \u279d \"(12)(5)(5)(20)(3)(15)(4)(5)\" \u279d \"12552031545\" \u279d 12552031545 - Transform #1: 12552031545 \u279d 1 + 2 + 5 + 5 + 2 + 0 + 3 + 1 + 5 + 4 + 5 \u279d 33 - Transform #2: 33 \u279d 3 + 3 \u279d 6 Thus the resulting integer is 6. **Example 3:** **Input:** s = \"zbax\", k = 2 **Output:** 8 **Constraints:** `1 <= s.length <= 100` `1 <= k <= 10` `s` consists of lowercase English letters.",
        "test_case": [
            {
                "label": "Example 1",
                "input": "s = \"iiii\", k = 1",
                "output": "36 Explanation: The operations are as follows: - Convert: \"iiii\" \u279d \"(9)(9)(9)(9)\" \u279d \"9999\" \u279d 9999 - Transform #1: 9999 \u279d 9 + 9 + 9 + 9 \u279d 36 Thus the resulting integer is 36."
            },
            {
                "label": "Example 2",
                "input": "s = \"leetcode\", k = 2",
                "output": "6 Explanation: The operations are as follows: - Convert: \"leetcode\" \u279d \"(12)(5)(5)(20)(3)(15)(4)(5)\" \u279d \"12552031545\" \u279d 12552031545 - Transform #1: 12552031545 \u279d 1 + 2 + 5 + 5 + 2 + 0 + 3 + 1 + 5 + 4 + 5 \u279d 33 - Transform #2: 33 \u279d 3 + 3 \u279d 6 Thus the resulting integer is 6."
            },
            {
                "label": "Example 3",
                "input": "s = \"zbax\", k = 2",
                "output": "8"
            }
        ],
        "elixir_template": "defmodule Solution do\n  @spec get_lucky(s :: String.t, k :: integer) :: integer\n  def get_lucky(s, k) do\n    \n  end\nend",
        "erlang_template": "-spec get_lucky(S :: unicode:unicode_binary(), K :: integer()) -> integer().\nget_lucky(S, K) ->\n  .",
        "scala_template": "object Solution {\n    def getLucky(s: String, k: Int): Int = {\n        \n    }\n}"
    },
    {
        "id": 2068,
        "name": "maximum-genetic-difference-query",
        "difficulty": "Hard",
        "link": "https://leetcode.com/problems/maximum-genetic-difference-query/",
        "task_description": "There is a rooted tree consisting of `n` nodes numbered `0` to `n - 1`. Each node's number denotes its **unique genetic value** (i.e. the genetic value of node `x` is `x`). The **genetic difference** between two genetic values is defined as the **bitwise-****XOR** of their values. You are given the integer array `parents`, where `parents[i]` is the parent for node `i`. If node `x` is the **root** of the tree, then `parents[x] == -1`. You are also given the array `queries` where `queries[i] = [nodei, vali]`. For each query `i`, find the **maximum genetic difference** between `vali` and `pi`, where `pi` is the genetic value of any node that is on the path between `nodei` and the root (including `nodei` and the root). More formally, you want to maximize `vali XOR pi`. Return _an array _`ans`_ where _`ans[i]`_ is the answer to the _`ith`_ query_. **Example 1:** ``` **Input:** parents = [-1,0,1,1], queries = [[0,2],[3,2],[2,5]] **Output:** [2,3,7] **Explanation: **The queries are processed as follows: - [0,2]: The node with the maximum genetic difference is 0, with a difference of 2 XOR 0 = 2. - [3,2]: The node with the maximum genetic difference is 1, with a difference of 2 XOR 1 = 3. - [2,5]: The node with the maximum genetic difference is 2, with a difference of 5 XOR 2 = 7. ``` **Example 2:** ``` **Input:** parents = [3,7,-1,2,0,7,0,2], queries = [[4,6],[1,15],[0,5]] **Output:** [6,14,7] **Explanation: **The queries are processed as follows: - [4,6]: The node with the maximum genetic difference is 0, with a difference of 6 XOR 0 = 6. - [1,15]: The node with the maximum genetic difference is 1, with a difference of 15 XOR 1 = 14. - [0,5]: The node with the maximum genetic difference is 2, with a difference of 5 XOR 2 = 7. ``` **Constraints:** `2 <= parents.length <= 105` `0 <= parents[i] <= parents.length - 1` for every node `i` that is **not** the root. `parents[root] == -1` `1 <= queries.length <= 3 * 104` `0 <= nodei <= parents.length - 1` `0 <= vali <= 2 * 105`",
        "test_case": [
            {
                "label": "Example 1",
                "input": "parents = [-1,0,1,1], queries = [[0,2],[3,2],[2,5]]",
                "output": "[2,3,7] Explanation: The queries are processed as follows:\n- [0,2]: The node with the maximum genetic difference is 0, with a difference of 2 XOR 0 = 2.\n- [3,2]: The node with the maximum genetic difference is 1, with a difference of 2 XOR 1 = 3.\n- [2,5]: The node with the maximum genetic difference is 2, with a difference of 5 XOR 2 = 7."
            },
            {
                "label": "Example 2",
                "input": "parents = [3,7,-1,2,0,7,0,2], queries = [[4,6],[1,15],[0,5]]",
                "output": "[6,14,7] Explanation: The queries are processed as follows:\n- [4,6]: The node with the maximum genetic difference is 0, with a difference of 6 XOR 0 = 6.\n- [1,15]: The node with the maximum genetic difference is 1, with a difference of 15 XOR 1 = 14.\n- [0,5]: The node with the maximum genetic difference is 2, with a difference of 5 XOR 2 = 7."
            }
        ],
        "elixir_template": "defmodule Solution do\n  @spec max_genetic_difference(parents :: [integer], queries :: [[integer]]) :: [integer]\n  def max_genetic_difference(parents, queries) do\n    \n  end\nend",
        "erlang_template": "-spec max_genetic_difference(Parents :: [integer()], Queries :: [[integer()]]) -> [integer()].\nmax_genetic_difference(Parents, Queries) ->\n  .",
        "scala_template": "object Solution {\n    def maxGeneticDifference(parents: Array[Int], queries: Array[Array[Int]]): Array[Int] = {\n        \n    }\n}"
    },
    {
        "id": 2067,
        "name": "maximum-number-of-points-with-cost",
        "difficulty": "Medium",
        "link": "https://leetcode.com/problems/maximum-number-of-points-with-cost/",
        "task_description": "You are given an `m x n` integer matrix `points` (**0-indexed**). Starting with `0` points, you want to **maximize** the number of points you can get from the matrix. To gain points, you must pick one cell in **each row**. Picking the cell at coordinates `(r, c)` will **add** `points[r][c]` to your score. However, you will lose points if you pick a cell too far from the cell that you picked in the previous row. For every two adjacent rows `r` and `r + 1` (where `0 <= r < m - 1`), picking cells at coordinates `(r, c1)` and `(r + 1, c2)` will **subtract** `abs(c1 - c2)` from your score. Return _the **maximum** number of points you can achieve_. `abs(x)` is defined as: `x` for `x >= 0`. `-x` for `x < 0`. **Example 1:**** ** ``` **Input:** points = [[1,2,3],[1,5,1],[3,1,1]] **Output:** 9 **Explanation:** The blue cells denote the optimal cells to pick, which have coordinates (0, 2), (1, 1), and (2, 0). You add 3 + 5 + 3 = 11 to your score. However, you must subtract abs(2 - 1) + abs(1 - 0) = 2 from your score. Your final score is 11 - 2 = 9. ``` **Example 2:** ``` **Input:** points = [[1,5],[2,3],[4,2]] **Output:** 11 **Explanation:** The blue cells denote the optimal cells to pick, which have coordinates (0, 1), (1, 1), and (2, 0). You add 5 + 3 + 4 = 12 to your score. However, you must subtract abs(1 - 1) + abs(1 - 0) = 1 from your score. Your final score is 12 - 1 = 11. ``` **Constraints:** `m == points.length` `n == points[r].length` `1 <= m, n <= 105` `1 <= m * n <= 105` `0 <= points[r][c] <= 105`",
        "test_case": [
            {
                "label": "Example 1",
                "input": "points = [[1,2,3],[1,5,1],[3,1,1]]",
                "output": "9 Explanation: The blue cells denote the optimal cells to pick, which have coordinates (0, 2), (1, 1), and (2, 0).\nYou add 3 + 5 + 3 = 11 to your score.\nHowever, you must subtract abs(2 - 1) + abs(1 - 0) = 2 from your score.\nYour final score is 11 - 2 = 9."
            },
            {
                "label": "Example 2",
                "input": "points = [[1,5],[2,3],[4,2]]",
                "output": "11 Explanation: The blue cells denote the optimal cells to pick, which have coordinates (0, 1), (1, 1), and (2, 0).\nYou add 5 + 3 + 4 = 12 to your score.\nHowever, you must subtract abs(1 - 1) + abs(1 - 0) = 1 from your score.\nYour final score is 12 - 1 = 11. Constraints: m == points.length n == points[r].length 1 <= m, n <= 10 5 1 <= m * n <= 10 5 0 <= points[r][c] <= 10 5"
            }
        ],
        "elixir_template": "defmodule Solution do\n  @spec max_points(points :: [[integer]]) :: integer\n  def max_points(points) do\n    \n  end\nend",
        "erlang_template": "-spec max_points(Points :: [[integer()]]) -> integer().\nmax_points(Points) ->\n  .",
        "scala_template": "object Solution {\n    def maxPoints(points: Array[Array[Int]]): Long = {\n        \n    }\n}"
    },
    {
        "id": 2066,
        "name": "add-minimum-number-of-rungs",
        "difficulty": "Medium",
        "link": "https://leetcode.com/problems/add-minimum-number-of-rungs/",
        "task_description": "You are given a **strictly increasing** integer array `rungs` that represents the **height** of rungs on a ladder. You are currently on the **floor** at height `0`, and you want to reach the last rung. You are also given an integer `dist`. You can only climb to the next highest rung if the distance between where you are currently at (the floor or on a rung) and the next rung is **at most** `dist`. You are able to insert rungs at any positive **integer** height if a rung is not already there. Return _the **minimum** number of rungs that must be added to the ladder in order for you to climb to the last rung._ **Example 1:** ``` **Input:** rungs = [1,3,5,10], dist = 2 **Output:** 2 **Explanation: **You currently cannot reach the last rung. Add rungs at heights 7 and 8 to climb this ladder. The ladder will now have rungs at [1,3,5,7,8,10]. ``` **Example 2:** ``` **Input:** rungs = [3,6,8,10], dist = 3 **Output:** 0 **Explanation:** This ladder can be climbed without adding additional rungs. ``` **Example 3:** ``` **Input:** rungs = [3,4,6,7], dist = 2 **Output:** 1 **Explanation:** You currently cannot reach the first rung from the ground. Add a rung at height 1 to climb this ladder. The ladder will now have rungs at [1,3,4,6,7]. ``` **Constraints:** `1 <= rungs.length <= 105` `1 <= rungs[i] <= 109` `1 <= dist <= 109` `rungs` is **strictly increasing**.",
        "test_case": [
            {
                "label": "Example 1",
                "input": "rungs = [1,3,5,10], dist = 2",
                "output": "2 Explanation: You currently cannot reach the last rung.\nAdd rungs at heights 7 and 8 to climb this ladder. \nThe ladder will now have rungs at [1,3,5, 7 , 8 ,10]."
            },
            {
                "label": "Example 2",
                "input": "rungs = [3,6,8,10], dist = 3",
                "output": "0 Explanation: This ladder can be climbed without adding additional rungs."
            },
            {
                "label": "Example 3",
                "input": "rungs = [3,4,6,7], dist = 2",
                "output": "1 Explanation: You currently cannot reach the first rung from the ground.\nAdd a rung at height 1 to climb this ladder.\nThe ladder will now have rungs at [ 1 ,3,4,6,7]."
            }
        ],
        "elixir_template": "defmodule Solution do\n  @spec add_rungs(rungs :: [integer], dist :: integer) :: integer\n  def add_rungs(rungs, dist) do\n    \n  end\nend",
        "erlang_template": "-spec add_rungs(Rungs :: [integer()], Dist :: integer()) -> integer().\nadd_rungs(Rungs, Dist) ->\n  .",
        "scala_template": "object Solution {\n    def addRungs(rungs: Array[Int], dist: Int): Int = {\n        \n    }\n}"
    },
    {
        "id": 2061,
        "name": "painting-a-grid-with-three-different-colors",
        "difficulty": "Hard",
        "link": "https://leetcode.com/problems/painting-a-grid-with-three-different-colors/",
        "task_description": "You are given two integers `m` and `n`. Consider an `m x n` grid where each cell is initially white. You can paint each cell **red**, **green**, or **blue**. All cells **must** be painted. Return_ the number of ways to color the grid with **no two adjacent cells having the same color**_. Since the answer can be very large, return it **modulo** `109 + 7`. **Example 1:** ``` **Input:** m = 1, n = 1 **Output:** 3 **Explanation:** The three possible colorings are shown in the image above. ``` **Example 2:** ``` **Input:** m = 1, n = 2 **Output:** 6 **Explanation:** The six possible colorings are shown in the image above. ``` **Example 3:** ``` **Input:** m = 5, n = 5 **Output:** 580986 ``` **Constraints:** `1 <= m <= 5` `1 <= n <= 1000`",
        "test_case": [
            {
                "label": "Example 1",
                "input": "m = 1, n = 1",
                "output": "3 Explanation: The three possible colorings are shown in the image above."
            },
            {
                "label": "Example 2",
                "input": "m = 1, n = 2",
                "output": "6 Explanation: The six possible colorings are shown in the image above."
            },
            {
                "label": "Example 3",
                "input": "m = 5, n = 5",
                "output": "580986"
            }
        ],
        "elixir_template": "defmodule Solution do\n  @spec color_the_grid(m :: integer, n :: integer) :: integer\n  def color_the_grid(m, n) do\n    \n  end\nend",
        "erlang_template": "-spec color_the_grid(M :: integer(), N :: integer()) -> integer().\ncolor_the_grid(M, N) ->\n  .",
        "scala_template": "object Solution {\n    def colorTheGrid(m: Int, n: Int): Int = {\n        \n    }\n}"
    },
    {
        "id": 2060,
        "name": "merge-bsts-to-create-single-bst",
        "difficulty": "Hard",
        "link": "https://leetcode.com/problems/merge-bsts-to-create-single-bst/",
        "task_description": "You are given `n` **BST (binary search tree) root nodes** for `n` separate BSTs stored in an array `trees` (**0-indexed**). Each BST in `trees` has **at most 3 nodes**, and no two roots have the same value. In one operation, you can: Select two **distinct** indices `i` and `j` such that the value stored at one of the **leaves **of `trees[i]` is equal to the **root value** of `trees[j]`. Replace the leaf node in `trees[i]` with `trees[j]`. Remove `trees[j]` from `trees`. Return_ the **root** of the resulting BST if it is possible to form a valid BST after performing _`n - 1`_ operations, or__ _`null` if it is impossible to create a valid BST. A BST (binary search tree) is a binary tree where each node satisfies the following property: Every node in the node's left subtree has a value **strictly less** than the node's value. Every node in the node's right subtree has a value **strictly greater** than the node's value. A leaf is a node that has no children. **Example 1:** ``` **Input:** trees = [[2,1],[3,2,5],[5,4]] **Output:** [3,2,5,1,null,4] **Explanation:** In the first operation, pick i=1 and j=0, and merge trees[0] into trees[1]. Delete trees[0], so trees = [[3,2,5,1],[5,4]]. In the second operation, pick i=0 and j=1, and merge trees[1] into trees[0]. Delete trees[1], so trees = [[3,2,5,1,null,4]]. The resulting tree, shown above, is a valid BST, so return its root. ``` **Example 2:** ``` **Input:** trees = [[5,3,8],[3,2,6]] **Output:** [] **Explanation:** Pick i=0 and j=1 and merge trees[1] into trees[0]. Delete trees[1], so trees = [[5,3,8,2,6]]. The resulting tree is shown above. This is the only valid operation that can be performed, but the resulting tree is not a valid BST, so return null. ``` **Example 3:** ``` **Input:** trees = [[5,4],[3]] **Output:** [] **Explanation:** It is impossible to perform any operations. ``` **Constraints:** `n == trees.length` `1 <= n <= 5 * 104` The number of nodes in each tree is in the range `[1, 3]`. Each node in the input may have children but no grandchildren. No two roots of `trees` have the same value. All the trees in the input are **valid BSTs**. `1 <= TreeNode.val <= 5 * 104`.",
        "test_case": [
            {
                "label": "Example 1",
                "input": "trees = [[2,1],[3,2,5],[5,4]]",
                "output": "[3,2,5,1,null,4] Explanation: In the first operation, pick i=1 and j=0, and merge trees[0] into trees[1].\nDelete trees[0], so trees = [[3,2,5,1],[5,4]]. In the second operation, pick i=0 and j=1, and merge trees[1] into trees[0].\nDelete trees[1], so trees = [[3,2,5,1,null,4]]. The resulting tree, shown above, is a valid BST, so return its root."
            },
            {
                "label": "Example 2",
                "input": "trees = [[5,3,8],[3,2,6]]",
                "output": "[] Explanation: Pick i=0 and j=1 and merge trees[1] into trees[0].\nDelete trees[1], so trees = [[5,3,8,2,6]]. The resulting tree is shown above. This is the only valid operation that can be performed, but the resulting tree is not a valid BST, so return null."
            },
            {
                "label": "Example 3",
                "input": "trees = [[5,4],[3]]",
                "output": "[] Explanation: It is impossible to perform any operations. Constraints: n == trees.length 1 <= n <= 5 * 10 4 The number of nodes in each tree is in the range [1, 3] . Each node in the input may have children but no grandchildren. No two roots of trees have the same value. All the trees in the input are valid BSTs . 1 <= TreeNode.val <= 5 * 10 4 ."
            }
        ],
        "elixir_template": "Elixir code template not available for this problem.",
        "erlang_template": "Elixir code template not available for this problem.",
        "scala_template": "/**\n * Definition for a binary tree node.\n * class TreeNode(_value: Int = 0, _left: TreeNode = null, _right: TreeNode = null) {\n *   var value: Int = _value\n *   var left: TreeNode = _left\n *   var right: TreeNode = _right\n * }\n */\nobject Solution {\n    def canMerge(trees: List[TreeNode]): TreeNode = {\n        \n    }\n}"
    },
    {
        "id": 2059,
        "name": "unique-length-3-palindromic-subsequences",
        "difficulty": "Medium",
        "link": "https://leetcode.com/problems/unique-length-3-palindromic-subsequences/",
        "task_description": "Given a string `s`, return _the number of **unique palindromes of length three** that are a **subsequence** of _`s`. Note that even if there are multiple ways to obtain the same subsequence, it is still only counted **once**. A **palindrome** is a string that reads the same forwards and backwards. A **subsequence** of a string is a new string generated from the original string with some characters (can be none) deleted without changing the relative order of the remaining characters. For example, `\"ace\"` is a subsequence of `\"abcde\"`. **Example 1:** ``` **Input:** s = \"aabca\" **Output:** 3 **Explanation:** The 3 palindromic subsequences of length 3 are: - \"aba\" (subsequence of \"aabca\") - \"aaa\" (subsequence of \"aabca\") - \"aca\" (subsequence of \"aabca\") ``` **Example 2:** ``` **Input:** s = \"adc\" **Output:** 0 **Explanation:** There are no palindromic subsequences of length 3 in \"adc\". ``` **Example 3:** ``` **Input:** s = \"bbcbaba\" **Output:** 4 **Explanation:** The 4 palindromic subsequences of length 3 are: - \"bbb\" (subsequence of \"bbcbaba\") - \"bcb\" (subsequence of \"bbcbaba\") - \"bab\" (subsequence of \"bbcbaba\") - \"aba\" (subsequence of \"bbcbaba\") ``` **Constraints:** `3 <= s.length <= 105` `s` consists of only lowercase English letters.",
        "test_case": [
            {
                "label": "Example 1",
                "input": "s = \"aabca\"",
                "output": "3 Explanation: The 3 palindromic subsequences of length 3 are:\n- \"aba\" (subsequence of \" a a b c a \")\n- \"aaa\" (subsequence of \" aa bc a \")\n- \"aca\" (subsequence of \" a ab ca \")"
            },
            {
                "label": "Example 2",
                "input": "s = \"adc\"",
                "output": "0 Explanation: There are no palindromic subsequences of length 3 in \"adc\"."
            },
            {
                "label": "Example 3",
                "input": "s = \"bbcbaba\"",
                "output": "4 Explanation: The 4 palindromic subsequences of length 3 are:\n- \"bbb\" (subsequence of \" bb c b aba\")\n- \"bcb\" (subsequence of \" b b cb aba\")\n- \"bab\" (subsequence of \" b bcb ab a\")\n- \"aba\" (subsequence of \"bbcb aba \")"
            }
        ],
        "elixir_template": "defmodule Solution do\n  @spec count_palindromic_subsequence(s :: String.t) :: integer\n  def count_palindromic_subsequence(s) do\n    \n  end\nend",
        "erlang_template": "-spec count_palindromic_subsequence(S :: unicode:unicode_binary()) -> integer().\ncount_palindromic_subsequence(S) ->\n  .",
        "scala_template": "object Solution {\n    def countPalindromicSubsequence(s: String): Int = {\n        \n    }\n}"
    },
    {
        "id": 2058,
        "name": "concatenation-of-array",
        "difficulty": "Easy",
        "link": "https://leetcode.com/problems/concatenation-of-array/",
        "task_description": "Given an integer array `nums` of length `n`, you want to create an array `ans` of length `2n` where `ans[i] == nums[i]` and `ans[i + n] == nums[i]` for `0 <= i < n` (**0-indexed**). Specifically, `ans` is the **concatenation** of two `nums` arrays. Return _the array _`ans`. **Example 1:** ``` **Input:** nums = [1,2,1] **Output:** [1,2,1,1,2,1] **Explanation:** The array ans is formed as follows: - ans = [nums[0],nums[1],nums[2],nums[0],nums[1],nums[2]] - ans = [1,2,1,1,2,1] ``` **Example 2:** ``` **Input:** nums = [1,3,2,1] **Output:** [1,3,2,1,1,3,2,1] **Explanation:** The array ans is formed as follows: - ans = [nums[0],nums[1],nums[2],nums[3],nums[0],nums[1],nums[2],nums[3]] - ans = [1,3,2,1,1,3,2,1] ``` **Constraints:** `n == nums.length` `1 <= n <= 1000` `1 <= nums[i] <= 1000`",
        "test_case": [
            {
                "label": "Example 1",
                "input": "nums = [1,2,1]",
                "output": "[1,2,1,1,2,1] Explanation: The array ans is formed as follows:\n- ans = [nums[0],nums[1],nums[2],nums[0],nums[1],nums[2]]\n- ans = [1,2,1,1,2,1]"
            },
            {
                "label": "Example 2",
                "input": "nums = [1,3,2,1]",
                "output": "[1,3,2,1,1,3,2,1] Explanation: The array ans is formed as follows:\n- ans = [nums[0],nums[1],nums[2],nums[3],nums[0],nums[1],nums[2],nums[3]]\n- ans = [1,3,2,1,1,3,2,1] Constraints: n == nums.length 1 <= n <= 1000 1 <= nums[i] <= 1000"
            }
        ],
        "elixir_template": "defmodule Solution do\n  @spec get_concatenation(nums :: [integer]) :: [integer]\n  def get_concatenation(nums) do\n    \n  end\nend",
        "erlang_template": "-spec get_concatenation(Nums :: [integer()]) -> [integer()].\nget_concatenation(Nums) ->\n  .",
        "scala_template": "object Solution {\n    def getConcatenation(nums: Array[Int]): Array[Int] = {\n        \n    }\n}"
    },
    {
        "id": 2055,
        "name": "describe-the-painting",
        "difficulty": "Medium",
        "link": "https://leetcode.com/problems/describe-the-painting/",
        "task_description": "There is a long and thin painting that can be represented by a number line. The painting was painted with multiple overlapping segments where each segment was painted with a **unique** color. You are given a 2D integer array `segments`, where `segments[i] = [starti, endi, colori]` represents the **half-closed segment** `[starti, endi)` with `colori` as the color. The colors in the overlapping segments of the painting were **mixed** when it was painted. When two or more colors mix, they form a new color that can be represented as a **set** of mixed colors. For example, if colors `2`, `4`, and `6` are mixed, then the resulting mixed color is `{2,4,6}`. For the sake of simplicity, you should only output the **sum** of the elements in the set rather than the full set. You want to **describe** the painting with the **minimum** number of non-overlapping **half-closed segments** of these mixed colors. These segments can be represented by the 2D array `painting` where `painting[j] = [leftj, rightj, mixj]` describes a **half-closed segment** `[leftj, rightj)` with the mixed color **sum** of `mixj`. For example, the painting created with `segments = [[1,4,5],[1,7,7]]` can be described by `painting = [[1,4,12],[4,7,7]]` because: `[1,4)` is colored `{5,7}` (with a sum of `12`) from both the first and second segments. `[4,7)` is colored `{7}` from only the second segment. Return _the 2D array _`painting`_ describing the finished painting (excluding any parts that are **not **painted). You may return the segments in **any order**_. A **half-closed segment** `[a, b)` is the section of the number line between points `a` and `b` **including** point `a` and **not including** point `b`. **Example 1:** ``` **Input:** segments = [[1,4,5],[4,7,7],[1,7,9]] **Output:** [[1,4,14],[4,7,16]] **Explanation: **The painting can be described as follows: - [1,4) is colored {5,9} (with a sum of 14) from the first and third segments. - [4,7) is colored {7,9} (with a sum of 16) from the second and third segments. ``` **Example 2:** ``` **Input:** segments = [[1,7,9],[6,8,15],[8,10,7]] **Output:** [[1,6,9],[6,7,24],[7,8,15],[8,10,7]] **Explanation: **The painting can be described as follows: - [1,6) is colored 9 from the first segment. - [6,7) is colored {9,15} (with a sum of 24) from the first and second segments. - [7,8) is colored 15 from the second segment. - [8,10) is colored 7 from the third segment. ``` **Example 3:** ``` **Input:** segments = [[1,4,5],[1,4,7],[4,7,1],[4,7,11]] **Output:** [[1,4,12],[4,7,12]] **Explanation: **The painting can be described as follows: - [1,4) is colored {5,7} (with a sum of 12) from the first and second segments. - [4,7) is colored {1,11} (with a sum of 12) from the third and fourth segments. Note that returning a single segment [1,7) is incorrect because the mixed color sets are different. ``` **Constraints:** `1 <= segments.length <= 2 * 104` `segments[i].length == 3` `1 <= starti < endi <= 105` `1 <= colori <= 109` Each `colori` is distinct.",
        "test_case": [
            {
                "label": "Example 1",
                "input": "segments = [[1,4,5],[4,7,7],[1,7,9]]",
                "output": "[[1,4,14],[4,7,16]] Explanation: The painting can be described as follows:\n- [1,4) is colored {5,9} (with a sum of 14) from the first and third segments.\n- [4,7) is colored {7,9} (with a sum of 16) from the second and third segments."
            },
            {
                "label": "Example 2",
                "input": "segments = [[1,7,9],[6,8,15],[8,10,7]]",
                "output": "[[1,6,9],[6,7,24],[7,8,15],[8,10,7]] Explanation: The painting can be described as follows:\n- [1,6) is colored 9 from the first segment.\n- [6,7) is colored {9,15} (with a sum of 24) from the first and second segments.\n- [7,8) is colored 15 from the second segment.\n- [8,10) is colored 7 from the third segment."
            },
            {
                "label": "Example 3",
                "input": "segments = [[1,4,5],[1,4,7],[4,7,1],[4,7,11]]",
                "output": "[[1,4,12],[4,7,12]] Explanation: The painting can be described as follows:\n- [1,4) is colored {5,7} (with a sum of 12) from the first and second segments.\n- [4,7) is colored {1,11} (with a sum of 12) from the third and fourth segments.\nNote that returning a single segment [1,7) is incorrect because the mixed color sets are different."
            }
        ],
        "elixir_template": "defmodule Solution do\n  @spec split_painting(segments :: [[integer]]) :: [[integer]]\n  def split_painting(segments) do\n    \n  end\nend",
        "erlang_template": "-spec split_painting(Segments :: [[integer()]]) -> [[integer()]].\nsplit_painting(Segments) ->\n  .",
        "scala_template": "object Solution {\n    def splitPainting(segments: Array[Array[Int]]): List[List[Long]] = {\n        \n    }\n}"
    },
    {
        "id": 2054,
        "name": "the-number-of-the-smallest-unoccupied-chair",
        "difficulty": "Medium",
        "link": "https://leetcode.com/problems/the-number-of-the-smallest-unoccupied-chair/",
        "task_description": "There is a party where `n` friends numbered from `0` to `n - 1` are attending. There is an **infinite** number of chairs in this party that are numbered from `0` to `infinity`. When a friend arrives at the party, they sit on the unoccupied chair with the **smallest number**. For example, if chairs `0`, `1`, and `5` are occupied when a friend comes, they will sit on chair number `2`. When a friend leaves the party, their chair becomes unoccupied at the moment they leave. If another friend arrives at that same moment, they can sit in that chair. You are given a **0-indexed** 2D integer array `times` where `times[i] = [arrivali, leavingi]`, indicating the arrival and leaving times of the `ith` friend respectively, and an integer `targetFriend`. All arrival times are **distinct**. Return_ the **chair number** that the friend numbered _`targetFriend`_ will sit on_. **Example 1:** ``` **Input:** times = [[1,4],[2,3],[4,6]], targetFriend = 1 **Output:** 1 **Explanation:** - Friend 0 arrives at time 1 and sits on chair 0. - Friend 1 arrives at time 2 and sits on chair 1. - Friend 1 leaves at time 3 and chair 1 becomes empty. - Friend 0 leaves at time 4 and chair 0 becomes empty. - Friend 2 arrives at time 4 and sits on chair 0. Since friend 1 sat on chair 1, we return 1. ``` **Example 2:** ``` **Input:** times = [[3,10],[1,5],[2,6]], targetFriend = 0 **Output:** 2 **Explanation:** - Friend 1 arrives at time 1 and sits on chair 0. - Friend 2 arrives at time 2 and sits on chair 1. - Friend 0 arrives at time 3 and sits on chair 2. - Friend 1 leaves at time 5 and chair 0 becomes empty. - Friend 2 leaves at time 6 and chair 1 becomes empty. - Friend 0 leaves at time 10 and chair 2 becomes empty. Since friend 0 sat on chair 2, we return 2. ``` **Constraints:** `n == times.length` `2 <= n <= 104` `times[i].length == 2` `1 <= arrivali < leavingi <= 105` `0 <= targetFriend <= n - 1` Each `arrivali` time is **distinct**.",
        "test_case": [
            {
                "label": "Example 1",
                "input": "times = [[1,4],[2,3],[4,6]], targetFriend = 1",
                "output": "1 Explanation: - Friend 0 arrives at time 1 and sits on chair 0.\n- Friend 1 arrives at time 2 and sits on chair 1.\n- Friend 1 leaves at time 3 and chair 1 becomes empty.\n- Friend 0 leaves at time 4 and chair 0 becomes empty.\n- Friend 2 arrives at time 4 and sits on chair 0.\nSince friend 1 sat on chair 1, we return 1."
            },
            {
                "label": "Example 2",
                "input": "times = [[3,10],[1,5],[2,6]], targetFriend = 0",
                "output": "2 Explanation: - Friend 1 arrives at time 1 and sits on chair 0.\n- Friend 2 arrives at time 2 and sits on chair 1.\n- Friend 0 arrives at time 3 and sits on chair 2.\n- Friend 1 leaves at time 5 and chair 0 becomes empty.\n- Friend 2 leaves at time 6 and chair 1 becomes empty.\n- Friend 0 leaves at time 10 and chair 2 becomes empty.\nSince friend 0 sat on chair 2, we return 2. Constraints: n == times.length 2 <= n <= 10 4 times[i].length == 2 1 <= arrival i < leaving i <= 10 5 0 <= targetFriend <= n - 1 Each arrival i time is distinct ."
            }
        ],
        "elixir_template": "defmodule Solution do\n  @spec smallest_chair(times :: [[integer]], target_friend :: integer) :: integer\n  def smallest_chair(times, target_friend) do\n    \n  end\nend",
        "erlang_template": "-spec smallest_chair(Times :: [[integer()]], TargetFriend :: integer()) -> integer().\nsmallest_chair(Times, TargetFriend) ->\n  .",
        "scala_template": "object Solution {\n    def smallestChair(times: Array[Array[Int]], targetFriend: Int): Int = {\n        \n    }\n}"
    },
    {
        "id": 2053,
        "name": "check-if-all-characters-have-equal-number-of-occurrences",
        "difficulty": "Easy",
        "link": "https://leetcode.com/problems/check-if-all-characters-have-equal-number-of-occurrences/",
        "task_description": "Given a string `s`, return `true`_ if _`s`_ is a **good** string, or _`false`_ otherwise_. A string `s` is **good** if **all** the characters that appear in `s` have the **same** number of occurrences (i.e., the same frequency). **Example 1:** ``` **Input:** s = \"abacbc\" **Output:** true **Explanation:** The characters that appear in s are 'a', 'b', and 'c'. All characters occur 2 times in s. ``` **Example 2:** ``` **Input:** s = \"aaabb\" **Output:** false **Explanation:** The characters that appear in s are 'a' and 'b'. 'a' occurs 3 times while 'b' occurs 2 times, which is not the same number of times. ``` **Constraints:** `1 <= s.length <= 1000` `s` consists of lowercase English letters.",
        "test_case": [
            {
                "label": "Example 1",
                "input": "s = \"abacbc\"",
                "output": "true Explanation: The characters that appear in s are 'a', 'b', and 'c'. All characters occur 2 times in s."
            },
            {
                "label": "Example 2",
                "input": "s = \"aaabb\"",
                "output": "false Explanation: The characters that appear in s are 'a' and 'b'.\n'a' occurs 3 times while 'b' occurs 2 times, which is not the same number of times."
            }
        ],
        "elixir_template": "defmodule Solution do\n  @spec are_occurrences_equal(s :: String.t) :: boolean\n  def are_occurrences_equal(s) do\n    \n  end\nend",
        "erlang_template": "-spec are_occurrences_equal(S :: unicode:unicode_binary()) -> boolean().\nare_occurrences_equal(S) ->\n  .",
        "scala_template": "object Solution {\n    def areOccurrencesEqual(s: String): Boolean = {\n        \n    }\n}"
    },
    {
        "id": 2051,
        "name": "longest-common-subpath",
        "difficulty": "Hard",
        "link": "https://leetcode.com/problems/longest-common-subpath/",
        "task_description": "There is a country of `n` cities numbered from `0` to `n - 1`. In this country, there is a road connecting every pair of cities. There are `m` friends numbered from `0` to `m - 1` who are traveling through the country. Each one of them will take a path consisting of some cities. Each path is represented by an integer array that contains the visited cities in order. The path may contain a city **more than once**, but the same city will not be listed consecutively. Given an integer `n` and a 2D integer array `paths` where `paths[i]` is an integer array representing the path of the `ith` friend, return _the length of the **longest common subpath** that is shared by **every** friend's path, or _`0`_ if there is no common subpath at all_. A **subpath** of a path is a contiguous sequence of cities within that path. **Example 1:** ``` **Input:** n = 5, paths = [[0,1,2,3,4], [2,3,4], [4,0,1,2,3]] **Output:** 2 **Explanation:** The longest common subpath is [2,3]. ``` **Example 2:** ``` **Input:** n = 3, paths = [[0],[1],[2]] **Output:** 0 **Explanation:** There is no common subpath shared by the three paths. ``` **Example 3:** ``` **Input:** n = 5, paths = [[0,1,2,3,4], [4,3,2,1,0]] **Output:** 1 **Explanation:** The possible longest common subpaths are [0], [1], [2], [3], and [4]. All have a length of 1. ``` **Constraints:** `1 <= n <= 105` `m == paths.length` `2 <= m <= 105` `sum(paths[i].length) <= 105` `0 <= paths[i][j] < n` The same city is not listed multiple times consecutively in `paths[i]`.",
        "test_case": [
            {
                "label": "Example 1",
                "input": "n = 5, paths = [[0,1, 2,3 ,4],\n                       [ 2,3 ,4],\n                       [4,0,1, 2,3 ]]",
                "output": "2 Explanation: The longest common subpath is [2,3]."
            },
            {
                "label": "Example 2",
                "input": "n = 3, paths = [[0],[1],[2]]",
                "output": "0 Explanation: There is no common subpath shared by the three paths."
            },
            {
                "label": "Example 3",
                "input": "n = 5, paths = [[ 0 ,1,2,3,4],\n                       [4,3,2,1, 0 ]]",
                "output": "1 Explanation: The possible longest common subpaths are [0], [1], [2], [3], and [4]. All have a length of 1."
            }
        ],
        "elixir_template": "defmodule Solution do\n  @spec longest_common_subpath(n :: integer, paths :: [[integer]]) :: integer\n  def longest_common_subpath(n, paths) do\n    \n  end\nend",
        "erlang_template": "-spec longest_common_subpath(N :: integer(), Paths :: [[integer()]]) -> integer().\nlongest_common_subpath(N, Paths) ->\n  .",
        "scala_template": "object Solution {\n    def longestCommonSubpath(n: Int, paths: Array[Array[Int]]): Int = {\n        \n    }\n}"
    },
    {
        "id": 2050,
        "name": "count-good-numbers",
        "difficulty": "Medium",
        "link": "https://leetcode.com/problems/count-good-numbers/",
        "task_description": "A digit string is **good** if the digits **(0-indexed)** at **even** indices are **even** and the digits at **odd** indices are **prime** (`2`, `3`, `5`, or `7`). For example, `\"2582\"` is good because the digits (`2` and `8`) at even positions are even and the digits (`5` and `2`) at odd positions are prime. However, `\"3245\"` is **not** good because `3` is at an even index but is not even. Given an integer `n`, return _the **total** number of good digit strings of length _`n`. Since the answer may be large, **return it modulo **`109 + 7`. A **digit string** is a string consisting of digits `0` through `9` that may contain leading zeros. **Example 1:** ``` **Input:** n = 1 **Output:** 5 **Explanation:** The good numbers of length 1 are \"0\", \"2\", \"4\", \"6\", \"8\". ``` **Example 2:** ``` **Input:** n = 4 **Output:** 400 ``` **Example 3:** ``` **Input:** n = 50 **Output:** 564908303 ``` **Constraints:** `1 <= n <= 1015`",
        "test_case": [
            {
                "label": "Example 1",
                "input": "n = 1",
                "output": "5 Explanation: The good numbers of length 1 are \"0\", \"2\", \"4\", \"6\", \"8\"."
            },
            {
                "label": "Example 2",
                "input": "n = 4",
                "output": "400"
            },
            {
                "label": "Example 3",
                "input": "n = 50",
                "output": "564908303"
            }
        ],
        "elixir_template": "defmodule Solution do\n  @spec count_good_numbers(n :: integer) :: integer\n  def count_good_numbers(n) do\n    \n  end\nend",
        "erlang_template": "-spec count_good_numbers(N :: integer()) -> integer().\ncount_good_numbers(N) ->\n  .",
        "scala_template": "object Solution {\n    def countGoodNumbers(n: Long): Int = {\n        \n    }\n}"
    },
    {
        "id": 2049,
        "name": "eliminate-maximum-number-of-monsters",
        "difficulty": "Medium",
        "link": "https://leetcode.com/problems/eliminate-maximum-number-of-monsters/",
        "task_description": "You are playing a video game where you are defending your city from a group of `n` monsters. You are given a **0-indexed** integer array `dist` of size `n`, where `dist[i]` is the **initial distance** in kilometers of the `ith` monster from the city. The monsters walk toward the city at a **constant** speed. The speed of each monster is given to you in an integer array `speed` of size `n`, where `speed[i]` is the speed of the `ith` monster in kilometers per minute. You have a weapon that, once fully charged, can eliminate a **single** monster. However, the weapon takes **one minute** to charge. The weapon is fully charged at the very start. You lose when any monster reaches your city. If a monster reaches the city at the exact moment the weapon is fully charged, it counts as a **loss**, and the game ends before you can use your weapon. Return _the **maximum** number of monsters that you can eliminate before you lose, or _`n`_ if you can eliminate all the monsters before they reach the city._ **Example 1:** ``` **Input:** dist = [1,3,4], speed = [1,1,1] **Output:** 3 **Explanation:** In the beginning, the distances of the monsters are [1,3,4]. You eliminate the first monster. After a minute, the distances of the monsters are [X,2,3]. You eliminate the second monster. After a minute, the distances of the monsters are [X,X,2]. You eliminate the third monster. All 3 monsters can be eliminated. ``` **Example 2:** ``` **Input:** dist = [1,1,2,3], speed = [1,1,1,1] **Output:** 1 **Explanation:** In the beginning, the distances of the monsters are [1,1,2,3]. You eliminate the first monster. After a minute, the distances of the monsters are [X,0,1,2], so you lose. You can only eliminate 1 monster. ``` **Example 3:** ``` **Input:** dist = [3,2,4], speed = [5,3,2] **Output:** 1 **Explanation:** In the beginning, the distances of the monsters are [3,2,4]. You eliminate the first monster. After a minute, the distances of the monsters are [X,0,2], so you lose. You can only eliminate 1 monster. ``` **Constraints:** `n == dist.length == speed.length` `1 <= n <= 105` `1 <= dist[i], speed[i] <= 105`",
        "test_case": [
            {
                "label": "Example 1",
                "input": "dist = [1,3,4], speed = [1,1,1]",
                "output": "3 Explanation: In the beginning, the distances of the monsters are [1,3,4]. You eliminate the first monster.\nAfter a minute, the distances of the monsters are [X,2,3]. You eliminate the second monster.\nAfter a minute, the distances of the monsters are [X,X,2]. You eliminate the third monster.\nAll 3 monsters can be eliminated."
            },
            {
                "label": "Example 2",
                "input": "dist = [1,1,2,3], speed = [1,1,1,1]",
                "output": "1 Explanation: In the beginning, the distances of the monsters are [1,1,2,3]. You eliminate the first monster.\nAfter a minute, the distances of the monsters are [X,0,1,2], so you lose.\nYou can only eliminate 1 monster."
            },
            {
                "label": "Example 3",
                "input": "dist = [3,2,4], speed = [5,3,2]",
                "output": "1 Explanation: In the beginning, the distances of the monsters are [3,2,4]. You eliminate the first monster.\nAfter a minute, the distances of the monsters are [X,0,2], so you lose.\nYou can only eliminate 1 monster. Constraints: n == dist.length == speed.length 1 <= n <= 10 5 1 <= dist[i], speed[i] <= 10 5"
            }
        ],
        "elixir_template": "defmodule Solution do\n  @spec eliminate_maximum(dist :: [integer], speed :: [integer]) :: integer\n  def eliminate_maximum(dist, speed) do\n    \n  end\nend",
        "erlang_template": "-spec eliminate_maximum(Dist :: [integer()], Speed :: [integer()]) -> integer().\neliminate_maximum(Dist, Speed) ->\n  .",
        "scala_template": "object Solution {\n    def eliminateMaximum(dist: Array[Int], speed: Array[Int]): Int = {\n        \n    }\n}"
    },
    {
        "id": 2048,
        "name": "build-array-from-permutation",
        "difficulty": "Easy",
        "link": "https://leetcode.com/problems/build-array-from-permutation/",
        "task_description": "Given a **zero-based permutation** `nums` (**0-indexed**), build an array `ans` of the **same length** where `ans[i] = nums[nums[i]]` for each `0 <= i < nums.length` and return it. A **zero-based permutation** `nums` is an array of **distinct** integers from `0` to `nums.length - 1` (**inclusive**). **Example 1:** ``` **Input:** nums = [0,2,1,5,3,4] **Output:** [0,1,2,4,5,3]** Explanation:** The array ans is built as follows: ans = [nums[nums[0]], nums[nums[1]], nums[nums[2]], nums[nums[3]], nums[nums[4]], nums[nums[5]]] = [nums[0], nums[2], nums[1], nums[5], nums[3], nums[4]] = [0,1,2,4,5,3] ``` **Example 2:** ``` **Input:** nums = [5,0,1,2,3,4] **Output:** [4,5,0,1,2,3] **Explanation:** The array ans is built as follows: ans = [nums[nums[0]], nums[nums[1]], nums[nums[2]], nums[nums[3]], nums[nums[4]], nums[nums[5]]] = [nums[5], nums[0], nums[1], nums[2], nums[3], nums[4]] = [4,5,0,1,2,3] ``` **Constraints:** `1 <= nums.length <= 1000` `0 <= nums[i] < nums.length` The elements in `nums` are **distinct**. **Follow-up:** Can you solve it without using an extra space (i.e., `O(1)` memory)?",
        "test_case": [
            {
                "label": "Example 1",
                "input": "nums = [0,2,1,5,3,4]",
                "output": "[0,1,2,4,5,3] Explanation: The array ans is built as follows: \nans = [nums[nums[0]], nums[nums[1]], nums[nums[2]], nums[nums[3]], nums[nums[4]], nums[nums[5]]]\n    = [nums[0], nums[2], nums[1], nums[5], nums[3], nums[4]]\n    = [0,1,2,4,5,3]"
            },
            {
                "label": "Example 2",
                "input": "nums = [5,0,1,2,3,4]",
                "output": "[4,5,0,1,2,3] Explanation: The array ans is built as follows:\nans = [nums[nums[0]], nums[nums[1]], nums[nums[2]], nums[nums[3]], nums[nums[4]], nums[nums[5]]]\n    = [nums[5], nums[0], nums[1], nums[2], nums[3], nums[4]]\n    = [4,5,0,1,2,3]"
            }
        ],
        "elixir_template": "defmodule Solution do\n  @spec build_array(nums :: [integer]) :: [integer]\n  def build_array(nums) do\n    \n  end\nend",
        "erlang_template": "-spec build_array(Nums :: [integer()]) -> [integer()].\nbuild_array(Nums) ->\n  .",
        "scala_template": "object Solution {\n    def buildArray(nums: Array[Int]): Array[Int] = {\n        \n    }\n}"
    },
    {
        "id": 2047,
        "name": "find-a-peak-element-ii",
        "difficulty": "Medium",
        "link": "https://leetcode.com/problems/find-a-peak-element-ii/",
        "task_description": "A **peak** element in a 2D grid is an element that is **strictly greater** than all of its **adjacent **neighbors to the left, right, top, and bottom. Given a **0-indexed** `m x n` matrix `mat` where **no two adjacent cells are equal**, find **any** peak element `mat[i][j]` and return _the length 2 array _`[i,j]`. You may assume that the entire matrix is surrounded by an **outer perimeter** with the value `-1` in each cell. You must write an algorithm that runs in `O(m log(n))` or `O(n log(m))` time. **Example 1:** ``` **Input:** mat = [[1,4],[3,2]] **Output:** [0,1] **Explanation:** Both 3 and 4 are peak elements so [1,0] and [0,1] are both acceptable answers. ``` **Example 2:** **** ``` **Input:** mat = [[10,20,15],[21,30,14],[7,16,32]] **Output:** [1,1] **Explanation:** Both 30 and 32 are peak elements so [1,1] and [2,2] are both acceptable answers. ``` **Constraints:** `m == mat.length` `n == mat[i].length` `1 <= m, n <= 500` `1 <= mat[i][j] <= 105` No two adjacent cells are equal.",
        "test_case": [
            {
                "label": "Example 1",
                "input": "mat = [[1,4],[3,2]]",
                "output": "[0,1] Explanation: Both 3 and 4 are peak elements so [1,0] and [0,1] are both acceptable answers."
            },
            {
                "label": "Example 2",
                "input": "mat = [[10,20,15],[21,30,14],[7,16,32]]",
                "output": "[1,1] Explanation: Both 30 and 32 are peak elements so [1,1] and [2,2] are both acceptable answers. Constraints: m == mat.length n == mat[i].length 1 <= m, n <= 500 1 <= mat[i][j] <= 10 5 No two adjacent cells are equal."
            }
        ],
        "elixir_template": "defmodule Solution do\n  @spec find_peak_grid(mat :: [[integer]]) :: [integer]\n  def find_peak_grid(mat) do\n    \n  end\nend",
        "erlang_template": "-spec find_peak_grid(Mat :: [[integer()]]) -> [integer()].\nfind_peak_grid(Mat) ->\n  .",
        "scala_template": "object Solution {\n    def findPeakGrid(mat: Array[Array[Int]]): Array[Int] = {\n        \n    }\n}"
    },
    {
        "id": 2044,
        "name": "number-of-wonderful-substrings",
        "difficulty": "Medium",
        "link": "https://leetcode.com/problems/number-of-wonderful-substrings/",
        "task_description": "A **wonderful** string is a string where **at most one** letter appears an **odd** number of times. For example, `\"ccjjc\"` and `\"abab\"` are wonderful, but `\"ab\"` is not. Given a string `word` that consists of the first ten lowercase English letters (`'a'` through `'j'`), return _the **number of wonderful non-empty substrings** in _`word`_. If the same substring appears multiple times in _`word`_, then count **each occurrence** separately._ A **substring** is a contiguous sequence of characters in a string. **Example 1:** ``` **Input:** word = \"aba\" **Output:** 4 **Explanation:** The four wonderful substrings are underlined below: - \"**a**ba\" -> \"a\" - \"a**b**a\" -> \"b\" - \"ab**a**\" -> \"a\" - \"**aba**\" -> \"aba\" ``` **Example 2:** ``` **Input:** word = \"aabb\" **Output:** 9 **Explanation:** The nine wonderful substrings are underlined below: - \"**a**abb\" -> \"a\" - \"**aa**bb\" -> \"aa\" - \"**aab**b\" -> \"aab\" - \"**aabb**\" -> \"aabb\" - \"a**a**bb\" -> \"a\" - \"a**abb**\" -> \"abb\" - \"aa**b**b\" -> \"b\" - \"aa**bb**\" -> \"bb\" - \"aab**b**\" -> \"b\" ``` **Example 3:** ``` **Input:** word = \"he\" **Output:** 2 **Explanation:** The two wonderful substrings are underlined below: - \"he\" -> \"h\" - \"h**e**\" -> \"e\" ``` **Constraints:** `1 <= word.length <= 105` `word` consists of lowercase English letters from `'a'` to `'j'`.",
        "test_case": [
            {
                "label": "Example 1",
                "input": "word = \"aba\"",
                "output": "4 Explanation: The four wonderful substrings are underlined below:\r\n- \" a ba\" -> \"a\"\r\n- \"a b a\" -> \"b\"\r\n- \"ab a \" -> \"a\"\r\n- \" aba \" -> \"aba\""
            },
            {
                "label": "Example 2",
                "input": "word = \"aabb\"",
                "output": "9 Explanation: The nine wonderful substrings are underlined below:\r\n- \" a abb\" -> \"a\"\r\n- \" aa bb\" -> \"aa\"\r\n- \" aab b\" -> \"aab\"\r\n- \" aabb \" -> \"aabb\"\r\n- \"a a bb\" -> \"a\"\r\n- \"a abb \" -> \"abb\"\r\n- \"aa b b\" -> \"b\"\r\n- \"aa bb \" -> \"bb\"\r\n- \"aab b \" -> \"b\""
            },
            {
                "label": "Example 3",
                "input": "word = \"he\"",
                "output": "2 Explanation: The two wonderful substrings are underlined below:\r\n- \" h e\" -> \"h\"\r\n- \"h e \" -> \"e\""
            }
        ],
        "elixir_template": "Elixir code template not available for this problem.",
        "erlang_template": "Elixir code template not available for this problem.",
        "scala_template": "object Solution {\r\n    def wonderfulSubstrings(word: String): Long = {\r\n        \r\n    }\r\n}"
    },
    {
        "id": 2043,
        "name": "cyclically-rotating-a-grid",
        "difficulty": "Medium",
        "link": "https://leetcode.com/problems/cyclically-rotating-a-grid/",
        "task_description": "You are given an `m x n` integer matrix `grid`\u200b\u200b\u200b, where `m` and `n` are both **even** integers, and an integer `k`. The matrix is composed of several layers, which is shown in the below image, where each color is its own layer: A cyclic rotation of the matrix is done by cyclically rotating **each layer** in the matrix. To cyclically rotate a layer once, each element in the layer will take the place of the adjacent element in the **counter-clockwise** direction. An example rotation is shown below: Return _the matrix after applying _`k` _cyclic rotations to it_. **Example 1:** ``` **Input:** grid = [[40,10],[30,20]], k = 1 **Output:** [[10,20],[40,30]] **Explanation:** The figures above represent the grid at every state. ``` **Example 2:** **** **** **** ``` **Input:** grid = [[1,2,3,4],[5,6,7,8],[9,10,11,12],[13,14,15,16]], k = 2 **Output:** [[3,4,8,12],[2,11,10,16],[1,7,6,15],[5,9,13,14]] **Explanation:** The figures above represent the grid at every state. ``` **Constraints:** `m == grid.length` `n == grid[i].length` `2 <= m, n <= 50` Both `m` and `n` are **even** integers. `1 <= grid[i][j] <= 5000` `1 <= k <= 109`",
        "test_case": [
            {
                "label": "Example 1",
                "input": "grid = [[40,10],[30,20]], k = 1",
                "output": "[[10,20],[40,30]] Explanation: The figures above represent the grid at every state."
            },
            {
                "label": "Example 2",
                "input": "grid = [[1,2,3,4],[5,6,7,8],[9,10,11,12],[13,14,15,16]], k = 2",
                "output": "[[3,4,8,12],[2,11,10,16],[1,7,6,15],[5,9,13,14]] Explanation: The figures above represent the grid at every state. Constraints: m == grid.length n == grid[i].length 2 <= m, n <= 50 Both m and n are even integers. 1 <= grid[i][j] <= 5000 1 <= k <= 10 9"
            }
        ],
        "elixir_template": "Elixir code template not available for this problem.",
        "erlang_template": "Elixir code template not available for this problem.",
        "scala_template": "object Solution {\r\n    def rotateGrid(grid: Array[Array[Int]], k: Int): Array[Array[Int]] = {\r\n        \r\n    }\r\n}"
    },
    {
        "id": 2042,
        "name": "maximum-product-difference-between-two-pairs",
        "difficulty": "Easy",
        "link": "https://leetcode.com/problems/maximum-product-difference-between-two-pairs/",
        "task_description": "The **product difference** between two pairs `(a, b)` and `(c, d)` is defined as `(a * b) - (c * d)`. For example, the product difference between `(5, 6)` and `(2, 7)` is `(5 * 6) - (2 * 7) = 16`. Given an integer array `nums`, choose four **distinct** indices `w`, `x`, `y`, and `z` such that the **product difference** between pairs `(nums[w], nums[x])` and `(nums[y], nums[z])` is **maximized**. Return _the **maximum** such product difference_. **Example 1:** ``` **Input:** nums = [5,6,2,7,4] **Output:** 34 **Explanation:** We can choose indices 1 and 3 for the first pair (6, 7) and indices 2 and 4 for the second pair (2, 4). The product difference is (6 * 7) - (2 * 4) = 34. ``` **Example 2:** ``` **Input:** nums = [4,2,5,9,7,4,8] **Output:** 64 **Explanation:** We can choose indices 3 and 6 for the first pair (9, 8) and indices 1 and 5 for the second pair (2, 4). The product difference is (9 * 8) - (2 * 4) = 64. ``` **Constraints:** `4 <= nums.length <= 104` `1 <= nums[i] <= 104`",
        "test_case": [
            {
                "label": "Example 1",
                "input": "nums = [5,6,2,7,4]",
                "output": "34 Explanation: We can choose indices 1 and 3 for the first pair (6, 7) and indices 2 and 4 for the second pair (2, 4).\r\nThe product difference is (6 * 7) - (2 * 4) = 34."
            },
            {
                "label": "Example 2",
                "input": "nums = [4,2,5,9,7,4,8]",
                "output": "64 Explanation: We can choose indices 3 and 6 for the first pair (9, 8) and indices 1 and 5 for the second pair (2, 4).\r\nThe product difference is (9 * 8) - (2 * 4) = 64."
            }
        ],
        "elixir_template": "Elixir code template not available for this problem.",
        "erlang_template": "Elixir code template not available for this problem.",
        "scala_template": "object Solution {\r\n    def maxProductDifference(nums: Array[Int]): Int = {\r\n        \r\n    }\r\n}"
    },
    {
        "id": 2040,
        "name": "minimum-cost-to-reach-destination-in-time",
        "difficulty": "Hard",
        "link": "https://leetcode.com/problems/minimum-cost-to-reach-destination-in-time/",
        "task_description": "There is a country of `n` cities numbered from `0` to `n - 1` where **all the cities are connected** by bi-directional roads. The roads are represented as a 2D integer array `edges` where `edges[i] = [xi, yi, timei]` denotes a road between cities `xi` and `yi` that takes `timei` minutes to travel. There may be multiple roads of differing travel times connecting the same two cities, but no road connects a city to itself. Each time you pass through a city, you must pay a passing fee. This is represented as a **0-indexed** integer array `passingFees` of length `n` where `passingFees[j]` is the amount of dollars you must pay when you pass through city `j`. In the beginning, you are at city `0` and want to reach city `n - 1` in `maxTime`** minutes or less**. The **cost** of your journey is the **summation of passing fees** for each city that you passed through at some moment of your journey (**including** the source and destination cities). Given `maxTime`, `edges`, and `passingFees`, return _the **minimum cost** to complete your journey, or _`-1`_ if you cannot complete it within _`maxTime`_ minutes_. **Example 1:** ``` **Input:** maxTime = 30, edges = [[0,1,10],[1,2,10],[2,5,10],[0,3,1],[3,4,10],[4,5,15]], passingFees = [5,1,2,20,20,3] **Output:** 11 **Explanation:** The path to take is 0 -> 1 -> 2 -> 5, which takes 30 minutes and has $11 worth of passing fees. ``` **Example 2:** **** ``` **Input:** maxTime = 29, edges = [[0,1,10],[1,2,10],[2,5,10],[0,3,1],[3,4,10],[4,5,15]], passingFees = [5,1,2,20,20,3] **Output:** 48 **Explanation:** The path to take is 0 -> 3 -> 4 -> 5, which takes 26 minutes and has $48 worth of passing fees. You cannot take path 0 -> 1 -> 2 -> 5 since it would take too long. ``` **Example 3:** ``` **Input:** maxTime = 25, edges = [[0,1,10],[1,2,10],[2,5,10],[0,3,1],[3,4,10],[4,5,15]], passingFees = [5,1,2,20,20,3] **Output:** -1 **Explanation:** There is no way to reach city 5 from city 0 within 25 minutes. ``` **Constraints:** `1 <= maxTime <= 1000` `n == passingFees.length` `2 <= n <= 1000` `n - 1 <= edges.length <= 1000` `0 <= xi, yi <= n - 1` `1 <= timei <= 1000` `1 <= passingFees[j] <= 1000` The graph may contain multiple edges between two nodes. The graph does not contain self loops.",
        "test_case": [
            {
                "label": "Example 1",
                "input": "maxTime = 30, edges = [[0,1,10],[1,2,10],[2,5,10],[0,3,1],[3,4,10],[4,5,15]], passingFees = [5,1,2,20,20,3]",
                "output": "11 Explanation: The path to take is 0 -> 1 -> 2 -> 5, which takes 30 minutes and has $11 worth of passing fees."
            },
            {
                "label": "Example 2",
                "input": "maxTime = 29, edges = [[0,1,10],[1,2,10],[2,5,10],[0,3,1],[3,4,10],[4,5,15]], passingFees = [5,1,2,20,20,3]",
                "output": "48 Explanation: The path to take is 0 -> 3 -> 4 -> 5, which takes 26 minutes and has $48 worth of passing fees.\nYou cannot take path 0 -> 1 -> 2 -> 5 since it would take too long."
            },
            {
                "label": "Example 3",
                "input": "maxTime = 25, edges = [[0,1,10],[1,2,10],[2,5,10],[0,3,1],[3,4,10],[4,5,15]], passingFees = [5,1,2,20,20,3]",
                "output": "-1 Explanation: There is no way to reach city 5 from city 0 within 25 minutes."
            }
        ],
        "elixir_template": "defmodule Solution do\n  @spec min_cost(max_time :: integer, edges :: [[integer]], passing_fees :: [integer]) :: integer\n  def min_cost(max_time, edges, passing_fees) do\n    \n  end\nend",
        "erlang_template": "-spec min_cost(MaxTime :: integer(), Edges :: [[integer()]], PassingFees :: [integer()]) -> integer().\nmin_cost(MaxTime, Edges, PassingFees) ->\n  .",
        "scala_template": "object Solution {\n    def minCost(maxTime: Int, edges: Array[Array[Int]], passingFees: Array[Int]): Int = {\n        \n    }\n}"
    },
    {
        "id": 2039,
        "name": "sum-game",
        "difficulty": "Medium",
        "link": "https://leetcode.com/problems/sum-game/",
        "task_description": "Alice and Bob take turns playing a game, with **Alice**** starting first**. You are given a string `num` of **even length** consisting of digits and `'?'` characters. On each turn, a player will do the following if there is still at least one `'?'` in `num`: Choose an index `i` where `num[i] == '?'`. Replace `num[i]` with any digit between `'0'` and `'9'`. The game ends when there are no more `'?'` characters in `num`. For Bob to win, the sum of the digits in the first half of `num` must be **equal** to the sum of the digits in the second half. For Alice to win, the sums must **not be equal**. For example, if the game ended with `num = \"243801\"`, then Bob wins because `2+4+3 = 8+0+1`. If the game ended with `num = \"243803\"`, then Alice wins because `2+4+3 != 8+0+3`. Assuming Alice and Bob play **optimally**, return `true` _if Alice will win and _`false` _if Bob will win_. **Example 1:** ``` **Input:** num = \"5023\" **Output:** false **Explanation:** There are no moves to be made. The sum of the first half is equal to the sum of the second half: 5 + 0 = 2 + 3. ``` **Example 2:** ``` **Input:** num = \"25??\" **Output:** true **Explanation: **Alice can replace one of the '?'s with '9' and it will be impossible for Bob to make the sums equal. ``` **Example 3:** ``` **Input:** num = \"?3295???\" **Output:** false **Explanation:** It can be proven that Bob will always win. One possible outcome is: - Alice replaces the first '?' with '9'. num = \"93295???\". - Bob replaces one of the '?' in the right half with '9'. num = \"932959??\". - Alice replaces one of the '?' in the right half with '2'. num = \"9329592?\". - Bob replaces the last '?' in the right half with '7'. num = \"93295927\". Bob wins because 9 + 3 + 2 + 9 = 5 + 9 + 2 + 7. ``` **Constraints:** `2 <= num.length <= 105` `num.length` is **even**. `num` consists of only digits and `'?'`.",
        "test_case": [
            {
                "label": "Example 1",
                "input": "num = \"5023\"",
                "output": "false Explanation: There are no moves to be made.\nThe sum of the first half is equal to the sum of the second half: 5 + 0 = 2 + 3."
            },
            {
                "label": "Example 2",
                "input": "num = \"25??\"",
                "output": "true Explanation: Alice can replace one of the '?'s with '9' and it will be impossible for Bob to make the sums equal."
            },
            {
                "label": "Example 3",
                "input": "num = \"?3295???\"",
                "output": "false Explanation: It can be proven that Bob will always win. One possible outcome is:\n- Alice replaces the first '?' with '9'. num = \"93295???\".\n- Bob replaces one of the '?' in the right half with '9'. num = \"932959??\".\n- Alice replaces one of the '?' in the right half with '2'. num = \"9329592?\".\n- Bob replaces the last '?' in the right half with '7'. num = \"93295927\".\nBob wins because 9 + 3 + 2 + 9 = 5 + 9 + 2 + 7."
            }
        ],
        "elixir_template": "defmodule Solution do\n  @spec sum_game(num :: String.t) :: boolean\n  def sum_game(num) do\n    \n  end\nend",
        "erlang_template": "-spec sum_game(Num :: unicode:unicode_binary()) -> boolean().\nsum_game(Num) ->\n  .",
        "scala_template": "object Solution {\n    def sumGame(num: String): Boolean = {\n        \n    }\n}"
    },
    {
        "id": 2038,
        "name": "nearest-exit-from-entrance-in-maze",
        "difficulty": "Medium",
        "link": "https://leetcode.com/problems/nearest-exit-from-entrance-in-maze/",
        "task_description": "You are given an `m x n` matrix `maze` (**0-indexed**) with empty cells (represented as `'.'`) and walls (represented as `'+'`). You are also given the `entrance` of the maze, where `entrance = [entrancerow, entrancecol]` denotes the row and column of the cell you are initially standing at. In one step, you can move one cell **up**, **down**, **left**, or **right**. You cannot step into a cell with a wall, and you cannot step outside the maze. Your goal is to find the **nearest exit** from the `entrance`. An **exit** is defined as an **empty cell** that is at the **border** of the `maze`. The `entrance` **does not count** as an exit. Return _the **number of steps** in the shortest path from the _`entrance`_ to the nearest exit, or _`-1`_ if no such path exists_. **Example 1:** ``` **Input:** maze = [[\"+\",\"+\",\".\",\"+\"],[\".\",\".\",\".\",\"+\"],[\"+\",\"+\",\"+\",\".\"]], entrance = [1,2] **Output:** 1 **Explanation:** There are 3 exits in this maze at [1,0], [0,2], and [2,3]. Initially, you are at the entrance cell [1,2]. - You can reach [1,0] by moving 2 steps left. - You can reach [0,2] by moving 1 step up. It is impossible to reach [2,3] from the entrance. Thus, the nearest exit is [0,2], which is 1 step away. ``` **Example 2:** ``` **Input:** maze = [[\"+\",\"+\",\"+\"],[\".\",\".\",\".\"],[\"+\",\"+\",\"+\"]], entrance = [1,0] **Output:** 2 **Explanation:** There is 1 exit in this maze at [1,2]. [1,0] does not count as an exit since it is the entrance cell. Initially, you are at the entrance cell [1,0]. - You can reach [1,2] by moving 2 steps right. Thus, the nearest exit is [1,2], which is 2 steps away. ``` **Example 3:** ``` **Input:** maze = [[\".\",\"+\"]], entrance = [0,0] **Output:** -1 **Explanation:** There are no exits in this maze. ``` **Constraints:** `maze.length == m` `maze[i].length == n` `1 <= m, n <= 100` `maze[i][j]` is either `'.'` or `'+'`. `entrance.length == 2` `0 <= entrancerow < m` `0 <= entrancecol < n` `entrance` will always be an empty cell.",
        "test_case": [
            {
                "label": "Example 1",
                "input": "maze = [[\"+\",\"+\",\".\",\"+\"],[\".\",\".\",\".\",\"+\"],[\"+\",\"+\",\"+\",\".\"]], entrance = [1,2]",
                "output": "1 Explanation: There are 3 exits in this maze at [1,0], [0,2], and [2,3].\nInitially, you are at the entrance cell [1,2].\n- You can reach [1,0] by moving 2 steps left.\n- You can reach [0,2] by moving 1 step up.\nIt is impossible to reach [2,3] from the entrance.\nThus, the nearest exit is [0,2], which is 1 step away."
            },
            {
                "label": "Example 2",
                "input": "maze = [[\"+\",\"+\",\"+\"],[\".\",\".\",\".\"],[\"+\",\"+\",\"+\"]], entrance = [1,0]",
                "output": "2 Explanation: There is 1 exit in this maze at [1,2].\n[1,0] does not count as an exit since it is the entrance cell.\nInitially, you are at the entrance cell [1,0].\n- You can reach [1,2] by moving 2 steps right.\nThus, the nearest exit is [1,2], which is 2 steps away."
            },
            {
                "label": "Example 3",
                "input": "maze = [[\".\",\"+\"]], entrance = [0,0]",
                "output": "-1 Explanation: There are no exits in this maze. Constraints: maze.length == m maze[i].length == n 1 <= m, n <= 100 maze[i][j] is either '.' or '+' . entrance.length == 2 0 <= entrance row < m 0 <= entrance col < n entrance will always be an empty cell."
            }
        ],
        "elixir_template": "defmodule Solution do\n  @spec nearest_exit(maze :: [[char]], entrance :: [integer]) :: integer\n  def nearest_exit(maze, entrance) do\n    \n  end\nend",
        "erlang_template": "-spec nearest_exit(Maze :: [[char()]], Entrance :: [integer()]) -> integer().\nnearest_exit(Maze, Entrance) ->\n  .",
        "scala_template": "object Solution {\n    def nearestExit(maze: Array[Array[Char]], entrance: Array[Int]): Int = {\n        \n    }\n}"
    },
    {
        "id": 2037,
        "name": "count-square-sum-triples",
        "difficulty": "Easy",
        "link": "https://leetcode.com/problems/count-square-sum-triples/",
        "task_description": "A **square triple** `(a,b,c)` is a triple where `a`, `b`, and `c` are **integers** and `a2 + b2 = c2`. Given an integer `n`, return _the number of **square triples** such that _`1 <= a, b, c <= n`. **Example 1:** ``` **Input:** n = 5 **Output:** 2 **Explanation**: The square triples are (3,4,5) and (4,3,5). ``` **Example 2:** ``` **Input:** n = 10 **Output:** 4 **Explanation**: The square triples are (3,4,5), (4,3,5), (6,8,10), and (8,6,10). ``` **Constraints:** `1 <= n <= 250`",
        "test_case": [
            {
                "label": "Example 1",
                "input": "n = 5",
                "output": "2 Explanation : The square triples are (3,4,5) and (4,3,5)."
            },
            {
                "label": "Example 2",
                "input": "n = 10",
                "output": "4 Explanation : The square triples are (3,4,5), (4,3,5), (6,8,10), and (8,6,10)."
            }
        ],
        "elixir_template": "defmodule Solution do\n  @spec count_triples(n :: integer) :: integer\n  def count_triples(n) do\n    \n  end\nend",
        "erlang_template": "-spec count_triples(N :: integer()) -> integer().\ncount_triples(N) ->\n  .",
        "scala_template": "object Solution {\n    def countTriples(n: Int): Int = {\n        \n    }\n}"
    },
    {
        "id": 2035,
        "name": "count-sub-islands",
        "difficulty": "Medium",
        "link": "https://leetcode.com/problems/count-sub-islands/",
        "task_description": "You are given two `m x n` binary matrices `grid1` and `grid2` containing only `0`'s (representing water) and `1`'s (representing land). An **island** is a group of `1`'s connected **4-directionally** (horizontal or vertical). Any cells outside of the grid are considered water cells. An island in `grid2` is considered a **sub-island **if there is an island in `grid1` that contains **all** the cells that make up **this** island in `grid2`. Return the _**number** of islands in _`grid2` _that are considered **sub-islands**_. **Example 1:** ``` **Input:** grid1 = [[1,1,1,0,0],[0,1,1,1,1],[0,0,0,0,0],[1,0,0,0,0],[1,1,0,1,1]], grid2 = [[1,1,1,0,0],[0,0,1,1,1],[0,1,0,0,0],[1,0,1,1,0],[0,1,0,1,0]] **Output:** 3 **Explanation: **In the picture above, the grid on the left is grid1 and the grid on the right is grid2. The 1s colored red in grid2 are those considered to be part of a sub-island. There are three sub-islands. ``` **Example 2:** ``` **Input:** grid1 = [[1,0,1,0,1],[1,1,1,1,1],[0,0,0,0,0],[1,1,1,1,1],[1,0,1,0,1]], grid2 = [[0,0,0,0,0],[1,1,1,1,1],[0,1,0,1,0],[0,1,0,1,0],[1,0,0,0,1]] **Output:** 2 **Explanation: **In the picture above, the grid on the left is grid1 and the grid on the right is grid2. The 1s colored red in grid2 are those considered to be part of a sub-island. There are two sub-islands. ``` **Constraints:** `m == grid1.length == grid2.length` `n == grid1[i].length == grid2[i].length` `1 <= m, n <= 500` `grid1[i][j]` and `grid2[i][j]` are either `0` or `1`.",
        "test_case": [
            {
                "label": "Example 1",
                "input": "grid1 = [[1,1,1,0,0],[0,1,1,1,1],[0,0,0,0,0],[1,0,0,0,0],[1,1,0,1,1]], grid2 = [[1,1,1,0,0],[0,0,1,1,1],[0,1,0,0,0],[1,0,1,1,0],[0,1,0,1,0]]",
                "output": "3 Explanation: In the picture above, the grid on the left is grid1 and the grid on the right is grid2.\nThe 1s colored red in grid2 are those considered to be part of a sub-island. There are three sub-islands."
            },
            {
                "label": "Example 2",
                "input": "grid1 = [[1,0,1,0,1],[1,1,1,1,1],[0,0,0,0,0],[1,1,1,1,1],[1,0,1,0,1]], grid2 = [[0,0,0,0,0],[1,1,1,1,1],[0,1,0,1,0],[0,1,0,1,0],[1,0,0,0,1]]",
                "output": "2 Explanation: In the picture above, the grid on the left is grid1 and the grid on the right is grid2.\nThe 1s colored red in grid2 are those considered to be part of a sub-island. There are two sub-islands. Constraints: m == grid1.length == grid2.length n == grid1[i].length == grid2[i].length 1 <= m, n <= 500 grid1[i][j] and grid2[i][j] are either 0 or 1 ."
            }
        ],
        "elixir_template": "defmodule Solution do\n  @spec count_sub_islands(grid1 :: [[integer]], grid2 :: [[integer]]) :: integer\n  def count_sub_islands(grid1, grid2) do\n    \n  end\nend",
        "erlang_template": "-spec count_sub_islands(Grid1 :: [[integer()]], Grid2 :: [[integer()]]) -> integer().\ncount_sub_islands(Grid1, Grid2) ->\n  .",
        "scala_template": "object Solution {\n    def countSubIslands(grid1: Array[Array[Int]], grid2: Array[Array[Int]]): Int = {\n        \n    }\n}"
    },
    {
        "id": 2034,
        "name": "minimum-absolute-difference-queries",
        "difficulty": "Medium",
        "link": "https://leetcode.com/problems/minimum-absolute-difference-queries/",
        "task_description": "The **minimum absolute difference** of an array `a` is defined as the **minimum value** of `|a[i] - a[j]|`, where `0 <= i < j < a.length` and `a[i] != a[j]`. If all elements of `a` are the **same**, the minimum absolute difference is `-1`. For example, the minimum absolute difference of the array `[5,2,3,7,2]` is `|2 - 3| = 1`. Note that it is not `0` because `a[i]` and `a[j]` must be different. You are given an integer array `nums` and the array `queries` where `queries[i] = [li, ri]`. For each query `i`, compute the **minimum absolute difference** of the **subarray** `nums[li...ri]` containing the elements of `nums` between the **0-based** indices `li` and `ri` (**inclusive**). Return _an **array** _`ans` _where_ `ans[i]` _is the answer to the_ `ith` _query_. A **subarray** is a contiguous sequence of elements in an array. The value of `|x|` is defined as: `x` if `x >= 0`. `-x` if `x < 0`. **Example 1:** ``` **Input:** nums = [1,3,4,8], queries = [[0,1],[1,2],[2,3],[0,3]] **Output:** [2,1,4,1] **Explanation:** The queries are processed as follows: - queries[0] = [0,1]: The subarray is [1,3] and the minimum absolute difference is |1-3| = 2. - queries[1] = [1,2]: The subarray is [3,4] and the minimum absolute difference is |3-4| = 1. - queries[2] = [2,3]: The subarray is [4,8] and the minimum absolute difference is |4-8| = 4. - queries[3] = [0,3]: The subarray is [1,3,4,8] and the minimum absolute difference is |3-4| = 1. ``` **Example 2:** ``` **Input:** nums = [4,5,2,2,7,10], queries = [[2,3],[0,2],[0,5],[3,5]] **Output:** [-1,1,1,3] **Explanation: **The queries are processed as follows: - queries[0] = [2,3]: The subarray is [2,2] and the minimum absolute difference is -1 because all the elements are the same. - queries[1] = [0,2]: The subarray is [4,5,2] and the minimum absolute difference is |4-5| = 1. - queries[2] = [0,5]: The subarray is [4,5,2,2,7,10] and the minimum absolute difference is |4-5| = 1. - queries[3] = [3,5]: The subarray is [2,7,10] and the minimum absolute difference is |7-10| = 3. ``` **Constraints:** `2 <= nums.length <= 105` `1 <= nums[i] <= 100` `1 <= queries.length <= 2 * 104` `0 <= li < ri < nums.length`",
        "test_case": [
            {
                "label": "Example 1",
                "input": "nums = [1,3,4,8], queries = [[0,1],[1,2],[2,3],[0,3]]",
                "output": "[2,1,4,1] Explanation: The queries are processed as follows:\n- queries[0] = [0,1]: The subarray is [ 1 , 3 ] and the minimum absolute difference is |1-3| = 2.\n- queries[1] = [1,2]: The subarray is [ 3 , 4 ] and the minimum absolute difference is |3-4| = 1.\n- queries[2] = [2,3]: The subarray is [ 4 , 8 ] and the minimum absolute difference is |4-8| = 4.\n- queries[3] = [0,3]: The subarray is [1, 3 , 4 ,8] and the minimum absolute difference is |3-4| = 1."
            },
            {
                "label": "Example 2",
                "input": "nums = [4,5,2,2,7,10], queries = [[2,3],[0,2],[0,5],[3,5]]",
                "output": "[-1,1,1,3] Explanation: The queries are processed as follows:\n- queries[0] = [2,3]: The subarray is [2,2] and the minimum absolute difference is -1 because all the\n  elements are the same.\n- queries[1] = [0,2]: The subarray is [ 4 , 5 ,2] and the minimum absolute difference is |4-5| = 1.\n- queries[2] = [0,5]: The subarray is [ 4 , 5 ,2,2,7,10] and the minimum absolute difference is |4-5| = 1.\n- queries[3] = [3,5]: The subarray is [2, 7 , 10 ] and the minimum absolute difference is |7-10| = 3."
            }
        ],
        "elixir_template": "defmodule Solution do\n  @spec min_difference(nums :: [integer], queries :: [[integer]]) :: [integer]\n  def min_difference(nums, queries) do\n    \n  end\nend",
        "erlang_template": "-spec min_difference(Nums :: [integer()], Queries :: [[integer()]]) -> [integer()].\nmin_difference(Nums, Queries) ->\n  .",
        "scala_template": "object Solution {\n    def minDifference(nums: Array[Int], queries: Array[Array[Int]]): Array[Int] = {\n        \n    }\n}"
    },
    {
        "id": 2033,
        "name": "the-number-of-full-rounds-you-have-played",
        "difficulty": "Medium",
        "link": "https://leetcode.com/problems/the-number-of-full-rounds-you-have-played/",
        "task_description": "You are participating in an online chess tournament. There is a chess round that starts every `15` minutes. The first round of the day starts at `00:00`, and after every `15` minutes, a new round starts. For example, the second round starts at `00:15`, the fourth round starts at `00:45`, and the seventh round starts at `01:30`. You are given two strings `loginTime` and `logoutTime` where: `loginTime` is the time you will login to the game, and `logoutTime` is the time you will logout from the game. If `logoutTime` is **earlier** than `loginTime`, this means you have played from `loginTime` to midnight and from midnight to `logoutTime`. Return _the number of full chess rounds you have played in the tournament_. **Note:** All the given times follow the 24-hour clock. That means the first round of the day starts at `00:00` and the last round of the day starts at `23:45`. **Example 1:** ``` **Input:** loginTime = \"09:31\", logoutTime = \"10:14\" **Output:** 1 **Explanation:** You played one full round from 09:45 to 10:00. You did not play the full round from 09:30 to 09:45 because you logged in at 09:31 after it began. You did not play the full round from 10:00 to 10:15 because you logged out at 10:14 before it ended. ``` **Example 2:** ``` **Input:** loginTime = \"21:30\", logoutTime = \"03:00\" **Output:** 22 **Explanation:** You played 10 full rounds from 21:30 to 00:00 and 12 full rounds from 00:00 to 03:00. 10 + 12 = 22. ``` **Constraints:** `loginTime` and `logoutTime` are in the format `hh:mm`. `00 <= hh <= 23` `00 <= mm <= 59` `loginTime` and `logoutTime` are not equal.",
        "test_case": [
            {
                "label": "Example 1",
                "input": "loginTime = \"09:31\", logoutTime = \"10:14\"",
                "output": "1 Explanation: You played one full round from 09:45 to 10:00.\nYou did not play the full round from 09:30 to 09:45 because you logged in at 09:31 after it began.\nYou did not play the full round from 10:00 to 10:15 because you logged out at 10:14 before it ended."
            },
            {
                "label": "Example 2",
                "input": "loginTime = \"21:30\", logoutTime = \"03:00\"",
                "output": "22 Explanation: You played 10 full rounds from 21:30 to 00:00 and 12 full rounds from 00:00 to 03:00.\n10 + 12 = 22. Constraints: loginTime and logoutTime are in the format hh:mm . 00 <= hh <= 23 00 <= mm <= 59 loginTime and logoutTime are not equal."
            }
        ],
        "elixir_template": "defmodule Solution do\n  @spec number_of_rounds(login_time :: String.t, logout_time :: String.t) :: integer\n  def number_of_rounds(login_time, logout_time) do\n    \n  end\nend",
        "erlang_template": "-spec number_of_rounds(LoginTime :: unicode:unicode_binary(), LogoutTime :: unicode:unicode_binary()) -> integer().\nnumber_of_rounds(LoginTime, LogoutTime) ->\n  .",
        "scala_template": "object Solution {\n    def numberOfRounds(loginTime: String, logoutTime: String): Int = {\n        \n    }\n}"
    },
    {
        "id": 2032,
        "name": "largest-odd-number-in-string",
        "difficulty": "Easy",
        "link": "https://leetcode.com/problems/largest-odd-number-in-string/",
        "task_description": "You are given a string `num`, representing a large integer. Return _the **largest-valued odd** integer (as a string) that is a **non-empty substring** of _`num`_, or an empty string _`\"\"`_ if no odd integer exists_. A **substring** is a contiguous sequence of characters within a string. **Example 1:** ``` **Input:** num = \"52\" **Output:** \"5\" **Explanation:** The only non-empty substrings are \"5\", \"2\", and \"52\". \"5\" is the only odd number. ``` **Example 2:** ``` **Input:** num = \"4206\" **Output:** \"\" **Explanation:** There are no odd numbers in \"4206\". ``` **Example 3:** ``` **Input:** num = \"35427\" **Output:** \"35427\" **Explanation:** \"35427\" is already an odd number. ``` **Constraints:** `1 <= num.length <= 105` `num` only consists of digits and does not contain any leading zeros.",
        "test_case": [
            {
                "label": "Example 1",
                "input": "num = \"52\"",
                "output": "\"5\" Explanation: The only non-empty substrings are \"5\", \"2\", and \"52\". \"5\" is the only odd number."
            },
            {
                "label": "Example 2",
                "input": "num = \"4206\"",
                "output": "\"\" Explanation: There are no odd numbers in \"4206\"."
            },
            {
                "label": "Example 3",
                "input": "num = \"35427\"",
                "output": "\"35427\" Explanation: \"35427\" is already an odd number."
            }
        ],
        "elixir_template": "defmodule Solution do\n  @spec largest_odd_number(num :: String.t) :: String.t\n  def largest_odd_number(num) do\n    \n  end\nend",
        "erlang_template": "-spec largest_odd_number(Num :: unicode:unicode_binary()) -> unicode:unicode_binary().\nlargest_odd_number(Num) ->\n  .",
        "scala_template": "object Solution {\n    def largestOddNumber(num: String): String = {\n        \n    }\n}"
    },
    {
        "id": 2031,
        "name": "egg-drop-with-2-eggs-and-n-floors",
        "difficulty": "Medium",
        "link": "https://leetcode.com/problems/egg-drop-with-2-eggs-and-n-floors/",
        "task_description": "You are given **two identical** eggs and you have access to a building with `n` floors labeled from `1` to `n`. You know that there exists a floor `f` where `0 <= f <= n` such that any egg dropped at a floor **higher** than `f` will **break**, and any egg dropped **at or below** floor `f` will **not break**. In each move, you may take an **unbroken** egg and drop it from any floor `x` (where `1 <= x <= n`). If the egg breaks, you can no longer use it. However, if the egg does not break, you may **reuse** it in future moves. Return _the **minimum number of moves** that you need to determine **with certainty** what the value of _`f` is. **Example 1:** ``` **Input:** n = 2 **Output:** 2 **Explanation:** We can drop the first egg from floor 1 and the second egg from floor 2. If the first egg breaks, we know that f = 0. If the second egg breaks but the first egg didn't, we know that f = 1. Otherwise, if both eggs survive, we know that f = 2. ``` **Example 2:** ``` **Input:** n = 100 **Output:** 14 **Explanation:** One optimal strategy is: - Drop the 1st egg at floor 9. If it breaks, we know f is between 0 and 8. Drop the 2nd egg starting from floor 1 and going up one at a time to find f within 8 more drops. Total drops is 1 + 8 = 9. - If the 1st egg does not break, drop the 1st egg again at floor 22. If it breaks, we know f is between 9 and 21. Drop the 2nd egg starting from floor 10 and going up one at a time to find f within 12 more drops. Total drops is 2 + 12 = 14. - If the 1st egg does not break again, follow a similar process dropping the 1st egg from floors 34, 45, 55, 64, 72, 79, 85, 90, 94, 97, 99, and 100. Regardless of the outcome, it takes at most 14 drops to determine f. ``` **Constraints:** `1 <= n <= 1000`",
        "test_case": [
            {
                "label": "Example 1",
                "input": "n = 2",
                "output": "2 Explanation: We can drop the first egg from floor 1 and the second egg from floor 2.\nIf the first egg breaks, we know that f = 0.\nIf the second egg breaks but the first egg didn't, we know that f = 1.\nOtherwise, if both eggs survive, we know that f = 2."
            },
            {
                "label": "Example 2",
                "input": "n = 100",
                "output": "14 Explanation: One optimal strategy is:\n- Drop the 1st egg at floor 9. If it breaks, we know f is between 0 and 8. Drop the 2nd egg starting from floor 1 and going up one at a time to find f within 8 more drops. Total drops is 1 + 8 = 9.\n- If the 1st egg does not break, drop the 1st egg again at floor 22. If it breaks, we know f is between 9 and 21. Drop the 2nd egg starting from floor 10 and going up one at a time to find f within 12 more drops. Total drops is 2 + 12 = 14.\n- If the 1st egg does not break again, follow a similar process dropping the 1st egg from floors 34, 45, 55, 64, 72, 79, 85, 90, 94, 97, 99, and 100.\nRegardless of the outcome, it takes at most 14 drops to determine f."
            }
        ],
        "elixir_template": "defmodule Solution do\n  @spec two_egg_drop(n :: integer) :: integer\n  def two_egg_drop(n) do\n    \n  end\nend",
        "erlang_template": "-spec two_egg_drop(N :: integer()) -> integer().\ntwo_egg_drop(N) ->\n  .",
        "scala_template": "object Solution {\n    def twoEggDrop(n: Int): Int = {\n        \n    }\n}"
    },
    {
        "id": 2028,
        "name": "the-earliest-and-latest-rounds-where-players-compete",
        "difficulty": "Hard",
        "link": "https://leetcode.com/problems/the-earliest-and-latest-rounds-where-players-compete/",
        "task_description": "There is a tournament where `n` players are participating. The players are standing in a single row and are numbered from `1` to `n` based on their **initial** standing position (player `1` is the first player in the row, player `2` is the second player in the row, etc.). The tournament consists of multiple rounds (starting from round number `1`). In each round, the `ith` player from the front of the row competes against the `ith` player from the end of the row, and the winner advances to the next round. When the number of players is odd for the current round, the player in the middle automatically advances to the next round. For example, if the row consists of players `1, 2, 4, 6, 7` Player `1` competes against player `7`. Player `2` competes against player `6`. Player `4` automatically advances to the next round. After each round is over, the winners are lined back up in the row based on the **original ordering** assigned to them initially (ascending order). The players numbered `firstPlayer` and `secondPlayer` are the best in the tournament. They can win against any other player before they compete against each other. If any two other players compete against each other, either of them might win, and thus you may **choose** the outcome of this round. Given the integers `n`, `firstPlayer`, and `secondPlayer`, return _an integer array containing two values, the **earliest** possible round number and the **latest** possible round number in which these two players will compete against each other, respectively_. **Example 1:** ``` **Input:** n = 11, firstPlayer = 2, secondPlayer = 4 **Output:** [3,4] **Explanation:** One possible scenario which leads to the earliest round number: First round: 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11 Second round: 2, 3, 4, 5, 6, 11 Third round: 2, 3, 4 One possible scenario which leads to the latest round number: First round: 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11 Second round: 1, 2, 3, 4, 5, 6 Third round: 1, 2, 4 Fourth round: 2, 4 ``` **Example 2:** ``` **Input:** n = 5, firstPlayer = 1, secondPlayer = 5 **Output:** [1,1] **Explanation:** The players numbered 1 and 5 compete in the first round. There is no way to make them compete in any other round. ``` **Constraints:** `2 <= n <= 28` `1 <= firstPlayer < secondPlayer <= n`",
        "test_case": [
            {
                "label": "Example 1",
                "input": "n = 11, firstPlayer = 2, secondPlayer = 4",
                "output": "[3,4] Explanation: One possible scenario which leads to the earliest round number:\nFirst round: 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11\nSecond round: 2, 3, 4, 5, 6, 11\nThird round: 2, 3, 4\nOne possible scenario which leads to the latest round number:\nFirst round: 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11\nSecond round: 1, 2, 3, 4, 5, 6\nThird round: 1, 2, 4\nFourth round: 2, 4"
            },
            {
                "label": "Example 2",
                "input": "n = 5, firstPlayer = 1, secondPlayer = 5",
                "output": "[1,1] Explanation: The players numbered 1 and 5 compete in the first round.\nThere is no way to make them compete in any other round."
            }
        ],
        "elixir_template": "defmodule Solution do\n  @spec earliest_and_latest(n :: integer, first_player :: integer, second_player :: integer) :: [integer]\n  def earliest_and_latest(n, first_player, second_player) do\n    \n  end\nend",
        "erlang_template": "-spec earliest_and_latest(N :: integer(), FirstPlayer :: integer(), SecondPlayer :: integer()) -> [integer()].\nearliest_and_latest(N, FirstPlayer, SecondPlayer) ->\n  .",
        "scala_template": "object Solution {\n    def earliestAndLatest(n: Int, firstPlayer: Int, secondPlayer: Int): Array[Int] = {\n        \n    }\n}"
    },
    {
        "id": 2027,
        "name": "maximum-number-of-removable-characters",
        "difficulty": "Medium",
        "link": "https://leetcode.com/problems/maximum-number-of-removable-characters/",
        "task_description": "You are given two strings `s` and `p` where `p` is a **subsequence **of `s`. You are also given a **distinct 0-indexed **integer array `removable` containing a subset of indices of `s` (`s` is also **0-indexed**). You want to choose an integer `k` (`0 <= k <= removable.length`) such that, after removing `k` characters from `s` using the **first** `k` indices in `removable`, `p` is still a **subsequence** of `s`. More formally, you will mark the character at `s[removable[i]]` for each `0 <= i < k`, then remove all marked characters and check if `p` is still a subsequence. Return _the **maximum** _`k`_ you can choose such that _`p`_ is still a **subsequence** of _`s`_ after the removals_. A **subsequence** of a string is a new string generated from the original string with some characters (can be none) deleted without changing the relative order of the remaining characters. **Example 1:** ``` **Input:** s = \"abcacb\", p = \"ab\", removable = [3,1,0] **Output:** 2 **Explanation**: After removing the characters at indices 3 and 1, \"a**b**c**a**cb\" becomes \"accb\". \"ab\" is a subsequence of \"**a**cc**b**\". If we remove the characters at indices 3, 1, and 0, \"**ab**c**a**cb\" becomes \"ccb\", and \"ab\" is no longer a subsequence. Hence, the maximum k is 2. ``` **Example 2:** ``` **Input:** s = \"abcbddddd\", p = \"abcd\", removable = [3,2,1,4,5,6] **Output:** 1 **Explanation**: After removing the character at index 3, \"abc**b**ddddd\" becomes \"abcddddd\". \"abcd\" is a subsequence of \"**abcd**dddd\". ``` **Example 3:** ``` **Input:** s = \"abcab\", p = \"abc\", removable = [0,1,2,3,4] **Output:** 0 **Explanation**: If you remove the first index in the array removable, \"abc\" is no longer a subsequence. ``` **Constraints:** `1 <= p.length <= s.length <= 105` `0 <= removable.length < s.length` `0 <= removable[i] < s.length` `p` is a **subsequence** of `s`. `s` and `p` both consist of lowercase English letters. The elements in `removable` are **distinct**.",
        "test_case": [
            {
                "label": "Example 1",
                "input": "s = \"abcacb\", p = \"ab\", removable = [3,1,0]",
                "output": "2 Explanation : After removing the characters at indices 3 and 1, \"a b c a cb\" becomes \"accb\".\n\"ab\" is a subsequence of \" a cc b \".\nIf we remove the characters at indices 3, 1, and 0, \" ab c a cb\" becomes \"ccb\", and \"ab\" is no longer a subsequence.\nHence, the maximum k is 2."
            },
            {
                "label": "Example 2",
                "input": "s = \"abcbddddd\", p = \"abcd\", removable = [3,2,1,4,5,6]",
                "output": "1 Explanation : After removing the character at index 3, \"abc b ddddd\" becomes \"abcddddd\".\n\"abcd\" is a subsequence of \" abcd dddd\"."
            },
            {
                "label": "Example 3",
                "input": "s = \"abcab\", p = \"abc\", removable = [0,1,2,3,4]",
                "output": "0 Explanation : If you remove the first index in the array removable, \"abc\" is no longer a subsequence."
            }
        ],
        "elixir_template": "defmodule Solution do\n  @spec maximum_removals(s :: String.t, p :: String.t, removable :: [integer]) :: integer\n  def maximum_removals(s, p, removable) do\n    \n  end\nend",
        "erlang_template": "-spec maximum_removals(S :: unicode:unicode_binary(), P :: unicode:unicode_binary(), Removable :: [integer()]) -> integer().\nmaximum_removals(S, P, Removable) ->\n  .",
        "scala_template": "object Solution {\n    def maximumRemovals(s: String, p: String, removable: Array[Int]): Int = {\n        \n    }\n}"
    },
    {
        "id": 2026,
        "name": "merge-triplets-to-form-target-triplet",
        "difficulty": "Medium",
        "link": "https://leetcode.com/problems/merge-triplets-to-form-target-triplet/",
        "task_description": "A **triplet** is an array of three integers. You are given a 2D integer array `triplets`, where `triplets[i] = [ai, bi, ci]` describes the `ith` **triplet**. You are also given an integer array `target = [x, y, z]` that describes the **triplet** you want to obtain. To obtain `target`, you may apply the following operation on `triplets` **any number** of times (possibly **zero**): Choose two indices (**0-indexed**) `i` and `j` (`i != j`) and **update** `triplets[j]` to become `[max(ai, aj), max(bi, bj), max(ci, cj)]`. For example, if `triplets[i] = [2, 5, 3]` and `triplets[j] = [1, 7, 5]`, `triplets[j]` will be updated to `[max(2, 1), max(5, 7), max(3, 5)] = [2, 7, 5]`. Return `true` _if it is possible to obtain the _`target`_ **triplet** _`[x, y, z]`_ as an** element** of _`triplets`_, or _`false`_ otherwise_. **Example 1:** ``` **Input:** triplets = [[2,5,3],[1,8,4],[1,7,5]], target = [2,7,5] **Output:** true **Explanation:** Perform the following operations: - Choose the first and last triplets [[2,5,3],[1,8,4],[1,7,5]]. Update the last triplet to be [max(2,1), max(5,7), max(3,5)] = [2,7,5]. triplets = [[2,5,3],[1,8,4],[2,7,5]] The target triplet [2,7,5] is now an element of triplets. ``` **Example 2:** ``` **Input:** triplets = [[3,4,5],[4,5,6]], target = [3,2,5] **Output:** false **Explanation:** It is impossible to have [3,2,5] as an element because there is no 2 in any of the triplets. ``` **Example 3:** ``` **Input:** triplets = [[2,5,3],[2,3,4],[1,2,5],[5,2,3]], target = [5,5,5] **Output:** true **Explanation: **Perform the following operations: - Choose the first and third triplets [[2,5,3],[2,3,4],[1,2,5],[5,2,3]]. Update the third triplet to be [max(2,1), max(5,2), max(3,5)] = [2,5,5]. triplets = [[2,5,3],[2,3,4],[2,5,5],[5,2,3]]. - Choose the third and fourth triplets [[2,5,3],[2,3,4],[2,5,5],[5,2,3]]. Update the fourth triplet to be [max(2,5), max(5,2), max(5,3)] = [5,5,5]. triplets = [[2,5,3],[2,3,4],[2,5,5],[5,5,5]]. The target triplet [5,5,5] is now an element of triplets. ``` **Constraints:** `1 <= triplets.length <= 105` `triplets[i].length == target.length == 3` `1 <= ai, bi, ci, x, y, z <= 1000`",
        "test_case": [
            {
                "label": "Example 1",
                "input": "triplets = [[2,5,3],[1,8,4],[1,7,5]], target = [2,7,5]",
                "output": "true Explanation: Perform the following operations:\n- Choose the first and last triplets [ [2,5,3] ,[1,8,4], [1,7,5] ]. Update the last triplet to be [max(2,1), max(5,7), max(3,5)] = [2,7,5]. triplets = [[2,5,3],[1,8,4], [2,7,5] ]\nThe target triplet [2,7,5] is now an element of triplets."
            },
            {
                "label": "Example 2",
                "input": "triplets = [[3,4,5],[4,5,6]], target = [3,2,5]",
                "output": "false Explanation: It is impossible to have [3,2,5] as an element because there is no 2 in any of the triplets."
            },
            {
                "label": "Example 3",
                "input": "triplets = [[2,5,3],[2,3,4],[1,2,5],[5,2,3]], target = [5,5,5]",
                "output": "true Explanation: Perform the following operations:\n- Choose the first and third triplets [ [2,5,3] ,[2,3,4], [1,2,5] ,[5,2,3]]. Update the third triplet to be [max(2,1), max(5,2), max(3,5)] = [2,5,5]. triplets = [[2,5,3],[2,3,4], [2,5,5] ,[5,2,3]].\n- Choose the third and fourth triplets [[2,5,3],[2,3,4], [2,5,5] , [5,2,3] ]. Update the fourth triplet to be [max(2,5), max(5,2), max(5,3)] = [5,5,5]. triplets = [[2,5,3],[2,3,4],[2,5,5], [5,5,5] ].\nThe target triplet [5,5,5] is now an element of triplets."
            }
        ],
        "elixir_template": "defmodule Solution do\n  @spec merge_triplets(triplets :: [[integer]], target :: [integer]) :: boolean\n  def merge_triplets(triplets, target) do\n    \n  end\nend",
        "erlang_template": "-spec merge_triplets(Triplets :: [[integer()]], Target :: [integer()]) -> boolean().\nmerge_triplets(Triplets, Target) ->\n  .",
        "scala_template": "object Solution {\n    def mergeTriplets(triplets: Array[Array[Int]], target: Array[Int]): Boolean = {\n        \n    }\n}"
    },
    {
        "id": 2025,
        "name": "redistribute-characters-to-make-all-strings-equal",
        "difficulty": "Easy",
        "link": "https://leetcode.com/problems/redistribute-characters-to-make-all-strings-equal/",
        "task_description": "You are given an array of strings `words` (**0-indexed**). In one operation, pick two **distinct** indices `i` and `j`, where `words[i]` is a non-empty string, and move **any** character from `words[i]` to **any** position in `words[j]`. Return `true` _if you can make** every** string in _`words`_ **equal **using **any** number of operations_,_ and _`false` _otherwise_. **Example 1:** ``` **Input:** words = [\"abc\",\"aabc\",\"bc\"] **Output:** true **Explanation:** Move the first 'a' in `words[1] to the front of words[2], to make ``words[1]` = \"abc\" and words[2] = \"abc\". All the strings are now equal to \"abc\", so return `true`. ``` **Example 2:** ``` **Input:** words = [\"ab\",\"a\"] **Output:** false **Explanation:** It is impossible to make all the strings equal using the operation. ``` **Constraints:** `1 <= words.length <= 100` `1 <= words[i].length <= 100` `words[i]` consists of lowercase English letters.",
        "test_case": [
            {
                "label": "Example 1",
                "input": "words = [\"abc\",\"aabc\",\"bc\"]",
                "output": "true Explanation: Move the first 'a' in words[1] to the front of words[2],\nto make words[1] = \"abc\" and words[2] = \"abc\".\nAll the strings are now equal to \"abc\", so return true ."
            },
            {
                "label": "Example 2",
                "input": "words = [\"ab\",\"a\"]",
                "output": "false Explanation: It is impossible to make all the strings equal using the operation."
            }
        ],
        "elixir_template": "defmodule Solution do\n  @spec make_equal(words :: [String.t]) :: boolean\n  def make_equal(words) do\n    \n  end\nend",
        "erlang_template": "-spec make_equal(Words :: [unicode:unicode_binary()]) -> boolean().\nmake_equal(Words) ->\n  .",
        "scala_template": "object Solution {\n    def makeEqual(words: Array[String]): Boolean = {\n        \n    }\n}"
    },
    {
        "id": 2023,
        "name": "design-movie-rental-system",
        "difficulty": "Hard",
        "link": "https://leetcode.com/problems/design-movie-rental-system/",
        "task_description": "You have a movie renting company consisting of `n` shops. You want to implement a renting system that supports searching for, booking, and returning movies. The system should also support generating a report of the currently rented movies. Each movie is given as a 2D integer array `entries` where `entries[i] = [shopi, moviei, pricei]` indicates that there is a copy of movie `moviei` at shop `shopi` with a rental price of `pricei`. Each shop carries **at most one** copy of a movie `moviei`. The system should support the following functions: **Search**: Finds the **cheapest 5 shops** that have an **unrented copy** of a given movie. The shops should be sorted by **price** in ascending order, and in case of a tie, the one with the **smaller **`shopi` should appear first. If there are less than 5 matching shops, then all of them should be returned. If no shop has an unrented copy, then an empty list should be returned. **Rent**: Rents an **unrented copy** of a given movie from a given shop. **Drop**: Drops off a **previously rented copy** of a given movie at a given shop. **Report**: Returns the **cheapest 5 rented movies** (possibly of the same movie ID) as a 2D list `res` where `res[j] = [shopj, moviej]` describes that the `jth` cheapest rented movie `moviej` was rented from the shop `shopj`. The movies in `res` should be sorted by **price **in ascending order, and in case of a tie, the one with the **smaller **`shopj` should appear first, and if there is still tie, the one with the **smaller **`moviej` should appear first. If there are fewer than 5 rented movies, then all of them should be returned. If no movies are currently being rented, then an empty list should be returned. Implement the `MovieRentingSystem` class: `MovieRentingSystem(int n, int[][] entries)` Initializes the `MovieRentingSystem` object with `n` shops and the movies in `entries`. `List<Integer> search(int movie)` Returns a list of shops that have an **unrented copy** of the given `movie` as described above. `void rent(int shop, int movie)` Rents the given `movie` from the given `shop`. `void drop(int shop, int movie)` Drops off a previously rented `movie` at the given `shop`. `List<List<Integer>> report()` Returns a list of cheapest **rented** movies as described above. **Note:** The test cases will be generated such that `rent` will only be called if the shop has an **unrented** copy of the movie, and `drop` will only be called if the shop had **previously rented** out the movie. **Example 1:** ``` **Input** [\"MovieRentingSystem\", \"search\", \"rent\", \"rent\", \"report\", \"drop\", \"search\"] [[3, [[0, 1, 5], [0, 2, 6], [0, 3, 7], [1, 1, 4], [1, 2, 7], [2, 1, 5]]], [1], [0, 1], [1, 2], [], [1, 2], [2]] **Output** [null, [1, 0, 2], null, null, [[0, 1], [1, 2]], null, [0, 1]] **Explanation** MovieRentingSystem movieRentingSystem = new MovieRentingSystem(3, [[0, 1, 5], [0, 2, 6], [0, 3, 7], [1, 1, 4], [1, 2, 7], [2, 1, 5]]); movieRentingSystem.search(1); // return [1, 0, 2], Movies of ID 1 are unrented at shops 1, 0, and 2. Shop 1 is cheapest; shop 0 and 2 are the same price, so order by shop number. movieRentingSystem.rent(0, 1); // Rent movie 1 from shop 0. Unrented movies at shop 0 are now [2,3]. movieRentingSystem.rent(1, 2); // Rent movie 2 from shop 1. Unrented movies at shop 1 are now [1]. movieRentingSystem.report(); // return [[0, 1], [1, 2]]. Movie 1 from shop 0 is cheapest, followed by movie 2 from shop 1. movieRentingSystem.drop(1, 2); // Drop off movie 2 at shop 1. Unrented movies at shop 1 are now [1,2]. movieRentingSystem.search(2); // return [0, 1]. Movies of ID 2 are unrented at shops 0 and 1. Shop 0 is cheapest, followed by shop 1. ``` **Constraints:** `1 <= n <= 3 * 105` `1 <= entries.length <= 105` `0 <= shopi < n` `1 <= moviei, pricei <= 104` Each shop carries **at most one** copy of a movie `moviei`. At most `105` calls **in total** will be made to `search`, `rent`, `drop` and `report`.",
        "test_case": [],
        "elixir_template": "defmodule MovieRentingSystem do\n  @spec init_(n :: integer, entries :: [[integer]]) :: any\n  def init_(n, entries) do\n    \n  end\n\n  @spec search(movie :: integer) :: [integer]\n  def search(movie) do\n    \n  end\n\n  @spec rent(shop :: integer, movie :: integer) :: any\n  def rent(shop, movie) do\n    \n  end\n\n  @spec drop(shop :: integer, movie :: integer) :: any\n  def drop(shop, movie) do\n    \n  end\n\n  @spec report() :: [[integer]]\n  def report() do\n    \n  end\nend\n\n# Your functions will be called as such:\n# MovieRentingSystem.init_(n, entries)\n# param_1 = MovieRentingSystem.search(movie)\n# MovieRentingSystem.rent(shop, movie)\n# MovieRentingSystem.drop(shop, movie)\n# param_4 = MovieRentingSystem.report()\n\n# MovieRentingSystem.init_ will be called before every test case, in which you can do some necessary initializations.",
        "erlang_template": "-spec movie_renting_system_init_(N :: integer(), Entries :: [[integer()]]) -> any().\nmovie_renting_system_init_(N, Entries) ->\n  .\n\n-spec movie_renting_system_search(Movie :: integer()) -> [integer()].\nmovie_renting_system_search(Movie) ->\n  .\n\n-spec movie_renting_system_rent(Shop :: integer(), Movie :: integer()) -> any().\nmovie_renting_system_rent(Shop, Movie) ->\n  .\n\n-spec movie_renting_system_drop(Shop :: integer(), Movie :: integer()) -> any().\nmovie_renting_system_drop(Shop, Movie) ->\n  .\n\n-spec movie_renting_system_report() -> [[integer()]].\nmovie_renting_system_report() ->\n  .\n\n\n%% Your functions will be called as such:\n%% movie_renting_system_init_(N, Entries),\n%% Param_1 = movie_renting_system_search(Movie),\n%% movie_renting_system_rent(Shop, Movie),\n%% movie_renting_system_drop(Shop, Movie),\n%% Param_4 = movie_renting_system_report(),\n\n%% movie_renting_system_init_ will be called before every test case, in which you can do some necessary initializations.",
        "scala_template": "class MovieRentingSystem(_n: Int, _entries: Array[Array[Int]]) {\n\n    def search(movie: Int): List[Int] = {\n        \n    }\n\n    def rent(shop: Int, movie: Int): Unit = {\n        \n    }\n\n    def drop(shop: Int, movie: Int): Unit = {\n        \n    }\n\n    def report(): List[List[Int]] = {\n        \n    }\n\n}\n\n/**\n * Your MovieRentingSystem object will be instantiated and called as such:\n * val obj = new MovieRentingSystem(n, entries)\n * val param_1 = obj.search(movie)\n * obj.rent(shop,movie)\n * obj.drop(shop,movie)\n * val param_4 = obj.report()\n */"
    },
    {
        "id": 2022,
        "name": "maximum-alternating-subsequence-sum",
        "difficulty": "Medium",
        "link": "https://leetcode.com/problems/maximum-alternating-subsequence-sum/",
        "task_description": "The **alternating sum** of a **0-indexed** array is defined as the **sum** of the elements at **even** indices **minus** the **sum** of the elements at **odd** indices. For example, the alternating sum of `[4,2,5,3]` is `(4 + 5) - (2 + 3) = 4`. Given an array `nums`, return _the **maximum alternating sum** of any subsequence of _`nums`_ (after **reindexing** the elements of the subsequence)_. A **subsequence** of an array is a new array generated from the original array by deleting some elements (possibly none) without changing the remaining elements' relative order. For example, `[2,7,4]` is a subsequence of `[4,2,3,7,2,1,4]` (the underlined elements), while `[2,4,2]` is not. **Example 1:** ``` **Input:** nums = [4,2,5,3] **Output:** 7 **Explanation:** It is optimal to choose the subsequence [4,2,5] with alternating sum (4 + 5) - 2 = 7. ``` **Example 2:** ``` **Input:** nums = [5,6,7,8] **Output:** 8 **Explanation:** It is optimal to choose the subsequence [8] with alternating sum 8. ``` **Example 3:** ``` **Input:** nums = [6,2,1,2,4,5] **Output:** 10 **Explanation:** It is optimal to choose the subsequence [6,1,5] with alternating sum (6 + 5) - 1 = 10. ``` **Constraints:** `1 <= nums.length <= 105` `1 <= nums[i] <= 105`",
        "test_case": [
            {
                "label": "Example 1",
                "input": "nums = [ 4 , 2 , 5 ,3]",
                "output": "7 Explanation: It is optimal to choose the subsequence [4,2,5] with alternating sum (4 + 5) - 2 = 7."
            },
            {
                "label": "Example 2",
                "input": "nums = [5,6,7, 8 ]",
                "output": "8 Explanation: It is optimal to choose the subsequence [8] with alternating sum 8."
            },
            {
                "label": "Example 3",
                "input": "nums = [ 6 ,2, 1 ,2,4, 5 ]",
                "output": "10 Explanation: It is optimal to choose the subsequence [6,1,5] with alternating sum (6 + 5) - 1 = 10."
            }
        ],
        "elixir_template": "Elixir code template not available for this problem.",
        "erlang_template": "Elixir code template not available for this problem.",
        "scala_template": "object Solution {\r\n    def maxAlternatingSum(nums: Array[Int]): Long = {\r\n        \r\n    }\r\n}"
    },
    {
        "id": 2021,
        "name": "remove-all-occurrences-of-a-substring",
        "difficulty": "Medium",
        "link": "https://leetcode.com/problems/remove-all-occurrences-of-a-substring/",
        "task_description": "Given two strings `s` and `part`, perform the following operation on `s` until **all** occurrences of the substring `part` are removed: Find the **leftmost** occurrence of the substring `part` and **remove** it from `s`. Return `s`_ after removing all occurrences of _`part`. A **substring** is a contiguous sequence of characters in a string. **Example 1:** ``` **Input:** s = \"daabcbaabcbc\", part = \"abc\" **Output:** \"dab\" **Explanation**: The following operations are done: - s = \"da**abc**baabcbc\", remove \"abc\" starting at index 2, so s = \"dabaabcbc\". - s = \"daba**abc**bc\", remove \"abc\" starting at index 4, so s = \"dababc\". - s = \"dab**abc**\", remove \"abc\" starting at index 3, so s = \"dab\". Now s has no occurrences of \"abc\". ``` **Example 2:** ``` **Input:** s = \"axxxxyyyyb\", part = \"xy\" **Output:** \"ab\" **Explanation**: The following operations are done: - s = \"axxx**xy**yyyb\", remove \"xy\" starting at index 4 so s = \"axxxyyyb\". - s = \"axx**xy**yyb\", remove \"xy\" starting at index 3 so s = \"axxyyb\". - s = \"ax**xy**yb\", remove \"xy\" starting at index 2 so s = \"axyb\". - s = \"a**xy**b\", remove \"xy\" starting at index 1 so s = \"ab\". Now s has no occurrences of \"xy\". ``` **Constraints:** `1 <= s.length <= 1000` `1 <= part.length <= 1000` `s`\u200b\u200b\u200b\u200b\u200b\u200b and `part` consists of lowercase English letters.",
        "test_case": [
            {
                "label": "Example 1",
                "input": "s = \"daabcbaabcbc\", part = \"abc\"",
                "output": "\"dab\" Explanation : The following operations are done:\n- s = \"da abc baabcbc\", remove \"abc\" starting at index 2, so s = \"dabaabcbc\".\n- s = \"daba abc bc\", remove \"abc\" starting at index 4, so s = \"dababc\".\n- s = \"dab abc \", remove \"abc\" starting at index 3, so s = \"dab\".\nNow s has no occurrences of \"abc\"."
            },
            {
                "label": "Example 2",
                "input": "s = \"axxxxyyyyb\", part = \"xy\"",
                "output": "\"ab\" Explanation : The following operations are done:\n- s = \"axxx xy yyyb\", remove \"xy\" starting at index 4 so s = \"axxxyyyb\".\n- s = \"axx xy yyb\", remove \"xy\" starting at index 3 so s = \"axxyyb\".\n- s = \"ax xy yb\", remove \"xy\" starting at index 2 so s = \"axyb\".\n- s = \"a xy b\", remove \"xy\" starting at index 1 so s = \"ab\".\nNow s has no occurrences of \"xy\"."
            }
        ],
        "elixir_template": "defmodule Solution do\n  @spec remove_occurrences(s :: String.t, part :: String.t) :: String.t\n  def remove_occurrences(s, part) do\n    \n  end\nend",
        "erlang_template": "-spec remove_occurrences(S :: unicode:unicode_binary(), Part :: unicode:unicode_binary()) -> unicode:unicode_binary().\nremove_occurrences(S, Part) ->\n  .",
        "scala_template": "object Solution {\n    def removeOccurrences(s: String, part: String): String = {\n        \n    }\n}"
    },
    {
        "id": 2020,
        "name": "remove-one-element-to-make-the-array-strictly-increasing",
        "difficulty": "Easy",
        "link": "https://leetcode.com/problems/remove-one-element-to-make-the-array-strictly-increasing/",
        "task_description": "Given a **0-indexed** integer array `nums`, return `true` _if it can be made **strictly increasing** after removing **exactly one** element, or _`false`_ otherwise. If the array is already strictly increasing, return _`true`. The array `nums` is **strictly increasing** if `nums[i - 1] < nums[i]` for each index `(1 <= i < nums.length).` **Example 1:** ``` **Input:** nums = [1,2,10,5,7] **Output:** true **Explanation:** By removing 10 at index 2 from nums, it becomes [1,2,5,7]. [1,2,5,7] is strictly increasing, so return true. ``` **Example 2:** ``` **Input:** nums = [2,3,1,2] **Output:** false **Explanation:** [3,1,2] is the result of removing the element at index 0. [2,1,2] is the result of removing the element at index 1. [2,3,2] is the result of removing the element at index 2. [2,3,1] is the result of removing the element at index 3. No resulting array is strictly increasing, so return false. ``` **Example 3:** ``` **Input:** nums = [1,1,1] **Output:** false **Explanation:** The result of removing any element is [1,1]. [1,1] is not strictly increasing, so return false. ``` **Constraints:** `2 <= nums.length <= 1000` `1 <= nums[i] <= 1000`",
        "test_case": [
            {
                "label": "Example 1",
                "input": "nums = [1,2, 10 ,5,7]",
                "output": "true Explanation: By removing 10 at index 2 from nums, it becomes [1,2,5,7].\n[1,2,5,7] is strictly increasing, so return true."
            },
            {
                "label": "Example 2",
                "input": "nums = [2,3,1,2]",
                "output": "false Explanation: [3,1,2] is the result of removing the element at index 0.\n[2,1,2] is the result of removing the element at index 1.\n[2,3,2] is the result of removing the element at index 2.\n[2,3,1] is the result of removing the element at index 3.\nNo resulting array is strictly increasing, so return false."
            },
            {
                "label": "Example 3",
                "input": "nums = [1,1,1]",
                "output": "false Explanation: The result of removing any element is [1,1].\n[1,1] is not strictly increasing, so return false."
            }
        ],
        "elixir_template": "defmodule Solution do\n  @spec can_be_increasing(nums :: [integer]) :: boolean\n  def can_be_increasing(nums) do\n    \n  end\nend",
        "erlang_template": "-spec can_be_increasing(Nums :: [integer()]) -> boolean().\ncan_be_increasing(Nums) ->\n  .",
        "scala_template": "object Solution {\n    def canBeIncreasing(nums: Array[Int]): Boolean = {\n        \n    }\n}"
    },
    {
        "id": 2018,
        "name": "minimum-space-wasted-from-packaging",
        "difficulty": "Hard",
        "link": "https://leetcode.com/problems/minimum-space-wasted-from-packaging/",
        "task_description": "You have `n` packages that you are trying to place in boxes, **one package in each box**. There are `m` suppliers that each produce boxes of **different sizes** (with infinite supply). A package can be placed in a box if the size of the package is **less than or equal to** the size of the box. The package sizes are given as an integer array `packages`, where `packages[i]` is the **size** of the `ith` package. The suppliers are given as a 2D integer array `boxes`, where `boxes[j]` is an array of **box sizes** that the `jth` supplier produces. You want to choose a **single supplier** and use boxes from them such that the **total wasted space **is **minimized**. For each package in a box, we define the space **wasted** to be `size of the box - size of the package`. The **total wasted space** is the sum of the space wasted in **all** the boxes. For example, if you have to fit packages with sizes `[2,3,5]` and the supplier offers boxes of sizes `[4,8]`, you can fit the packages of size-`2` and size-`3` into two boxes of size-`4` and the package with size-`5` into a box of size-`8`. This would result in a waste of `(4-2) + (4-3) + (8-5) = 6`. Return _the **minimum total wasted space** by choosing the box supplier **optimally**, or _`-1` if it is **impossible** to fit all the packages inside boxes. Since the answer may be **large**, return it **modulo **`109 + 7`. **Example 1:** ``` **Input:** packages = [2,3,5], boxes = [[4,8],[2,8]] **Output:** 6 **Explanation**: It is optimal to choose the first supplier, using two size-4 boxes and one size-8 box. The total waste is (4-2) + (4-3) + (8-5) = 6. ``` **Example 2:** ``` **Input:** packages = [2,3,5], boxes = [[1,4],[2,3],[3,4]] **Output:** -1 **Explanation:** There is no box that the package of size 5 can fit in. ``` **Example 3:** ``` **Input:** packages = [3,5,8,10,11,12], boxes = [[12],[11,9],[10,5,14]] **Output:** 9 **Explanation:** It is optimal to choose the third supplier, using two size-5 boxes, two size-10 boxes, and two size-14 boxes. The total waste is (5-3) + (5-5) + (10-8) + (10-10) + (14-11) + (14-12) = 9. ``` **Constraints:** `n == packages.length` `m == boxes.length` `1 <= n <= 105` `1 <= m <= 105` `1 <= packages[i] <= 105` `1 <= boxes[j].length <= 105` `1 <= boxes[j][k] <= 105` `sum(boxes[j].length) <= 105` The elements in `boxes[j]` are **distinct**.",
        "test_case": [
            {
                "label": "Example 1",
                "input": "packages = [2,3,5], boxes = [[4,8],[2,8]]",
                "output": "6 Explanation : It is optimal to choose the first supplier, using two size-4 boxes and one size-8 box.\nThe total waste is (4-2) + (4-3) + (8-5) = 6."
            },
            {
                "label": "Example 2",
                "input": "packages = [2,3,5], boxes = [[1,4],[2,3],[3,4]]",
                "output": "-1 Explanation: There is no box that the package of size 5 can fit in."
            },
            {
                "label": "Example 3",
                "input": "packages = [3,5,8,10,11,12], boxes = [[12],[11,9],[10,5,14]]",
                "output": "9 Explanation: It is optimal to choose the third supplier, using two size-5 boxes, two size-10 boxes, and two size-14 boxes.\nThe total waste is (5-3) + (5-5) + (10-8) + (10-10) + (14-11) + (14-12) = 9. Constraints: n == packages.length m == boxes.length 1 <= n <= 10 5 1 <= m <= 10 5 1 <= packages[i] <= 10 5 1 <= boxes[j].length <= 10 5 1 <= boxes[j][k] <= 10 5 sum(boxes[j].length) <= 10 5 The elements in boxes[j] are distinct ."
            }
        ],
        "elixir_template": "defmodule Solution do\n  @spec min_wasted_space(packages :: [integer], boxes :: [[integer]]) :: integer\n  def min_wasted_space(packages, boxes) do\n    \n  end\nend",
        "erlang_template": "-spec min_wasted_space(Packages :: [integer()], Boxes :: [[integer()]]) -> integer().\nmin_wasted_space(Packages, Boxes) ->\n  .",
        "scala_template": "object Solution {\n    def minWastedSpace(packages: Array[Int], boxes: Array[Array[Int]]): Int = {\n        \n    }\n}"
    },
    {
        "id": 2017,
        "name": "minimum-number-of-flips-to-make-the-binary-string-alternating",
        "difficulty": "Medium",
        "link": "https://leetcode.com/problems/minimum-number-of-flips-to-make-the-binary-string-alternating/",
        "task_description": "You are given a binary string `s`. You are allowed to perform two types of operations on the string in any sequence: **Type-1: Remove** the character at the start of the string `s` and **append** it to the end of the string. **Type-2: Pick** any character in `s` and **flip** its value, i.e., if its value is `'0'` it becomes `'1'` and vice-versa. Return _the **minimum** number of **type-2** operations you need to perform_ _such that _`s` _becomes **alternating**._ The string is called **alternating** if no two adjacent characters are equal. For example, the strings `\"010\"` and `\"1010\"` are alternating, while the string `\"0100\"` is not. **Example 1:** ``` **Input:** s = \"111000\" **Output:** 2 **Explanation**: Use the first operation two times to make s = \"100011\". Then, use the second operation on the third and sixth elements to make s = \"101010\". ``` **Example 2:** ``` **Input:** s = \"010\" **Output:** 0 **Explanation**: The string is already alternating. ``` **Example 3:** ``` **Input:** s = \"1110\" **Output:** 1 **Explanation**: Use the second operation on the second element to make s = \"1010\". ``` **Constraints:** `1 <= s.length <= 105` `s[i]` is either `'0'` or `'1'`.",
        "test_case": [
            {
                "label": "Example 1",
                "input": "s = \"111000\"",
                "output": "2 Explanation : Use the first operation two times to make s = \"100011\".\nThen, use the second operation on the third and sixth elements to make s = \"10 1 01 0 \"."
            },
            {
                "label": "Example 2",
                "input": "s = \"010\"",
                "output": "0 Explanation : The string is already alternating."
            },
            {
                "label": "Example 3",
                "input": "s = \"1110\"",
                "output": "1 Explanation : Use the second operation on the second element to make s = \"1 0 10\"."
            }
        ],
        "elixir_template": "defmodule Solution do\n  @spec min_flips(s :: String.t) :: integer\n  def min_flips(s) do\n    \n  end\nend",
        "erlang_template": "-spec min_flips(S :: unicode:unicode_binary()) -> integer().\nmin_flips(S) ->\n  .",
        "scala_template": "object Solution {\n    def minFlips(s: String): Int = {\n        \n    }\n}"
    },
    {
        "id": 2016,
        "name": "reduction-operations-to-make-the-array-elements-equal",
        "difficulty": "Medium",
        "link": "https://leetcode.com/problems/reduction-operations-to-make-the-array-elements-equal/",
        "task_description": "Given an integer array `nums`, your goal is to make all elements in `nums` equal. To complete one operation, follow these steps: Find the **largest** value in `nums`. Let its index be `i` (**0-indexed**) and its value be `largest`. If there are multiple elements with the largest value, pick the smallest `i`. Find the **next largest** value in `nums` **strictly smaller** than `largest`. Let its value be `nextLargest`. Reduce `nums[i]` to `nextLargest`. Return _the number of operations to make all elements in _`nums`_ equal_. **Example 1:** ``` **Input:** nums = [5,1,3] **Output:** 3 **Explanation:** It takes 3 operations to make all elements in nums equal: 1. largest = 5 at index 0. nextLargest = 3. Reduce nums[0] to 3. nums = [3,1,3]. 2. largest = 3 at index 0. nextLargest = 1. Reduce nums[0] to 1. nums = [1,1,3]. 3. largest = 3 at index 2. nextLargest = 1. Reduce nums[2] to 1. nums = [1,1,1]. ``` **Example 2:** ``` **Input:** nums = [1,1,1] **Output:** 0 **Explanation:** All elements in nums are already equal. ``` **Example 3:** ``` **Input:** nums = [1,1,2,2,3] **Output:** 4 **Explanation:** It takes 4 operations to make all elements in nums equal: 1. largest = 3 at index 4. nextLargest = 2. Reduce nums[4] to 2. nums = [1,1,2,2,2]. 2. largest = 2 at index 2. nextLargest = 1. Reduce nums[2] to 1. nums = [1,1,1,2,2]. 3. largest = 2 at index 3. nextLargest = 1. Reduce nums[3] to 1. nums = [1,1,1,1,2]. 4. largest = 2 at index 4. nextLargest = 1. Reduce nums[4] to 1. nums = [1,1,1,1,1]. ``` **Constraints:** `1 <= nums.length <= 5 * 104` `1 <= nums[i] <= 5 * 104`",
        "test_case": [
            {
                "label": "Example 1",
                "input": "nums = [5,1,3]",
                "output": "3 Explanation: It takes 3 operations to make all elements in nums equal:\n1. largest = 5 at index 0. nextLargest = 3. Reduce nums[0] to 3. nums = [ 3 ,1,3].\n2. largest = 3 at index 0. nextLargest = 1. Reduce nums[0] to 1. nums = [ 1 ,1,3].\n3. largest = 3 at index 2. nextLargest = 1. Reduce nums[2] to 1. nums = [1,1, 1 ]."
            },
            {
                "label": "Example 2",
                "input": "nums = [1,1,1]",
                "output": "0 Explanation: All elements in nums are already equal."
            },
            {
                "label": "Example 3",
                "input": "nums = [1,1,2,2,3]",
                "output": "4 Explanation: It takes 4 operations to make all elements in nums equal:\n1. largest = 3 at index 4. nextLargest = 2. Reduce nums[4] to 2. nums = [1,1,2,2, 2 ].\n2. largest = 2 at index 2. nextLargest = 1. Reduce nums[2] to 1. nums = [1,1, 1 ,2,2].\n3. largest = 2 at index 3. nextLargest = 1. Reduce nums[3] to 1. nums = [1,1,1, 1 ,2].\n4. largest = 2 at index 4. nextLargest = 1. Reduce nums[4] to 1. nums = [1,1,1,1, 1 ]."
            }
        ],
        "elixir_template": "defmodule Solution do\n  @spec reduction_operations(nums :: [integer]) :: integer\n  def reduction_operations(nums) do\n    \n  end\nend",
        "erlang_template": "-spec reduction_operations(Nums :: [integer()]) -> integer().\nreduction_operations(Nums) ->\n  .",
        "scala_template": "object Solution {\n    def reductionOperations(nums: Array[Int]): Int = {\n        \n    }\n}"
    },
    {
        "id": 2015,
        "name": "determine-whether-matrix-can-be-obtained-by-rotation",
        "difficulty": "Easy",
        "link": "https://leetcode.com/problems/determine-whether-matrix-can-be-obtained-by-rotation/",
        "task_description": "Given two `n x n` binary matrices `mat` and `target`, return `true`_ if it is possible to make _`mat`_ equal to _`target`_ by **rotating** _`mat`_ in **90-degree increments**, or _`false`_ otherwise._ **Example 1:** ``` **Input:** mat = [[0,1],[1,0]], target = [[1,0],[0,1]] **Output:** true **Explanation: **We can rotate mat 90 degrees clockwise to make mat equal target. ``` **Example 2:** ``` **Input:** mat = [[0,1],[1,1]], target = [[1,0],[0,1]] **Output:** false **Explanation:** It is impossible to make mat equal to target by rotating mat. ``` **Example 3:** ``` **Input:** mat = [[0,0,0],[0,1,0],[1,1,1]], target = [[1,1,1],[0,1,0],[0,0,0]] **Output:** true **Explanation: **We can rotate mat 90 degrees clockwise two times to make mat equal target. ``` **Constraints:** `n == mat.length == target.length` `n == mat[i].length == target[i].length` `1 <= n <= 10` `mat[i][j]` and `target[i][j]` are either `0` or `1`.",
        "test_case": [
            {
                "label": "Example 1",
                "input": "mat = [[0,1],[1,0]], target = [[1,0],[0,1]]",
                "output": "true Explanation: We can rotate mat 90 degrees clockwise to make mat equal target."
            },
            {
                "label": "Example 2",
                "input": "mat = [[0,1],[1,1]], target = [[1,0],[0,1]]",
                "output": "false Explanation: It is impossible to make mat equal to target by rotating mat."
            },
            {
                "label": "Example 3",
                "input": "mat = [[0,0,0],[0,1,0],[1,1,1]], target = [[1,1,1],[0,1,0],[0,0,0]]",
                "output": "true Explanation: We can rotate mat 90 degrees clockwise two times to make mat equal target. Constraints: n == mat.length == target.length n == mat[i].length == target[i].length 1 <= n <= 10 mat[i][j] and target[i][j] are either 0 or 1 ."
            }
        ],
        "elixir_template": "defmodule Solution do\n  @spec find_rotation(mat :: [[integer]], target :: [[integer]]) :: boolean\n  def find_rotation(mat, target) do\n    \n  end\nend",
        "erlang_template": "-spec find_rotation(Mat :: [[integer()]], Target :: [[integer()]]) -> boolean().\nfind_rotation(Mat, Target) ->\n  .",
        "scala_template": "object Solution {\n    def findRotation(mat: Array[Array[Int]], target: Array[Array[Int]]): Boolean = {\n        \n    }\n}"
    },
    {
        "id": 2013,
        "name": "minimum-skips-to-arrive-at-meeting-on-time",
        "difficulty": "Hard",
        "link": "https://leetcode.com/problems/minimum-skips-to-arrive-at-meeting-on-time/",
        "task_description": "You are given an integer `hoursBefore`, the number of hours you have to travel to your meeting. To arrive at your meeting, you have to travel through `n` roads. The road lengths are given as an integer array `dist` of length `n`, where `dist[i]` describes the length of the `ith` road in **kilometers**. In addition, you are given an integer `speed`, which is the speed (in **km/h**) you will travel at. After you travel road `i`, you must rest and wait for the **next integer hour** before you can begin traveling on the next road. Note that you do not have to rest after traveling the last road because you are already at the meeting. For example, if traveling a road takes `1.4` hours, you must wait until the `2` hour mark before traveling the next road. If traveling a road takes exactly `2` hours, you do not need to wait. However, you are allowed to **skip** some rests to be able to arrive on time, meaning you do not need to wait for the next integer hour. Note that this means you may finish traveling future roads at different hour marks. For example, suppose traveling the first road takes `1.4` hours and traveling the second road takes `0.6` hours. Skipping the rest after the first road will mean you finish traveling the second road right at the `2` hour mark, letting you start traveling the third road immediately. Return _the **minimum number of skips required** to arrive at the meeting on time, or_ `-1`_ if it is** impossible**_. **Example 1:** ``` **Input:** dist = [1,3,2], speed = 4, hoursBefore = 2 **Output:** 1 **Explanation:** Without skipping any rests, you will arrive in (1/4 + 3/4) + (3/4 + 1/4) + (2/4) = 2.5 hours. You can skip the first rest to arrive in ((1/4 + 0) + (3/4 + 0)) + (2/4) = 1.5 hours. Note that the second rest is shortened because you finish traveling the second road at an integer hour due to skipping the first rest. ``` **Example 2:** ``` **Input:** dist = [7,3,5,5], speed = 2, hoursBefore = 10 **Output:** 2 **Explanation:** Without skipping any rests, you will arrive in (7/2 + 1/2) + (3/2 + 1/2) + (5/2 + 1/2) + (5/2) = 11.5 hours. You can skip the first and third rest to arrive in ((7/2 + 0) + (3/2 + 0)) + ((5/2 + 0) + (5/2)) = 10 hours. ``` **Example 3:** ``` **Input:** dist = [7,3,5,5], speed = 1, hoursBefore = 10 **Output:** -1 **Explanation:** It is impossible to arrive at the meeting on time even if you skip all the rests. ``` **Constraints:** `n == dist.length` `1 <= n <= 1000` `1 <= dist[i] <= 105` `1 <= speed <= 106` `1 <= hoursBefore <= 107`",
        "test_case": [
            {
                "label": "Example 1",
                "input": "dist = [1,3,2], speed = 4, hoursBefore = 2",
                "output": "1 Explanation: Without skipping any rests, you will arrive in (1/4 + 3/4) + (3/4 + 1/4) + (2/4) = 2.5 hours.\nYou can skip the first rest to arrive in ((1/4 + 0 ) + (3/4 + 0)) + (2/4) = 1.5 hours.\nNote that the second rest is shortened because you finish traveling the second road at an integer hour due to skipping the first rest."
            },
            {
                "label": "Example 2",
                "input": "dist = [7,3,5,5], speed = 2, hoursBefore = 10",
                "output": "2 Explanation: Without skipping any rests, you will arrive in (7/2 + 1/2) + (3/2 + 1/2) + (5/2 + 1/2) + (5/2) = 11.5 hours.\nYou can skip the first and third rest to arrive in ((7/2 + 0 ) + (3/2 + 0)) + ((5/2 + 0 ) + (5/2)) = 10 hours."
            },
            {
                "label": "Example 3",
                "input": "dist = [7,3,5,5], speed = 1, hoursBefore = 10",
                "output": "-1 Explanation: It is impossible to arrive at the meeting on time even if you skip all the rests. Constraints: n == dist.length 1 <= n <= 1000 1 <= dist[i] <= 10 5 1 <= speed <= 10 6 1 <= hoursBefore <= 10 7"
            }
        ],
        "elixir_template": "defmodule Solution do\n  @spec min_skips(dist :: [integer], speed :: integer, hours_before :: integer) :: integer\n  def min_skips(dist, speed, hours_before) do\n    \n  end\nend",
        "erlang_template": "-spec min_skips(Dist :: [integer()], Speed :: integer(), HoursBefore :: integer()) -> integer().\nmin_skips(Dist, Speed, HoursBefore) ->\n  .",
        "scala_template": "object Solution {\n    def minSkips(dist: Array[Int], speed: Int, hoursBefore: Int): Int = {\n        \n    }\n}"
    },
    {
        "id": 2012,
        "name": "process-tasks-using-servers",
        "difficulty": "Medium",
        "link": "https://leetcode.com/problems/process-tasks-using-servers/",
        "task_description": "You are given two **0-indexed** integer arrays `servers` and `tasks` of lengths `n`\u200b\u200b\u200b\u200b\u200b\u200b and `m`\u200b\u200b\u200b\u200b\u200b\u200b respectively. `servers[i]` is the **weight** of the `i\u200b\u200b\u200b\u200b\u200b\u200bth`\u200b\u200b\u200b\u200b server, and `tasks[j]` is the **time needed** to process the `j\u200b\u200b\u200b\u200b\u200b\u200bth`\u200b\u200b\u200b\u200b task **in seconds**. Tasks are assigned to the servers using a **task queue**. Initially, all servers are free, and the queue is **empty**. At second `j`, the `jth` task is **inserted** into the queue (starting with the `0th` task being inserted at second `0`). As long as there are free servers and the queue is not empty, the task in the front of the queue will be assigned to a free server with the **smallest weight**, and in case of a tie, it is assigned to a free server with the **smallest index**. If there are no free servers and the queue is not empty, we wait until a server becomes free and immediately assign the next task. If multiple servers become free at the same time, then multiple tasks from the queue will be assigned **in order of insertion** following the weight and index priorities above. A server that is assigned task `j` at second `t` will be free again at second `t + tasks[j]`. Build an array `ans`\u200b\u200b\u200b\u200b of length `m`, where `ans[j]` is the **index** of the server the `j\u200b\u200b\u200b\u200b\u200b\u200bth` task will be assigned to. Return _the array _`ans`\u200b\u200b\u200b\u200b. **Example 1:** ``` **Input:** servers = [3,3,2], tasks = [1,2,3,2,1,2] **Output:** [2,2,0,2,1,2] **Explanation: **Events in chronological order go as follows: - At second 0, task 0 is added and processed using server 2 until second 1. - At second 1, server 2 becomes free. Task 1 is added and processed using server 2 until second 3. - At second 2, task 2 is added and processed using server 0 until second 5. - At second 3, server 2 becomes free. Task 3 is added and processed using server 2 until second 5. - At second 4, task 4 is added and processed using server 1 until second 5. - At second 5, all servers become free. Task 5 is added and processed using server 2 until second 7. ``` **Example 2:** ``` **Input:** servers = [5,1,4,3,2], tasks = [2,1,2,4,5,2,1] **Output:** [1,4,1,4,1,3,2] **Explanation: **Events in chronological order go as follows: - At second 0, task 0 is added and processed using server 1 until second 2. - At second 1, task 1 is added and processed using server 4 until second 2. - At second 2, servers 1 and 4 become free. Task 2 is added and processed using server 1 until second 4. - At second 3, task 3 is added and processed using server 4 until second 7. - At second 4, server 1 becomes free. Task 4 is added and processed using server 1 until second 9. - At second 5, task 5 is added and processed using server 3 until second 7. - At second 6, task 6 is added and processed using server 2 until second 7. ``` **Constraints:** `servers.length == n` `tasks.length == m` `1 <= n, m <= 2 * 105` `1 <= servers[i], tasks[j] <= 2 * 105`",
        "test_case": [
            {
                "label": "Example 1",
                "input": "servers = [3,3,2], tasks = [1,2,3,2,1,2]",
                "output": "[2,2,0,2,1,2] Explanation: Events in chronological order go as follows:\n- At second 0, task 0 is added and processed using server 2 until second 1.\n- At second 1, server 2 becomes free. Task 1 is added and processed using server 2 until second 3.\n- At second 2, task 2 is added and processed using server 0 until second 5.\n- At second 3, server 2 becomes free. Task 3 is added and processed using server 2 until second 5.\n- At second 4, task 4 is added and processed using server 1 until second 5.\n- At second 5, all servers become free. Task 5 is added and processed using server 2 until second 7."
            },
            {
                "label": "Example 2",
                "input": "servers = [5,1,4,3,2], tasks = [2,1,2,4,5,2,1]",
                "output": "[1,4,1,4,1,3,2] Explanation: Events in chronological order go as follows: \n- At second 0, task 0 is added and processed using server 1 until second 2.\n- At second 1, task 1 is added and processed using server 4 until second 2.\n- At second 2, servers 1 and 4 become free. Task 2 is added and processed using server 1 until second 4. \n- At second 3, task 3 is added and processed using server 4 until second 7.\n- At second 4, server 1 becomes free. Task 4 is added and processed using server 1 until second 9. \n- At second 5, task 5 is added and processed using server 3 until second 7.\n- At second 6, task 6 is added and processed using server 2 until second 7. Constraints: servers.length == n tasks.length == m 1 <= n, m <= 2 * 10 5 1 <= servers[i], tasks[j] <= 2 * 10 5"
            }
        ],
        "elixir_template": "defmodule Solution do\n  @spec assign_tasks(servers :: [integer], tasks :: [integer]) :: [integer]\n  def assign_tasks(servers, tasks) do\n    \n  end\nend",
        "erlang_template": "-spec assign_tasks(Servers :: [integer()], Tasks :: [integer()]) -> [integer()].\nassign_tasks(Servers, Tasks) ->\n  .",
        "scala_template": "object Solution {\n    def assignTasks(servers: Array[Int], tasks: Array[Int]): Array[Int] = {\n        \n    }\n}"
    },
    {
        "id": 2011,
        "name": "maximum-value-after-insertion",
        "difficulty": "Medium",
        "link": "https://leetcode.com/problems/maximum-value-after-insertion/",
        "task_description": "You are given a very large integer `n`, represented as a string,\u200b\u200b\u200b\u200b\u200b\u200b and an integer digit `x`. The digits in `n` and the digit `x` are in the **inclusive** range `[1, 9]`, and `n` may represent a negative number. You want to **maximize **`n`**'s numerical value** by inserting `x` anywhere in the decimal representation of `n`\u200b\u200b\u200b\u200b\u200b\u200b. You **cannot** insert `x` to the left of the negative sign. For example, if `n = 73` and `x = 6`, it would be best to insert it between `7` and `3`, making `n = 763`. If `n = -55` and `x = 2`, it would be best to insert it before the first `5`, making `n = -255`. Return _a string representing the **maximum** value of _`n`_\u200b\u200b\u200b\u200b\u200b\u200b after the insertion_. **Example 1:** ``` **Input:** n = \"99\", x = 9 **Output:** \"999\" **Explanation:** The result is the same regardless of where you insert 9. ``` **Example 2:** ``` **Input:** n = \"-13\", x = 2 **Output:** \"-123\" **Explanation:** You can make n one of {-213, -123, -132}, and the largest of those three is -123. ``` **Constraints:** `1 <= n.length <= 105` `1 <= x <= 9` The digits in `n`\u200b\u200b\u200b are in the range `[1, 9]`. `n` is a valid representation of an integer. In the case of a negative `n`,\u200b\u200b\u200b\u200b\u200b\u200b it will begin with `'-'`.",
        "test_case": [
            {
                "label": "Example 1",
                "input": "n = \"99\", x = 9",
                "output": "\"999\" Explanation: The result is the same regardless of where you insert 9."
            },
            {
                "label": "Example 2",
                "input": "n = \"-13\", x = 2",
                "output": "\"-123\" Explanation: You can make n one of {-213, -123, -132}, and the largest of those three is -123."
            }
        ],
        "elixir_template": "defmodule Solution do\n  @spec max_value(n :: String.t, x :: integer) :: String.t\n  def max_value(n, x) do\n    \n  end\nend",
        "erlang_template": "-spec max_value(N :: unicode:unicode_binary(), X :: integer()) -> unicode:unicode_binary().\nmax_value(N, X) ->\n  .",
        "scala_template": "object Solution {\n    def maxValue(n: String, x: Int): String = {\n        \n    }\n}"
    },
    {
        "id": 2010,
        "name": "check-if-word-equals-summation-of-two-words",
        "difficulty": "Easy",
        "link": "https://leetcode.com/problems/check-if-word-equals-summation-of-two-words/",
        "task_description": "The **letter value** of a letter is its position in the alphabet **starting from 0** (i.e. `'a' -> 0`, `'b' -> 1`, `'c' -> 2`, etc.). The **numerical value** of some string of lowercase English letters `s` is the **concatenation** of the **letter values** of each letter in `s`, which is then **converted** into an integer. For example, if `s = \"acb\"`, we concatenate each letter's letter value, resulting in `\"021\"`. After converting it, we get `21`. You are given three strings `firstWord`, `secondWord`, and `targetWord`, each consisting of lowercase English letters `'a'` through `'j'` **inclusive**. Return `true` _if the **summation** of the **numerical values** of _`firstWord`_ and _`secondWord`_ equals the **numerical value** of _`targetWord`_, or _`false`_ otherwise._ **Example 1:** ``` **Input:** firstWord = \"acb\", secondWord = \"cba\", targetWord = \"cdb\" **Output:** true **Explanation:** The numerical value of firstWord is \"acb\" -> \"021\" -> 21. The numerical value of secondWord is \"cba\" -> \"210\" -> 210. The numerical value of targetWord is \"cdb\" -> \"231\" -> 231. We return true because 21 + 210 == 231. ``` **Example 2:** ``` **Input:** firstWord = \"aaa\", secondWord = \"a\", targetWord = \"aab\" **Output:** false **Explanation:** The numerical value of firstWord is \"aaa\" -> \"000\" -> 0. The numerical value of secondWord is \"a\" -> \"0\" -> 0. The numerical value of targetWord is \"aab\" -> \"001\" -> 1. We return false because 0 + 0 != 1. ``` **Example 3:** ``` **Input:** firstWord = \"aaa\", secondWord = \"a\", targetWord = \"aaaa\" **Output:** true **Explanation:** The numerical value of firstWord is \"aaa\" -> \"000\" -> 0. The numerical value of secondWord is \"a\" -> \"0\" -> 0. The numerical value of targetWord is \"aaaa\" -> \"0000\" -> 0. We return true because 0 + 0 == 0. ``` **Constraints:** `1 <= firstWord.length, ``secondWord.length, ``targetWord.length <= 8` `firstWord`, `secondWord`, and `targetWord` consist of lowercase English letters from `'a'` to `'j'` **inclusive**.",
        "test_case": [
            {
                "label": "Example 1",
                "input": "firstWord = \"acb\", secondWord = \"cba\", targetWord = \"cdb\"",
                "output": "true Explanation: The numerical value of firstWord is \"acb\" -> \"021\" -> 21.\nThe numerical value of secondWord is \"cba\" -> \"210\" -> 210.\nThe numerical value of targetWord is \"cdb\" -> \"231\" -> 231.\nWe return true because 21 + 210 == 231."
            },
            {
                "label": "Example 2",
                "input": "firstWord = \"aaa\", secondWord = \"a\", targetWord = \"aab\"",
                "output": "false Explanation: The numerical value of firstWord is \"aaa\" -> \"000\" -> 0.\nThe numerical value of secondWord is \"a\" -> \"0\" -> 0.\nThe numerical value of targetWord is \"aab\" -> \"001\" -> 1.\nWe return false because 0 + 0 != 1."
            },
            {
                "label": "Example 3",
                "input": "firstWord = \"aaa\", secondWord = \"a\", targetWord = \"aaaa\"",
                "output": "true Explanation: The numerical value of firstWord is \"aaa\" -> \"000\" -> 0.\nThe numerical value of secondWord is \"a\" -> \"0\" -> 0.\nThe numerical value of targetWord is \"aaaa\" -> \"0000\" -> 0.\nWe return true because 0 + 0 == 0."
            }
        ],
        "elixir_template": "defmodule Solution do\n  @spec is_sum_equal(first_word :: String.t, second_word :: String.t, target_word :: String.t) :: boolean\n  def is_sum_equal(first_word, second_word, target_word) do\n    \n  end\nend",
        "erlang_template": "-spec is_sum_equal(FirstWord :: unicode:unicode_binary(), SecondWord :: unicode:unicode_binary(), TargetWord :: unicode:unicode_binary()) -> boolean().\nis_sum_equal(FirstWord, SecondWord, TargetWord) ->\n  .",
        "scala_template": "object Solution {\n    def isSumEqual(firstWord: String, secondWord: String, targetWord: String): Boolean = {\n        \n    }\n}"
    },
    {
        "id": 2008,
        "name": "minimum-cost-to-change-the-final-value-of-expression",
        "difficulty": "Hard",
        "link": "https://leetcode.com/problems/minimum-cost-to-change-the-final-value-of-expression/",
        "task_description": "You are given a **valid** boolean expression as a string `expression` consisting of the characters `'1'`,`'0'`,`'&'` (bitwise **AND** operator),`'|'` (bitwise **OR** operator),`'('`, and `')'`. For example, `\"()1|1\"` and `\"(1)&()\"` are **not valid** while `\"1\"`, `\"(((1))|(0))\"`, and `\"1|(0&(1))\"` are **valid** expressions. Return_ the **minimum cost** to change the final value of the expression_. For example, if `expression = \"1|1|(0&0)&1\"`, its **value** is `1|1|(0&0)&1 = 1|1|0&1 = 1|0&1 = 1&1 = 1`. We want to apply operations so that the** new** expression evaluates to `0`. The **cost** of changing the final value of an expression is the **number of operations** performed on the expression. The types of **operations** are described as follows: Turn a `'1'` into a `'0'`. Turn a `'0'` into a `'1'`. Turn a `'&'` into a `'|'`. Turn a `'|'` into a `'&'`. **Note:** `'&'` does **not** take precedence over `'|'` in the **order of calculation**. Evaluate parentheses **first**, then in **left-to-right** order. **Example 1:** ``` **Input:** expression = \"1&(0|1)\" **Output:** 1 **Explanation:** We can turn \"1&(0**|**1)\" into \"1&(0**&**1)\" by changing the '|' to a '&' using 1 operation. The new expression evaluates to 0. ``` **Example 2:** ``` **Input:** expression = \"(0&0)&(0&0&0)\" **Output:** 3 **Explanation:** We can turn \"(0**&0**)**&**(0&0&0)\" into \"(0**|1**)**|**(0&0&0)\" using 3 operations. The new expression evaluates to 1. ``` **Example 3:** ``` **Input:** expression = \"(0|(1|0&1))\" **Output:** 1 **Explanation:** We can turn \"(0|(**1**|0&1))\" into \"(0|(**0**|0&1))\" using 1 operation. The new expression evaluates to 0. ``` **Constraints:** `1 <= expression.length <= 105` `expression` only contains `'1'`,`'0'`,`'&'`,`'|'`,`'('`, and `')'` All parentheses are properly matched. There will be no empty parentheses (i.e: `\"()\"` is not a substring of `expression`).",
        "test_case": [
            {
                "label": "Example 1",
                "input": "expression = \"1&(0|1)\"",
                "output": "1 Explanation: We can turn \"1&(0 | 1)\" into \"1&(0 & 1)\" by changing the '|' to a '&' using 1 operation.\nThe new expression evaluates to 0."
            },
            {
                "label": "Example 2",
                "input": "expression = \"(0&0)&(0&0&0)\"",
                "output": "3 Explanation: We can turn \"(0 &0 ) & (0&0&0)\" into \"(0 |1 ) | (0&0&0)\" using 3 operations.\nThe new expression evaluates to 1."
            },
            {
                "label": "Example 3",
                "input": "expression = \"(0|(1|0&1))\"",
                "output": "1 Explanation: We can turn \"(0|( 1 |0&1))\" into \"(0|( 0 |0&1))\" using 1 operation.\nThe new expression evaluates to 0."
            }
        ],
        "elixir_template": "defmodule Solution do\n  @spec min_operations_to_flip(expression :: String.t) :: integer\n  def min_operations_to_flip(expression) do\n    \n  end\nend",
        "erlang_template": "-spec min_operations_to_flip(Expression :: unicode:unicode_binary()) -> integer().\nmin_operations_to_flip(Expression) ->\n  .",
        "scala_template": "object Solution {\n    def minOperationsToFlip(expression: String): Int = {\n        \n    }\n}"
    },
    {
        "id": 2006,
        "name": "find-the-student-that-will-replace-the-chalk",
        "difficulty": "Medium",
        "link": "https://leetcode.com/problems/find-the-student-that-will-replace-the-chalk/",
        "task_description": "There are `n` students in a class numbered from `0` to `n - 1`. The teacher will give each student a problem starting with the student number `0`, then the student number `1`, and so on until the teacher reaches the student number `n - 1`. After that, the teacher will restart the process, starting with the student number `0` again. You are given a **0-indexed** integer array `chalk` and an integer `k`. There are initially `k` pieces of chalk. When the student number `i` is given a problem to solve, they will use `chalk[i]` pieces of chalk to solve that problem. However, if the current number of chalk pieces is **strictly less** than `chalk[i]`, then the student number `i` will be asked to **replace** the chalk. Return _the **index** of the student that will **replace** the chalk pieces_. **Example 1:** ``` **Input:** chalk = [5,1,5], k = 22 **Output:** 0 **Explanation: **The students go in turns as follows: - Student number 0 uses 5 chalk, so k = 17. - Student number 1 uses 1 chalk, so k = 16. - Student number 2 uses 5 chalk, so k = 11. - Student number 0 uses 5 chalk, so k = 6. - Student number 1 uses 1 chalk, so k = 5. - Student number 2 uses 5 chalk, so k = 0. Student number 0 does not have enough chalk, so they will have to replace it. ``` **Example 2:** ``` **Input:** chalk = [3,4,1,2], k = 25 **Output:** 1 **Explanation: **The students go in turns as follows: - Student number 0 uses 3 chalk so k = 22. - Student number 1 uses 4 chalk so k = 18. - Student number 2 uses 1 chalk so k = 17. - Student number 3 uses 2 chalk so k = 15. - Student number 0 uses 3 chalk so k = 12. - Student number 1 uses 4 chalk so k = 8. - Student number 2 uses 1 chalk so k = 7. - Student number 3 uses 2 chalk so k = 5. - Student number 0 uses 3 chalk so k = 2. Student number 1 does not have enough chalk, so they will have to replace it. ``` **Constraints:** `chalk.length == n` `1 <= n <= 105` `1 <= chalk[i] <= 105` `1 <= k <= 109`",
        "test_case": [
            {
                "label": "Example 1",
                "input": "chalk = [5,1,5], k = 22",
                "output": "0 Explanation: The students go in turns as follows:\n- Student number 0 uses 5 chalk, so k = 17.\n- Student number 1 uses 1 chalk, so k = 16.\n- Student number 2 uses 5 chalk, so k = 11.\n- Student number 0 uses 5 chalk, so k = 6.\n- Student number 1 uses 1 chalk, so k = 5.\n- Student number 2 uses 5 chalk, so k = 0.\nStudent number 0 does not have enough chalk, so they will have to replace it."
            },
            {
                "label": "Example 2",
                "input": "chalk = [3,4,1,2], k = 25",
                "output": "1 Explanation: The students go in turns as follows:\n- Student number 0 uses 3 chalk so k = 22.\n- Student number 1 uses 4 chalk so k = 18.\n- Student number 2 uses 1 chalk so k = 17.\n- Student number 3 uses 2 chalk so k = 15.\n- Student number 0 uses 3 chalk so k = 12.\n- Student number 1 uses 4 chalk so k = 8.\n- Student number 2 uses 1 chalk so k = 7.\n- Student number 3 uses 2 chalk so k = 5.\n- Student number 0 uses 3 chalk so k = 2.\nStudent number 1 does not have enough chalk, so they will have to replace it. Constraints: chalk.length == n 1 <= n <= 10 5 1 <= chalk[i] <= 10 5 1 <= k <= 10 9"
            }
        ],
        "elixir_template": "defmodule Solution do\n  @spec chalk_replacer(chalk :: [integer], k :: integer) :: integer\n  def chalk_replacer(chalk, k) do\n    \n  end\nend",
        "erlang_template": "-spec chalk_replacer(Chalk :: [integer()], K :: integer()) -> integer().\nchalk_replacer(Chalk, K) ->\n  .",
        "scala_template": "object Solution {\n    def chalkReplacer(chalk: Array[Int], k: Int): Int = {\n        \n    }\n}"
    },
    {
        "id": 2005,
        "name": "check-if-all-the-integers-in-a-range-are-covered",
        "difficulty": "Easy",
        "link": "https://leetcode.com/problems/check-if-all-the-integers-in-a-range-are-covered/",
        "task_description": "You are given a 2D integer array `ranges` and two integers `left` and `right`. Each `ranges[i] = [starti, endi]` represents an **inclusive** interval between `starti` and `endi`. Return `true` _if each integer in the inclusive range_ `[left, right]` _is covered by **at least one** interval in_ `ranges`. Return `false` _otherwise_. An integer `x` is covered by an interval `ranges[i] = [starti, endi]` if `starti <= x <= endi`. **Example 1:** ``` **Input:** ranges = [[1,2],[3,4],[5,6]], left = 2, right = 5 **Output:** true **Explanation:** Every integer between 2 and 5 is covered: - 2 is covered by the first range. - 3 and 4 are covered by the second range. - 5 is covered by the third range. ``` **Example 2:** ``` **Input:** ranges = [[1,10],[10,20]], left = 21, right = 21 **Output:** false **Explanation:** 21 is not covered by any range. ``` **Constraints:** `1 <= ranges.length <= 50` `1 <= starti <= endi <= 50` `1 <= left <= right <= 50`",
        "test_case": [
            {
                "label": "Example 1",
                "input": "ranges = [[1,2],[3,4],[5,6]], left = 2, right = 5",
                "output": "true Explanation: Every integer between 2 and 5 is covered:\n- 2 is covered by the first range.\n- 3 and 4 are covered by the second range.\n- 5 is covered by the third range."
            },
            {
                "label": "Example 2",
                "input": "ranges = [[1,10],[10,20]], left = 21, right = 21",
                "output": "false Explanation: 21 is not covered by any range."
            }
        ],
        "elixir_template": "defmodule Solution do\n  @spec is_covered(ranges :: [[integer]], left :: integer, right :: integer) :: boolean\n  def is_covered(ranges, left, right) do\n    \n  end\nend",
        "erlang_template": "-spec is_covered(Ranges :: [[integer()]], Left :: integer(), Right :: integer()) -> boolean().\nis_covered(Ranges, Left, Right) ->\n  .",
        "scala_template": "object Solution {\n    def isCovered(ranges: Array[Array[Int]], left: Int, right: Int): Boolean = {\n        \n    }\n}"
    },
    {
        "id": 2002,
        "name": "stone-game-viii",
        "difficulty": "Hard",
        "link": "https://leetcode.com/problems/stone-game-viii/",
        "task_description": "Alice and Bob take turns playing a game, with **Alice starting first**. There are `n` stones arranged in a row. On each player's turn, while the number of stones is **more than one**, they will do the following: Choose an integer `x > 1`, and **remove** the leftmost `x` stones from the row. Add the **sum** of the **removed** stones' values to the player's score. Place a **new stone**, whose value is equal to that sum, on the left side of the row. The game stops when **only** **one** stone is left in the row. The **score difference** between Alice and Bob is `(Alice's score - Bob's score)`. Alice's goal is to **maximize** the score difference, and Bob's goal is the **minimize** the score difference. Given an integer array `stones` of length `n` where `stones[i]` represents the value of the `ith` stone **from the left**, return _the **score difference** between Alice and Bob if they both play **optimally**._ **Example 1:** ``` **Input:** stones = [-1,2,-3,4,-5] **Output:** 5 **Explanation:** - Alice removes the first 4 stones, adds (-1) + 2 + (-3) + 4 = 2 to her score, and places a stone of value 2 on the left. stones = [2,-5]. - Bob removes the first 2 stones, adds 2 + (-5) = -3 to his score, and places a stone of value -3 on the left. stones = [-3]. The difference between their scores is 2 - (-3) = 5. ``` **Example 2:** ``` **Input:** stones = [7,-6,5,10,5,-2,-6] **Output:** 13 **Explanation:** - Alice removes all stones, adds 7 + (-6) + 5 + 10 + 5 + (-2) + (-6) = 13 to her score, and places a stone of value 13 on the left. stones = [13]. The difference between their scores is 13 - 0 = 13. ``` **Example 3:** ``` **Input:** stones = [-10,-12] **Output:** -22 **Explanation:** - Alice can only make one move, which is to remove both stones. She adds (-10) + (-12) = -22 to her score and places a stone of value -22 on the left. stones = [-22]. The difference between their scores is (-22) - 0 = -22. ``` **Constraints:** `n == stones.length` `2 <= n <= 105` `-104 <= stones[i] <= 104`",
        "test_case": [
            {
                "label": "Example 1",
                "input": "stones = [-1,2,-3,4,-5]",
                "output": "5 Explanation: - Alice removes the first 4 stones, adds (-1) + 2 + (-3) + 4 = 2 to her score, and places a stone of\r\n  value 2 on the left. stones = [2,-5].\r\n- Bob removes the first 2 stones, adds 2 + (-5) = -3 to his score, and places a stone of value -3 on\r\n  the left. stones = [-3].\r\nThe difference between their scores is 2 - (-3) = 5."
            },
            {
                "label": "Example 2",
                "input": "stones = [7,-6,5,10,5,-2,-6]",
                "output": "13 Explanation: - Alice removes all stones, adds 7 + (-6) + 5 + 10 + 5 + (-2) + (-6) = 13 to her score, and places a\r\n  stone of value 13 on the left. stones = [13].\r\nThe difference between their scores is 13 - 0 = 13."
            },
            {
                "label": "Example 3",
                "input": "stones = [-10,-12]",
                "output": "-22 Explanation: - Alice can only make one move, which is to remove both stones. She adds (-10) + (-12) = -22 to her\r\n  score and places a stone of value -22 on the left. stones = [-22].\r\nThe difference between their scores is (-22) - 0 = -22. Constraints: n == stones.length 2 <= n <= 10 5 -10 4 <= stones[i] <= 10 4"
            }
        ],
        "elixir_template": "Elixir code template not available for this problem.",
        "erlang_template": "Elixir code template not available for this problem.",
        "scala_template": "object Solution {\n    def stoneGameVIII(stones: Array[Int]): Int = {\n        \n    }\n}"
    },
    {
        "id": 2001,
        "name": "jump-game-vii",
        "difficulty": "Medium",
        "link": "https://leetcode.com/problems/jump-game-vii/",
        "task_description": "You are given a **0-indexed** binary string `s` and two integers `minJump` and `maxJump`. In the beginning, you are standing at index `0`, which is equal to `'0'`. You can move from index `i` to index `j` if the following conditions are fulfilled: `i + minJump <= j <= min(i + maxJump, s.length - 1)`, and `s[j] == '0'`. Return `true` if you can reach index `s.length - 1` in `s`_, or _`false`_ otherwise._ **Example 1:** ``` **Input:** s = \"011010\", minJump = 2, maxJump = 3 **Output:** true **Explanation:** In the first step, move from index 0 to index 3. In the second step, move from index 3 to index 5. ``` **Example 2:** ``` **Input:** s = \"01101110\", minJump = 2, maxJump = 3 **Output:** false ``` **Constraints:** `2 <= s.length <= 105` `s[i]` is either `'0'` or `'1'`. `s[0] == '0'` `1 <= minJump <= maxJump < s.length`",
        "test_case": [
            {
                "label": "Example 1",
                "input": "s = \" 0 11 0 1 0 \", minJump = 2, maxJump = 3",
                "output": "true Explanation: In the first step, move from index 0 to index 3. \nIn the second step, move from index 3 to index 5."
            },
            {
                "label": "Example 2",
                "input": "s = \"01101110\", minJump = 2, maxJump = 3",
                "output": "false"
            }
        ],
        "elixir_template": "defmodule Solution do\n  @spec can_reach(s :: String.t, min_jump :: integer, max_jump :: integer) :: boolean\n  def can_reach(s, min_jump, max_jump) do\n    \n  end\nend",
        "erlang_template": "-spec can_reach(S :: unicode:unicode_binary(), MinJump :: integer(), MaxJump :: integer()) -> boolean().\ncan_reach(S, MinJump, MaxJump) ->\n  .",
        "scala_template": "object Solution {\n    def canReach(s: String, minJump: Int, maxJump: Int): Boolean = {\n        \n    }\n}"
    },
    {
        "id": 2000,
        "name": "minimum-speed-to-arrive-on-time",
        "difficulty": "Medium",
        "link": "https://leetcode.com/problems/minimum-speed-to-arrive-on-time/",
        "task_description": "You are given a floating-point number `hour`, representing the amount of time you have to reach the office. To commute to the office, you must take `n` trains in sequential order. You are also given an integer array `dist` of length `n`, where `dist[i]` describes the distance (in kilometers) of the `ith` train ride. Each train can only depart at an integer hour, so you may need to wait in between each train ride. For example, if the `1st` train ride takes `1.5` hours, you must wait for an additional `0.5` hours before you can depart on the `2nd` train ride at the 2 hour mark. Return _the **minimum positive integer** speed **(in kilometers per hour)** that all the trains must travel at for you to reach the office on time, or _`-1`_ if it is impossible to be on time_. Tests are generated such that the answer will not exceed `107` and `hour` will have **at most two digits after the decimal point**. **Example 1:** ``` **Input:** dist = [1,3,2], hour = 6 **Output:** 1 **Explanation: **At speed 1: - The first train ride takes 1/1 = 1 hour. - Since we are already at an integer hour, we depart immediately at the 1 hour mark. The second train takes 3/1 = 3 hours. - Since we are already at an integer hour, we depart immediately at the 4 hour mark. The third train takes 2/1 = 2 hours. - You will arrive at exactly the 6 hour mark. ``` **Example 2:** ``` **Input:** dist = [1,3,2], hour = 2.7 **Output:** 3 **Explanation: **At speed 3: - The first train ride takes 1/3 = 0.33333 hours. - Since we are not at an integer hour, we wait until the 1 hour mark to depart. The second train ride takes 3/3 = 1 hour. - Since we are already at an integer hour, we depart immediately at the 2 hour mark. The third train takes 2/3 = 0.66667 hours. - You will arrive at the 2.66667 hour mark. ``` **Example 3:** ``` **Input:** dist = [1,3,2], hour = 1.9 **Output:** -1 **Explanation:** It is impossible because the earliest the third train can depart is at the 2 hour mark. ``` **Constraints:** `n == dist.length` `1 <= n <= 105` `1 <= dist[i] <= 105` `1 <= hour <= 109` There will be at most two digits after the decimal point in `hour`.",
        "test_case": [
            {
                "label": "Example 1",
                "input": "dist = [1,3,2], hour = 6",
                "output": "1 Explanation: At speed 1:\n- The first train ride takes 1/1 = 1 hour.\n- Since we are already at an integer hour, we depart immediately at the 1 hour mark. The second train takes 3/1 = 3 hours.\n- Since we are already at an integer hour, we depart immediately at the 4 hour mark. The third train takes 2/1 = 2 hours.\n- You will arrive at exactly the 6 hour mark."
            },
            {
                "label": "Example 2",
                "input": "dist = [1,3,2], hour = 2.7",
                "output": "3 Explanation: At speed 3:\n- The first train ride takes 1/3 = 0.33333 hours.\n- Since we are not at an integer hour, we wait until the 1 hour mark to depart. The second train ride takes 3/3 = 1 hour.\n- Since we are already at an integer hour, we depart immediately at the 2 hour mark. The third train takes 2/3 = 0.66667 hours.\n- You will arrive at the 2.66667 hour mark."
            },
            {
                "label": "Example 3",
                "input": "dist = [1,3,2], hour = 1.9",
                "output": "-1 Explanation: It is impossible because the earliest the third train can depart is at the 2 hour mark. Constraints: n == dist.length 1 <= n <= 10 5 1 <= dist[i] <= 10 5 1 <= hour <= 10 9 There will be at most two digits after the decimal point in hour ."
            }
        ],
        "elixir_template": "defmodule Solution do\n  @spec min_speed_on_time(dist :: [integer], hour :: float) :: integer\n  def min_speed_on_time(dist, hour) do\n    \n  end\nend",
        "erlang_template": "-spec min_speed_on_time(Dist :: [integer()], Hour :: float()) -> integer().\nmin_speed_on_time(Dist, Hour) ->\n  .",
        "scala_template": "object Solution {\n    def minSpeedOnTime(dist: Array[Int], hour: Double): Int = {\n        \n    }\n}"
    },
    {
        "id": 1999,
        "name": "longer-contiguous-segments-of-ones-than-zeros",
        "difficulty": "Easy",
        "link": "https://leetcode.com/problems/longer-contiguous-segments-of-ones-than-zeros/",
        "task_description": "Given a binary string `s`, return `true`_ if the **longest** contiguous segment of _`1`'_s is **strictly longer** than the **longest** contiguous segment of _`0`'_s in _`s`, or return `false`_ otherwise_. For example, in `s = \"110100010\"` the longest continuous segment of `1`s has length `2`, and the longest continuous segment of `0`s has length `3`. Note that if there are no `0`'s, then the longest continuous segment of `0`'s is considered to have a length `0`. The same applies if there is no `1`'s. **Example 1:** ``` **Input:** s = \"1101\" **Output:** true **Explanation:** The longest contiguous segment of 1s has length 2: \"1101\" The longest contiguous segment of 0s has length 1: \"1101\" The segment of 1s is longer, so return true. ``` **Example 2:** ``` **Input:** s = \"111000\" **Output:** false **Explanation:** The longest contiguous segment of 1s has length 3: \"111000\" The longest contiguous segment of 0s has length 3: \"111000\" The segment of 1s is not longer, so return false. ``` **Example 3:** ``` **Input:** s = \"110100010\" **Output:** false **Explanation:** The longest contiguous segment of 1s has length 2: \"110100010\" The longest contiguous segment of 0s has length 3: \"110100010\" The segment of 1s is not longer, so return false. ``` **Constraints:** `1 <= s.length <= 100` `s[i]` is either `'0'` or `'1'`.",
        "test_case": [
            {
                "label": "Example 1",
                "input": "s = \"1101\"",
                "output": "true Explanation: The longest contiguous segment of 1s has length 2: \" 11 01\"\nThe longest contiguous segment of 0s has length 1: \"11 0 1\"\nThe segment of 1s is longer, so return true."
            },
            {
                "label": "Example 2",
                "input": "s = \"111000\"",
                "output": "false Explanation: The longest contiguous segment of 1s has length 3: \" 111 000\"\nThe longest contiguous segment of 0s has length 3: \"111 000 \"\nThe segment of 1s is not longer, so return false."
            },
            {
                "label": "Example 3",
                "input": "s = \"110100010\"",
                "output": "false Explanation: The longest contiguous segment of 1s has length 2: \" 11 0100010\"\nThe longest contiguous segment of 0s has length 3: \"1101 000 10\"\nThe segment of 1s is not longer, so return false."
            }
        ],
        "elixir_template": "defmodule Solution do\n  @spec check_zero_ones(s :: String.t) :: boolean\n  def check_zero_ones(s) do\n    \n  end\nend",
        "erlang_template": "-spec check_zero_ones(S :: unicode:unicode_binary()) -> boolean().\ncheck_zero_ones(S) ->\n  .",
        "scala_template": "object Solution {\n    def checkZeroOnes(s: String): Boolean = {\n        \n    }\n}"
    },
    {
        "id": 1996,
        "name": "number-of-ways-to-rearrange-sticks-with-k-sticks-visible",
        "difficulty": "Hard",
        "link": "https://leetcode.com/problems/number-of-ways-to-rearrange-sticks-with-k-sticks-visible/",
        "task_description": "There are `n` uniquely-sized sticks whose lengths are integers from `1` to `n`. You want to arrange the sticks such that **exactly** `k` sticks are **visible** from the left. A stick is **visible** from the left if there are no **longer** sticks to the **left** of it. For example, if the sticks are arranged `[1,3,2,5,4]`, then the sticks with lengths `1`, `3`, and `5` are visible from the left. Given `n` and `k`, return _the **number** of such arrangements_. Since the answer may be large, return it **modulo** `109 + 7`. **Example 1:** ``` **Input:** n = 3, k = 2 **Output:** 3 **Explanation:** [1,3,2], [2,3,1], and [2,1,3] are the only arrangements such that exactly 2 sticks are visible. The visible sticks are underlined. ``` **Example 2:** ``` **Input:** n = 5, k = 5 **Output:** 1 **Explanation:** [1,2,3,4,5] is the only arrangement such that all 5 sticks are visible. The visible sticks are underlined. ``` **Example 3:** ``` **Input:** n = 20, k = 11 **Output:** 647427950 **Explanation:** There are 647427950 (mod 109 + 7) ways to rearrange the sticks such that exactly 11 sticks are visible. ``` **Constraints:** `1 <= n <= 1000` `1 <= k <= n`",
        "test_case": [
            {
                "label": "Example 1",
                "input": "n = 3, k = 2",
                "output": "3 Explanation: [ 1 , 3 ,2], [ 2 , 3 ,1], and [ 2 ,1, 3 ] are the only arrangements such that exactly 2 sticks are visible.\nThe visible sticks are underlined."
            },
            {
                "label": "Example 2",
                "input": "n = 5, k = 5",
                "output": "1 Explanation: [ 1 , 2 , 3 , 4 , 5 ] is the only arrangement such that all 5 sticks are visible.\nThe visible sticks are underlined."
            },
            {
                "label": "Example 3",
                "input": "n = 20, k = 11",
                "output": "647427950 Explanation: There are 647427950 (mod 10 9 + 7) ways to rearrange the sticks such that exactly 11 sticks are visible."
            }
        ],
        "elixir_template": "defmodule Solution do\n  @spec rearrange_sticks(n :: integer, k :: integer) :: integer\n  def rearrange_sticks(n, k) do\n    \n  end\nend",
        "erlang_template": "-spec rearrange_sticks(N :: integer(), K :: integer()) -> integer().\nrearrange_sticks(N, K) ->\n  .",
        "scala_template": "object Solution {\n    def rearrangeSticks(n: Int, k: Int): Int = {\n        \n    }\n}"
    },
    {
        "id": 1995,
        "name": "finding-pairs-with-a-certain-sum",
        "difficulty": "Medium",
        "link": "https://leetcode.com/problems/finding-pairs-with-a-certain-sum/",
        "task_description": "You are given two integer arrays `nums1` and `nums2`. You are tasked to implement a data structure that supports queries of two types: **Add** a positive integer to an element of a given index in the array `nums2`. **Count** the number of pairs `(i, j)` such that `nums1[i] + nums2[j]` equals a given value (`0 <= i < nums1.length` and `0 <= j < nums2.length`). Implement the `FindSumPairs` class: `FindSumPairs(int[] nums1, int[] nums2)` Initializes the `FindSumPairs` object with two integer arrays `nums1` and `nums2`. `void add(int index, int val)` Adds `val` to `nums2[index]`, i.e., apply `nums2[index] += val`. `int count(int tot)` Returns the number of pairs `(i, j)` such that `nums1[i] + nums2[j] == tot`. **Example 1:** ``` **Input** [\"FindSumPairs\", \"count\", \"add\", \"count\", \"count\", \"add\", \"add\", \"count\"] [[[1, 1, 2, 2, 2, 3], [1, 4, 5, 2, 5, 4]], [7], [3, 2], [8], [4], [0, 1], [1, 1], [7]] **Output** [null, 8, null, 2, 1, null, null, 11] **Explanation** FindSumPairs findSumPairs = new FindSumPairs([1, 1, 2, 2, 2, 3], [1, 4, 5, 2, 5, 4]); findSumPairs.count(7); // return 8; pairs (2,2), (3,2), (4,2), (2,4), (3,4), (4,4) make 2 + 5 and pairs (5,1), (5,5) make 3 + 4 findSumPairs.add(3, 2); // now nums2 = [1,4,5,**4**`,5,4`] findSumPairs.count(8); // return 2; pairs (5,2), (5,4) make 3 + 5 findSumPairs.count(4); // return 1; pair (5,0) makes 3 + 1 findSumPairs.add(0, 1); // now nums2 = [**`2`**,4,5,4`,5,4`] findSumPairs.add(1, 1); // now nums2 = [`2`,**5**,5,4`,5,4`] findSumPairs.count(7); // return 11; pairs (2,1), (2,2), (2,4), (3,1), (3,2), (3,4), (4,1), (4,2), (4,4) make 2 + 5 and pairs (5,3), (5,5) make 3 + 4 ``` **Constraints:** `1 <= nums1.length <= 1000` `1 <= nums2.length <= 105` `1 <= nums1[i] <= 109` `1 <= nums2[i] <= 105` `0 <= index < nums2.length` `1 <= val <= 105` `1 <= tot <= 109` At most `1000` calls are made to `add` and `count` **each**.",
        "test_case": [],
        "elixir_template": "defmodule FindSumPairs do\n  @spec init_(nums1 :: [integer], nums2 :: [integer]) :: any\n  def init_(nums1, nums2) do\n    \n  end\n\n  @spec add(index :: integer, val :: integer) :: any\n  def add(index, val) do\n    \n  end\n\n  @spec count(tot :: integer) :: integer\n  def count(tot) do\n    \n  end\nend\n\n# Your functions will be called as such:\n# FindSumPairs.init_(nums1, nums2)\n# FindSumPairs.add(index, val)\n# param_2 = FindSumPairs.count(tot)\n\n# FindSumPairs.init_ will be called before every test case, in which you can do some necessary initializations.",
        "erlang_template": "-spec find_sum_pairs_init_(Nums1 :: [integer()], Nums2 :: [integer()]) -> any().\nfind_sum_pairs_init_(Nums1, Nums2) ->\n  .\n\n-spec find_sum_pairs_add(Index :: integer(), Val :: integer()) -> any().\nfind_sum_pairs_add(Index, Val) ->\n  .\n\n-spec find_sum_pairs_count(Tot :: integer()) -> integer().\nfind_sum_pairs_count(Tot) ->\n  .\n\n\n%% Your functions will be called as such:\n%% find_sum_pairs_init_(Nums1, Nums2),\n%% find_sum_pairs_add(Index, Val),\n%% Param_2 = find_sum_pairs_count(Tot),\n\n%% find_sum_pairs_init_ will be called before every test case, in which you can do some necessary initializations.",
        "scala_template": "class FindSumPairs(_nums1: Array[Int], _nums2: Array[Int]) {\n\n    def add(index: Int, `val`: Int): Unit = {\n        \n    }\n\n    def count(tot: Int): Int = {\n        \n    }\n\n}\n\n/**\n * Your FindSumPairs object will be instantiated and called as such:\n * val obj = new FindSumPairs(nums1, nums2)\n * obj.add(index,`val`)\n * val param_2 = obj.count(tot)\n */"
    },
    {
        "id": 1994,
        "name": "minimum-number-of-swaps-to-make-the-binary-string-alternating",
        "difficulty": "Medium",
        "link": "https://leetcode.com/problems/minimum-number-of-swaps-to-make-the-binary-string-alternating/",
        "task_description": "Given a binary string `s`, return _the **minimum** number of character swaps to make it **alternating**, or _`-1`_ if it is impossible._ The string is called **alternating** if no two adjacent characters are equal. For example, the strings `\"010\"` and `\"1010\"` are alternating, while the string `\"0100\"` is not. Any two characters may be swapped, even if they are **not adjacent**. **Example 1:** ``` **Input:** s = \"111000\" **Output:** 1 **Explanation:** Swap positions 1 and 4: \"111000\" -> \"101010\" The string is now alternating. ``` **Example 2:** ``` **Input:** s = \"010\" **Output:** 0 **Explanation:** The string is already alternating, no swaps are needed. ``` **Example 3:** ``` **Input:** s = \"1110\" **Output:** -1 ``` **Constraints:** `1 <= s.length <= 1000` `s[i]` is either `'0'` or `'1'`.",
        "test_case": [
            {
                "label": "Example 1",
                "input": "s = \"111000\"",
                "output": "1 Explanation: Swap positions 1 and 4: \"1 1 10 0 0\" -> \"1 0 10 1 0\"\nThe string is now alternating."
            },
            {
                "label": "Example 2",
                "input": "s = \"010\"",
                "output": "0 Explanation: The string is already alternating, no swaps are needed."
            },
            {
                "label": "Example 3",
                "input": "s = \"1110\"",
                "output": "-1"
            }
        ],
        "elixir_template": "defmodule Solution do\n  @spec min_swaps(s :: String.t) :: integer\n  def min_swaps(s) do\n    \n  end\nend",
        "erlang_template": "-spec min_swaps(S :: unicode:unicode_binary()) -> integer().\nmin_swaps(S) ->\n  .",
        "scala_template": "object Solution {\n    def minSwaps(s: String): Int = {\n        \n    }\n}"
    },
    {
        "id": 1993,
        "name": "sum-of-all-subset-xor-totals",
        "difficulty": "Easy",
        "link": "https://leetcode.com/problems/sum-of-all-subset-xor-totals/",
        "task_description": "The **XOR total** of an array is defined as the bitwise `XOR` of** all its elements**, or `0` if the array is** empty**. For example, the **XOR total** of the array `[2,5,6]` is `2 XOR 5 XOR 6 = 1`. Given an array `nums`, return _the **sum** of all **XOR totals** for every **subset** of _`nums`. **Note:** Subsets with the **same** elements should be counted **multiple** times. An array `a` is a **subset** of an array `b` if `a` can be obtained from `b` by deleting some (possibly zero) elements of `b`. **Example 1:** ``` **Input:** nums = [1,3] **Output:** 6 **Explanation: **The 4 subsets of [1,3] are: - The empty subset has an XOR total of 0. - [1] has an XOR total of 1. - [3] has an XOR total of 3. - [1,3] has an XOR total of 1 XOR 3 = 2. 0 + 1 + 3 + 2 = 6 ``` **Example 2:** ``` **Input:** nums = [5,1,6] **Output:** 28 **Explanation: **The 8 subsets of [5,1,6] are: - The empty subset has an XOR total of 0. - [5] has an XOR total of 5. - [1] has an XOR total of 1. - [6] has an XOR total of 6. - [5,1] has an XOR total of 5 XOR 1 = 4. - [5,6] has an XOR total of 5 XOR 6 = 3. - [1,6] has an XOR total of 1 XOR 6 = 7. - [5,1,6] has an XOR total of 5 XOR 1 XOR 6 = 2. 0 + 5 + 1 + 6 + 4 + 3 + 7 + 2 = 28 ``` **Example 3:** ``` **Input:** nums = [3,4,5,6,7,8] **Output:** 480 **Explanation:** The sum of all XOR totals for every subset is 480. ``` **Constraints:** `1 <= nums.length <= 12` `1 <= nums[i] <= 20`",
        "test_case": [
            {
                "label": "Example 1",
                "input": "nums = [1,3]",
                "output": "6 Explanation: The 4 subsets of [1,3] are:\n- The empty subset has an XOR total of 0.\n- [1] has an XOR total of 1.\n- [3] has an XOR total of 3.\n- [1,3] has an XOR total of 1 XOR 3 = 2.\n0 + 1 + 3 + 2 = 6"
            },
            {
                "label": "Example 2",
                "input": "nums = [5,1,6]",
                "output": "28 Explanation: The 8 subsets of [5,1,6] are:\n- The empty subset has an XOR total of 0.\n- [5] has an XOR total of 5.\n- [1] has an XOR total of 1.\n- [6] has an XOR total of 6.\n- [5,1] has an XOR total of 5 XOR 1 = 4.\n- [5,6] has an XOR total of 5 XOR 6 = 3.\n- [1,6] has an XOR total of 1 XOR 6 = 7.\n- [5,1,6] has an XOR total of 5 XOR 1 XOR 6 = 2.\n0 + 5 + 1 + 6 + 4 + 3 + 7 + 2 = 28"
            },
            {
                "label": "Example 3",
                "input": "nums = [3,4,5,6,7,8]",
                "output": "480 Explanation: The sum of all XOR totals for every subset is 480."
            }
        ],
        "elixir_template": "defmodule Solution do\n  @spec subset_xor_sum(nums :: [integer]) :: integer\n  def subset_xor_sum(nums) do\n    \n  end\nend",
        "erlang_template": "-spec subset_xor_sum(Nums :: [integer()]) -> integer().\nsubset_xor_sum(Nums) ->\n  .",
        "scala_template": "object Solution {\n    def subsetXORSum(nums: Array[Int]): Int = {\n        \n    }\n}"
    },
    {
        "id": 1990,
        "name": "get-biggest-three-rhombus-sums-in-a-grid",
        "difficulty": "Medium",
        "link": "https://leetcode.com/problems/get-biggest-three-rhombus-sums-in-a-grid/",
        "task_description": "You are given an `m x n` integer matrix `grid`\u200b\u200b\u200b. A **rhombus sum** is the sum of the elements that form **the** **border** of a regular rhombus shape in `grid`\u200b\u200b\u200b. The rhombus must have the shape of a square rotated 45 degrees with each of the corners centered in a grid cell. Below is an image of four valid rhombus shapes with the corresponding colored cells that should be included in each **rhombus sum**: Note that the rhombus can have an area of 0, which is depicted by the purple rhombus in the bottom right corner. Return _the biggest three **distinct rhombus sums** in the _`grid`_ in **descending order**__. If there are less than three distinct values, return all of them_. **Example 1:** ``` **Input:** grid = [[3,4,5,1,3],[3,3,4,2,3],[20,30,200,40,10],[1,5,5,4,1],[4,3,2,2,5]] **Output:** [228,216,211] **Explanation:** The rhombus shapes for the three biggest distinct rhombus sums are depicted above. - Blue: 20 + 3 + 200 + 5 = 228 - Red: 200 + 2 + 10 + 4 = 216 - Green: 5 + 200 + 4 + 2 = 211 ``` **Example 2:** ``` **Input:** grid = [[1,2,3],[4,5,6],[7,8,9]] **Output:** [20,9,8] **Explanation:** The rhombus shapes for the three biggest distinct rhombus sums are depicted above. - Blue: 4 + 2 + 6 + 8 = 20 - Red: 9 (area 0 rhombus in the bottom right corner) - Green: 8 (area 0 rhombus in the bottom middle) ``` **Example 3:** ``` **Input:** grid = [[7,7,7]] **Output:** [7] **Explanation:** All three possible rhombus sums are the same, so return [7]. ``` **Constraints:** `m == grid.length` `n == grid[i].length` `1 <= m, n <= 50` `1 <= grid[i][j] <= 105`",
        "test_case": [
            {
                "label": "Example 1",
                "input": "grid = [[3,4,5,1,3],[3,3,4,2,3],[20,30,200,40,10],[1,5,5,4,1],[4,3,2,2,5]]",
                "output": "[228,216,211] Explanation: The rhombus shapes for the three biggest distinct rhombus sums are depicted above.\n- Blue: 20 + 3 + 200 + 5 = 228\n- Red: 200 + 2 + 10 + 4 = 216\n- Green: 5 + 200 + 4 + 2 = 211"
            },
            {
                "label": "Example 2",
                "input": "grid = [[1,2,3],[4,5,6],[7,8,9]]",
                "output": "[20,9,8] Explanation: The rhombus shapes for the three biggest distinct rhombus sums are depicted above.\n- Blue: 4 + 2 + 6 + 8 = 20\n- Red: 9 (area 0 rhombus in the bottom right corner)\n- Green: 8 (area 0 rhombus in the bottom middle)"
            },
            {
                "label": "Example 3",
                "input": "grid = [[7,7,7]]",
                "output": "[7] Explanation: All three possible rhombus sums are the same, so return [7]. Constraints: m == grid.length n == grid[i].length 1 <= m, n <= 50 1 <= grid[i][j] <= 10 5"
            }
        ],
        "elixir_template": "defmodule Solution do\n  @spec get_biggest_three(grid :: [[integer]]) :: [integer]\n  def get_biggest_three(grid) do\n    \n  end\nend",
        "erlang_template": "-spec get_biggest_three(Grid :: [[integer()]]) -> [integer()].\nget_biggest_three(Grid) ->\n  .",
        "scala_template": "object Solution {\n    def getBiggestThree(grid: Array[Array[Int]]): Array[Int] = {\n        \n    }\n}"
    },
    {
        "id": 1989,
        "name": "minimum-xor-sum-of-two-arrays",
        "difficulty": "Hard",
        "link": "https://leetcode.com/problems/minimum-xor-sum-of-two-arrays/",
        "task_description": "You are given two integer arrays `nums1` and `nums2` of length `n`. The **XOR sum** of the two integer arrays is `(nums1[0] XOR nums2[0]) + (nums1[1] XOR nums2[1]) + ... + (nums1[n - 1] XOR nums2[n - 1])` (**0-indexed**). For example, the **XOR sum** of `[1,2,3]` and `[3,2,1]` is equal to `(1 XOR 3) + (2 XOR 2) + (3 XOR 1) = 2 + 0 + 2 = 4`. Rearrange the elements of `nums2` such that the resulting **XOR sum** is minimized. Return _the **XOR sum** after the rearrangement_. **Example 1:** ``` **Input:** nums1 = [1,2], nums2 = [2,3] **Output:** 2 Explanation: Rearrange `nums2` so that it becomes `[3,2]`. The XOR sum is (1 XOR 3) + (2 XOR 2) = 2 + 0 = 2. ``` **Example 2:** ``` **Input:** nums1 = [1,0,3], nums2 = [5,3,4] **Output:** 8 Explanation: Rearrange `nums2` so that it becomes `[5,4,3]`. The XOR sum is (1 XOR 5) + (0 XOR 4) + (3 XOR 3) = 4 + 4 + 0 = 8. ``` **Constraints:** `n == nums1.length` `n == nums2.length` `1 <= n <= 14` `0 <= nums1[i], nums2[i] <= 107`",
        "test_case": [
            {
                "label": "Example 1",
                "input": "nums1 = [1,2], nums2 = [2,3]",
                "output": "2 Explanation: Rearrange nums2 so that it becomes [3,2] .\nThe XOR sum is (1 XOR 3) + (2 XOR 2) = 2 + 0 = 2."
            },
            {
                "label": "Example 2",
                "input": "nums1 = [1,0,3], nums2 = [5,3,4]",
                "output": "8 Explanation: Rearrange nums2 so that it becomes [5,4,3] . \nThe XOR sum is (1 XOR 5) + (0 XOR 4) + (3 XOR 3) = 4 + 4 + 0 = 8. Constraints: n == nums1.length n == nums2.length 1 <= n <= 14 0 <= nums1[i], nums2[i] <= 10 7"
            }
        ],
        "elixir_template": "defmodule Solution do\n  @spec minimum_xor_sum(nums1 :: [integer], nums2 :: [integer]) :: integer\n  def minimum_xor_sum(nums1, nums2) do\n    \n  end\nend",
        "erlang_template": "-spec minimum_xor_sum(Nums1 :: [integer()], Nums2 :: [integer()]) -> integer().\nminimum_xor_sum(Nums1, Nums2) ->\n  .",
        "scala_template": "object Solution {\n    def minimumXORSum(nums1: Array[Int], nums2: Array[Int]): Int = {\n        \n    }\n}"
    },
    {
        "id": 1988,
        "name": "minimize-maximum-pair-sum-in-array",
        "difficulty": "Medium",
        "link": "https://leetcode.com/problems/minimize-maximum-pair-sum-in-array/",
        "task_description": "The **pair sum** of a pair `(a,b)` is equal to `a + b`. The **maximum pair sum** is the largest **pair sum** in a list of pairs. For example, if we have pairs `(1,5)`, `(2,3)`, and `(4,4)`, the **maximum pair sum** would be `max(1+5, 2+3, 4+4) = max(6, 5, 8) = 8`. Given an array `nums` of **even** length `n`, pair up the elements of `nums` into `n / 2` pairs such that: Each element of `nums` is in **exactly one** pair, and The **maximum pair sum **is **minimized**. Return _the minimized **maximum pair sum** after optimally pairing up the elements_. **Example 1:** ``` **Input:** nums = [3,5,2,3] **Output:** 7 **Explanation:** The elements can be paired up into pairs (3,3) and (5,2). The maximum pair sum is max(3+3, 5+2) = max(6, 7) = 7. ``` **Example 2:** ``` **Input:** nums = [3,5,4,2,4,6] **Output:** 8 **Explanation:** The elements can be paired up into pairs (3,5), (4,4), and (6,2). The maximum pair sum is max(3+5, 4+4, 6+2) = max(8, 8, 8) = 8. ``` **Constraints:** `n == nums.length` `2 <= n <= 105` `n` is **even**. `1 <= nums[i] <= 105`",
        "test_case": [
            {
                "label": "Example 1",
                "input": "nums = [3,5,2,3]",
                "output": "7 Explanation: The elements can be paired up into pairs (3,3) and (5,2).\r\nThe maximum pair sum is max(3+3, 5+2) = max(6, 7) = 7."
            },
            {
                "label": "Example 2",
                "input": "nums = [3,5,4,2,4,6]",
                "output": "8 Explanation: The elements can be paired up into pairs (3,5), (4,4), and (6,2).\r\nThe maximum pair sum is max(3+5, 4+4, 6+2) = max(8, 8, 8) = 8. Constraints: n == nums.length 2 <= n <= 10 5 n is even . 1 <= nums[i] <= 10 5"
            }
        ],
        "elixir_template": "Elixir code template not available for this problem.",
        "erlang_template": "Elixir code template not available for this problem.",
        "scala_template": "object Solution {\n    def minPairSum(nums: Array[Int]): Int = {\n        \n    }\n}"
    },
    {
        "id": 1987,
        "name": "substrings-of-size-three-with-distinct-characters",
        "difficulty": "Easy",
        "link": "https://leetcode.com/problems/substrings-of-size-three-with-distinct-characters/",
        "task_description": "A string is **good** if there are no repeated characters. Given a string `s`\u200b\u200b\u200b\u200b\u200b, return _the number of **good substrings** of length **three **in _`s`\u200b\u200b\u200b\u200b\u200b\u200b. Note that if there are multiple occurrences of the same substring, every occurrence should be counted. A **substring** is a contiguous sequence of characters in a string. **Example 1:** ``` **Input:** s = \"xyzzaz\" **Output:** 1 **Explanation:** There are 4 substrings of size 3: \"xyz\", \"yzz\", \"zza\", and \"zaz\". The only good substring of length 3 is \"xyz\". ``` **Example 2:** ``` **Input:** s = \"aababcabc\" **Output:** 4 **Explanation:** There are 7 substrings of size 3: \"aab\", \"aba\", \"bab\", \"abc\", \"bca\", \"cab\", and \"abc\". The good substrings are \"abc\", \"bca\", \"cab\", and \"abc\". ``` **Constraints:** `1 <= s.length <= 100` `s`\u200b\u200b\u200b\u200b\u200b\u200b consists of lowercase English letters.",
        "test_case": [
            {
                "label": "Example 1",
                "input": "s = \"xyzzaz\"",
                "output": "1 Explanation: There are 4 substrings of size 3: \"xyz\", \"yzz\", \"zza\", and \"zaz\". \nThe only good substring of length 3 is \"xyz\"."
            },
            {
                "label": "Example 2",
                "input": "s = \"aababcabc\"",
                "output": "4 Explanation: There are 7 substrings of size 3: \"aab\", \"aba\", \"bab\", \"abc\", \"bca\", \"cab\", and \"abc\".\nThe good substrings are \"abc\", \"bca\", \"cab\", and \"abc\"."
            }
        ],
        "elixir_template": "defmodule Solution do\n  @spec count_good_substrings(s :: String.t) :: integer\n  def count_good_substrings(s) do\n    \n  end\nend",
        "erlang_template": "-spec count_good_substrings(S :: unicode:unicode_binary()) -> integer().\ncount_good_substrings(S) ->\n  .",
        "scala_template": "object Solution {\n    def countGoodSubstrings(s: String): Int = {\n        \n    }\n}"
    },
    {
        "id": 1986,
        "name": "largest-color-value-in-a-directed-graph",
        "difficulty": "Hard",
        "link": "https://leetcode.com/problems/largest-color-value-in-a-directed-graph/",
        "task_description": "There is a **directed graph** of `n` colored nodes and `m` edges. The nodes are numbered from `0` to `n - 1`. You are given a string `colors` where `colors[i]` is a lowercase English letter representing the **color** of the `ith` node in this graph (**0-indexed**). You are also given a 2D array `edges` where `edges[j] = [aj, bj]` indicates that there is a **directed edge** from node `aj` to node `bj`. A valid **path** in the graph is a sequence of nodes `x1 -> x2 -> x3 -> ... -> xk` such that there is a directed edge from `xi` to `xi+1` for every `1 <= i < k`. The **color value** of the path is the number of nodes that are colored the **most frequently** occurring color along that path. Return _the **largest color value** of any valid path in the given graph, or _`-1`_ if the graph contains a cycle_. **Example 1:** ``` **Input:** colors = \"abaca\", edges = [[0,1],[0,2],[2,3],[3,4]] **Output:** 3 **Explanation:** The path 0 -> 2 -> 3 -> 4 contains 3 nodes that are colored `\"a\" (red in the above image)`. ``` **Example 2:** ``` **Input:** colors = \"a\", edges = [[0,0]] **Output:** -1 **Explanation:** There is a cycle from 0 to 0. ``` **Constraints:** `n == colors.length` `m == edges.length` `1 <= n <= 105` `0 <= m <= 105` `colors` consists of lowercase English letters. `0 <= aj, bj < n`",
        "test_case": [
            {
                "label": "Example 1",
                "input": "colors = \"abaca\", edges = [[0,1],[0,2],[2,3],[3,4]]",
                "output": "3 Explanation: The path 0 -> 2 -> 3 -> 4 contains 3 nodes that are colored \"a\" (red in the above image) ."
            },
            {
                "label": "Example 2",
                "input": "colors = \"a\", edges = [[0,0]]",
                "output": "-1 Explanation: There is a cycle from 0 to 0. Constraints: n == colors.length m == edges.length 1 <= n <= 10 5 0 <= m <= 10 5 colors consists of lowercase English letters. 0 <= a j , b j < n"
            }
        ],
        "elixir_template": "Elixir code template not available for this problem.",
        "erlang_template": "Elixir code template not available for this problem.",
        "scala_template": "object Solution {\r\n    def largestPathValue(colors: String, edges: Array[Array[Int]]): Int = {\r\n        \r\n    }\r\n}"
    },
    {
        "id": 1985,
        "name": "maximum-subarray-min-product",
        "difficulty": "Medium",
        "link": "https://leetcode.com/problems/maximum-subarray-min-product/",
        "task_description": "The **min-product** of an array is equal to the **minimum value** in the array **multiplied by** the array's **sum**. For example, the array `[3,2,5]` (minimum value is `2`) has a min-product of `2 * (3+2+5) = 2 * 10 = 20`. Given an array of integers `nums`, return _the **maximum min-product** of any **non-empty subarray** of _`nums`. Since the answer may be large, return it **modulo** `109 + 7`. Note that the min-product should be maximized **before** performing the modulo operation. Testcases are generated such that the maximum min-product **without** modulo will fit in a **64-bit signed integer**. A **subarray** is a **contiguous** part of an array. **Example 1:** ``` **Input:** nums = [1,2,3,2] **Output:** 14 **Explanation:** The maximum min-product is achieved with the subarray [2,3,2] (minimum value is 2). 2 * (2+3+2) = 2 * 7 = 14. ``` **Example 2:** ``` **Input:** nums = [2,3,3,1,2] **Output:** 18 **Explanation:** The maximum min-product is achieved with the subarray [3,3] (minimum value is 3). 3 * (3+3) = 3 * 6 = 18. ``` **Example 3:** ``` **Input:** nums = [3,1,5,6,4,2] **Output:** 60 **Explanation:** The maximum min-product is achieved with the subarray [5,6,4] (minimum value is 4). 4 * (5+6+4) = 4 * 15 = 60. ``` **Constraints:** `1 <= nums.length <= 105` `1 <= nums[i] <= 107`",
        "test_case": [
            {
                "label": "Example 1",
                "input": "nums = [1, 2,3,2 ]",
                "output": "14 Explanation: The maximum min-product is achieved with the subarray [2,3,2] (minimum value is 2).\n2 * (2+3+2) = 2 * 7 = 14."
            },
            {
                "label": "Example 2",
                "input": "nums = [2, 3,3 ,1,2]",
                "output": "18 Explanation: The maximum min-product is achieved with the subarray [3,3] (minimum value is 3).\n3 * (3+3) = 3 * 6 = 18."
            },
            {
                "label": "Example 3",
                "input": "nums = [3,1, 5,6,4 ,2]",
                "output": "60 Explanation: The maximum min-product is achieved with the subarray [5,6,4] (minimum value is 4).\n4 * (5+6+4) = 4 * 15 = 60."
            }
        ],
        "elixir_template": "defmodule Solution do\n  @spec max_sum_min_product(nums :: [integer]) :: integer\n  def max_sum_min_product(nums) do\n    \n  end\nend",
        "erlang_template": "-spec max_sum_min_product(Nums :: [integer()]) -> integer().\nmax_sum_min_product(Nums) ->\n  .",
        "scala_template": "object Solution {\n    def maxSumMinProduct(nums: Array[Int]): Int = {\n        \n    }\n}"
    },
    {
        "id": 1984,
        "name": "maximum-distance-between-a-pair-of-values",
        "difficulty": "Medium",
        "link": "https://leetcode.com/problems/maximum-distance-between-a-pair-of-values/",
        "task_description": "You are given two **non-increasing 0-indexed **integer arrays `nums1`\u200b\u200b\u200b\u200b\u200b\u200b and `nums2`\u200b\u200b\u200b\u200b\u200b\u200b. A pair of indices `(i, j)`, where `0 <= i < nums1.length` and `0 <= j < nums2.length`, is **valid** if both `i <= j` and `nums1[i] <= nums2[j]`. The **distance** of the pair is `j - i`\u200b\u200b\u200b\u200b. Return _the **maximum distance** of any **valid** pair _`(i, j)`_. If there are no valid pairs, return _`0`. An array `arr` is **non-increasing** if `arr[i-1] >= arr[i]` for every `1 <= i < arr.length`. **Example 1:** ``` **Input:** nums1 = [55,30,5,4,2], nums2 = [100,20,10,10,5] **Output:** 2 **Explanation:** The valid pairs are (0,0), (2,2), (2,3), (2,4), (3,3), (3,4), and (4,4). The maximum distance is 2 with pair (2,4). ``` **Example 2:** ``` **Input:** nums1 = [2,2,2], nums2 = [10,10,1] **Output:** 1 **Explanation:** The valid pairs are (0,0), (0,1), and (1,1). The maximum distance is 1 with pair (0,1). ``` **Example 3:** ``` **Input:** nums1 = [30,29,19,5], nums2 = [25,25,25,25,25] **Output:** 2 **Explanation:** The valid pairs are (2,2), (2,3), (2,4), (3,3), and (3,4). The maximum distance is 2 with pair (2,4). ``` **Constraints:** `1 <= nums1.length, nums2.length <= 105` `1 <= nums1[i], nums2[j] <= 105` Both `nums1` and `nums2` are **non-increasing**.",
        "test_case": [
            {
                "label": "Example 1",
                "input": "nums1 = [55,30,5,4,2], nums2 = [100,20,10,10,5]",
                "output": "2 Explanation: The valid pairs are (0,0), (2,2), (2,3), (2,4), (3,3), (3,4), and (4,4).\nThe maximum distance is 2 with pair (2,4)."
            },
            {
                "label": "Example 2",
                "input": "nums1 = [2,2,2], nums2 = [10,10,1]",
                "output": "1 Explanation: The valid pairs are (0,0), (0,1), and (1,1).\nThe maximum distance is 1 with pair (0,1)."
            },
            {
                "label": "Example 3",
                "input": "nums1 = [30,29,19,5], nums2 = [25,25,25,25,25]",
                "output": "2 Explanation: The valid pairs are (2,2), (2,3), (2,4), (3,3), and (3,4).\nThe maximum distance is 2 with pair (2,4)."
            }
        ],
        "elixir_template": "defmodule Solution do\n  @spec max_distance(nums1 :: [integer], nums2 :: [integer]) :: integer\n  def max_distance(nums1, nums2) do\n    \n  end\nend",
        "erlang_template": "-spec max_distance(Nums1 :: [integer()], Nums2 :: [integer()]) -> integer().\nmax_distance(Nums1, Nums2) ->\n  .",
        "scala_template": "object Solution {\n    def maxDistance(nums1: Array[Int], nums2: Array[Int]): Int = {\n        \n    }\n}"
    },
    {
        "id": 1983,
        "name": "maximum-population-year",
        "difficulty": "Easy",
        "link": "https://leetcode.com/problems/maximum-population-year/",
        "task_description": "You are given a 2D integer array `logs` where each `logs[i] = [birthi, deathi]` indicates the birth and death years of the `ith` person. The **population** of some year `x` is the number of people alive during that year. The `ith` person is counted in year `x`'s population if `x` is in the **inclusive** range `[birthi, deathi - 1]`. Note that the person is **not** counted in the year that they die. Return _the **earliest** year with the **maximum population**_. **Example 1:** ``` **Input:** logs = [[1993,1999],[2000,2010]] **Output:** 1993 **Explanation:** The maximum population is 1, and 1993 is the earliest year with this population. ``` **Example 2:** ``` **Input:** logs = [[1950,1961],[1960,1971],[1970,1981]] **Output:** 1960 **Explanation:** The maximum population is 2, and it had happened in years 1960 and 1970. The earlier year between them is 1960. ``` **Constraints:** `1 <= logs.length <= 100` `1950 <= birthi < deathi <= 2050`",
        "test_case": [
            {
                "label": "Example 1",
                "input": "logs = [[1993,1999],[2000,2010]]",
                "output": "1993 Explanation: The maximum population is 1, and 1993 is the earliest year with this population."
            },
            {
                "label": "Example 2",
                "input": "logs = [[1950,1961],[1960,1971],[1970,1981]]",
                "output": "1960 Explanation: The maximum population is 2, and it had happened in years 1960 and 1970.\nThe earlier year between them is 1960."
            }
        ],
        "elixir_template": "defmodule Solution do\n  @spec maximum_population(logs :: [[integer]]) :: integer\n  def maximum_population(logs) do\n    \n  end\nend",
        "erlang_template": "-spec maximum_population(Logs :: [[integer()]]) -> integer().\nmaximum_population(Logs) ->\n  .",
        "scala_template": "object Solution {\n    def maximumPopulation(logs: Array[Array[Int]]): Int = {\n        \n    }\n}"
    },
    {
        "id": 1978,
        "name": "minimum-adjacent-swaps-to-reach-the-kth-smallest-number",
        "difficulty": "Medium",
        "link": "https://leetcode.com/problems/minimum-adjacent-swaps-to-reach-the-kth-smallest-number/",
        "task_description": "You are given a string `num`, representing a large integer, and an integer `k`. We call some integer **wonderful** if it is a **permutation** of the digits in `num` and is **greater in value** than `num`. There can be many wonderful integers. However, we only care about the **smallest-valued** ones. For example, when `num = \"5489355142\"`: The 1st smallest wonderful integer is `\"5489355214\"`. The 2nd smallest wonderful integer is `\"5489355241\"`. The 3rd smallest wonderful integer is `\"5489355412\"`. The 4th smallest wonderful integer is `\"5489355421\"`. Return _the **minimum number of adjacent digit swaps** that needs to be applied to _`num`_ to reach the _`kth`_** smallest wonderful** integer_. The tests are generated in such a way that `kth` smallest wonderful integer exists. **Example 1:** ``` **Input:** num = \"5489355142\", k = 4 **Output:** 2 **Explanation:** The 4th smallest wonderful number is \"5489355421\". To get this number: - Swap index 7 with index 8: \"5489355142\" -> \"5489355412\" - Swap index 8 with index 9: \"5489355412\" -> \"5489355421\" ``` **Example 2:** ``` **Input:** num = \"11112\", k = 4 **Output:** 4 **Explanation:** The 4th smallest wonderful number is \"21111\". To get this number: - Swap index 3 with index 4: \"11112\" -> \"11121\" - Swap index 2 with index 3: \"11121\" -> \"11211\" - Swap index 1 with index 2: \"11211\" -> \"12111\" - Swap index 0 with index 1: \"12111\" -> \"21111\" ``` **Example 3:** ``` **Input:** num = \"00123\", k = 1 **Output:** 1 **Explanation:** The 1st smallest wonderful number is \"00132\". To get this number: - Swap index 3 with index 4: \"00123\" -> \"00132\" ``` **Constraints:** `2 <= num.length <= 1000` `1 <= k <= 1000` `num` only consists of digits.",
        "test_case": [
            {
                "label": "Example 1",
                "input": "num = \"5489355142\", k = 4",
                "output": "2 Explanation: The 4 th smallest wonderful number is \"5489355421\". To get this number:\n- Swap index 7 with index 8: \"5489355 14 2\" -> \"5489355 41 2\"\n- Swap index 8 with index 9: \"54893554 12 \" -> \"54893554 21 \""
            },
            {
                "label": "Example 2",
                "input": "num = \"11112\", k = 4",
                "output": "4 Explanation: The 4 th smallest wonderful number is \"21111\". To get this number:\n- Swap index 3 with index 4: \"111 12 \" -> \"111 21 \"\n- Swap index 2 with index 3: \"11 12 1\" -> \"11 21 1\"\n- Swap index 1 with index 2: \"1 12 11\" -> \"1 21 11\"\n- Swap index 0 with index 1: \" 12 111\" -> \" 21 111\""
            },
            {
                "label": "Example 3",
                "input": "num = \"00123\", k = 1",
                "output": "1 Explanation: The 1 st smallest wonderful number is \"00132\". To get this number:\n- Swap index 3 with index 4: \"001 23 \" -> \"001 32 \""
            }
        ],
        "elixir_template": "defmodule Solution do\n  @spec get_min_swaps(num :: String.t, k :: integer) :: integer\n  def get_min_swaps(num, k) do\n    \n  end\nend",
        "erlang_template": "-spec get_min_swaps(Num :: unicode:unicode_binary(), K :: integer()) -> integer().\nget_min_swaps(Num, K) ->\n  .",
        "scala_template": "object Solution {\n    def getMinSwaps(num: String, k: Int): Int = {\n        \n    }\n}"
    },
    {
        "id": 1977,
        "name": "minimum-interval-to-include-each-query",
        "difficulty": "Hard",
        "link": "https://leetcode.com/problems/minimum-interval-to-include-each-query/",
        "task_description": "You are given a 2D integer array `intervals`, where `intervals[i] = [lefti, righti]` describes the `ith` interval starting at `lefti` and ending at `righti` **(inclusive)**. The **size** of an interval is defined as the number of integers it contains, or more formally `righti - lefti + 1`. You are also given an integer array `queries`. The answer to the `jth` query is the **size of the smallest interval** `i` such that `lefti <= queries[j] <= righti`. If no such interval exists, the answer is `-1`. Return _an array containing the answers to the queries_. **Example 1:** ``` **Input:** intervals = [[1,4],[2,4],[3,6],[4,4]], queries = [2,3,4,5] **Output:** [3,3,1,4] **Explanation:** The queries are processed as follows: - Query = 2: The interval [2,4] is the smallest interval containing 2. The answer is 4 - 2 + 1 = 3. - Query = 3: The interval [2,4] is the smallest interval containing 3. The answer is 4 - 2 + 1 = 3. - Query = 4: The interval [4,4] is the smallest interval containing 4. The answer is 4 - 4 + 1 = 1. - Query = 5: The interval [3,6] is the smallest interval containing 5. The answer is 6 - 3 + 1 = 4. ``` **Example 2:** ``` **Input:** intervals = [[2,3],[2,5],[1,8],[20,25]], queries = [2,19,5,22] **Output:** [2,-1,4,6] **Explanation:** The queries are processed as follows: - Query = 2: The interval [2,3] is the smallest interval containing 2. The answer is 3 - 2 + 1 = 2. - Query = 19: None of the intervals contain 19. The answer is -1. - Query = 5: The interval [2,5] is the smallest interval containing 5. The answer is 5 - 2 + 1 = 4. - Query = 22: The interval [20,25] is the smallest interval containing 22. The answer is 25 - 20 + 1 = 6. ``` **Constraints:** `1 <= intervals.length <= 105` `1 <= queries.length <= 105` `intervals[i].length == 2` `1 <= lefti <= righti <= 107` `1 <= queries[j] <= 107`",
        "test_case": [
            {
                "label": "Example 1",
                "input": "intervals = [[1,4],[2,4],[3,6],[4,4]], queries = [2,3,4,5]",
                "output": "[3,3,1,4] Explanation: The queries are processed as follows:\n- Query = 2: The interval [2,4] is the smallest interval containing 2. The answer is 4 - 2 + 1 = 3.\n- Query = 3: The interval [2,4] is the smallest interval containing 3. The answer is 4 - 2 + 1 = 3.\n- Query = 4: The interval [4,4] is the smallest interval containing 4. The answer is 4 - 4 + 1 = 1.\n- Query = 5: The interval [3,6] is the smallest interval containing 5. The answer is 6 - 3 + 1 = 4."
            },
            {
                "label": "Example 2",
                "input": "intervals = [[2,3],[2,5],[1,8],[20,25]], queries = [2,19,5,22]",
                "output": "[2,-1,4,6] Explanation: The queries are processed as follows:\n- Query = 2: The interval [2,3] is the smallest interval containing 2. The answer is 3 - 2 + 1 = 2.\n- Query = 19: None of the intervals contain 19. The answer is -1.\n- Query = 5: The interval [2,5] is the smallest interval containing 5. The answer is 5 - 2 + 1 = 4.\n- Query = 22: The interval [20,25] is the smallest interval containing 22. The answer is 25 - 20 + 1 = 6."
            }
        ],
        "elixir_template": "defmodule Solution do\n  @spec min_interval(intervals :: [[integer]], queries :: [integer]) :: [integer]\n  def min_interval(intervals, queries) do\n    \n  end\nend",
        "erlang_template": "-spec min_interval(Intervals :: [[integer()]], Queries :: [integer()]) -> [integer()].\nmin_interval(Intervals, Queries) ->\n  .",
        "scala_template": "object Solution {\n    def minInterval(intervals: Array[Array[Int]], queries: Array[Int]): Array[Int] = {\n        \n    }\n}"
    },
    {
        "id": 1976,
        "name": "splitting-a-string-into-descending-consecutive-values",
        "difficulty": "Medium",
        "link": "https://leetcode.com/problems/splitting-a-string-into-descending-consecutive-values/",
        "task_description": "You are given a string `s` that consists of only digits. Check if we can split `s` into **two or more non-empty substrings** such that the **numerical values** of the substrings are in **descending order** and the **difference** between numerical values of every two **adjacent** **substrings** is equal to `1`. For example, the string `s = \"0090089\"` can be split into `[\"0090\", \"089\"]` with numerical values `[90,89]`. The values are in descending order and adjacent values differ by `1`, so this way is valid. Another example, the string `s = \"001\"` can be split into `[\"0\", \"01\"]`, `[\"00\", \"1\"]`, or `[\"0\", \"0\", \"1\"]`. However all the ways are invalid because they have numerical values `[0,1]`, `[0,1]`, and `[0,0,1]` respectively, all of which are not in descending order. Return `true` _if it is possible to split_ `s`\u200b\u200b\u200b\u200b\u200b\u200b _as described above__, or _`false`_ otherwise._ A **substring** is a contiguous sequence of characters in a string. **Example 1:** ``` **Input:** s = \"1234\" **Output:** false **Explanation:** There is no valid way to split s. ``` **Example 2:** ``` **Input:** s = \"050043\" **Output:** true **Explanation:** s can be split into [\"05\", \"004\", \"3\"] with numerical values [5,4,3]. The values are in descending order with adjacent values differing by 1. ``` **Example 3:** ``` **Input:** s = \"9080701\" **Output:** false **Explanation:** There is no valid way to split s. ``` **Constraints:** `1 <= s.length <= 20` `s` only consists of digits.",
        "test_case": [
            {
                "label": "Example 1",
                "input": "s = \"1234\"",
                "output": "false Explanation: There is no valid way to split s."
            },
            {
                "label": "Example 2",
                "input": "s = \"050043\"",
                "output": "true Explanation: s can be split into [\"05\", \"004\", \"3\"] with numerical values [5,4,3].\nThe values are in descending order with adjacent values differing by 1."
            },
            {
                "label": "Example 3",
                "input": "s = \"9080701\"",
                "output": "false Explanation: There is no valid way to split s."
            }
        ],
        "elixir_template": "defmodule Solution do\n  @spec split_string(s :: String.t) :: boolean\n  def split_string(s) do\n    \n  end\nend",
        "erlang_template": "-spec split_string(S :: unicode:unicode_binary()) -> boolean().\nsplit_string(S) ->\n  .",
        "scala_template": "object Solution {\n    def splitString(s: String): Boolean = {\n        \n    }\n}"
    },
    {
        "id": 1975,
        "name": "minimum-distance-to-the-target-element",
        "difficulty": "Easy",
        "link": "https://leetcode.com/problems/minimum-distance-to-the-target-element/",
        "task_description": "Given an integer array `nums` **(0-indexed)** and two integers `target` and `start`, find an index `i` such that `nums[i] == target` and `abs(i - start)` is **minimized**. Note that `abs(x)` is the absolute value of `x`. Return `abs(i - start)`. It is **guaranteed** that `target` exists in `nums`. **Example 1:** ``` **Input:** nums = [1,2,3,4,5], target = 5, start = 3 **Output:** 1 **Explanation:** nums[4] = 5 is the only value equal to target, so the answer is abs(4 - 3) = 1. ``` **Example 2:** ``` **Input:** nums = [1], target = 1, start = 0 **Output:** 0 **Explanation:** nums[0] = 1 is the only value equal to target, so the answer is abs(0 - 0) = 0. ``` **Example 3:** ``` **Input:** nums = [1,1,1,1,1,1,1,1,1,1], target = 1, start = 0 **Output:** 0 **Explanation:** Every value of nums is 1, but nums[0] minimizes abs(i - start), which is abs(0 - 0) = 0. ``` **Constraints:** `1 <= nums.length <= 1000` `1 <= nums[i] <= 104` `0 <= start < nums.length` `target` is in `nums`.",
        "test_case": [
            {
                "label": "Example 1",
                "input": "nums = [1,2,3,4,5], target = 5, start = 3",
                "output": "1 Explanation: nums[4] = 5 is the only value equal to target, so the answer is abs(4 - 3) = 1."
            },
            {
                "label": "Example 2",
                "input": "nums = [1], target = 1, start = 0",
                "output": "0 Explanation: nums[0] = 1 is the only value equal to target, so the answer is abs(0 - 0) = 0."
            },
            {
                "label": "Example 3",
                "input": "nums = [1,1,1,1,1,1,1,1,1,1], target = 1, start = 0",
                "output": "0 Explanation: Every value of nums is 1, but nums[0] minimizes abs(i - start), which is abs(0 - 0) = 0."
            }
        ],
        "elixir_template": "defmodule Solution do\n  @spec get_min_distance(nums :: [integer], target :: integer, start :: integer) :: integer\n  def get_min_distance(nums, target, start) do\n    \n  end\nend",
        "erlang_template": "-spec get_min_distance(Nums :: [integer()], Target :: integer(), Start :: integer()) -> integer().\nget_min_distance(Nums, Target, Start) ->\n  .",
        "scala_template": "object Solution {\n    def getMinDistance(nums: Array[Int], target: Int, start: Int): Int = {\n        \n    }\n}"
    },
    {
        "id": 1972,
        "name": "rotating-the-box",
        "difficulty": "Medium",
        "link": "https://leetcode.com/problems/rotating-the-box/",
        "task_description": "You are given an `m x n` matrix of characters `boxGrid` representing a side-view of a box. Each cell of the box is one of the following: A stone `'#'` A stationary obstacle `'*'` Empty `'.'` The box is rotated **90 degrees clockwise**, causing some of the stones to fall due to gravity. Each stone falls down until it lands on an obstacle, another stone, or the bottom of the box. Gravity **does not** affect the obstacles' positions, and the inertia from the box's rotation **does not **affect the stones' horizontal positions. It is **guaranteed** that each stone in `boxGrid` rests on an obstacle, another stone, or the bottom of the box. Return _an _`n x m`_ matrix representing the box after the rotation described above_. **Example 1:** ``` **Input:** boxGrid = [[\"#\",\".\",\"#\"]] **Output:** [[\".\"], [\"#\"], [\"#\"]] ``` **Example 2:** ``` **Input:** boxGrid = [[\"#\",\".\",\"*\",\".\"], [\"#\",\"#\",\"*\",\".\"]] **Output:** [[\"#\",\".\"], [\"#\",\"#\"], [\"*\",\"*\"], [\".\",\".\"]] ``` **Example 3:** ``` **Input:** boxGrid = [[\"#\",\"#\",\"*\",\".\",\"*\",\".\"], [\"#\",\"#\",\"#\",\"*\",\".\",\".\"], [\"#\",\"#\",\"#\",\".\",\"#\",\".\"]] **Output:** [[\".\",\"#\",\"#\"], [\".\",\"#\",\"#\"], [\"#\",\"#\",\"*\"], [\"#\",\"*\",\".\"], [\"#\",\".\",\"*\"], [\"#\",\".\",\".\"]] ``` **Constraints:** `m == boxGrid.length` `n == boxGrid[i].length` `1 <= m, n <= 500` `boxGrid[i][j]` is either `'#'`, `'*'`, or `'.'`.",
        "test_case": [
            {
                "label": "Example 1",
                "input": "boxGrid = [[\"#\",\".\",\"#\"]]",
                "output": "[[\".\"],\n\u00a0        [\"#\"],\n\u00a0        [\"#\"]]"
            },
            {
                "label": "Example 2",
                "input": "boxGrid = [[\"#\",\".\",\"*\",\".\"],\n\u00a0             [\"#\",\"#\",\"*\",\".\"]]",
                "output": "[[\"#\",\".\"],\n\u00a0        [\"#\",\"#\"],\n\u00a0        [\"*\",\"*\"],\n\u00a0        [\".\",\".\"]]"
            },
            {
                "label": "Example 3",
                "input": "boxGrid = [[\"#\",\"#\",\"*\",\".\",\"*\",\".\"],\n\u00a0             [\"#\",\"#\",\"#\",\"*\",\".\",\".\"],\n\u00a0             [\"#\",\"#\",\"#\",\".\",\"#\",\".\"]]",
                "output": "[[\".\",\"#\",\"#\"],\n\u00a0        [\".\",\"#\",\"#\"],\n\u00a0        [\"#\",\"#\",\"*\"],\n\u00a0        [\"#\",\"*\",\".\"],\n\u00a0        [\"#\",\".\",\"*\"],\n\u00a0        [\"#\",\".\",\".\"]] Constraints: m == boxGrid.length n == boxGrid[i].length 1 <= m, n <= 500 boxGrid[i][j] is either '#' , '*' , or '.' ."
            }
        ],
        "elixir_template": "defmodule Solution do\n  @spec rotate_the_box(box_grid :: [[char]]) :: [[char]]\n  def rotate_the_box(box_grid) do\n    \n  end\nend",
        "erlang_template": "-spec rotate_the_box(BoxGrid :: [[char()]]) -> [[char()]].\nrotate_the_box(BoxGrid) ->\n  .",
        "scala_template": "object Solution {\n    def rotateTheBox(boxGrid: Array[Array[Char]]): Array[Array[Char]] = {\n        \n    }\n}"
    },
    {
        "id": 1971,
        "name": "incremental-memory-leak",
        "difficulty": "Medium",
        "link": "https://leetcode.com/problems/incremental-memory-leak/",
        "task_description": "You are given two integers `memory1` and `memory2` representing the available memory in bits on two memory sticks. There is currently a faulty program running that consumes an increasing amount of memory every second. At the `ith` second (starting from 1), `i` bits of memory are allocated to the stick with **more available memory** (or from the first memory stick if both have the same available memory). If neither stick has at least `i` bits of available memory, the program **crashes**. Return _an array containing _`[crashTime, memory1crash, memory2crash]`_, where _`crashTime`_ is the time (in seconds) when the program crashed and _`memory1crash`_ and _`memory2crash`_ are the available bits of memory in the first and second sticks respectively_. **Example 1:** ``` **Input:** memory1 = 2, memory2 = 2 **Output:** [3,1,0] **Explanation:** The memory is allocated as follows: - At the 1st second, 1 bit of memory is allocated to stick 1. The first stick now has 1 bit of available memory. - At the 2nd second, 2 bits of memory are allocated to stick 2. The second stick now has 0 bits of available memory. - At the 3rd second, the program crashes. The sticks have 1 and 0 bits available respectively. ``` **Example 2:** ``` **Input:** memory1 = 8, memory2 = 11 **Output:** [6,0,4] **Explanation:** The memory is allocated as follows: - At the 1st second, 1 bit of memory is allocated to stick 2. The second stick now has 10 bit of available memory. - At the 2nd second, 2 bits of memory are allocated to stick 2. The second stick now has 8 bits of available memory. - At the 3rd second, 3 bits of memory are allocated to stick 1. The first stick now has 5 bits of available memory. - At the 4th second, 4 bits of memory are allocated to stick 2. The second stick now has 4 bits of available memory. - At the 5th second, 5 bits of memory are allocated to stick 1. The first stick now has 0 bits of available memory. - At the 6th second, the program crashes. The sticks have 0 and 4 bits available respectively. ``` **Constraints:** `0 <= memory1, memory2 <= 231 - 1`",
        "test_case": [
            {
                "label": "Example 1",
                "input": "memory1 = 2, memory2 = 2",
                "output": "[3,1,0] Explanation: The memory is allocated as follows:\n- At the 1 st second, 1 bit of memory is allocated to stick 1. The first stick now has 1 bit of available memory.\n- At the 2 nd second, 2 bits of memory are allocated to stick 2. The second stick now has 0 bits of available memory.\n- At the 3 rd second, the program crashes. The sticks have 1 and 0 bits available respectively."
            },
            {
                "label": "Example 2",
                "input": "memory1 = 8, memory2 = 11",
                "output": "[6,0,4] Explanation: The memory is allocated as follows:\n- At the 1 st second, 1 bit of memory is allocated to stick 2. The second stick now has 10 bit of available memory.\n- At the 2 nd second, 2 bits of memory are allocated to stick 2. The second stick now has 8 bits of available memory.\n- At the 3 rd second, 3 bits of memory are allocated to stick 1. The first stick now has 5 bits of available memory.\n- At the 4 th second, 4 bits of memory are allocated to stick 2. The second stick now has 4 bits of available memory.\n- At the 5 th second, 5 bits of memory are allocated to stick 1. The first stick now has 0 bits of available memory.\n- At the 6 th second, the program crashes. The sticks have 0 and 4 bits available respectively."
            }
        ],
        "elixir_template": "defmodule Solution do\n  @spec mem_leak(memory1 :: integer, memory2 :: integer) :: [integer]\n  def mem_leak(memory1, memory2) do\n    \n  end\nend",
        "erlang_template": "-spec mem_leak(Memory1 :: integer(), Memory2 :: integer()) -> [integer()].\nmem_leak(Memory1, Memory2) ->\n  .",
        "scala_template": "object Solution {\n    def memLeak(memory1: Int, memory2: Int): Array[Int] = {\n        \n    }\n}"
    },
    {
        "id": 1970,
        "name": "sorting-the-sentence",
        "difficulty": "Easy",
        "link": "https://leetcode.com/problems/sorting-the-sentence/",
        "task_description": "A **sentence** is a list of words that are separated by a single space with no leading or trailing spaces. Each word consists of lowercase and uppercase English letters. A sentence can be **shuffled** by appending the **1-indexed word position** to each word then rearranging the words in the sentence. For example, the sentence `\"This is a sentence\"` can be shuffled as `\"sentence4 a3 is2 This1\"` or `\"is2 sentence4 This1 a3\"`. Given a **shuffled sentence** `s` containing no more than `9` words, reconstruct and return _the original sentence_. **Example 1:** ``` **Input:** s = \"is2 sentence4 This1 a3\" **Output:** \"This is a sentence\" **Explanation:** Sort the words in s to their original positions \"This1 is2 a3 sentence4\", then remove the numbers. ``` **Example 2:** ``` **Input:** s = \"Myself2 Me1 I4 and3\" **Output:** \"Me Myself and I\" **Explanation:** Sort the words in s to their original positions \"Me1 Myself2 and3 I4\", then remove the numbers. ``` **Constraints:** `2 <= s.length <= 200` `s` consists of lowercase and uppercase English letters, spaces, and digits from `1` to `9`. The number of words in `s` is between `1` and `9`. The words in `s` are separated by a single space. `s` contains no leading or trailing spaces.",
        "test_case": [
            {
                "label": "Example 1",
                "input": "s = \"is2 sentence4 This1 a3\"",
                "output": "\"This is a sentence\" Explanation: Sort the words in s to their original positions \"This1 is2 a3 sentence4\", then remove the numbers."
            },
            {
                "label": "Example 2",
                "input": "s = \"Myself2 Me1 I4 and3\"",
                "output": "\"Me Myself and I\" Explanation: Sort the words in s to their original positions \"Me1 Myself2 and3 I4\", then remove the numbers."
            }
        ],
        "elixir_template": "Elixir code template not available for this problem.",
        "erlang_template": "Elixir code template not available for this problem.",
        "scala_template": "object Solution {\n    def sortSentence(s: String): String = {\n        \n    }\n}"
    },
    {
        "id": 1968,
        "name": "maximum-building-height",
        "difficulty": "Hard",
        "link": "https://leetcode.com/problems/maximum-building-height/",
        "task_description": "You want to build `n` new buildings in a city. The new buildings will be built in a line and are labeled from `1` to `n`. However, there are city restrictions on the heights of the new buildings: The height of each building must be a non-negative integer. The height of the first building **must** be `0`. The height difference between any two adjacent buildings **cannot exceed** `1`. Additionally, there are city restrictions on the maximum height of specific buildings. These restrictions are given as a 2D integer array `restrictions` where `restrictions[i] = [idi, maxHeighti]` indicates that building `idi` must have a height **less than or equal to** `maxHeighti`. It is guaranteed that each building will appear **at most once** in `restrictions`, and building `1` will **not** be in `restrictions`. Return _the **maximum possible height** of the **tallest** building_. **Example 1:** ``` **Input:** n = 5, restrictions = [[2,1],[4,1]] **Output:** 2 **Explanation:** The green area in the image indicates the maximum allowed height for each building. We can build the buildings with heights [0,1,2,1,2], and the tallest building has a height of 2. ``` **Example 2:** ``` **Input:** n = 6, restrictions = [] **Output:** 5 **Explanation:** The green area in the image indicates the maximum allowed height for each building. We can build the buildings with heights [0,1,2,3,4,5], and the tallest building has a height of 5. ``` **Example 3:** ``` **Input:** n = 10, restrictions = [[5,3],[2,5],[7,4],[10,3]] **Output:** 5 **Explanation:** The green area in the image indicates the maximum allowed height for each building. We can build the buildings with heights [0,1,2,3,3,4,4,5,4,3], and the tallest building has a height of 5. ``` **Constraints:** `2 <= n <= 109` `0 <= restrictions.length <= min(n - 1, 105)` `2 <= idi <= n` `idi` is **unique**. `0 <= maxHeighti <= 109`",
        "test_case": [
            {
                "label": "Example 1",
                "input": "n = 5, restrictions = [[2,1],[4,1]]",
                "output": "2 Explanation: The green area in the image indicates the maximum allowed height for each building.\nWe can build the buildings with heights [0,1,2,1,2], and the tallest building has a height of 2."
            },
            {
                "label": "Example 2",
                "input": "n = 6, restrictions = []",
                "output": "5 Explanation: The green area in the image indicates the maximum allowed height for each building.\nWe can build the buildings with heights [0,1,2,3,4,5], and the tallest building has a height of 5."
            },
            {
                "label": "Example 3",
                "input": "n = 10, restrictions = [[5,3],[2,5],[7,4],[10,3]]",
                "output": "5 Explanation: The green area in the image indicates the maximum allowed height for each building.\nWe can build the buildings with heights [0,1,2,3,3,4,4,5,4,3], and the tallest building has a height of 5."
            }
        ],
        "elixir_template": "defmodule Solution do\n  @spec max_building(n :: integer, restrictions :: [[integer]]) :: integer\n  def max_building(n, restrictions) do\n    \n  end\nend",
        "erlang_template": "-spec max_building(N :: integer(), Restrictions :: [[integer()]]) -> integer().\nmax_building(N, Restrictions) ->\n  .",
        "scala_template": "object Solution {\n    def maxBuilding(n: Int, restrictions: Array[Array[Int]]): Int = {\n        \n    }\n}"
    },
    {
        "id": 1967,
        "name": "longest-substring-of-all-vowels-in-order",
        "difficulty": "Medium",
        "link": "https://leetcode.com/problems/longest-substring-of-all-vowels-in-order/",
        "task_description": "A string is considered **beautiful** if it satisfies the following conditions: Each of the 5 English vowels (`'a'`, `'e'`, `'i'`, `'o'`, `'u'`) must appear **at least once** in it. The letters must be sorted in **alphabetical order** (i.e. all `'a'`s before `'e'`s, all `'e'`s before `'i'`s, etc.). For example, strings `\"aeiou\"` and `\"aaaaaaeiiiioou\"` are considered **beautiful**, but `\"uaeio\"`, `\"aeoiu\"`, and `\"aaaeeeooo\"` are **not beautiful**. Given a string `word` consisting of English vowels, return _the **length of the longest beautiful substring** of _`word`_. If no such substring exists, return _`0`. A **substring** is a contiguous sequence of characters in a string. **Example 1:** ``` **Input:** word = \"aeiaaioaaaaeiiiiouuuooaauuaeiu\" **Output:** 13 Explanation: The longest beautiful substring in word is \"aaaaeiiiiouuu\" of length 13. ``` **Example 2:** ``` **Input:** word = \"aeeeiiiioooauuuaeiou\" **Output:** 5 Explanation: The longest beautiful substring in word is \"aeiou\" of length 5. ``` **Example 3:** ``` **Input:** word = \"a\" **Output:** 0 Explanation: There is no beautiful substring, so return 0. ``` **Constraints:** `1 <= word.length <= 5 * 105` `word` consists of characters `'a'`, `'e'`, `'i'`, `'o'`, and `'u'`.",
        "test_case": [
            {
                "label": "Example 1",
                "input": "word = \"aeiaaio aaaaeiiiiouuu ooaauuaeiu\"",
                "output": "13 Explanation: The longest beautiful substring in word is \"aaaaeiiiiouuu\" of length 13."
            },
            {
                "label": "Example 2",
                "input": "word = \"aeeeiiiioooauuu aeiou \"",
                "output": "5 Explanation: The longest beautiful substring in word is \"aeiou\" of length 5."
            },
            {
                "label": "Example 3",
                "input": "word = \"a\"",
                "output": "0 Explanation: There is no beautiful substring, so return 0."
            }
        ],
        "elixir_template": "defmodule Solution do\n  @spec longest_beautiful_substring(word :: String.t) :: integer\n  def longest_beautiful_substring(word) do\n    \n  end\nend",
        "erlang_template": "-spec longest_beautiful_substring(Word :: unicode:unicode_binary()) -> integer().\nlongest_beautiful_substring(Word) ->\n  .",
        "scala_template": "object Solution {\n    def longestBeautifulSubstring(word: String): Int = {\n        \n    }\n}"
    },
    {
        "id": 1966,
        "name": "frequency-of-the-most-frequent-element",
        "difficulty": "Medium",
        "link": "https://leetcode.com/problems/frequency-of-the-most-frequent-element/",
        "task_description": "The **frequency** of an element is the number of times it occurs in an array. You are given an integer array `nums` and an integer `k`. In one operation, you can choose an index of `nums` and increment the element at that index by `1`. Return _the **maximum possible frequency** of an element after performing **at most** _`k`_ operations_. **Example 1:** ``` **Input:** nums = [1,2,4], k = 5 **Output:** 3** Explanation:** Increment the first element three times and the second element two times to make nums = [4,4,4]. 4 has a frequency of 3. ``` **Example 2:** ``` **Input:** nums = [1,4,8,13], k = 5 **Output:** 2 **Explanation:** There are multiple optimal solutions: - Increment the first element three times to make nums = [4,4,8,13]. 4 has a frequency of 2. - Increment the second element four times to make nums = [1,8,8,13]. 8 has a frequency of 2. - Increment the third element five times to make nums = [1,4,13,13]. 13 has a frequency of 2. ``` **Example 3:** ``` **Input:** nums = [3,9,6], k = 2 **Output:** 1 ``` **Constraints:** `1 <= nums.length <= 105` `1 <= nums[i] <= 105` `1 <= k <= 105`",
        "test_case": [
            {
                "label": "Example 1",
                "input": "nums = [1,2,4], k = 5",
                "output": "3 Explanation: Increment the first element three times and the second element two times to make nums = [4,4,4].\n4 has a frequency of 3."
            },
            {
                "label": "Example 2",
                "input": "nums = [1,4,8,13], k = 5",
                "output": "2 Explanation: There are multiple optimal solutions:\n- Increment the first element three times to make nums = [4,4,8,13]. 4 has a frequency of 2.\n- Increment the second element four times to make nums = [1,8,8,13]. 8 has a frequency of 2.\n- Increment the third element five times to make nums = [1,4,13,13]. 13 has a frequency of 2."
            },
            {
                "label": "Example 3",
                "input": "nums = [3,9,6], k = 2",
                "output": "1"
            }
        ],
        "elixir_template": "defmodule Solution do\n  @spec max_frequency(nums :: [integer], k :: integer) :: integer\n  def max_frequency(nums, k) do\n    \n  end\nend",
        "erlang_template": "-spec max_frequency(Nums :: [integer()], K :: integer()) -> integer().\nmax_frequency(Nums, K) ->\n  .",
        "scala_template": "object Solution {\n    def maxFrequency(nums: Array[Int], k: Int): Int = {\n        \n    }\n}"
    },
    {
        "id": 1965,
        "name": "sum-of-digits-in-base-k",
        "difficulty": "Easy",
        "link": "https://leetcode.com/problems/sum-of-digits-in-base-k/",
        "task_description": "Given an integer `n` (in base `10`) and a base `k`, return _the **sum** of the digits of _`n`_ **after** converting _`n`_ from base _`10`_ to base _`k`. After converting, each digit should be interpreted as a base `10` number, and the sum should be returned in base `10`. **Example 1:** ``` **Input:** n = 34, k = 6 **Output:** 9 **Explanation: **34 (base 10) expressed in base 6 is 54. 5 + 4 = 9. ``` **Example 2:** ``` **Input:** n = 10, k = 10 **Output:** 1 **Explanation: **n is already in base 10. 1 + 0 = 1. ``` **Constraints:** `1 <= n <= 100` `2 <= k <= 10`",
        "test_case": [
            {
                "label": "Example 1",
                "input": "n = 34, k = 6",
                "output": "9 Explanation: 34 (base 10) expressed in base 6 is 54. 5 + 4 = 9."
            },
            {
                "label": "Example 2",
                "input": "n = 10, k = 10",
                "output": "1 Explanation: n is already in base 10. 1 + 0 = 1."
            }
        ],
        "elixir_template": "defmodule Solution do\n  @spec sum_base(n :: integer, k :: integer) :: integer\n  def sum_base(n, k) do\n    \n  end\nend",
        "erlang_template": "-spec sum_base(N :: integer(), K :: integer()) -> integer().\nsum_base(N, K) ->\n  .",
        "scala_template": "object Solution {\n    def sumBase(n: Int, k: Int): Int = {\n        \n    }\n}"
    },
    {
        "id": 1963,
        "name": "find-xor-sum-of-all-pairs-bitwise-and",
        "difficulty": "Hard",
        "link": "https://leetcode.com/problems/find-xor-sum-of-all-pairs-bitwise-and/",
        "task_description": "The **XOR sum** of a list is the bitwise `XOR` of all its elements. If the list only contains one element, then its **XOR sum** will be equal to this element. For example, the **XOR sum** of `[1,2,3,4]` is equal to `1 XOR 2 XOR 3 XOR 4 = 4`, and the **XOR sum** of `[3]` is equal to `3`. You are given two **0-indexed** arrays `arr1` and `arr2` that consist only of non-negative integers. Consider the list containing the result of `arr1[i] AND arr2[j]` (bitwise `AND`) for every `(i, j)` pair where `0 <= i < arr1.length` and `0 <= j < arr2.length`. Return _the **XOR sum** of the aforementioned list_. **Example 1:** ``` **Input:** arr1 = [1,2,3], arr2 = [6,5] **Output:** 0 **Explanation:** The list = [1 AND 6, 1 AND 5, 2 AND 6, 2 AND 5, 3 AND 6, 3 AND 5] = [0,1,2,0,2,1]. The XOR sum = 0 XOR 1 XOR 2 XOR 0 XOR 2 XOR 1 = 0. ``` **Example 2:** ``` **Input:** arr1 = [12], arr2 = [4] **Output:** 4 **Explanation:** The list = [12 AND 4] = [4]. The XOR sum = 4. ``` **Constraints:** `1 <= arr1.length, arr2.length <= 105` `0 <= arr1[i], arr2[j] <= 109`",
        "test_case": [
            {
                "label": "Example 1",
                "input": "arr1 = [1,2,3], arr2 = [6,5]",
                "output": "0 Explanation: The list = [1 AND 6, 1 AND 5, 2 AND 6, 2 AND 5, 3 AND 6, 3 AND 5] = [0,1,2,0,2,1].\nThe XOR sum = 0 XOR 1 XOR 2 XOR 0 XOR 2 XOR 1 = 0."
            },
            {
                "label": "Example 2",
                "input": "arr1 = [12], arr2 = [4]",
                "output": "4 Explanation: The list = [12 AND 4] = [4]. The XOR sum = 4."
            }
        ],
        "elixir_template": "defmodule Solution do\n  @spec get_xor_sum(arr1 :: [integer], arr2 :: [integer]) :: integer\n  def get_xor_sum(arr1, arr2) do\n    \n  end\nend",
        "erlang_template": "-spec get_xor_sum(Arr1 :: [integer()], Arr2 :: [integer()]) -> integer().\nget_xor_sum(Arr1, Arr2) ->\n  .",
        "scala_template": "object Solution {\n    def getXORSum(arr1: Array[Int], arr2: Array[Int]): Int = {\n        \n    }\n}"
    },
    {
        "id": 1962,
        "name": "single-threaded-cpu",
        "difficulty": "Medium",
        "link": "https://leetcode.com/problems/single-threaded-cpu/",
        "task_description": "You are given `n`\u200b\u200b\u200b\u200b\u200b\u200b tasks labeled from `0` to `n - 1` represented by a 2D integer array `tasks`, where `tasks[i] = [enqueueTimei, processingTimei]` means that the `i\u200b\u200b\u200b\u200b\u200b\u200bth`\u200b\u200b\u200b\u200b task will be available to process at `enqueueTimei` and will take `processingTimei` to finish processing. You have a single-threaded CPU that can process **at most one** task at a time and will act in the following way: If the CPU is idle and there are no available tasks to process, the CPU remains idle. If the CPU is idle and there are available tasks, the CPU will choose the one with the **shortest processing time**. If multiple tasks have the same shortest processing time, it will choose the task with the smallest index. Once a task is started, the CPU will **process the entire task** without stopping. The CPU can finish a task then start a new one instantly. Return _the order in which the CPU will process the tasks._ **Example 1:** ``` **Input:** tasks = [[1,2],[2,4],[3,2],[4,1]] **Output:** [0,2,3,1] **Explanation: **The events go as follows: - At time = 1, task 0 is available to process. Available tasks = {0}. - Also at time = 1, the idle CPU starts processing task 0. Available tasks = {}. - At time = 2, task 1 is available to process. Available tasks = {1}. - At time = 3, task 2 is available to process. Available tasks = {1, 2}. - Also at time = 3, the CPU finishes task 0 and starts processing task 2 as it is the shortest. Available tasks = {1}. - At time = 4, task 3 is available to process. Available tasks = {1, 3}. - At time = 5, the CPU finishes task 2 and starts processing task 3 as it is the shortest. Available tasks = {1}. - At time = 6, the CPU finishes task 3 and starts processing task 1. Available tasks = {}. - At time = 10, the CPU finishes task 1 and becomes idle. ``` **Example 2:** ``` **Input:** tasks = [[7,10],[7,12],[7,5],[7,4],[7,2]] **Output:** [4,3,2,0,1] **Explanation****: **The events go as follows: - At time = 7, all the tasks become available. Available tasks = {0,1,2,3,4}. - Also at time = 7, the idle CPU starts processing task 4. Available tasks = {0,1,2,3}. - At time = 9, the CPU finishes task 4 and starts processing task 3. Available tasks = {0,1,2}. - At time = 13, the CPU finishes task 3 and starts processing task 2. Available tasks = {0,1}. - At time = 18, the CPU finishes task 2 and starts processing task 0. Available tasks = {1}. - At time = 28, the CPU finishes task 0 and starts processing task 1. Available tasks = {}. - At time = 40, the CPU finishes task 1 and becomes idle. ``` **Constraints:** `tasks.length == n` `1 <= n <= 105` `1 <= enqueueTimei, processingTimei <= 109`",
        "test_case": [
            {
                "label": "Example 1",
                "input": "tasks = [[1,2],[2,4],[3,2],[4,1]]",
                "output": "[0,2,3,1] Explanation: The events go as follows: \n- At time = 1, task 0 is available to process. Available tasks = {0}.\n- Also at time = 1, the idle CPU starts processing task 0. Available tasks = {}.\n- At time = 2, task 1 is available to process. Available tasks = {1}.\n- At time = 3, task 2 is available to process. Available tasks = {1, 2}.\n- Also at time = 3, the CPU finishes task 0 and starts processing task 2 as it is the shortest. Available tasks = {1}.\n- At time = 4, task 3 is available to process. Available tasks = {1, 3}.\n- At time = 5, the CPU finishes task 2 and starts processing task 3 as it is the shortest. Available tasks = {1}.\n- At time = 6, the CPU finishes task 3 and starts processing task 1. Available tasks = {}.\n- At time = 10, the CPU finishes task 1 and becomes idle."
            },
            {
                "label": "Example 2",
                "input": "tasks = [[7,10],[7,12],[7,5],[7,4],[7,2]]",
                "output": "[4,3,2,0,1] Explanation : The events go as follows:\n- At time = 7, all the tasks become available. Available tasks = {0,1,2,3,4}.\n- Also at time = 7, the idle CPU starts processing task 4. Available tasks = {0,1,2,3}.\n- At time = 9, the CPU finishes task 4 and starts processing task 3. Available tasks = {0,1,2}.\n- At time = 13, the CPU finishes task 3 and starts processing task 2. Available tasks = {0,1}.\n- At time = 18, the CPU finishes task 2 and starts processing task 0. Available tasks = {1}.\n- At time = 28, the CPU finishes task 0 and starts processing task 1. Available tasks = {}.\n- At time = 40, the CPU finishes task 1 and becomes idle. Constraints: tasks.length == n 1 <= n <= 10 5 1 <= enqueueTime i , processingTime i <= 10 9"
            }
        ],
        "elixir_template": "defmodule Solution do\n  @spec get_order(tasks :: [[integer]]) :: [integer]\n  def get_order(tasks) do\n    \n  end\nend",
        "erlang_template": "-spec get_order(Tasks :: [[integer()]]) -> [integer()].\nget_order(Tasks) ->\n  .",
        "scala_template": "object Solution {\n    def getOrder(tasks: Array[Array[Int]]): Array[Int] = {\n        \n    }\n}"
    },
    {
        "id": 1961,
        "name": "maximum-ice-cream-bars",
        "difficulty": "Medium",
        "link": "https://leetcode.com/problems/maximum-ice-cream-bars/",
        "task_description": "It is a sweltering summer day, and a boy wants to buy some ice cream bars. At the store, there are `n` ice cream bars. You are given an array `costs` of length `n`, where `costs[i]` is the price of the `ith` ice cream bar in coins. The boy initially has `coins` coins to spend, and he wants to buy as many ice cream bars as possible. **Note:** The boy can buy the ice cream bars in any order. Return _the **maximum** number of ice cream bars the boy can buy with _`coins`_ coins._ You must solve the problem by counting sort. **Example 1:** ``` **Input:** costs = [1,3,2,4,1], coins = 7 **Output:** 4 **Explanation: **The boy can buy ice cream bars at indices 0,1,2,4 for a total price of 1 + 3 + 2 + 1 = 7. ``` **Example 2:** ``` **Input:** costs = [10,6,8,7,7,8], coins = 5 **Output:** 0 **Explanation: **The boy cannot afford any of the ice cream bars. ``` **Example 3:** ``` **Input:** costs = [1,6,3,1,2,5], coins = 20 **Output:** 6 **Explanation: **The boy can buy all the ice cream bars for a total price of 1 + 6 + 3 + 1 + 2 + 5 = 18. ``` **Constraints:** `costs.length == n` `1 <= n <= 105` `1 <= costs[i] <= 105` `1 <= coins <= 108`",
        "test_case": [
            {
                "label": "Example 1",
                "input": "costs = [1,3,2,4,1], coins = 7",
                "output": "4 Explanation: The boy can buy ice cream bars at indices 0,1,2,4 for a total price of 1 + 3 + 2 + 1 = 7."
            },
            {
                "label": "Example 2",
                "input": "costs = [10,6,8,7,7,8], coins = 5",
                "output": "0 Explanation: The boy cannot afford any of the ice cream bars."
            },
            {
                "label": "Example 3",
                "input": "costs = [1,6,3,1,2,5], coins = 20",
                "output": "6 Explanation: The boy can buy all the ice cream bars for a total price of 1 + 6 + 3 + 1 + 2 + 5 = 18. Constraints: costs.length == n 1 <= n <= 10 5 1 <= costs[i] <= 10 5 1 <= coins <= 10 8"
            }
        ],
        "elixir_template": "defmodule Solution do\n  @spec max_ice_cream(costs :: [integer], coins :: integer) :: integer\n  def max_ice_cream(costs, coins) do\n    \n  end\nend",
        "erlang_template": "-spec max_ice_cream(Costs :: [integer()], Coins :: integer()) -> integer().\nmax_ice_cream(Costs, Coins) ->\n  .",
        "scala_template": "object Solution {\n    def maxIceCream(costs: Array[Int], coins: Int): Int = {\n        \n    }\n}"
    },
    {
        "id": 1960,
        "name": "check-if-the-sentence-is-pangram",
        "difficulty": "Easy",
        "link": "https://leetcode.com/problems/check-if-the-sentence-is-pangram/",
        "task_description": "A **pangram** is a sentence where every letter of the English alphabet appears at least once. Given a string `sentence` containing only lowercase English letters, return_ _`true`_ if _`sentence`_ is a **pangram**, or _`false`_ otherwise._ **Example 1:** ``` **Input:** sentence = \"thequickbrownfoxjumpsoverthelazydog\" **Output:** true **Explanation:** sentence contains at least one of every letter of the English alphabet. ``` **Example 2:** ``` **Input:** sentence = \"leetcode\" **Output:** false ``` **Constraints:** `1 <= sentence.length <= 1000` `sentence` consists of lowercase English letters.",
        "test_case": [
            {
                "label": "Example 1",
                "input": "sentence = \"thequickbrownfoxjumpsoverthelazydog\"",
                "output": "true Explanation: sentence contains at least one of every letter of the English alphabet."
            },
            {
                "label": "Example 2",
                "input": "sentence = \"leetcode\"",
                "output": "false"
            }
        ],
        "elixir_template": "defmodule Solution do\n  @spec check_if_pangram(sentence :: String.t) :: boolean\n  def check_if_pangram(sentence) do\n    \n  end\nend",
        "erlang_template": "-spec check_if_pangram(Sentence :: unicode:unicode_binary()) -> boolean().\ncheck_if_pangram(Sentence) ->\n  .",
        "scala_template": "object Solution {\n    def checkIfPangram(sentence: String): Boolean = {\n        \n    }\n}"
    },
    {
        "id": 1957,
        "name": "closest-room",
        "difficulty": "Hard",
        "link": "https://leetcode.com/problems/closest-room/",
        "task_description": "There is a hotel with `n` rooms. The rooms are represented by a 2D integer array `rooms` where `rooms[i] = [roomIdi, sizei]` denotes that there is a room with room number `roomIdi` and size equal to `sizei`. Each `roomIdi` is guaranteed to be **unique**. You are also given `k` queries in a 2D array `queries` where `queries[j] = [preferredj, minSizej]`. The answer to the `jth` query is the room number `id` of a room such that: The room has a size of **at least** `minSizej`, and `abs(id - preferredj)` is **minimized**, where `abs(x)` is the absolute value of `x`. If there is a **tie** in the absolute difference, then use the room with the **smallest** such `id`. If there is **no such room**, the answer is `-1`. Return _an array _`answer`_ of length _`k`_ where _`answer[j]`_ contains the answer to the _`jth`_ query_. **Example 1:** ``` **Input:** rooms = [[2,2],[1,2],[3,2]], queries = [[3,1],[3,3],[5,2]] **Output:** [3,-1,3] **Explanation: **The answers to the queries are as follows: Query = [3,1]: Room number 3 is the closest as abs(3 - 3) = 0, and its size of 2 is at least 1. The answer is 3. Query = [3,3]: There are no rooms with a size of at least 3, so the answer is -1. Query = [5,2]: Room number 3 is the closest as abs(3 - 5) = 2, and its size of 2 is at least 2. The answer is 3. ``` **Example 2:** ``` **Input:** rooms = [[1,4],[2,3],[3,5],[4,1],[5,2]], queries = [[2,3],[2,4],[2,5]] **Output:** [2,1,3] **Explanation: **The answers to the queries are as follows: Query = [2,3]: Room number 2 is the closest as abs(2 - 2) = 0, and its size of 3 is at least 3. The answer is 2. Query = [2,4]: Room numbers 1 and 3 both have sizes of at least 4. The answer is 1 since it is smaller. Query = [2,5]: Room number 3 is the only room with a size of at least 5. The answer is 3. ``` **Constraints:** `n == rooms.length` `1 <= n <= 105` `k == queries.length` `1 <= k <= 104` `1 <= roomIdi, preferredj <= 107` `1 <= sizei, minSizej <= 107`",
        "test_case": [
            {
                "label": "Example 1",
                "input": "rooms = [[2,2],[1,2],[3,2]], queries = [[3,1],[3,3],[5,2]]",
                "output": "[3,-1,3] Explanation: The answers to the queries are as follows:\nQuery = [3,1]: Room number 3 is the closest as abs(3 - 3) = 0, and its size of 2 is at least 1. The answer is 3.\nQuery = [3,3]: There are no rooms with a size of at least 3, so the answer is -1.\nQuery = [5,2]: Room number 3 is the closest as abs(3 - 5) = 2, and its size of 2 is at least 2. The answer is 3."
            },
            {
                "label": "Example 2",
                "input": "rooms = [[1,4],[2,3],[3,5],[4,1],[5,2]], queries = [[2,3],[2,4],[2,5]]",
                "output": "[2,1,3] Explanation: The answers to the queries are as follows:\nQuery = [2,3]: Room number 2 is the closest as abs(2 - 2) = 0, and its size of 3 is at least 3. The answer is 2.\nQuery = [2,4]: Room numbers 1 and 3 both have sizes of at least 4. The answer is 1 since it is smaller.\nQuery = [2,5]: Room number 3 is the only room with a size of at least 5. The answer is 3. Constraints: n == rooms.length 1 <= n <= 10 5 k == queries.length 1 <= k <= 10 4 1 <= roomId i , preferred j <= 10 7 1 <= size i , minSize j <= 10 7"
            }
        ],
        "elixir_template": "defmodule Solution do\n  @spec closest_room(rooms :: [[integer]], queries :: [[integer]]) :: [integer]\n  def closest_room(rooms, queries) do\n    \n  end\nend",
        "erlang_template": "-spec closest_room(Rooms :: [[integer()]], Queries :: [[integer()]]) -> [integer()].\nclosest_room(Rooms, Queries) ->\n  .",
        "scala_template": "object Solution {\n    def closestRoom(rooms: Array[Array[Int]], queries: Array[Array[Int]]): Array[Int] = {\n        \n    }\n}"
    },
    {
        "id": 1956,
        "name": "maximum-element-after-decreasing-and-rearranging",
        "difficulty": "Medium",
        "link": "https://leetcode.com/problems/maximum-element-after-decreasing-and-rearranging/",
        "task_description": "You are given an array of positive integers `arr`. Perform some operations (possibly none) on `arr` so that it satisfies these conditions: The value of the **first** element in `arr` must be `1`. The absolute difference between any 2 adjacent elements must be **less than or equal to **`1`. In other words, `abs(arr[i] - arr[i - 1]) <= 1` for each `i` where `1 <= i < arr.length` (**0-indexed**). `abs(x)` is the absolute value of `x`. There are 2 types of operations that you can perform any number of times: **Decrease** the value of any element of `arr` to a **smaller positive integer**. **Rearrange** the elements of `arr` to be in any order. Return _the **maximum** possible value of an element in _`arr`_ after performing the operations to satisfy the conditions_. **Example 1:** ``` **Input:** arr = [2,2,1,2,1] **Output:** 2 **Explanation:** We can satisfy the conditions by rearranging `arr` so it becomes `[1,2,2,2,1]`. The largest element in `arr` is 2. ``` **Example 2:** ``` **Input:** arr = [100,1,1000] **Output:** 3 **Explanation:** One possible way to satisfy the conditions is by doing the following: 1. Rearrange `arr` so it becomes `[1,100,1000]`. 2. Decrease the value of the second element to 2. 3. Decrease the value of the third element to 3. Now `arr = [1,2,3]`, which` `satisfies the conditions. The largest element in `arr is 3.` ``` **Example 3:** ``` **Input:** arr = [1,2,3,4,5] **Output:** 5 **Explanation:** The array already satisfies the conditions, and the largest element is 5. ``` **Constraints:** `1 <= arr.length <= 105` `1 <= arr[i] <= 109`",
        "test_case": [
            {
                "label": "Example 1",
                "input": "arr = [2,2,1,2,1]",
                "output": "2 Explanation: We can satisfy the conditions by rearranging arr so it becomes [1,2,2,2,1] .\nThe largest element in arr is 2."
            },
            {
                "label": "Example 2",
                "input": "arr = [100,1,1000]",
                "output": "3 Explanation: One possible way to satisfy the conditions is by doing the following:\n1. Rearrange arr so it becomes [1,100,1000] .\n2. Decrease the value of the second element to 2.\n3. Decrease the value of the third element to 3.\nNow arr = [1,2,3] , which satisfies the conditions.\nThe largest element in arr is 3."
            },
            {
                "label": "Example 3",
                "input": "arr = [1,2,3,4,5]",
                "output": "5 Explanation: The array already satisfies the conditions, and the largest element is 5."
            }
        ],
        "elixir_template": "defmodule Solution do\n  @spec maximum_element_after_decrementing_and_rearranging(arr :: [integer]) :: integer\n  def maximum_element_after_decrementing_and_rearranging(arr) do\n    \n  end\nend",
        "erlang_template": "-spec maximum_element_after_decrementing_and_rearranging(Arr :: [integer()]) -> integer().\nmaximum_element_after_decrementing_and_rearranging(Arr) ->\n  .",
        "scala_template": "object Solution {\n    def maximumElementAfterDecrementingAndRearranging(arr: Array[Int]): Int = {\n        \n    }\n}"
    },
    {
        "id": 1955,
        "name": "seat-reservation-manager",
        "difficulty": "Medium",
        "link": "https://leetcode.com/problems/seat-reservation-manager/",
        "task_description": "Design a system that manages the reservation state of `n` seats that are numbered from `1` to `n`. Implement the `SeatManager` class: `SeatManager(int n)` Initializes a `SeatManager` object that will manage `n` seats numbered from `1` to `n`. All seats are initially available. `int reserve()` Fetches the **smallest-numbered** unreserved seat, reserves it, and returns its number. `void unreserve(int seatNumber)` Unreserves the seat with the given `seatNumber`. **Example 1:** ``` **Input** [\"SeatManager\", \"reserve\", \"reserve\", \"unreserve\", \"reserve\", \"reserve\", \"reserve\", \"reserve\", \"unreserve\"] [[5], [], [], [2], [], [], [], [], [5]] **Output** [null, 1, 2, null, 2, 3, 4, 5, null] **Explanation** SeatManager seatManager = new SeatManager(5); // Initializes a SeatManager with 5 seats. seatManager.reserve(); // All seats are available, so return the lowest numbered seat, which is 1. seatManager.reserve(); // The available seats are [2,3,4,5], so return the lowest of them, which is 2. seatManager.unreserve(2); // Unreserve seat 2, so now the available seats are [2,3,4,5]. seatManager.reserve(); // The available seats are [2,3,4,5], so return the lowest of them, which is 2. seatManager.reserve(); // The available seats are [3,4,5], so return the lowest of them, which is 3. seatManager.reserve(); // The available seats are [4,5], so return the lowest of them, which is 4. seatManager.reserve(); // The only available seat is seat 5, so return 5. seatManager.unreserve(5); // Unreserve seat 5, so now the available seats are [5]. ``` **Constraints:** `1 <= n <= 105` `1 <= seatNumber <= n` For each call to `reserve`, it is guaranteed that there will be at least one unreserved seat. For each call to `unreserve`, it is guaranteed that `seatNumber` will be reserved. At most `105` calls **in total** will be made to `reserve` and `unreserve`.",
        "test_case": [],
        "elixir_template": "defmodule SeatManager do\n  @spec init_(n :: integer) :: any\n  def init_(n) do\n    \n  end\n\n  @spec reserve() :: integer\n  def reserve() do\n    \n  end\n\n  @spec unreserve(seat_number :: integer) :: any\n  def unreserve(seat_number) do\n    \n  end\nend\n\n# Your functions will be called as such:\n# SeatManager.init_(n)\n# param_1 = SeatManager.reserve()\n# SeatManager.unreserve(seat_number)\n\n# SeatManager.init_ will be called before every test case, in which you can do some necessary initializations.",
        "erlang_template": "-spec seat_manager_init_(N :: integer()) -> any().\nseat_manager_init_(N) ->\n  .\n\n-spec seat_manager_reserve() -> integer().\nseat_manager_reserve() ->\n  .\n\n-spec seat_manager_unreserve(SeatNumber :: integer()) -> any().\nseat_manager_unreserve(SeatNumber) ->\n  .\n\n\n%% Your functions will be called as such:\n%% seat_manager_init_(N),\n%% Param_1 = seat_manager_reserve(),\n%% seat_manager_unreserve(SeatNumber),\n\n%% seat_manager_init_ will be called before every test case, in which you can do some necessary initializations.",
        "scala_template": "class SeatManager(_n: Int) {\n\n    def reserve(): Int = {\n        \n    }\n\n    def unreserve(seatNumber: Int): Unit = {\n        \n    }\n\n}\n\n/**\n * Your SeatManager object will be instantiated and called as such:\n * val obj = new SeatManager(n)\n * val param_1 = obj.reserve()\n * obj.unreserve(seatNumber)\n */"
    },
    {
        "id": 1954,
        "name": "replace-all-digits-with-characters",
        "difficulty": "Easy",
        "link": "https://leetcode.com/problems/replace-all-digits-with-characters/",
        "task_description": "You are given a **0-indexed** string `s` that has lowercase English letters in its **even** indices and digits in its **odd** indices. You must perform an operation `shift(c, x)`, where `c` is a character and `x` is a digit, that returns the `xth` character after `c`. For example, `shift('a', 5) = 'f'` and `shift('x', 0) = 'x'`. For every **odd** index `i`, you want to replace the digit `s[i]` with the result of the `shift(s[i-1], s[i])` operation. Return `s`_ _after replacing all digits. It is **guaranteed** that_ _`shift(s[i-1], s[i])`_ _will never exceed_ _`'z'`. **Note** that `shift(c, x)` is **not** a preloaded function, but an operation _to be implemented_ as part of the solution. **Example 1:** ``` **Input:** s = \"a1c1e1\" **Output:** \"abcdef\" **Explanation: **The digits are replaced as follows: - s[1] -> shift('a',1) = 'b' - s[3] -> shift('c',1) = 'd' - s[5] -> shift('e',1) = 'f' ``` **Example 2:** ``` **Input:** s = \"a1b2c3d4e\" **Output:** \"abbdcfdhe\" **Explanation: **The digits are replaced as follows: - s[1] -> shift('a',1) = 'b' - s[3] -> shift('b',2) = 'd' - s[5] -> shift('c',3) = 'f' - s[7] -> shift('d',4) = 'h' ``` **Constraints:** `1 <= s.length <= 100` `s` consists only of lowercase English letters and digits. `shift(s[i-1], s[i]) <= 'z'` for all **odd** indices `i`.",
        "test_case": [
            {
                "label": "Example 1",
                "input": "s = \"a1c1e1\"",
                "output": "\"abcdef\" Explanation: The digits are replaced as follows:\n- s[1] -> shift('a',1) = 'b'\n- s[3] -> shift('c',1) = 'd'\n- s[5] -> shift('e',1) = 'f'"
            },
            {
                "label": "Example 2",
                "input": "s = \"a1b2c3d4e\"",
                "output": "\"abbdcfdhe\" Explanation: The digits are replaced as follows:\n- s[1] -> shift('a',1) = 'b'\n- s[3] -> shift('b',2) = 'd'\n- s[5] -> shift('c',3) = 'f'\n- s[7] -> shift('d',4) = 'h'"
            }
        ],
        "elixir_template": "defmodule Solution do\n  @spec replace_digits(s :: String.t) :: String.t\n  def replace_digits(s) do\n    \n  end\nend",
        "erlang_template": "-spec replace_digits(S :: unicode:unicode_binary()) -> unicode:unicode_binary().\nreplace_digits(S) ->\n  .",
        "scala_template": "object Solution {\n    def replaceDigits(s: String): String = {\n        \n    }\n}"
    },
    {
        "id": 1953,
        "name": "finding-mk-average",
        "difficulty": "Hard",
        "link": "https://leetcode.com/problems/finding-mk-average/",
        "task_description": "You are given two integers, `m` and `k`, and a stream of integers. You are tasked to implement a data structure that calculates the **MKAverage** for the stream. The **MKAverage** can be calculated using these steps: If the number of the elements in the stream is less than `m` you should consider the **MKAverage** to be `-1`. Otherwise, copy the last `m` elements of the stream to a separate container. Remove the smallest `k` elements and the largest `k` elements from the container. Calculate the average value for the rest of the elements **rounded down to the nearest integer**. Implement the `MKAverage` class: `MKAverage(int m, int k)` Initializes the **MKAverage** object with an empty stream and the two integers `m` and `k`. `void addElement(int num)` Inserts a new element `num` into the stream. `int calculateMKAverage()` Calculates and returns the **MKAverage** for the current stream **rounded down to the nearest integer**. **Example 1:** ``` **Input** [\"MKAverage\", \"addElement\", \"addElement\", \"calculateMKAverage\", \"addElement\", \"calculateMKAverage\", \"addElement\", \"addElement\", \"addElement\", \"calculateMKAverage\"] [[3, 1], [3], [1], [], [10], [], [5], [5], [5], []] **Output** [null, null, null, -1, null, 3, null, null, null, 5] **Explanation** `MKAverage obj = new MKAverage(3, 1); obj.addElement(3); // current elements are [3] obj.addElement(1); // current elements are [3,1] obj.calculateMKAverage(); // return -1, because m = 3 and only 2 elements exist. obj.addElement(10); // current elements are [3,1,10] obj.calculateMKAverage(); // The last 3 elements are [3,1,10]. // After removing smallest and largest 1 element the container will be [3]. // The average of [3] equals 3/1 = 3, return 3 obj.addElement(5); // current elements are [3,1,10,5] obj.addElement(5); // current elements are [3,1,10,5,5] obj.addElement(5); // current elements are [3,1,10,5,5,5] obj.calculateMKAverage(); // The last 3 elements are [5,5,5]. // After removing smallest and largest 1 element the container will be [5]. // The average of [5] equals 5/1 = 5, return 5 ` ``` **Constraints:** `3 <= m <= 105` `1 <= k*2 < m` `1 <= num <= 105` At most `105` calls will be made to `addElement` and `calculateMKAverage`.",
        "test_case": [],
        "elixir_template": "defmodule MKAverage do\n  @spec init_(m :: integer, k :: integer) :: any\n  def init_(m, k) do\n    \n  end\n\n  @spec add_element(num :: integer) :: any\n  def add_element(num) do\n    \n  end\n\n  @spec calculate_mk_average() :: integer\n  def calculate_mk_average() do\n    \n  end\nend\n\n# Your functions will be called as such:\n# MKAverage.init_(m, k)\n# MKAverage.add_element(num)\n# param_2 = MKAverage.calculate_mk_average()\n\n# MKAverage.init_ will be called before every test case, in which you can do some necessary initializations.",
        "erlang_template": "-spec mk_average_init_(M :: integer(), K :: integer()) -> any().\nmk_average_init_(M, K) ->\n  .\n\n-spec mk_average_add_element(Num :: integer()) -> any().\nmk_average_add_element(Num) ->\n  .\n\n-spec mk_average_calculate_mk_average() -> integer().\nmk_average_calculate_mk_average() ->\n  .\n\n\n%% Your functions will be called as such:\n%% mk_average_init_(M, K),\n%% mk_average_add_element(Num),\n%% Param_2 = mk_average_calculate_mk_average(),\n\n%% mk_average_init_ will be called before every test case, in which you can do some necessary initializations.",
        "scala_template": "class MKAverage(_m: Int, _k: Int) {\n\n    def addElement(num: Int): Unit = {\n        \n    }\n\n    def calculateMKAverage(): Int = {\n        \n    }\n\n}\n\n/**\n * Your MKAverage object will be instantiated and called as such:\n * val obj = new MKAverage(m, k)\n * obj.addElement(num)\n * val param_2 = obj.calculateMKAverage()\n */"
    },
    {
        "id": 1952,
        "name": "minimum-sideway-jumps",
        "difficulty": "Medium",
        "link": "https://leetcode.com/problems/minimum-sideway-jumps/",
        "task_description": "There is a **3 lane road** of length `n` that consists of `n + 1` **points** labeled from `0` to `n`. A frog **starts** at point `0` in the **second **lane** **and wants to jump to point `n`. However, there could be obstacles along the way. You are given an array `obstacles` of length `n + 1` where each `obstacles[i]` (**ranging from 0 to 3**) describes an obstacle on the lane `obstacles[i]` at point `i`. If `obstacles[i] == 0`, there are no obstacles at point `i`. There will be **at most one** obstacle in the 3 lanes at each point. For example, if `obstacles[2] == 1`, then there is an obstacle on lane 1 at point 2. The frog can only travel from point `i` to point `i + 1` on the same lane if there is not an obstacle on the lane at point `i + 1`. To avoid obstacles, the frog can also perform a **side jump** to jump to **another** lane (even if they are not adjacent) at the **same** point if there is no obstacle on the new lane. For example, the frog can jump from lane 3 at point 3 to lane 1 at point 3. Return_ the **minimum number of side jumps** the frog needs to reach **any lane** at point n starting from lane `2` at point 0._ **Note:** There will be no obstacles on points `0` and `n`. **Example 1:** ``` **Input:** obstacles = [0,1,2,3,0] **Output:** 2 **Explanation:** The optimal solution is shown by the arrows above. There are 2 side jumps (red arrows). Note that the frog can jump over obstacles only when making side jumps (as shown at point 2). ``` **Example 2:** ``` **Input:** obstacles = [0,1,1,3,3,0] **Output:** 0 **Explanation:** There are no obstacles on lane 2. No side jumps are required. ``` **Example 3:** ``` **Input:** obstacles = [0,2,1,0,3,0] **Output:** 2 **Explanation:** The optimal solution is shown by the arrows above. There are 2 side jumps. ``` **Constraints:** `obstacles.length == n + 1` `1 <= n <= 5 * 105` `0 <= obstacles[i] <= 3` `obstacles[0] == obstacles[n] == 0`",
        "test_case": [
            {
                "label": "Example 1",
                "input": "obstacles = [0,1,2,3,0]",
                "output": "2 Explanation: The optimal solution is shown by the arrows above. There are 2 side jumps (red arrows).\nNote that the frog can jump over obstacles only when making side jumps (as shown at point 2)."
            },
            {
                "label": "Example 2",
                "input": "obstacles = [0,1,1,3,3,0]",
                "output": "0 Explanation: There are no obstacles on lane 2. No side jumps are required."
            },
            {
                "label": "Example 3",
                "input": "obstacles = [0,2,1,0,3,0]",
                "output": "2 Explanation: The optimal solution is shown by the arrows above. There are 2 side jumps. Constraints: obstacles.length == n + 1 1 <= n <= 5 * 10 5 0 <= obstacles[i] <= 3 obstacles[0] == obstacles[n] == 0"
            }
        ],
        "elixir_template": "defmodule Solution do\n  @spec min_side_jumps(obstacles :: [integer]) :: integer\n  def min_side_jumps(obstacles) do\n    \n  end\nend",
        "erlang_template": "-spec min_side_jumps(Obstacles :: [integer()]) -> integer().\nmin_side_jumps(Obstacles) ->\n  .",
        "scala_template": "object Solution {\n    def minSideJumps(obstacles: Array[Int]): Int = {\n        \n    }\n}"
    },
    {
        "id": 1951,
        "name": "find-the-winner-of-the-circular-game",
        "difficulty": "Medium",
        "link": "https://leetcode.com/problems/find-the-winner-of-the-circular-game/",
        "task_description": "There are `n` friends that are playing a game. The friends are sitting in a circle and are numbered from `1` to `n` in **clockwise order**. More formally, moving clockwise from the `ith` friend brings you to the `(i+1)th` friend for `1 <= i < n`, and moving clockwise from the `nth` friend brings you to the `1st` friend. The rules of the game are as follows: **Start** at the `1st` friend. Count the next `k` friends in the clockwise direction **including** the friend you started at. The counting wraps around the circle and may count some friends more than once. The last friend you counted leaves the circle and loses the game. If there is still more than one friend in the circle, go back to step `2` **starting** from the friend **immediately clockwise** of the friend who just lost and repeat. Else, the last friend in the circle wins the game. Given the number of friends, `n`, and an integer `k`, return _the winner of the game_. **Example 1:** ``` **Input:** n = 5, k = 2 **Output:** 3 **Explanation:** Here are the steps of the game: 1) Start at friend 1. 2) Count 2 friends clockwise, which are friends 1 and 2. 3) Friend 2 leaves the circle. Next start is friend 3. 4) Count 2 friends clockwise, which are friends 3 and 4. 5) Friend 4 leaves the circle. Next start is friend 5. 6) Count 2 friends clockwise, which are friends 5 and 1. 7) Friend 1 leaves the circle. Next start is friend 3. 8) Count 2 friends clockwise, which are friends 3 and 5. 9) Friend 5 leaves the circle. Only friend 3 is left, so they are the winner. ``` **Example 2:** ``` **Input:** n = 6, k = 5 **Output:** 1 **Explanation:** The friends leave in this order: 5, 4, 6, 2, 3. The winner is friend 1. ``` **Constraints:** `1 <= k <= n <= 500` **Follow up:** Could you solve this problem in linear time with constant space?",
        "test_case": [
            {
                "label": "Example 1",
                "input": "n = 5, k = 2",
                "output": "3 Explanation: Here are the steps of the game:\n1) Start at friend 1.\n2) Count 2 friends clockwise, which are friends 1 and 2.\n3) Friend 2 leaves the circle. Next start is friend 3.\n4) Count 2 friends clockwise, which are friends 3 and 4.\n5) Friend 4 leaves the circle. Next start is friend 5.\n6) Count 2 friends clockwise, which are friends 5 and 1.\n7) Friend 1 leaves the circle. Next start is friend 3.\n8) Count 2 friends clockwise, which are friends 3 and 5.\n9) Friend 5 leaves the circle. Only friend 3 is left, so they are the winner."
            },
            {
                "label": "Example 2",
                "input": "n = 6, k = 5",
                "output": "1 Explanation: The friends leave in this order: 5, 4, 6, 2, 3. The winner is friend 1."
            }
        ],
        "elixir_template": "defmodule Solution do\n  @spec find_the_winner(n :: integer, k :: integer) :: integer\n  def find_the_winner(n, k) do\n    \n  end\nend",
        "erlang_template": "-spec find_the_winner(N :: integer(), K :: integer()) -> integer().\nfind_the_winner(N, K) ->\n  .",
        "scala_template": "object Solution {\n    def findTheWinner(n: Int, k: Int): Int = {\n        \n    }\n}"
    },
    {
        "id": 1950,
        "name": "sign-of-the-product-of-an-array",
        "difficulty": "Easy",
        "link": "https://leetcode.com/problems/sign-of-the-product-of-an-array/",
        "task_description": "Implement a function `signFunc(x)` that returns: `1` if `x` is positive. `-1` if `x` is negative. `0` if `x` is equal to `0`. You are given an integer array `nums`. Let `product` be the product of all values in the array `nums`. Return `signFunc(product)`. **Example 1:** ``` **Input:** nums = [-1,-2,-3,-4,3,2,1] **Output:** 1 **Explanation:** The product of all values in the array is 144, and signFunc(144) = 1 ``` **Example 2:** ``` **Input:** nums = [1,5,0,2,-3] **Output:** 0 **Explanation:** The product of all values in the array is 0, and signFunc(0) = 0 ``` **Example 3:** ``` **Input:** nums = [-1,1,-1,1,-1] **Output:** -1 **Explanation:** The product of all values in the array is -1, and signFunc(-1) = -1 ``` **Constraints:** `1 <= nums.length <= 1000` `-100 <= nums[i] <= 100`",
        "test_case": [
            {
                "label": "Example 1",
                "input": "nums = [-1,-2,-3,-4,3,2,1]",
                "output": "1 Explanation: The product of all values in the array is 144, and signFunc(144) = 1"
            },
            {
                "label": "Example 2",
                "input": "nums = [1,5,0,2,-3]",
                "output": "0 Explanation: The product of all values in the array is 0, and signFunc(0) = 0"
            },
            {
                "label": "Example 3",
                "input": "nums = [-1,1,-1,1,-1]",
                "output": "-1 Explanation: The product of all values in the array is -1, and signFunc(-1) = -1"
            }
        ],
        "elixir_template": "defmodule Solution do\n  @spec array_sign(nums :: [integer]) :: integer\n  def array_sign(nums) do\n    \n  end\nend",
        "erlang_template": "-spec array_sign(Nums :: [integer()]) -> integer().\narray_sign(Nums) ->\n  .",
        "scala_template": "object Solution {\n    def arraySign(nums: Array[Int]): Int = {\n        \n    }\n}"
    },
    {
        "id": 1947,
        "name": "number-of-different-subsequences-gcds",
        "difficulty": "Hard",
        "link": "https://leetcode.com/problems/number-of-different-subsequences-gcds/",
        "task_description": "You are given an array `nums` that consists of positive integers. The **GCD** of a sequence of numbers is defined as the greatest integer that divides **all** the numbers in the sequence evenly. For example, the GCD of the sequence `[4,6,16]` is `2`. A **subsequence** of an array is a sequence that can be formed by removing some elements (possibly none) of the array. For example, `[2,5,10]` is a subsequence of `[1,2,1,**2**,4,1,**5**,**10**]`. Return _the **number** of **different** GCDs among all **non-empty** subsequences of_ `nums`. **Example 1:** ``` **Input:** nums = [6,10,3] **Output:** 5 **Explanation:** The figure shows all the non-empty subsequences and their GCDs. The different GCDs are 6, 10, 3, 2, and 1. ``` **Example 2:** ``` **Input:** nums = [5,15,40,5,6] **Output:** 7 ``` **Constraints:** `1 <= nums.length <= 105` `1 <= nums[i] <= 2 * 105`",
        "test_case": [
            {
                "label": "Example 1",
                "input": "nums = [6,10,3]",
                "output": "5 Explanation: The figure shows all the non-empty subsequences and their GCDs.\nThe different GCDs are 6, 10, 3, 2, and 1."
            },
            {
                "label": "Example 2",
                "input": "nums = [5,15,40,5,6]",
                "output": "7"
            }
        ],
        "elixir_template": "defmodule Solution do\n  @spec count_different_subsequence_gc_ds(nums :: [integer]) :: integer\n  def count_different_subsequence_gc_ds(nums) do\n    \n  end\nend",
        "erlang_template": "-spec count_different_subsequence_gc_ds(Nums :: [integer()]) -> integer().\ncount_different_subsequence_gc_ds(Nums) ->\n  .",
        "scala_template": "object Solution {\n    def countDifferentSubsequenceGCDs(nums: Array[Int]): Int = {\n        \n    }\n}"
    },
    {
        "id": 1946,
        "name": "minimum-absolute-sum-difference",
        "difficulty": "Medium",
        "link": "https://leetcode.com/problems/minimum-absolute-sum-difference/",
        "task_description": "You are given two positive integer arrays `nums1` and `nums2`, both of length `n`. The **absolute sum difference** of arrays `nums1` and `nums2` is defined as the **sum** of `|nums1[i] - nums2[i]|` for each `0 <= i < n` (**0-indexed**). You can replace **at most one** element of `nums1` with **any** other element in `nums1` to **minimize** the absolute sum difference. Return the _minimum absolute sum difference **after** replacing at most one** **element in the array `nums1`._ Since the answer may be large, return it **modulo** `109 + 7`. `|x|` is defined as: `x` if `x >= 0`, or `-x` if `x < 0`. **Example 1:** ``` **Input:** nums1 = [1,7,5], nums2 = [2,3,5] **Output:** 3 **Explanation: **There are two possible optimal solutions: - Replace the second element with the first: [1,**7**,5] => [1,**1**,5], or - Replace the second element with the third: [1,**7**,5] => [1,**5**,5]. Both will yield an absolute sum difference of `|1-2| + (|1-3| or |5-3|) + |5-5| = `3. ``` **Example 2:** ``` **Input:** nums1 = [2,4,6,8,10], nums2 = [2,4,6,8,10] **Output:** 0 **Explanation: **nums1 is equal to nums2 so no replacement is needed. This will result in an absolute sum difference of 0. ``` **Example 3:** ``` **Input:** nums1 = [1,10,4,4,2,7], nums2 = [9,3,5,1,7,4] **Output:** 20 **Explanation: **Replace the first element with the second: [**1**,10,4,4,2,7] => [**10**,10,4,4,2,7]. This yields an absolute sum difference of `|10-9| + |10-3| + |4-5| + |4-1| + |2-7| + |7-4| = 20` ``` **Constraints:** `n == nums1.length` `n == nums2.length` `1 <= n <= 105` `1 <= nums1[i], nums2[i] <= 105`",
        "test_case": [
            {
                "label": "Example 1",
                "input": "nums1 = [1,7,5], nums2 = [2,3,5]",
                "output": "3 Explanation: There are two possible optimal solutions:\n- Replace the second element with the first: [1, 7 ,5] => [1, 1 ,5], or\n- Replace the second element with the third: [1, 7 ,5] => [1, 5 ,5].\nBoth will yield an absolute sum difference of |1-2| + (|1-3| or |5-3|) + |5-5| = 3."
            },
            {
                "label": "Example 2",
                "input": "nums1 = [2,4,6,8,10], nums2 = [2,4,6,8,10]",
                "output": "0 Explanation: nums1 is equal to nums2 so no replacement is needed. This will result in an \nabsolute sum difference of 0."
            },
            {
                "label": "Example 3",
                "input": "nums1 = [1,10,4,4,2,7], nums2 = [9,3,5,1,7,4]",
                "output": "20 Explanation: Replace the first element with the second: [ 1 ,10,4,4,2,7] => [ 10 ,10,4,4,2,7].\nThis yields an absolute sum difference of |10-9| + |10-3| + |4-5| + |4-1| + |2-7| + |7-4| = 20 Constraints: n == nums1.length n == nums2.length 1 <= n <= 10 5 1 <= nums1[i], nums2[i] <= 10 5"
            }
        ],
        "elixir_template": "defmodule Solution do\n  @spec min_absolute_sum_diff(nums1 :: [integer], nums2 :: [integer]) :: integer\n  def min_absolute_sum_diff(nums1, nums2) do\n    \n  end\nend",
        "erlang_template": "-spec min_absolute_sum_diff(Nums1 :: [integer()], Nums2 :: [integer()]) -> integer().\nmin_absolute_sum_diff(Nums1, Nums2) ->\n  .",
        "scala_template": "object Solution {\n    def minAbsoluteSumDiff(nums1: Array[Int], nums2: Array[Int]): Int = {\n        \n    }\n}"
    },
    {
        "id": 1945,
        "name": "finding-the-users-active-minutes",
        "difficulty": "Medium",
        "link": "https://leetcode.com/problems/finding-the-users-active-minutes/",
        "task_description": "You are given the logs for users' actions on LeetCode, and an integer `k`. The logs are represented by a 2D integer array `logs` where each `logs[i] = [IDi, timei]` indicates that the user with `IDi` performed an action at the minute `timei`. **Multiple users** can perform actions simultaneously, and a single user can perform **multiple actions** in the same minute. The **user active minutes (UAM)** for a given user is defined as the **number of unique minutes** in which the user performed an action on LeetCode. A minute can only be counted once, even if multiple actions occur during it. You are to calculate a **1-indexed** array `answer` of size `k` such that, for each `j` (`1 <= j <= k`), `answer[j]` is the **number of users** whose **UAM** equals `j`. Return the array `answer` as described above. **Example 1:** ``` **Input:** logs = [[0,5],[1,2],[0,2],[0,5],[1,3]], k = 5 **Output:** [0,2,0,0,0] **Explanation:** The user with ID=0 performed actions at minutes 5, 2, and 5 again. Hence, they have a UAM of 2 (minute 5 is only counted once). The user with ID=1 performed actions at minutes 2 and 3. Hence, they have a UAM of 2. Since both users have a UAM of 2, answer[2] is 2, and the remaining answer[j] values are 0. ``` **Example 2:** ``` **Input:** logs = [[1,1],[2,2],[2,3]], k = 4 **Output:** [1,1,0,0] **Explanation:** The user with ID=1 performed a single action at minute 1. Hence, they have a UAM of 1. The user with ID=2 performed actions at minutes 2 and 3. Hence, they have a UAM of 2. There is one user with a UAM of 1 and one with a UAM of 2. Hence, answer[1] = 1, answer[2] = 1, and the remaining values are 0. ``` **Constraints:** `1 <= logs.length <= 104` `0 <= IDi <= 109` `1 <= timei <= 105` `k` is in the range `[The maximum **UAM** for a user, 105]`.",
        "test_case": [
            {
                "label": "Example 1",
                "input": "logs = [[0,5],[1,2],[0,2],[0,5],[1,3]], k = 5",
                "output": "[0,2,0,0,0] Explanation: The user with ID=0 performed actions at minutes 5, 2, and 5 again. Hence, they have a UAM of 2 (minute 5 is only counted once).\nThe user with ID=1 performed actions at minutes 2 and 3. Hence, they have a UAM of 2.\nSince both users have a UAM of 2, answer[2] is 2, and the remaining answer[j] values are 0."
            },
            {
                "label": "Example 2",
                "input": "logs = [[1,1],[2,2],[2,3]], k = 4",
                "output": "[1,1,0,0] Explanation: The user with ID=1 performed a single action at minute 1. Hence, they have a UAM of 1.\nThe user with ID=2 performed actions at minutes 2 and 3. Hence, they have a UAM of 2.\nThere is one user with a UAM of 1 and one with a UAM of 2.\nHence, answer[1] = 1, answer[2] = 1, and the remaining values are 0."
            }
        ],
        "elixir_template": "defmodule Solution do\n  @spec finding_users_active_minutes(logs :: [[integer]], k :: integer) :: [integer]\n  def finding_users_active_minutes(logs, k) do\n    \n  end\nend",
        "erlang_template": "-spec finding_users_active_minutes(Logs :: [[integer()]], K :: integer()) -> [integer()].\nfinding_users_active_minutes(Logs, K) ->\n  .",
        "scala_template": "object Solution {\n    def findingUsersActiveMinutes(logs: Array[Array[Int]], k: Int): Array[Int] = {\n        \n    }\n}"
    },
    {
        "id": 1944,
        "name": "truncate-sentence",
        "difficulty": "Easy",
        "link": "https://leetcode.com/problems/truncate-sentence/",
        "task_description": "A **sentence** is a list of words that are separated by a single space with no leading or trailing spaces. Each of the words consists of **only** uppercase and lowercase English letters (no punctuation). For example, `\"Hello World\"`, `\"HELLO\"`, and `\"hello world hello world\"` are all sentences. You are given a sentence `s`\u200b\u200b\u200b\u200b\u200b\u200b and an integer `k`\u200b\u200b\u200b\u200b\u200b\u200b. You want to **truncate** `s`\u200b\u200b\u200b\u200b\u200b\u200b such that it contains only the **first** `k`\u200b\u200b\u200b\u200b\u200b\u200b words. Return `s`\u200b\u200b\u200b\u200b_\u200b\u200b after **truncating** it._ **Example 1:** ``` **Input:** s = \"Hello how are you Contestant\", k = 4 **Output:** \"Hello how are you\" **Explanation:** The words in s are [\"Hello\", \"how\" \"are\", \"you\", \"Contestant\"]. The first 4 words are [\"Hello\", \"how\", \"are\", \"you\"]. Hence, you should return \"Hello how are you\". ``` **Example 2:** ``` **Input:** s = \"What is the solution to this problem\", k = 4 **Output:** \"What is the solution\" **Explanation:** The words in s are [\"What\", \"is\" \"the\", \"solution\", \"to\", \"this\", \"problem\"]. The first 4 words are [\"What\", \"is\", \"the\", \"solution\"]. Hence, you should return \"What is the solution\". ``` **Example 3:** ``` **Input:** s = \"chopper is not a tanuki\", k = 5 **Output:** \"chopper is not a tanuki\" ``` **Constraints:** `1 <= s.length <= 500` `k` is in the range `[1, the number of words in s]`. `s` consist of only lowercase and uppercase English letters and spaces. The words in `s` are separated by a single space. There are no leading or trailing spaces.",
        "test_case": [
            {
                "label": "Example 1",
                "input": "s = \"Hello how are you Contestant\", k = 4",
                "output": "\"Hello how are you\" Explanation: The words in s are [\"Hello\", \"how\" \"are\", \"you\", \"Contestant\"].\nThe first 4 words are [\"Hello\", \"how\", \"are\", \"you\"].\nHence, you should return \"Hello how are you\"."
            },
            {
                "label": "Example 2",
                "input": "s = \"What is the solution to this problem\", k = 4",
                "output": "\"What is the solution\" Explanation: The words in s are [\"What\", \"is\" \"the\", \"solution\", \"to\", \"this\", \"problem\"].\nThe first 4 words are [\"What\", \"is\", \"the\", \"solution\"].\nHence, you should return \"What is the solution\"."
            },
            {
                "label": "Example 3",
                "input": "s = \"chopper is not a tanuki\", k = 5",
                "output": "\"chopper is not a tanuki\""
            }
        ],
        "elixir_template": "defmodule Solution do\n  @spec truncate_sentence(s :: String.t, k :: integer) :: String.t\n  def truncate_sentence(s, k) do\n    \n  end\nend",
        "erlang_template": "-spec truncate_sentence(S :: unicode:unicode_binary(), K :: integer()) -> unicode:unicode_binary().\ntruncate_sentence(S, K) ->\n  .",
        "scala_template": "object Solution {\n    def truncateSentence(s: String, k: Int): String = {\n        \n    }\n}"
    },
    {
        "id": 1941,
        "name": "minimum-number-of-operations-to-make-string-sorted",
        "difficulty": "Hard",
        "link": "https://leetcode.com/problems/minimum-number-of-operations-to-make-string-sorted/",
        "task_description": "You are given a string `s` (**0-indexed**)\u200b\u200b\u200b\u200b\u200b\u200b. You are asked to perform the following operation on `s`\u200b\u200b\u200b\u200b\u200b\u200b until you get a sorted string: Find **the largest index** `i` such that `1 <= i < s.length` and `s[i] < s[i - 1]`. Find **the largest index** `j` such that `i <= j < s.length` and `s[k] < s[i - 1]` for all the possible values of `k` in the range `[i, j]` inclusive. Swap the two characters at indices `i - 1`\u200b\u200b\u200b\u200b and `j`\u200b\u200b\u200b\u200b\u200b. Reverse the suffix starting at index `i`\u200b\u200b\u200b\u200b\u200b\u200b. Return _the number of operations needed to make the string sorted._ Since the answer can be too large, return it **modulo** `109 + 7`. **Example 1:** ``` **Input:** s = \"cba\" **Output:** 5 **Explanation:** The simulation goes as follows: Operation 1: i=2, j=2. Swap s[1] and s[2] to get s=\"cab\", then reverse the suffix starting at 2. Now, s=\"cab\". Operation 2: i=1, j=2. Swap s[0] and s[2] to get s=\"bac\", then reverse the suffix starting at 1. Now, s=\"bca\". Operation 3: i=2, j=2. Swap s[1] and s[2] to get s=\"bac\", then reverse the suffix starting at 2. Now, s=\"bac\". Operation 4: i=1, j=1. Swap s[0] and s[1] to get s=\"abc\", then reverse the suffix starting at 1. Now, s=\"acb\". Operation 5: i=2, j=2. Swap s[1] and s[2] to get s=\"abc\", then reverse the suffix starting at 2. Now, s=\"abc\". ``` **Example 2:** ``` **Input:** s = \"aabaa\" **Output:** 2 **Explanation:** The simulation goes as follows: Operation 1: i=3, j=4. Swap s[2] and s[4] to get s=\"aaaab\", then reverse the substring starting at 3. Now, s=\"aaaba\". Operation 2: i=4, j=4. Swap s[3] and s[4] to get s=\"aaaab\", then reverse the substring starting at 4. Now, s=\"aaaab\". ``` **Constraints:** `1 <= s.length <= 3000` `s`\u200b\u200b\u200b\u200b\u200b\u200b consists only of lowercase English letters.",
        "test_case": [
            {
                "label": "Example 1",
                "input": "s = \"cba\"",
                "output": "5 Explanation: The simulation goes as follows:\nOperation 1: i=2, j=2. Swap s[1] and s[2] to get s=\"cab\", then reverse the suffix starting at 2. Now, s=\"cab\".\nOperation 2: i=1, j=2. Swap s[0] and s[2] to get s=\"bac\", then reverse the suffix starting at 1. Now, s=\"bca\".\nOperation 3: i=2, j=2. Swap s[1] and s[2] to get s=\"bac\", then reverse the suffix starting at 2. Now, s=\"bac\".\nOperation 4: i=1, j=1. Swap s[0] and s[1] to get s=\"abc\", then reverse the suffix starting at 1. Now, s=\"acb\".\nOperation 5: i=2, j=2. Swap s[1] and s[2] to get s=\"abc\", then reverse the suffix starting at 2. Now, s=\"abc\"."
            },
            {
                "label": "Example 2",
                "input": "s = \"aabaa\"",
                "output": "2 Explanation: The simulation goes as follows:\nOperation 1: i=3, j=4. Swap s[2] and s[4] to get s=\"aaaab\", then reverse the substring starting at 3. Now, s=\"aaaba\".\nOperation 2: i=4, j=4. Swap s[3] and s[4] to get s=\"aaaab\", then reverse the substring starting at 4. Now, s=\"aaaab\"."
            }
        ],
        "elixir_template": "defmodule Solution do\n  @spec make_string_sorted(s :: String.t) :: integer\n  def make_string_sorted(s) do\n    \n  end\nend",
        "erlang_template": "-spec make_string_sorted(S :: unicode:unicode_binary()) -> integer().\nmake_string_sorted(S) ->\n  .",
        "scala_template": "object Solution {\n    def makeStringSorted(s: String): Int = {\n        \n    }\n}"
    },
    {
        "id": 1940,
        "name": "maximum-xor-for-each-query",
        "difficulty": "Medium",
        "link": "https://leetcode.com/problems/maximum-xor-for-each-query/",
        "task_description": "You are given a **sorted** array `nums` of `n` non-negative integers and an integer `maximumBit`. You want to perform the following query `n` **times**: Find a non-negative integer `k < 2maximumBit` such that `nums[0] XOR nums[1] XOR ... XOR nums[nums.length-1] XOR k` is **maximized**. `k` is the answer to the `ith` query. Remove the **last **element from the current array `nums`. Return _an array_ `answer`_, where _`answer[i]`_ is the answer to the _`ith`_ query_. **Example 1:** ``` **Input:** nums = [0,1,1,3], maximumBit = 2 **Output:** [0,3,2,3] **Explanation**: The queries are answered as follows: 1st query: nums = [0,1,1,3], k = 0 since 0 XOR 1 XOR 1 XOR 3 XOR 0 = 3. 2nd query: nums = [0,1,1], k = 3 since 0 XOR 1 XOR 1 XOR 3 = 3. 3rd query: nums = [0,1], k = 2 since 0 XOR 1 XOR 2 = 3. 4th query: nums = [0], k = 3 since 0 XOR 3 = 3. ``` **Example 2:** ``` **Input:** nums = [2,3,4,7], maximumBit = 3 **Output:** [5,2,6,5] **Explanation**: The queries are answered as follows: 1st query: nums = [2,3,4,7], k = 5 since 2 XOR 3 XOR 4 XOR 7 XOR 5 = 7. 2nd query: nums = [2,3,4], k = 2 since 2 XOR 3 XOR 4 XOR 2 = 7. 3rd query: nums = [2,3], k = 6 since 2 XOR 3 XOR 6 = 7. 4th query: nums = [2], k = 5 since 2 XOR 5 = 7. ``` **Example 3:** ``` **Input:** nums = [0,1,2,2,5,7], maximumBit = 3 **Output:** [4,3,6,4,6,7] ``` **Constraints:** `nums.length == n` `1 <= n <= 105` `1 <= maximumBit <= 20` `0 <= nums[i] < 2maximumBit` `nums`\u200b\u200b\u200b is sorted in **ascending** order.",
        "test_case": [
            {
                "label": "Example 1",
                "input": "nums = [0,1,1,3], maximumBit = 2",
                "output": "[0,3,2,3] Explanation : The queries are answered as follows:\n1 st query: nums = [0,1,1,3], k = 0 since 0 XOR 1 XOR 1 XOR 3 XOR 0 = 3.\n2 nd query: nums = [0,1,1], k = 3 since 0 XOR 1 XOR 1 XOR 3 = 3.\n3 rd query: nums = [0,1], k = 2 since 0 XOR 1 XOR 2 = 3.\n4 th query: nums = [0], k = 3 since 0 XOR 3 = 3."
            },
            {
                "label": "Example 2",
                "input": "nums = [2,3,4,7], maximumBit = 3",
                "output": "[5,2,6,5] Explanation : The queries are answered as follows:\n1 st query: nums = [2,3,4,7], k = 5 since 2 XOR 3 XOR 4 XOR 7 XOR 5 = 7.\n2 nd query: nums = [2,3,4], k = 2 since 2 XOR 3 XOR 4 XOR 2 = 7.\n3 rd query: nums = [2,3], k = 6 since 2 XOR 3 XOR 6 = 7.\n4 th query: nums = [2], k = 5 since 2 XOR 5 = 7."
            },
            {
                "label": "Example 3",
                "input": "nums = [0,1,2,2,5,7], maximumBit = 3",
                "output": "[4,3,6,4,6,7] Constraints: nums.length == n 1 <= n <= 10 5 1 <= maximumBit <= 20 0 <= nums[i] < 2 maximumBit nums \u200b\u200b\u200b is sorted in ascending order."
            }
        ],
        "elixir_template": "defmodule Solution do\n  @spec get_maximum_xor(nums :: [integer], maximum_bit :: integer) :: [integer]\n  def get_maximum_xor(nums, maximum_bit) do\n    \n  end\nend",
        "erlang_template": "-spec get_maximum_xor(Nums :: [integer()], MaximumBit :: integer()) -> [integer()].\nget_maximum_xor(Nums, MaximumBit) ->\n  .",
        "scala_template": "object Solution {\n    def getMaximumXor(nums: Array[Int], maximumBit: Int): Array[Int] = {\n        \n    }\n}"
    },
    {
        "id": 1939,
        "name": "queries-on-number-of-points-inside-a-circle",
        "difficulty": "Medium",
        "link": "https://leetcode.com/problems/queries-on-number-of-points-inside-a-circle/",
        "task_description": "You are given an array `points` where `points[i] = [xi, yi]` is the coordinates of the `ith` point on a 2D plane. Multiple points can have the **same** coordinates. You are also given an array `queries` where `queries[j] = [xj, yj, rj]` describes a circle centered at `(xj, yj)` with a radius of `rj`. For each query `queries[j]`, compute the number of points **inside** the `jth` circle. Points **on the border** of the circle are considered **inside**. Return _an array _`answer`_, where _`answer[j]`_ is the answer to the _`jth`_ query_. **Example 1:** ``` **Input:** points = [[1,3],[3,3],[5,3],[2,2]], queries = [[2,3,1],[4,3,1],[1,1,2]] **Output:** [3,2,2] Explanation: The points and circles are shown above. queries[0] is the green circle, queries[1] is the red circle, and queries[2] is the blue circle. ``` **Example 2:** ``` **Input:** points = [[1,1],[2,2],[3,3],[4,4],[5,5]], queries = [[1,2,2],[2,2,2],[4,3,2],[4,3,3]] **Output:** [2,3,2,4] Explanation: The points and circles are shown above. queries[0] is green, queries[1] is red, queries[2] is blue, and queries[3] is purple. ``` **Constraints:** `1 <= points.length <= 500` `points[i].length == 2` `0 <= x\u200b\u200b\u200b\u200b\u200b\u200bi, y\u200b\u200b\u200b\u200b\u200b\u200bi <= 500` `1 <= queries.length <= 500` `queries[j].length == 3` `0 <= xj, yj <= 500` `1 <= rj <= 500` All coordinates are integers. **Follow up:** Could you find the answer for each query in better complexity than `O(n)`?",
        "test_case": [
            {
                "label": "Example 1",
                "input": "points = [[1,3],[3,3],[5,3],[2,2]], queries = [[2,3,1],[4,3,1],[1,1,2]]",
                "output": "[3,2,2] Explanation: The points and circles are shown above.\nqueries[0] is the green circle, queries[1] is the red circle, and queries[2] is the blue circle."
            },
            {
                "label": "Example 2",
                "input": "points = [[1,1],[2,2],[3,3],[4,4],[5,5]], queries = [[1,2,2],[2,2,2],[4,3,2],[4,3,3]]",
                "output": "[2,3,2,4] Explanation: The points and circles are shown above.\nqueries[0] is green, queries[1] is red, queries[2] is blue, and queries[3] is purple."
            }
        ],
        "elixir_template": "defmodule Solution do\n  @spec count_points(points :: [[integer]], queries :: [[integer]]) :: [integer]\n  def count_points(points, queries) do\n    \n  end\nend",
        "erlang_template": "-spec count_points(Points :: [[integer()]], Queries :: [[integer()]]) -> [integer()].\ncount_points(Points, Queries) ->\n  .",
        "scala_template": "object Solution {\n    def countPoints(points: Array[Array[Int]], queries: Array[Array[Int]]): Array[Int] = {\n        \n    }\n}"
    },
    {
        "id": 1938,
        "name": "minimum-operations-to-make-the-array-increasing",
        "difficulty": "Easy",
        "link": "https://leetcode.com/problems/minimum-operations-to-make-the-array-increasing/",
        "task_description": "You are given an integer array `nums` (**0-indexed**). In one operation, you can choose an element of the array and increment it by `1`. For example, if `nums = [1,2,3]`, you can choose to increment `nums[1]` to make `nums = [1,3,3]`. Return _the **minimum** number of operations needed to make_ `nums` _**strictly** **increasing**._ An array `nums` is **strictly increasing** if `nums[i] < nums[i+1]` for all `0 <= i < nums.length - 1`. An array of length `1` is trivially strictly increasing. **Example 1:** ``` **Input:** nums = [1,1,1] **Output:** 3 **Explanation:** You can do the following operations: 1) Increment nums[2], so nums becomes [1,1,**2**]. 2) Increment nums[1], so nums becomes [1,**2**,2]. 3) Increment nums[2], so nums becomes [1,2,**3**]. ``` **Example 2:** ``` **Input:** nums = [1,5,2,4,1] **Output:** 14 ``` **Example 3:** ``` **Input:** nums = [8] **Output:** 0 ``` **Constraints:** `1 <= nums.length <= 5000` `1 <= nums[i] <= 104`",
        "test_case": [
            {
                "label": "Example 1",
                "input": "nums = [1,1,1]",
                "output": "3 Explanation: You can do the following operations:\r\n1) Increment nums[2], so nums becomes [1,1, 2 ].\r\n2) Increment nums[1], so nums becomes [1, 2 ,2].\r\n3) Increment nums[2], so nums becomes [1,2, 3 ]."
            },
            {
                "label": "Example 2",
                "input": "nums = [1,5,2,4,1]",
                "output": "14"
            },
            {
                "label": "Example 3",
                "input": "nums = [8]",
                "output": "0"
            }
        ],
        "elixir_template": "Elixir code template not available for this problem.",
        "erlang_template": "Elixir code template not available for this problem.",
        "scala_template": "object Solution {\n    def minOperations(nums: Array[Int]): Int = {\n        \n    }\n}"
    },
    {
        "id": 1936,
        "name": "maximize-number-of-nice-divisors",
        "difficulty": "Hard",
        "link": "https://leetcode.com/problems/maximize-number-of-nice-divisors/",
        "task_description": "You are given a positive integer `primeFactors`. You are asked to construct a positive integer `n` that satisfies the following conditions: The number of prime factors of `n` (not necessarily distinct) is **at most** `primeFactors`. The number of nice divisors of `n` is maximized. Note that a divisor of `n` is **nice** if it is divisible by every prime factor of `n`. For example, if `n = 12`, then its prime factors are `[2,2,3]`, then `6` and `12` are nice divisors, while `3` and `4` are not. Return _the number of nice divisors of_ `n`. Since that number can be too large, return it **modulo** `109 + 7`. Note that a prime number is a natural number greater than `1` that is not a product of two smaller natural numbers. The prime factors of a number `n` is a list of prime numbers such that their product equals `n`. **Example 1:** ``` **Input:** primeFactors = 5 **Output:** 6 **Explanation:** 200 is a valid value of n. It has 5 prime factors: [2,2,2,5,5], and it has 6 nice divisors: [10,20,40,50,100,200]. There is not other value of n that has at most 5 prime factors and more nice divisors. ``` **Example 2:** ``` **Input:** primeFactors = 8 **Output:** 18 ``` **Constraints:** `1 <= primeFactors <= 109`",
        "test_case": [
            {
                "label": "Example 1",
                "input": "primeFactors = 5",
                "output": "6 Explanation: 200 is a valid value of n.\r\nIt has 5 prime factors: [2,2,2,5,5], and it has 6 nice divisors: [10,20,40,50,100,200].\r\nThere is not other value of n that has at most 5 prime factors and more nice divisors."
            },
            {
                "label": "Example 2",
                "input": "primeFactors = 8",
                "output": "18"
            }
        ],
        "elixir_template": "Elixir code template not available for this problem.",
        "erlang_template": "Elixir code template not available for this problem.",
        "scala_template": "object Solution {\n    def maxNiceDivisors(primeFactors: Int): Int = {\n        \n    }\n}"
    },
    {
        "id": 1935,
        "name": "minimum-number-of-operations-to-reinitialize-a-permutation",
        "difficulty": "Medium",
        "link": "https://leetcode.com/problems/minimum-number-of-operations-to-reinitialize-a-permutation/",
        "task_description": "You are given an **even** integer `n`\u200b\u200b\u200b\u200b\u200b\u200b. You initially have a permutation `perm` of size `n`\u200b\u200b where `perm[i] == i`\u200b **(0-indexed)**\u200b\u200b\u200b\u200b. In one operation, you will create a new array `arr`, and for each `i`: If `i % 2 == 0`, then `arr[i] = perm[i / 2]`. If `i % 2 == 1`, then `arr[i] = perm[n / 2 + (i - 1) / 2]`. You will then assign `arr`\u200b\u200b\u200b\u200b to `perm`. Return _the minimum **non-zero** number of operations you need to perform on _`perm`_ to return the permutation to its initial value._ **Example 1:** ``` **Input:** n = 2 **Output:** 1 **Explanation:** perm = [0,1] initially. After the 1st operation, perm = [0,1] So it takes only 1 operation. ``` **Example 2:** ``` **Input:** n = 4 **Output:** 2 **Explanation:** perm = [0,1,2,3] initially. After the 1st operation, perm = [0,2,1,3] After the 2nd operation, perm = [0,1,2,3] So it takes only 2 operations. ``` **Example 3:** ``` **Input:** n = 6 **Output:** 4 ``` **Constraints:** `2 <= n <= 1000` `n`\u200b\u200b\u200b\u200b\u200b\u200b is even.",
        "test_case": [
            {
                "label": "Example 1",
                "input": "n = 2",
                "output": "1 Explanation: perm = [0,1] initially.\nAfter the 1 st operation, perm = [0,1]\nSo it takes only 1 operation."
            },
            {
                "label": "Example 2",
                "input": "n = 4",
                "output": "2 Explanation: perm = [0,1,2,3] initially.\nAfter the 1 st operation, perm = [0,2,1,3]\nAfter the 2 nd operation, perm = [0,1,2,3]\nSo it takes only 2 operations."
            },
            {
                "label": "Example 3",
                "input": "n = 6",
                "output": "4"
            }
        ],
        "elixir_template": "defmodule Solution do\n  @spec reinitialize_permutation(n :: integer) :: integer\n  def reinitialize_permutation(n) do\n    \n  end\nend",
        "erlang_template": "-spec reinitialize_permutation(N :: integer()) -> integer().\nreinitialize_permutation(N) ->\n  .",
        "scala_template": "object Solution {\n    def reinitializePermutation(n: Int): Int = {\n        \n    }\n}"
    },
    {
        "id": 1934,
        "name": "evaluate-the-bracket-pairs-of-a-string",
        "difficulty": "Medium",
        "link": "https://leetcode.com/problems/evaluate-the-bracket-pairs-of-a-string/",
        "task_description": "You are given a string `s` that contains some bracket pairs, with each pair containing a **non-empty** key. For example, in the string `\"(name)is(age)yearsold\"`, there are **two** bracket pairs that contain the keys `\"name\"` and `\"age\"`. You know the values of a wide range of keys. This is represented by a 2D string array `knowledge` where each `knowledge[i] = [keyi, valuei]` indicates that key `keyi` has a value of `valuei`. You are tasked to evaluate **all** of the bracket pairs. When you evaluate a bracket pair that contains some key `keyi`, you will: Replace `keyi` and the bracket pair with the key's corresponding `valuei`. If you do not know the value of the key, you will replace `keyi` and the bracket pair with a question mark `\"?\"` (without the quotation marks). Each key will appear at most once in your `knowledge`. There will not be any nested brackets in `s`. Return _the resulting string after evaluating **all** of the bracket pairs._ **Example 1:** ``` **Input:** s = \"(name)is(age)yearsold\", knowledge = [[\"name\",\"bob\"],[\"age\",\"two\"]] **Output:** \"bobistwoyearsold\" **Explanation:** The key \"name\" has a value of \"bob\", so replace \"(name)\" with \"bob\". The key \"age\" has a value of \"two\", so replace \"(age)\" with \"two\". ``` **Example 2:** ``` **Input:** s = \"hi(name)\", knowledge = [[\"a\",\"b\"]] **Output:** \"hi?\" **Explanation:** As you do not know the value of the key \"name\", replace \"(name)\" with \"?\". ``` **Example 3:** ``` **Input:** s = \"(a)(a)(a)aaa\", knowledge = [[\"a\",\"yes\"]] **Output:** \"yesyesyesaaa\" **Explanation:** The same key can appear multiple times. The key \"a\" has a value of \"yes\", so replace all occurrences of \"(a)\" with \"yes\". Notice that the \"a\"s not in a bracket pair are not evaluated. ``` **Constraints:** `1 <= s.length <= 105` `0 <= knowledge.length <= 105` `knowledge[i].length == 2` `1 <= keyi.length, valuei.length <= 10` `s` consists of lowercase English letters and round brackets `'('` and `')'`. Every open bracket `'('` in `s` will have a corresponding close bracket `')'`. The key in each bracket pair of `s` will be non-empty. There will not be any nested bracket pairs in `s`. `keyi` and `valuei` consist of lowercase English letters. Each `keyi` in `knowledge` is unique.",
        "test_case": [
            {
                "label": "Example 1",
                "input": "s = \"(name)is(age)yearsold\", knowledge = [[\"name\",\"bob\"],[\"age\",\"two\"]]",
                "output": "\"bobistwoyearsold\" Explanation: The key \"name\" has a value of \"bob\", so replace \"(name)\" with \"bob\".\nThe key \"age\" has a value of \"two\", so replace \"(age)\" with \"two\"."
            },
            {
                "label": "Example 2",
                "input": "s = \"hi(name)\", knowledge = [[\"a\",\"b\"]]",
                "output": "\"hi?\" Explanation: As you do not know the value of the key \"name\", replace \"(name)\" with \"?\"."
            },
            {
                "label": "Example 3",
                "input": "s = \"(a)(a)(a)aaa\", knowledge = [[\"a\",\"yes\"]]",
                "output": "\"yesyesyesaaa\" Explanation: The same key can appear multiple times.\nThe key \"a\" has a value of \"yes\", so replace all occurrences of \"(a)\" with \"yes\".\nNotice that the \"a\"s not in a bracket pair are not evaluated."
            }
        ],
        "elixir_template": "defmodule Solution do\n  @spec evaluate(s :: String.t, knowledge :: [[String.t]]) :: String.t\n  def evaluate(s, knowledge) do\n    \n  end\nend",
        "erlang_template": "-spec evaluate(S :: unicode:unicode_binary(), Knowledge :: [[unicode:unicode_binary()]]) -> unicode:unicode_binary().\nevaluate(S, Knowledge) ->\n  .",
        "scala_template": "object Solution {\n    def evaluate(s: String, knowledge: List[List[String]]): String = {\n        \n    }\n}"
    },
    {
        "id": 1933,
        "name": "number-of-different-integers-in-a-string",
        "difficulty": "Easy",
        "link": "https://leetcode.com/problems/number-of-different-integers-in-a-string/",
        "task_description": "You are given a string `word` that consists of digits and lowercase English letters. You will replace every non-digit character with a space. For example, `\"a123bc34d8ef34\"` will become `\" 123 34 8 34\"`. Notice that you are left with some integers that are separated by at least one space: `\"123\"`, `\"34\"`, `\"8\"`, and `\"34\"`. Return _the number of **different** integers after performing the replacement operations on _`word`. Two integers are considered different if their decimal representations **without any leading zeros** are different. **Example 1:** ``` **Input:** word = \"a123bc34d8ef34\" **Output:** 3 **Explanation: **The three different integers are \"123\", \"34\", and \"8\". Notice that \"34\" is only counted once. ``` **Example 2:** ``` **Input:** word = \"leet1234code234\" **Output:** 2 ``` **Example 3:** ``` **Input:** word = \"a1b01c001\" **Output:** 1 **Explanation: **The three integers \"1\", \"01\", and \"001\" all represent the same integer because the leading zeros are ignored when comparing their decimal values. ``` **Constraints:** `1 <= word.length <= 1000` `word` consists of digits and lowercase English letters.",
        "test_case": [
            {
                "label": "Example 1",
                "input": "word = \"a 123 bc 34 d 8 ef 34 \"",
                "output": "3 Explanation: The three different integers are \"123\", \"34\", and \"8\". Notice that \"34\" is only counted once."
            },
            {
                "label": "Example 2",
                "input": "word = \"leet 1234 code 234 \"",
                "output": "2"
            },
            {
                "label": "Example 3",
                "input": "word = \"a 1 b 01 c 001 \"",
                "output": "1 Explanation: The three integers \"1\", \"01\", and \"001\" all represent the same integer because\nthe leading zeros are ignored when comparing their decimal values."
            }
        ],
        "elixir_template": "defmodule Solution do\n  @spec num_different_integers(word :: String.t) :: integer\n  def num_different_integers(word) do\n    \n  end\nend",
        "erlang_template": "-spec num_different_integers(Word :: unicode:unicode_binary()) -> integer().\nnum_different_integers(Word) ->\n  .",
        "scala_template": "object Solution {\n    def numDifferentIntegers(word: String): Int = {\n        \n    }\n}"
    },
    {
        "id": 1930,
        "name": "maximum-number-of-consecutive-values-you-can-make",
        "difficulty": "Medium",
        "link": "https://leetcode.com/problems/maximum-number-of-consecutive-values-you-can-make/",
        "task_description": "You are given an integer array `coins` of length `n` which represents the `n` coins that you own. The value of the `ith` coin is `coins[i]`. You can **make** some value `x` if you can choose some of your `n` coins such that their values sum up to `x`. Return the _maximum number of consecutive integer values that you **can** **make** with your coins **starting** from and **including** _`0`. Note that you may have multiple coins of the same value. **Example 1:** ``` **Input:** coins = [1,3] **Output:** 2 **Explanation: **You can make the following values: - 0: take [] - 1: take [1] You can make 2 consecutive integer values starting from 0. ``` **Example 2:** ``` **Input:** coins = [1,1,1,4] **Output:** 8 **Explanation: **You can make the following values: - 0: take [] - 1: take [1] - 2: take [1,1] - 3: take [1,1,1] - 4: take [4] - 5: take [4,1] - 6: take [4,1,1] - 7: take [4,1,1,1] You can make 8 consecutive integer values starting from 0. ``` **Example 3:** ``` **Input:** coins = [1,4,10,3,1] **Output:** 20 ``` **Constraints:** `coins.length == n` `1 <= n <= 4 * 104` `1 <= coins[i] <= 4 * 104`",
        "test_case": [
            {
                "label": "Example 1",
                "input": "coins = [1,3]",
                "output": "2 Explanation: You can make the following values:\n- 0: take []\n- 1: take [1]\nYou can make 2 consecutive integer values starting from 0."
            },
            {
                "label": "Example 2",
                "input": "coins = [1,1,1,4]",
                "output": "8 Explanation: You can make the following values:\n- 0: take []\n- 1: take [1]\n- 2: take [1,1]\n- 3: take [1,1,1]\n- 4: take [4]\n- 5: take [4,1]\n- 6: take [4,1,1]\n- 7: take [4,1,1,1]\nYou can make 8 consecutive integer values starting from 0."
            },
            {
                "label": "Example 3",
                "input": "coins = [1,4,10,3,1]",
                "output": "20 Constraints: coins.length == n 1 <= n <= 4 * 10 4 1 <= coins[i] <= 4 * 10 4"
            }
        ],
        "elixir_template": "defmodule Solution do\n  @spec get_maximum_consecutive(coins :: [integer]) :: integer\n  def get_maximum_consecutive(coins) do\n    \n  end\nend",
        "erlang_template": "-spec get_maximum_consecutive(Coins :: [integer()]) -> integer().\nget_maximum_consecutive(Coins) ->\n  .",
        "scala_template": "object Solution {\n    def getMaximumConsecutive(coins: Array[Int]): Int = {\n        \n    }\n}"
    },
    {
        "id": 1929,
        "name": "maximum-value-at-a-given-index-in-a-bounded-array",
        "difficulty": "Medium",
        "link": "https://leetcode.com/problems/maximum-value-at-a-given-index-in-a-bounded-array/",
        "task_description": "You are given three positive integers: `n`, `index`, and `maxSum`. You want to construct an array `nums` (**0-indexed**)** **that satisfies the following conditions: `nums.length == n` `nums[i]` is a **positive** integer where `0 <= i < n`. `abs(nums[i] - nums[i+1]) <= 1` where `0 <= i < n-1`. The sum of all the elements of `nums` does not exceed `maxSum`. `nums[index]` is **maximized**. Return `nums[index]`_ of the constructed array_. Note that `abs(x)` equals `x` if `x >= 0`, and `-x` otherwise. **Example 1:** ``` **Input:** n = 4, index = 2, maxSum = 6 **Output:** 2 **Explanation:** nums = [1,2,**2**,1] is one array that satisfies all the conditions. There are no arrays that satisfy all the conditions and have nums[2] == 3, so 2 is the maximum nums[2]. ``` **Example 2:** ``` **Input:** n = 6, index = 1, maxSum = 10 **Output:** 3 ``` **Constraints:** `1 <= n <= maxSum <= 109` `0 <= index < n`",
        "test_case": [
            {
                "label": "Example 1",
                "input": "n = 4, index = 2,  maxSum = 6",
                "output": "2 Explanation: nums = [1,2, 2 ,1] is one array that satisfies all the conditions.\nThere are no arrays that satisfy all the conditions and have nums[2] == 3, so 2 is the maximum nums[2]."
            },
            {
                "label": "Example 2",
                "input": "n = 6, index = 1,  maxSum = 10",
                "output": "3"
            }
        ],
        "elixir_template": "defmodule Solution do\n  @spec max_value(n :: integer, index :: integer, max_sum :: integer) :: integer\n  def max_value(n, index, max_sum) do\n    \n  end\nend",
        "erlang_template": "-spec max_value(N :: integer(), Index :: integer(), MaxSum :: integer()) -> integer().\nmax_value(N, Index, MaxSum) ->\n  .",
        "scala_template": "object Solution {\n    def maxValue(n: Int, index: Int, maxSum: Int): Int = {\n        \n    }\n}"
    },
    {
        "id": 1928,
        "name": "number-of-orders-in-the-backlog",
        "difficulty": "Medium",
        "link": "https://leetcode.com/problems/number-of-orders-in-the-backlog/",
        "task_description": "You are given a 2D integer array `orders`, where each `orders[i] = [pricei, amounti, orderTypei]` denotes that `amounti` orders have been placed of type `orderTypei` at the price `pricei`. The `orderTypei` is: `0` if it is a batch of `buy` orders, or `1` if it is a batch of `sell` orders. Note that `orders[i]` represents a batch of `amounti` independent orders with the same price and order type. All orders represented by `orders[i]` will be placed before all orders represented by `orders[i+1]` for all valid `i`. There is a **backlog** that consists of orders that have not been executed. The backlog is initially empty. When an order is placed, the following happens: If the order is a `buy` order, you look at the `sell` order with the **smallest** price in the backlog. If that `sell` order's price is **smaller than or equal to** the current `buy` order's price, they will match and be executed, and that `sell` order will be removed from the backlog. Else, the `buy` order is added to the backlog. Vice versa, if the order is a `sell` order, you look at the `buy` order with the **largest** price in the backlog. If that `buy` order's price is **larger than or equal to** the current `sell` order's price, they will match and be executed, and that `buy` order will be removed from the backlog. Else, the `sell` order is added to the backlog. Return _the total **amount** of orders in the backlog after placing all the orders from the input_. Since this number can be large, return it **modulo** `109 + 7`. **Example 1:** ``` **Input:** orders = [[10,5,0],[15,2,1],[25,1,1],[30,4,0]] **Output:** 6 **Explanation:** Here is what happens with the orders: - 5 orders of type buy with price 10 are placed. There are no sell orders, so the 5 orders are added to the backlog. - 2 orders of type sell with price 15 are placed. There are no buy orders with prices larger than or equal to 15, so the 2 orders are added to the backlog. - 1 order of type sell with price 25 is placed. There are no buy orders with prices larger than or equal to 25 in the backlog, so this order is added to the backlog. - 4 orders of type buy with price 30 are placed. The first 2 orders are matched with the 2 sell orders of the least price, which is 15 and these 2 sell orders are removed from the backlog. The 3rd order is matched with the sell order of the least price, which is 25 and this sell order is removed from the backlog. Then, there are no more sell orders in the backlog, so the 4th order is added to the backlog. Finally, the backlog has 5 buy orders with price 10, and 1 buy order with price 30. So the total number of orders in the backlog is 6. ``` **Example 2:** ``` **Input:** orders = [[7,1000000000,1],[15,3,0],[5,999999995,0],[5,1,1]] **Output:** 999999984 **Explanation:** Here is what happens with the orders: - 109 orders of type sell with price 7 are placed. There are no buy orders, so the 109 orders are added to the backlog. - 3 orders of type buy with price 15 are placed. They are matched with the 3 sell orders with the least price which is 7, and those 3 sell orders are removed from the backlog. - 999999995 orders of type buy with price 5 are placed. The least price of a sell order is 7, so the 999999995 orders are added to the backlog. - 1 order of type sell with price 5 is placed. It is matched with the buy order of the highest price, which is 5, and that buy order is removed from the backlog. Finally, the backlog has (1000000000-3) sell orders with price 7, and (999999995-1) buy orders with price 5. So the total number of orders = 1999999991, which is equal to 999999984 % (109 + 7). ``` **Constraints:** `1 <= orders.length <= 105` `orders[i].length == 3` `1 <= pricei, amounti <= 109` `orderTypei` is either `0` or `1`.",
        "test_case": [
            {
                "label": "Example 1",
                "input": "orders = [[10,5,0],[15,2,1],[25,1,1],[30,4,0]]",
                "output": "6 Explanation: Here is what happens with the orders:\r\n- 5 orders of type buy with price 10 are placed. There are no sell orders, so the 5 orders are added to the backlog.\r\n- 2 orders of type sell with price 15 are placed. There are no buy orders with prices larger than or equal to 15, so the 2 orders are added to the backlog.\r\n- 1 order of type sell with price 25 is placed. There are no buy orders with prices larger than or equal to 25 in the backlog, so this order is added to the backlog.\r\n- 4 orders of type buy with price 30 are placed. The first 2 orders are matched with the 2 sell orders of the least price, which is 15 and these 2 sell orders are removed from the backlog. The 3 rd order is matched with the sell order of the least price, which is 25 and this sell order is removed from the backlog. Then, there are no more sell orders in the backlog, so the 4 th order is added to the backlog.\r\nFinally, the backlog has 5 buy orders with price 10, and 1 buy order with price 30. So the total number of orders in the backlog is 6."
            },
            {
                "label": "Example 2",
                "input": "orders = [[7,1000000000,1],[15,3,0],[5,999999995,0],[5,1,1]]",
                "output": "999999984 Explanation: Here is what happens with the orders:\r\n- 10 9 orders of type sell with price 7 are placed. There are no buy orders, so the 10 9 orders are added to the backlog.\r\n- 3 orders of type buy with price 15 are placed. They are matched with the 3 sell orders with the least price which is 7, and those 3 sell orders are removed from the backlog.\r\n- 999999995 orders of type buy with price 5 are placed. The least price of a sell order is 7, so the 999999995 orders are added to the backlog.\r\n- 1 order of type sell with price 5 is placed. It is matched with the buy order of the highest price, which is 5, and that buy order is removed from the backlog.\r\nFinally, the backlog has (1000000000-3) sell orders with price 7, and (999999995-1) buy orders with price 5. So the total number of orders = 1999999991, which is equal to 999999984 % (10 9 + 7)."
            }
        ],
        "elixir_template": "Elixir code template not available for this problem.",
        "erlang_template": "Elixir code template not available for this problem.",
        "scala_template": "object Solution {\n    def getNumberOfBacklogOrders(orders: Array[Array[Int]]): Int = {\n        \n    }\n}"
    },
    {
        "id": 1927,
        "name": "maximum-ascending-subarray-sum",
        "difficulty": "Easy",
        "link": "https://leetcode.com/problems/maximum-ascending-subarray-sum/",
        "task_description": "Given an array of positive integers `nums`, return the _maximum possible sum of an **ascending** subarray in _`nums`. A subarray is defined as a contiguous sequence of numbers in an array. A subarray `[numsl, numsl+1, ..., numsr-1, numsr]` is **ascending** if for all `i` where `l <= i < r`, `numsi < numsi+1`. Note that a subarray of size `1` is **ascending**. **Example 1:** ``` **Input:** nums = [10,20,30,5,10,50] **Output:** 65 **Explanation: **[5,10,50] is the ascending subarray with the maximum sum of 65. ``` **Example 2:** ``` **Input:** nums = [10,20,30,40,50] **Output:** 150 **Explanation: **[10,20,30,40,50] is the ascending subarray with the maximum sum of 150. ``` **Example 3:** ``` **Input:** nums = [12,17,15,13,10,11,12] **Output:** 33 **Explanation: **[10,11,12] is the ascending subarray with the maximum sum of 33. ``` **Constraints:** `1 <= nums.length <= 100` `1 <= nums[i] <= 100`",
        "test_case": [
            {
                "label": "Example 1",
                "input": "nums = [10,20,30,5,10,50]",
                "output": "65 Explanation: [5,10,50] is the ascending subarray with the maximum sum of 65."
            },
            {
                "label": "Example 2",
                "input": "nums = [10,20,30,40,50]",
                "output": "150 Explanation: [10,20,30,40,50] is the ascending subarray with the maximum sum of 150."
            },
            {
                "label": "Example 3",
                "input": "nums = [12,17,15,13,10,11,12]",
                "output": "33 Explanation: [10,11,12] is the ascending subarray with the maximum sum of 33."
            }
        ],
        "elixir_template": "defmodule Solution do\n  @spec max_ascending_sum(nums :: [integer]) :: integer\n  def max_ascending_sum(nums) do\n    \n  end\nend",
        "erlang_template": "-spec max_ascending_sum(Nums :: [integer()]) -> integer().\nmax_ascending_sum(Nums) ->\n  .",
        "scala_template": "object Solution {\n    def maxAscendingSum(nums: Array[Int]): Int = {\n        \n    }\n}"
    },
    {
        "id": 1925,
        "name": "count-nice-pairs-in-an-array",
        "difficulty": "Medium",
        "link": "https://leetcode.com/problems/count-nice-pairs-in-an-array/",
        "task_description": "You are given an array `nums` that consists of non-negative integers. Let us define `rev(x)` as the reverse of the non-negative integer `x`. For example, `rev(123) = 321`, and `rev(120) = 21`. A pair of indices `(i, j)` is **nice** if it satisfies all of the following conditions: `0 <= i < j < nums.length` `nums[i] + rev(nums[j]) == nums[j] + rev(nums[i])` Return _the number of nice pairs of indices_. Since that number can be too large, return it **modulo** `109 + 7`. **Example 1:** ``` **Input:** nums = [42,11,1,97] **Output:** 2 **Explanation:** The two pairs are: - (0,3) : 42 + rev(97) = 42 + 79 = 121, 97 + rev(42) = 97 + 24 = 121. - (1,2) : 11 + rev(1) = 11 + 1 = 12, 1 + rev(11) = 1 + 11 = 12. ``` **Example 2:** ``` **Input:** nums = [13,10,35,24,76] **Output:** 4 ``` **Constraints:** `1 <= nums.length <= 105` `0 <= nums[i] <= 109`",
        "test_case": [
            {
                "label": "Example 1",
                "input": "nums = [42,11,1,97]",
                "output": "2 Explanation: The two pairs are:\n - (0,3) : 42 + rev(97) = 42 + 79 = 121, 97 + rev(42) = 97 + 24 = 121.\n - (1,2) : 11 + rev(1) = 11 + 1 = 12, 1 + rev(11) = 1 + 11 = 12."
            },
            {
                "label": "Example 2",
                "input": "nums = [13,10,35,24,76]",
                "output": "4"
            }
        ],
        "elixir_template": "defmodule Solution do\n  @spec count_nice_pairs(nums :: [integer]) :: integer\n  def count_nice_pairs(nums) do\n    \n  end\nend",
        "erlang_template": "-spec count_nice_pairs(Nums :: [integer()]) -> integer().\ncount_nice_pairs(Nums) ->\n  .",
        "scala_template": "object Solution {\n    def countNicePairs(nums: Array[Int]): Int = {\n        \n    }\n}"
    },
    {
        "id": 1924,
        "name": "maximum-number-of-groups-getting-fresh-donuts",
        "difficulty": "Hard",
        "link": "https://leetcode.com/problems/maximum-number-of-groups-getting-fresh-donuts/",
        "task_description": "There is a donuts shop that bakes donuts in batches of `batchSize`. They have a rule where they must serve **all** of the donuts of a batch before serving any donuts of the next batch. You are given an integer `batchSize` and an integer array `groups`, where `groups[i]` denotes that there is a group of `groups[i]` customers that will visit the shop. Each customer will get exactly one donut. When a group visits the shop, all customers of the group must be served before serving any of the following groups. A group will be happy if they all get fresh donuts. That is, the first customer of the group does not receive a donut that was left over from the previous group. You can freely rearrange the ordering of the groups. Return _the **maximum** possible number of happy groups after rearranging the groups._ **Example 1:** ``` **Input:** batchSize = 3, groups = [1,2,3,4,5,6] **Output:** 4 **Explanation:** You can arrange the groups as [6,2,4,5,1,3]. Then the 1st, 2nd, 4th, and 6th groups will be happy. ``` **Example 2:** ``` **Input:** batchSize = 4, groups = [1,3,2,5,2,2,1,6] **Output:** 4 ``` **Constraints:** `1 <= batchSize <= 9` `1 <= groups.length <= 30` `1 <= groups[i] <= 109`",
        "test_case": [
            {
                "label": "Example 1",
                "input": "batchSize = 3, groups = [1,2,3,4,5,6]",
                "output": "4 Explanation: You can arrange the groups as [6,2,4,5,1,3]. Then the 1 st , 2 nd , 4 th , and 6 th groups will be happy."
            },
            {
                "label": "Example 2",
                "input": "batchSize = 4, groups = [1,3,2,5,2,2,1,6]",
                "output": "4"
            }
        ],
        "elixir_template": "defmodule Solution do\n  @spec max_happy_groups(batch_size :: integer, groups :: [integer]) :: integer\n  def max_happy_groups(batch_size, groups) do\n    \n  end\nend",
        "erlang_template": "-spec max_happy_groups(BatchSize :: integer(), Groups :: [integer()]) -> integer().\nmax_happy_groups(BatchSize, Groups) ->\n  .",
        "scala_template": "object Solution {\n    def maxHappyGroups(batchSize: Int, groups: Array[Int]): Int = {\n        \n    }\n}"
    },
    {
        "id": 1923,
        "name": "sentence-similarity-iii",
        "difficulty": "Medium",
        "link": "https://leetcode.com/problems/sentence-similarity-iii/",
        "task_description": "You are given two strings `sentence1` and `sentence2`, each representing a **sentence** composed of words. A sentence is a list of **words** that are separated by a **single** space with no leading or trailing spaces. Each word consists of only uppercase and lowercase English characters. Two sentences `s1` and `s2` are considered **similar** if it is possible to insert an arbitrary sentence (_possibly empty_) inside one of these sentences such that the two sentences become equal. **Note** that the inserted sentence must be separated from existing words by spaces. For example, `s1 = \"Hello Jane\"` and `s2 = \"Hello my name is Jane\"` can be made equal by inserting `\"my name is\"` between `\"Hello\"` and `\"Jane\"` in s1. `s1 = \"Frog cool\"` and `s2 = \"Frogs are cool\"` are **not** similar, since although there is a sentence `\"s are\"` inserted into `s1`, it is not separated from `\"Frog\"` by a space. Given two sentences `sentence1` and `sentence2`, return **true** if `sentence1` and `sentence2` are **similar**. Otherwise, return **false**. **Example 1:** **Input:** sentence1 = \"My name is Haley\", sentence2 = \"My Haley\" **Output:** true **Explanation:** `sentence2` can be turned to `sentence1` by inserting \"name is\" between \"My\" and \"Haley\". **Example 2:** **Input:** sentence1 = \"of\", sentence2 = \"A lot of words\" **Output:** false **Explanation:** No single sentence can be inserted inside one of the sentences to make it equal to the other. **Example 3:** **Input:** sentence1 = \"Eating right now\", sentence2 = \"Eating\" **Output:** true **Explanation:** `sentence2` can be turned to `sentence1` by inserting \"right now\" at the end of the sentence. **Constraints:** `1 <= sentence1.length, sentence2.length <= 100` `sentence1` and `sentence2` consist of lowercase and uppercase English letters and spaces. The words in `sentence1` and `sentence2` are separated by a single space.",
        "test_case": [
            {
                "label": "Example 1",
                "input": "sentence1 = \"My name is Haley\", sentence2 = \"My Haley\"",
                "output": "true Explanation: sentence2 can be turned to sentence1 by inserting \"name is\" between \"My\" and \"Haley\"."
            },
            {
                "label": "Example 2",
                "input": "sentence1 = \"of\", sentence2 = \"A lot of words\"",
                "output": "false Explanation: No single sentence can be inserted inside one of the sentences to make it equal to the other."
            },
            {
                "label": "Example 3",
                "input": "sentence1 = \"Eating right now\", sentence2 = \"Eating\"",
                "output": "true Explanation: sentence2 can be turned to sentence1 by inserting \"right now\" at the end of the sentence."
            }
        ],
        "elixir_template": "defmodule Solution do\n  @spec are_sentences_similar(sentence1 :: String.t, sentence2 :: String.t) :: boolean\n  def are_sentences_similar(sentence1, sentence2) do\n    \n  end\nend",
        "erlang_template": "-spec are_sentences_similar(Sentence1 :: unicode:unicode_binary(), Sentence2 :: unicode:unicode_binary()) -> boolean().\nare_sentences_similar(Sentence1, Sentence2) ->\n  .",
        "scala_template": "object Solution {\n    def areSentencesSimilar(sentence1: String, sentence2: String): Boolean = {\n        \n    }\n}"
    },
    {
        "id": 1920,
        "name": "determine-color-of-a-chessboard-square",
        "difficulty": "Easy",
        "link": "https://leetcode.com/problems/determine-color-of-a-chessboard-square/",
        "task_description": "You are given `coordinates`, a string that represents the coordinates of a square of the chessboard. Below is a chessboard for your reference. Return `true`_ if the square is white, and _`false`_ if the square is black_. The coordinate will always represent a valid chessboard square. The coordinate will always have the letter first, and the number second. **Example 1:** ``` **Input:** coordinates = \"a1\" **Output:** false **Explanation:** From the chessboard above, the square with coordinates \"a1\" is black, so return false. ``` **Example 2:** ``` **Input:** coordinates = \"h3\" **Output:** true **Explanation:** From the chessboard above, the square with coordinates \"h3\" is white, so return true. ``` **Example 3:** ``` **Input:** coordinates = \"c7\" **Output:** false ``` **Constraints:** `coordinates.length == 2` `'a' <= coordinates[0] <= 'h'` `'1' <= coordinates[1] <= '8'`",
        "test_case": [
            {
                "label": "Example 1",
                "input": "coordinates = \"a1\"",
                "output": "false Explanation: From the chessboard above, the square with coordinates \"a1\" is black, so return false."
            },
            {
                "label": "Example 2",
                "input": "coordinates = \"h3\"",
                "output": "true Explanation: From the chessboard above, the square with coordinates \"h3\" is white, so return true."
            },
            {
                "label": "Example 3",
                "input": "coordinates = \"c7\"",
                "output": "false Constraints: coordinates.length == 2 'a' <= coordinates[0] <= 'h' '1' <= coordinates[1] <= '8'"
            }
        ],
        "elixir_template": "defmodule Solution do\n  @spec square_is_white(coordinates :: String.t) :: boolean\n  def square_is_white(coordinates) do\n    \n  end\nend",
        "erlang_template": "-spec square_is_white(Coordinates :: unicode:unicode_binary()) -> boolean().\nsquare_is_white(Coordinates) ->\n  .",
        "scala_template": "object Solution {\n    def squareIsWhite(coordinates: String): Boolean = {\n        \n    }\n}"
    },
    {
        "id": 1918,
        "name": "maximum-score-of-a-good-subarray",
        "difficulty": "Hard",
        "link": "https://leetcode.com/problems/maximum-score-of-a-good-subarray/",
        "task_description": "You are given an array of integers `nums` **(0-indexed)** and an integer `k`. The **score** of a subarray `(i, j)` is defined as `min(nums[i], nums[i+1], ..., nums[j]) * (j - i + 1)`. A **good** subarray is a subarray where `i <= k <= j`. Return _the maximum possible **score** of a **good** subarray._ **Example 1:** ``` **Input:** nums = [1,4,3,7,4,5], k = 3 **Output:** 15 **Explanation:** The optimal subarray is (1, 5) with a score of min(4,3,7,4,5) * (5-1+1) = 3 * 5 = 15. ``` **Example 2:** ``` **Input:** nums = [5,5,4,5,4,1,1,1], k = 0 **Output:** 20 **Explanation:** The optimal subarray is (0, 4) with a score of min(5,5,4,5,4) * (4-0+1) = 4 * 5 = 20. ``` **Constraints:** `1 <= nums.length <= 105` `1 <= nums[i] <= 2 * 104` `0 <= k < nums.length`",
        "test_case": [
            {
                "label": "Example 1",
                "input": "nums = [1,4,3,7,4,5], k = 3",
                "output": "15 Explanation: The optimal subarray is (1, 5) with a score of min(4,3,7,4,5) * (5-1+1) = 3 * 5 = 15."
            },
            {
                "label": "Example 2",
                "input": "nums = [5,5,4,5,4,1,1,1], k = 0",
                "output": "20 Explanation: The optimal subarray is (0, 4) with a score of min(5,5,4,5,4) * (4-0+1) = 4 * 5 = 20."
            }
        ],
        "elixir_template": "defmodule Solution do\n  @spec maximum_score(nums :: [integer], k :: integer) :: integer\n  def maximum_score(nums, k) do\n    \n  end\nend",
        "erlang_template": "-spec maximum_score(Nums :: [integer()], K :: integer()) -> integer().\nmaximum_score(Nums, K) ->\n  .",
        "scala_template": "object Solution {\n    def maximumScore(nums: Array[Int], k: Int): Int = {\n        \n    }\n}"
    },
    {
        "id": 1917,
        "name": "maximum-average-pass-ratio",
        "difficulty": "Medium",
        "link": "https://leetcode.com/problems/maximum-average-pass-ratio/",
        "task_description": "There is a school that has classes of students and each class will be having a final exam. You are given a 2D integer array `classes`, where `classes[i] = [passi, totali]`. You know beforehand that in the `ith` class, there are `totali` total students, but only `passi` number of students will pass the exam. You are also given an integer `extraStudents`. There are another `extraStudents` brilliant students that are **guaranteed** to pass the exam of any class they are assigned to. You want to assign each of the `extraStudents` students to a class in a way that **maximizes** the **average** pass ratio across **all** the classes. The **pass ratio** of a class is equal to the number of students of the class that will pass the exam divided by the total number of students of the class. The **average pass ratio** is the sum of pass ratios of all the classes divided by the number of the classes. Return _the **maximum** possible average pass ratio after assigning the _`extraStudents`_ students. _Answers within `10-5` of the actual answer will be accepted. **Example 1:** ``` **Input:** classes = [[1,2],[3,5],[2,2]], `extraStudents` = 2 **Output:** 0.78333 **Explanation:** You can assign the two extra students to the first class. The average pass ratio will be equal to (3/4 + 3/5 + 2/2) / 3 = 0.78333. ``` **Example 2:** ``` **Input:** classes = [[2,4],[3,9],[4,5],[2,10]], `extraStudents` = 4 **Output:** 0.53485 ``` **Constraints:** `1 <= classes.length <= 105` `classes[i].length == 2` `1 <= passi <= totali <= 105` `1 <= extraStudents <= 105`",
        "test_case": [
            {
                "label": "Example 1",
                "input": "classes = [[1,2],[3,5],[2,2]], extraStudents = 2",
                "output": "0.78333 Explanation: You can assign the two extra students to the first class. The average pass ratio will be equal to (3/4 + 3/5 + 2/2) / 3 = 0.78333."
            },
            {
                "label": "Example 2",
                "input": "classes = [[2,4],[3,9],[4,5],[2,10]], extraStudents = 4",
                "output": "0.53485"
            }
        ],
        "elixir_template": "defmodule Solution do\n  @spec max_average_ratio(classes :: [[integer]], extra_students :: integer) :: float\n  def max_average_ratio(classes, extra_students) do\n    \n  end\nend",
        "erlang_template": "-spec max_average_ratio(Classes :: [[integer()]], ExtraStudents :: integer()) -> float().\nmax_average_ratio(Classes, ExtraStudents) ->\n  .",
        "scala_template": "object Solution {\n    def maxAverageRatio(classes: Array[Array[Int]], extraStudents: Int): Double = {\n        \n    }\n}"
    },
    {
        "id": 1916,
        "name": "find-center-of-star-graph",
        "difficulty": "Easy",
        "link": "https://leetcode.com/problems/find-center-of-star-graph/",
        "task_description": "There is an undirected **star** graph consisting of `n` nodes labeled from `1` to `n`. A star graph is a graph where there is one **center** node and **exactly** `n - 1` edges that connect the center node with every other node. You are given a 2D integer array `edges` where each `edges[i] = [ui, vi]` indicates that there is an edge between the nodes `ui` and `vi`. Return the center of the given star graph. **Example 1:** ``` **Input:** edges = [[1,2],[2,3],[4,2]] **Output:** 2 **Explanation:** As shown in the figure above, node 2 is connected to every other node, so 2 is the center. ``` **Example 2:** ``` **Input:** edges = [[1,2],[5,1],[1,3],[1,4]] **Output:** 1 ``` **Constraints:** `3 <= n <= 105` `edges.length == n - 1` `edges[i].length == 2` `1 <= ui, vi <= n` `ui != vi` The given `edges` represent a valid star graph.",
        "test_case": [
            {
                "label": "Example 1",
                "input": "edges = [[1,2],[2,3],[4,2]]",
                "output": "2 Explanation: As shown in the figure above, node 2 is connected to every other node, so 2 is the center."
            },
            {
                "label": "Example 2",
                "input": "edges = [[1,2],[5,1],[1,3],[1,4]]",
                "output": "1"
            }
        ],
        "elixir_template": "defmodule Solution do\n  @spec find_center(edges :: [[integer]]) :: integer\n  def find_center(edges) do\n    \n  end\nend",
        "erlang_template": "-spec find_center(Edges :: [[integer()]]) -> integer().\nfind_center(Edges) ->\n  .",
        "scala_template": "object Solution {\n    def findCenter(edges: Array[Array[Int]]): Int = {\n        \n    }\n}"
    },
    {
        "id": 1915,
        "name": "check-if-one-string-swap-can-make-strings-equal",
        "difficulty": "Easy",
        "link": "https://leetcode.com/problems/check-if-one-string-swap-can-make-strings-equal/",
        "task_description": "You are given two strings `s1` and `s2` of equal length. A **string swap** is an operation where you choose two indices in a string (not necessarily different) and swap the characters at these indices. Return `true` _if it is possible to make both strings equal by performing **at most one string swap **on **exactly one** of the strings. _Otherwise, return `false`. **Example 1:** ``` **Input:** s1 = \"bank\", s2 = \"kanb\" **Output:** true **Explanation:** For example, swap the first character with the last character of s2 to make \"bank\". ``` **Example 2:** ``` **Input:** s1 = \"attack\", s2 = \"defend\" **Output:** false **Explanation:** It is impossible to make them equal with one string swap. ``` **Example 3:** ``` **Input:** s1 = \"kelb\", s2 = \"kelb\" **Output:** true **Explanation:** The two strings are already equal, so no string swap operation is required. ``` **Constraints:** `1 <= s1.length, s2.length <= 100` `s1.length == s2.length` `s1` and `s2` consist of only lowercase English letters.",
        "test_case": [
            {
                "label": "Example 1",
                "input": "s1 = \"bank\", s2 = \"kanb\"",
                "output": "true Explanation: For example, swap the first character with the last character of s2 to make \"bank\"."
            },
            {
                "label": "Example 2",
                "input": "s1 = \"attack\", s2 = \"defend\"",
                "output": "false Explanation: It is impossible to make them equal with one string swap."
            },
            {
                "label": "Example 3",
                "input": "s1 = \"kelb\", s2 = \"kelb\"",
                "output": "true Explanation: The two strings are already equal, so no string swap operation is required."
            }
        ],
        "elixir_template": "defmodule Solution do\n  @spec are_almost_equal(s1 :: String.t, s2 :: String.t) :: boolean\n  def are_almost_equal(s1, s2) do\n    \n  end\nend",
        "erlang_template": "-spec are_almost_equal(S1 :: unicode:unicode_binary(), S2 :: unicode:unicode_binary()) -> boolean().\nare_almost_equal(S1, S2) ->\n  .",
        "scala_template": "object Solution {\n    def areAlmostEqual(s1: String, s2: String): Boolean = {\n        \n    }\n}"
    },
    {
        "id": 1913,
        "name": "make-the-xor-of-all-segments-equal-to-zero",
        "difficulty": "Hard",
        "link": "https://leetcode.com/problems/make-the-xor-of-all-segments-equal-to-zero/",
        "task_description": "You are given an array `nums`\u200b\u200b\u200b and an integer `k`\u200b\u200b\u200b\u200b\u200b. The XOR of a segment `[left, right]` where `left <= right` is the `XOR` of all the elements with indices between `left` and `right`, inclusive: `nums[left] XOR nums[left+1] XOR ... XOR nums[right]`. Return _the minimum number of elements to change in the array _such that the `XOR` of all segments of size `k`\u200b\u200b\u200b\u200b\u200b\u200b is equal to zero. **Example 1:** ``` **Input:** nums = [1,2,0,3,0], k = 1 **Output:** 3 **Explanation: **Modify the array from [**1**,**2**,0,**3**,0] to from [**0**,**0**,0,**0**,0]. ``` **Example 2:** ``` **Input:** nums = [3,4,5,2,1,7,3,4,7], k = 3 **Output:** 3 **Explanation: **Modify the array from [3,4,**5**,**2**,**1**,7,3,4,7] to [3,4,**7**,**3**,**4**,7,3,4,7]. ``` **Example 3:** ``` **Input:** nums = [1,2,4,1,2,5,1,2,6], k = 3 **Output:** 3 **Explanation: **Modify the array from [1,2,**4,**1,2,**5**,1,2,**6**] to [1,2,**3**,1,2,**3**,1,2,**3**]. ``` **Constraints:** `1 <= k <= nums.length <= 2000` `\u200b\u200b\u200b\u200b\u200b\u200b0 <= nums[i] < 210`",
        "test_case": [
            {
                "label": "Example 1",
                "input": "nums = [1,2,0,3,0], k = 1",
                "output": "3 Explanation: Modify the array from [ 1 , 2 ,0, 3 ,0] to from [ 0 , 0 ,0, 0 ,0]."
            },
            {
                "label": "Example 2",
                "input": "nums = [3,4,5,2,1,7,3,4,7], k = 3",
                "output": "3 Explanation: Modify the array from [3,4, 5 , 2 , 1 ,7,3,4,7] to [3,4, 7 , 3 , 4 ,7,3,4,7]."
            },
            {
                "label": "Example 3",
                "input": "nums = [1,2,4,1,2,5,1,2,6], k = 3",
                "output": "3 Explanation: Modify the array from [1,2, 4, 1,2, 5 ,1,2, 6 ] to [1,2, 3 ,1,2, 3 ,1,2, 3 ]."
            }
        ],
        "elixir_template": "defmodule Solution do\n  @spec min_changes(nums :: [integer], k :: integer) :: integer\n  def min_changes(nums, k) do\n    \n  end\nend",
        "erlang_template": "-spec min_changes(Nums :: [integer()], K :: integer()) -> integer().\nmin_changes(Nums, K) ->\n  .",
        "scala_template": "object Solution {\n    def minChanges(nums: Array[Int], k: Int): Int = {\n        \n    }\n}"
    },
    {
        "id": 1912,
        "name": "number-of-restricted-paths-from-first-to-last-node",
        "difficulty": "Medium",
        "link": "https://leetcode.com/problems/number-of-restricted-paths-from-first-to-last-node/",
        "task_description": "There is an undirected weighted connected graph. You are given a positive integer `n` which denotes that the graph has `n` nodes labeled from `1` to `n`, and an array `edges` where each `edges[i] = [ui, vi, weighti]` denotes that there is an edge between nodes `ui` and `vi` with weight equal to `weighti`. A path from node `start` to node `end` is a sequence of nodes `[z0, z1, z2, ..., zk]` such that `z0 = start` and `zk = end` and there is an edge between `zi` and `zi+1` where `0 <= i <= k-1`. The distance of a path is the sum of the weights on the edges of the path. Let `distanceToLastNode(x)` denote the shortest distance of a path between node `n` and node `x`. A **restricted path** is a path that also satisfies that `distanceToLastNode(zi) > distanceToLastNode(zi+1)` where `0 <= i <= k-1`. Return _the number of restricted paths from node_ `1` _to node_ `n`. Since that number may be too large, return it **modulo** `109 + 7`. **Example 1:** ``` **Input:** n = 5, edges = [[1,2,3],[1,3,3],[2,3,1],[1,4,2],[5,2,2],[3,5,1],[5,4,10]] **Output:** 3 **Explanation:** Each circle contains the node number in black and its `distanceToLastNode value in blue. `The three restricted paths are: 1) 1 --> 2 --> 5 2) 1 --> 2 --> 3 --> 5 3) 1 --> 3 --> 5 ``` **Example 2:** ``` **Input:** n = 7, edges = [[1,3,1],[4,1,2],[7,3,4],[2,5,3],[5,6,1],[6,7,2],[7,5,3],[2,6,4]] **Output:** 1 **Explanation:** Each circle contains the node number in black and its `distanceToLastNode value in blue. `The only restricted path is 1 --> 3 --> 7. ``` **Constraints:** `1 <= n <= 2 * 104` `n - 1 <= edges.length <= 4 * 104` `edges[i].length == 3` `1 <= ui, vi <= n` `ui != vi` `1 <= weighti <= 105` There is at most one edge between any two nodes. There is at least one path between any two nodes.",
        "test_case": [
            {
                "label": "Example 1",
                "input": "n = 5, edges = [[1,2,3],[1,3,3],[2,3,1],[1,4,2],[5,2,2],[3,5,1],[5,4,10]]",
                "output": "3 Explanation: Each circle contains the node number in black and its distanceToLastNode value in blue. The three restricted paths are:\n1) 1 --> 2 --> 5\n2) 1 --> 2 --> 3 --> 5\n3) 1 --> 3 --> 5"
            },
            {
                "label": "Example 2",
                "input": "n = 7, edges = [[1,3,1],[4,1,2],[7,3,4],[2,5,3],[5,6,1],[6,7,2],[7,5,3],[2,6,4]]",
                "output": "1 Explanation: Each circle contains the node number in black and its distanceToLastNode value in blue. The only restricted path is 1 --> 3 --> 7."
            }
        ],
        "elixir_template": "defmodule Solution do\n  @spec count_restricted_paths(n :: integer, edges :: [[integer]]) :: integer\n  def count_restricted_paths(n, edges) do\n    \n  end\nend",
        "erlang_template": "-spec count_restricted_paths(N :: integer(), Edges :: [[integer()]]) -> integer().\ncount_restricted_paths(N, Edges) ->\n  .",
        "scala_template": "object Solution {\n    def countRestrictedPaths(n: Int, edges: Array[Array[Int]]): Int = {\n        \n    }\n}"
    },
    {
        "id": 1911,
        "name": "minimum-elements-to-add-to-form-a-given-sum",
        "difficulty": "Medium",
        "link": "https://leetcode.com/problems/minimum-elements-to-add-to-form-a-given-sum/",
        "task_description": "You are given an integer array `nums` and two integers `limit` and `goal`. The array `nums` has an interesting property that `abs(nums[i]) <= limit`. Return _the minimum number of elements you need to add to make the sum of the array equal to _`goal`. The array must maintain its property that `abs(nums[i]) <= limit`. Note that `abs(x)` equals `x` if `x >= 0`, and `-x` otherwise. **Example 1:** ``` **Input:** nums = [1,-1,1], limit = 3, goal = -4 **Output:** 2 **Explanation:** You can add -2 and -3, then the sum of the array will be 1 - 1 + 1 - 2 - 3 = -4. ``` **Example 2:** ``` **Input:** nums = [1,-10,9,1], limit = 100, goal = 0 **Output:** 1 ``` **Constraints:** `1 <= nums.length <= 105` `1 <= limit <= 106` `-limit <= nums[i] <= limit` `-109 <= goal <= 109`",
        "test_case": [
            {
                "label": "Example 1",
                "input": "nums = [1,-1,1], limit = 3, goal = -4",
                "output": "2 Explanation: You can add -2 and -3, then the sum of the array will be 1 - 1 + 1 - 2 - 3 = -4."
            },
            {
                "label": "Example 2",
                "input": "nums = [1,-10,9,1], limit = 100, goal = 0",
                "output": "1"
            }
        ],
        "elixir_template": "defmodule Solution do\n  @spec min_elements(nums :: [integer], limit :: integer, goal :: integer) :: integer\n  def min_elements(nums, limit, goal) do\n    \n  end\nend",
        "erlang_template": "-spec min_elements(Nums :: [integer()], Limit :: integer(), Goal :: integer()) -> integer().\nmin_elements(Nums, Limit, Goal) ->\n  .",
        "scala_template": "object Solution {\n    def minElements(nums: Array[Int], limit: Int, goal: Int): Int = {\n        \n    }\n}"
    },
    {
        "id": 1910,
        "name": "check-if-binary-string-has-at-most-one-segment-of-ones",
        "difficulty": "Easy",
        "link": "https://leetcode.com/problems/check-if-binary-string-has-at-most-one-segment-of-ones/",
        "task_description": "Given a binary string `s` **\u200b\u200b\u200b\u200b\u200bwithout leading zeros**, return `true`\u200b\u200b\u200b _if _`s`_ contains **at most one contiguous segment of ones**_. Otherwise, return `false`. **Example 1:** ``` **Input:** s = \"1001\" **Output:** false **Explanation: **The ones do not form a contiguous segment. ``` **Example 2:** ``` **Input:** s = \"110\" **Output:** true ``` **Constraints:** `1 <= s.length <= 100` `s[i]`\u200b\u200b\u200b\u200b is either `'0'` or `'1'`. `s[0]` is `'1'`.",
        "test_case": [
            {
                "label": "Example 1",
                "input": "s = \"1001\"",
                "output": "false Explanation: The ones do not form a contiguous segment."
            },
            {
                "label": "Example 2",
                "input": "s = \"110\"",
                "output": "true"
            }
        ],
        "elixir_template": "defmodule Solution do\n  @spec check_ones_segment(s :: String.t) :: boolean\n  def check_ones_segment(s) do\n    \n  end\nend",
        "erlang_template": "-spec check_ones_segment(S :: unicode:unicode_binary()) -> boolean().\ncheck_ones_segment(S) ->\n  .",
        "scala_template": "object Solution {\n    def checkOnesSegment(s: String): Boolean = {\n        \n    }\n}"
    },
    {
        "id": 1907,
        "name": "count-pairs-with-xor-in-a-range",
        "difficulty": "Hard",
        "link": "https://leetcode.com/problems/count-pairs-with-xor-in-a-range/",
        "task_description": "Given a **(0-indexed)** integer array `nums` and two integers `low` and `high`, return _the number of **nice pairs**_. A **nice pair** is a pair `(i, j)` where `0 <= i < j < nums.length` and `low <= (nums[i] XOR nums[j]) <= high`. **Example 1:** ``` **Input:** nums = [1,4,2,7], low = 2, high = 6 **Output:** 6 **Explanation:** All nice pairs (i, j) are as follows: - (0, 1): nums[0] XOR nums[1] = 5 - (0, 2): nums[0] XOR nums[2] = 3 - (0, 3): nums[0] XOR nums[3] = 6 - (1, 2): nums[1] XOR nums[2] = 6 - (1, 3): nums[1] XOR nums[3] = 3 - (2, 3): nums[2] XOR nums[3] = 5 ``` **Example 2:** ``` **Input:** nums = [9,8,4,2,1], low = 5, high = 14 **Output:** 8 **Explanation:** All nice pairs (i, j) are as follows: \u200b\u200b\u200b\u200b\u200b - (0, 2): nums[0] XOR nums[2] = 13 - (0, 3): nums[0] XOR nums[3] = 11 - (0, 4): nums[0] XOR nums[4] = 8 - (1, 2): nums[1] XOR nums[2] = 12 - (1, 3): nums[1] XOR nums[3] = 10 - (1, 4): nums[1] XOR nums[4] = 9 - (2, 3): nums[2] XOR nums[3] = 6 - (2, 4): nums[2] XOR nums[4] = 5 ``` **Constraints:** `1 <= nums.length <= 2 * 104` `1 <= nums[i] <= 2 * 104` `1 <= low <= high <= 2 * 104`",
        "test_case": [
            {
                "label": "Example 1",
                "input": "nums = [1,4,2,7], low = 2, high = 6",
                "output": "6 Explanation: All nice pairs (i, j) are as follows:\r\n    - (0, 1): nums[0] XOR nums[1] = 5 \r\n    - (0, 2): nums[0] XOR nums[2] = 3\r\n    - (0, 3): nums[0] XOR nums[3] = 6\r\n    - (1, 2): nums[1] XOR nums[2] = 6\r\n    - (1, 3): nums[1] XOR nums[3] = 3\r\n    - (2, 3): nums[2] XOR nums[3] = 5"
            },
            {
                "label": "Example 2",
                "input": "nums = [9,8,4,2,1], low = 5, high = 14",
                "output": "8 Explanation: All nice pairs (i, j) are as follows:\r\n\u200b\u200b\u200b\u200b\u200b    - (0, 2): nums[0] XOR nums[2] = 13\r\n\u00a0   - (0, 3): nums[0] XOR nums[3] = 11\r\n\u00a0   - (0, 4): nums[0] XOR nums[4] = 8\r\n\u00a0   - (1, 2): nums[1] XOR nums[2] = 12\r\n\u00a0   - (1, 3): nums[1] XOR nums[3] = 10\r\n\u00a0   - (1, 4): nums[1] XOR nums[4] = 9\r\n\u00a0   - (2, 3): nums[2] XOR nums[3] = 6\r\n\u00a0   - (2, 4): nums[2] XOR nums[4] = 5"
            }
        ],
        "elixir_template": "Elixir code template not available for this problem.",
        "erlang_template": "Elixir code template not available for this problem.",
        "scala_template": "object Solution {\n    def countPairs(nums: Array[Int], low: Int, high: Int): Int = {\n        \n    }\n}"
    },
    {
        "id": 1906,
        "name": "maximize-score-after-n-operations",
        "difficulty": "Hard",
        "link": "https://leetcode.com/problems/maximize-score-after-n-operations/",
        "task_description": "You are given `nums`, an array of positive integers of size `2 * n`. You must perform `n` operations on this array. In the `ith` operation **(1-indexed)**, you will: Choose two elements, `x` and `y`. Receive a score of `i * gcd(x, y)`. Remove `x` and `y` from `nums`. Return _the maximum score you can receive after performing _`n`_ operations._ The function `gcd(x, y)` is the greatest common divisor of `x` and `y`. **Example 1:** ``` **Input:** nums = [1,2] **Output:** 1 **Explanation:** The optimal choice of operations is: (1 * gcd(1, 2)) = 1 ``` **Example 2:** ``` **Input:** nums = [3,4,6,8] **Output:** 11 **Explanation:** The optimal choice of operations is: (1 * gcd(3, 6)) + (2 * gcd(4, 8)) = 3 + 8 = 11 ``` **Example 3:** ``` **Input:** nums = [1,2,3,4,5,6] **Output:** 14 **Explanation:** The optimal choice of operations is: (1 * gcd(1, 5)) + (2 * gcd(2, 4)) + (3 * gcd(3, 6)) = 1 + 4 + 9 = 14 ``` **Constraints:** `1 <= n <= 7` `nums.length == 2 * n` `1 <= nums[i] <= 106`",
        "test_case": [
            {
                "label": "Example 1",
                "input": "nums = [1,2]",
                "output": "1 Explanation: The optimal choice of operations is:\n(1 * gcd(1, 2)) = 1"
            },
            {
                "label": "Example 2",
                "input": "nums = [3,4,6,8]",
                "output": "11 Explanation: The optimal choice of operations is:\n(1 * gcd(3, 6)) + (2 * gcd(4, 8)) = 3 + 8 = 11"
            },
            {
                "label": "Example 3",
                "input": "nums = [1,2,3,4,5,6]",
                "output": "14 Explanation: The optimal choice of operations is:\n(1 * gcd(1, 5)) + (2 * gcd(2, 4)) + (3 * gcd(3, 6)) = 1 + 4 + 9 = 14"
            }
        ],
        "elixir_template": "defmodule Solution do\n  @spec max_score(nums :: [integer]) :: integer\n  def max_score(nums) do\n    \n  end\nend",
        "erlang_template": "-spec max_score(Nums :: [integer()]) -> integer().\nmax_score(Nums) ->\n  .",
        "scala_template": "object Solution {\n    def maxScore(nums: Array[Int]): Int = {\n        \n    }\n}"
    },
    {
        "id": 1905,
        "name": "design-authentication-manager",
        "difficulty": "Medium",
        "link": "https://leetcode.com/problems/design-authentication-manager/",
        "task_description": "There is an authentication system that works with authentication tokens. For each session, the user will receive a new authentication token that will expire `timeToLive` seconds after the `currentTime`. If the token is renewed, the expiry time will be extended to expire `timeToLive` seconds after the (potentially different) `currentTime`. Implement the `AuthenticationManager` class: `AuthenticationManager(int timeToLive)` constructs the `AuthenticationManager` and sets the `timeToLive`. `generate(string tokenId, int currentTime)` generates a new token with the given `tokenId` at the given `currentTime` in seconds. `renew(string tokenId, int currentTime)` renews the **unexpired** token with the given `tokenId` at the given `currentTime` in seconds. If there are no unexpired tokens with the given `tokenId`, the request is ignored, and nothing happens. `countUnexpiredTokens(int currentTime)` returns the number of **unexpired** tokens at the given currentTime. Note that if a token expires at time `t`, and another action happens on time `t` (`renew` or `countUnexpiredTokens`), the expiration takes place **before** the other actions. **Example 1:** ``` **Input** [\"AuthenticationManager\", \"`renew`\", \"generate\", \"`countUnexpiredTokens`\", \"generate\", \"`renew`\", \"`renew`\", \"`countUnexpiredTokens`\"] [[5], [\"aaa\", 1], [\"aaa\", 2], [6], [\"bbb\", 7], [\"aaa\", 8], [\"bbb\", 10], [15]] **Output** [null, null, null, 1, null, null, null, 0] **Explanation** AuthenticationManager authenticationManager = new AuthenticationManager(5); // Constructs the AuthenticationManager with `timeToLive` = 5 seconds. authenticationManager.`renew`(\"aaa\", 1); // No token exists with tokenId \"aaa\" at time 1, so nothing happens. authenticationManager.generate(\"aaa\", 2); // Generates a new token with tokenId \"aaa\" at time 2. authenticationManager.`countUnexpiredTokens`(6); // The token with tokenId \"aaa\" is the only unexpired one at time 6, so return 1. authenticationManager.generate(\"bbb\", 7); // Generates a new token with tokenId \"bbb\" at time 7. authenticationManager.`renew`(\"aaa\", 8); // The token with tokenId \"aaa\" expired at time 7, and 8 >= 7, so at time 8 the `renew` request is ignored, and nothing happens. authenticationManager.`renew`(\"bbb\", 10); // The token with tokenId \"bbb\" is unexpired at time 10, so the `renew` request is fulfilled and now the token will expire at time 15. authenticationManager.`countUnexpiredTokens`(15); // The token with tokenId \"bbb\" expires at time 15, and the token with tokenId \"aaa\" expired at time 7, so currently no token is unexpired, so return 0. ``` **Constraints:** `1 <= timeToLive <= 108` `1 <= currentTime <= 108` `1 <= tokenId.length <= 5` `tokenId` consists only of lowercase letters. All calls to `generate` will contain unique values of `tokenId`. The values of `currentTime` across all the function calls will be **strictly increasing**. At most `2000` calls will be made to all functions combined.",
        "test_case": [],
        "elixir_template": "defmodule AuthenticationManager do\n  @spec init_(time_to_live :: integer) :: any\n  def init_(time_to_live) do\n    \n  end\n\n  @spec generate(token_id :: String.t, current_time :: integer) :: any\n  def generate(token_id, current_time) do\n    \n  end\n\n  @spec renew(token_id :: String.t, current_time :: integer) :: any\n  def renew(token_id, current_time) do\n    \n  end\n\n  @spec count_unexpired_tokens(current_time :: integer) :: integer\n  def count_unexpired_tokens(current_time) do\n    \n  end\nend\n\n# Your functions will be called as such:\n# AuthenticationManager.init_(time_to_live)\n# AuthenticationManager.generate(token_id, current_time)\n# AuthenticationManager.renew(token_id, current_time)\n# param_3 = AuthenticationManager.count_unexpired_tokens(current_time)\n\n# AuthenticationManager.init_ will be called before every test case, in which you can do some necessary initializations.",
        "erlang_template": "-spec authentication_manager_init_(TimeToLive :: integer()) -> any().\nauthentication_manager_init_(TimeToLive) ->\n  .\n\n-spec authentication_manager_generate(TokenId :: unicode:unicode_binary(), CurrentTime :: integer()) -> any().\nauthentication_manager_generate(TokenId, CurrentTime) ->\n  .\n\n-spec authentication_manager_renew(TokenId :: unicode:unicode_binary(), CurrentTime :: integer()) -> any().\nauthentication_manager_renew(TokenId, CurrentTime) ->\n  .\n\n-spec authentication_manager_count_unexpired_tokens(CurrentTime :: integer()) -> integer().\nauthentication_manager_count_unexpired_tokens(CurrentTime) ->\n  .\n\n\n%% Your functions will be called as such:\n%% authentication_manager_init_(TimeToLive),\n%% authentication_manager_generate(TokenId, CurrentTime),\n%% authentication_manager_renew(TokenId, CurrentTime),\n%% Param_3 = authentication_manager_count_unexpired_tokens(CurrentTime),\n\n%% authentication_manager_init_ will be called before every test case, in which you can do some necessary initializations.",
        "scala_template": "class AuthenticationManager(_timeToLive: Int) {\n\n    def generate(tokenId: String, currentTime: Int): Unit = {\n        \n    }\n\n    def renew(tokenId: String, currentTime: Int): Unit = {\n        \n    }\n\n    def countUnexpiredTokens(currentTime: Int): Int = {\n        \n    }\n\n}\n\n/**\n * Your AuthenticationManager object will be instantiated and called as such:\n * val obj = new AuthenticationManager(timeToLive)\n * obj.generate(tokenId,currentTime)\n * obj.renew(tokenId,currentTime)\n * val param_3 = obj.countUnexpiredTokens(currentTime)\n */"
    },
    {
        "id": 1904,
        "name": "second-largest-digit-in-a-string",
        "difficulty": "Easy",
        "link": "https://leetcode.com/problems/second-largest-digit-in-a-string/",
        "task_description": "Given an alphanumeric string `s`, return _the **second largest** numerical digit that appears in _`s`_, or _`-1`_ if it does not exist_. An **alphanumeric**** **string is a string consisting of lowercase English letters and digits. **Example 1:** ``` **Input:** s = \"dfa12321afd\" **Output:** 2 **Explanation:** The digits that appear in s are [1, 2, 3]. The second largest digit is 2. ``` **Example 2:** ``` **Input:** s = \"abc1111\" **Output:** -1 **Explanation:** The digits that appear in s are [1]. There is no second largest digit. ``` **Constraints:** `1 <= s.length <= 500` `s` consists of only lowercase English letters and digits.",
        "test_case": [
            {
                "label": "Example 1",
                "input": "s = \"dfa12321afd\"",
                "output": "2 Explanation: The digits that appear in s are [1, 2, 3]. The second largest digit is 2."
            },
            {
                "label": "Example 2",
                "input": "s = \"abc1111\"",
                "output": "-1 Explanation: The digits that appear in s are [1]. There is no second largest digit."
            }
        ],
        "elixir_template": "defmodule Solution do\n  @spec second_highest(s :: String.t) :: integer\n  def second_highest(s) do\n    \n  end\nend",
        "erlang_template": "-spec second_highest(S :: unicode:unicode_binary()) -> integer().\nsecond_highest(S) ->\n  .",
        "scala_template": "object Solution {\n    def secondHighest(s: String): Int = {\n        \n    }\n}"
    },
    {
        "id": 1902,
        "name": "car-fleet-ii",
        "difficulty": "Hard",
        "link": "https://leetcode.com/problems/car-fleet-ii/",
        "task_description": "There are `n` cars traveling at different speeds in the same direction along a one-lane road. You are given an array `cars` of length `n`, where `cars[i] = [positioni, speedi]` represents: `positioni` is the distance between the `ith` car and the beginning of the road in meters. It is guaranteed that `positioni < positioni+1`. `speedi` is the initial speed of the `ith` car in meters per second. For simplicity, cars can be considered as points moving along the number line. Two cars collide when they occupy the same position. Once a car collides with another car, they unite and form a single car fleet. The cars in the formed fleet will have the same position and the same speed, which is the initial speed of the **slowest** car in the fleet. Return an array `answer`, where `answer[i]` is the time, in seconds, at which the `ith` car collides with the next car, or `-1` if the car does not collide with the next car. Answers within `10-5` of the actual answers are accepted. **Example 1:** ``` **Input:** cars = [[1,2],[2,1],[4,3],[7,2]] **Output:** [1.00000,-1.00000,3.00000,-1.00000] **Explanation:** After exactly one second, the first car will collide with the second car, and form a car fleet with speed 1 m/s. After exactly 3 seconds, the third car will collide with the fourth car, and form a car fleet with speed 2 m/s. ``` **Example 2:** ``` **Input:** cars = [[3,4],[5,4],[6,3],[9,1]] **Output:** [2.00000,1.00000,1.50000,-1.00000] ``` **Constraints:** `1 <= cars.length <= 105` `1 <= positioni, speedi <= 106` `positioni < positioni+1`",
        "test_case": [
            {
                "label": "Example 1",
                "input": "cars = [[1,2],[2,1],[4,3],[7,2]]",
                "output": "[1.00000,-1.00000,3.00000,-1.00000] Explanation: After exactly one second, the first car will collide with the second car, and form a car fleet with speed 1 m/s. After exactly 3 seconds, the third car will collide with the fourth car, and form a car fleet with speed 2 m/s."
            },
            {
                "label": "Example 2",
                "input": "cars = [[3,4],[5,4],[6,3],[9,1]]",
                "output": "[2.00000,1.00000,1.50000,-1.00000]"
            }
        ],
        "elixir_template": "defmodule Solution do\n  @spec get_collision_times(cars :: [[integer]]) :: [float]\n  def get_collision_times(cars) do\n    \n  end\nend",
        "erlang_template": "-spec get_collision_times(Cars :: [[integer()]]) -> [float()].\nget_collision_times(Cars) ->\n  .",
        "scala_template": "object Solution {\n    def getCollisionTimes(cars: Array[Array[Int]]): Array[Double] = {\n        \n    }\n}"
    },
    {
        "id": 1901,
        "name": "equal-sum-arrays-with-minimum-number-of-operations",
        "difficulty": "Medium",
        "link": "https://leetcode.com/problems/equal-sum-arrays-with-minimum-number-of-operations/",
        "task_description": "You are given two arrays of integers `nums1` and `nums2`, possibly of different lengths. The values in the arrays are between `1` and `6`, inclusive. In one operation, you can change any integer's value in **any **of the arrays to **any** value between `1` and `6`, inclusive. Return _the minimum number of operations required to make the sum of values in _`nums1`_ equal to the sum of values in _`nums2`_._ Return `-1`\u200b\u200b\u200b\u200b\u200b if it is not possible to make the sum of the two arrays equal. **Example 1:** ``` **Input:** nums1 = [1,2,3,4,5,6], nums2 = [1,1,2,2,2,2] **Output:** 3 **Explanation:** You can make the sums of nums1 and nums2 equal with 3 operations. All indices are 0-indexed. - Change nums2[0] to 6. nums1 = [1,2,3,4,5,6], nums2 = [**6**,1,2,2,2,2]. - Change nums1[5] to 1. nums1 = [1,2,3,4,5,**1**], nums2 = [6,1,2,2,2,2]. - Change nums1[2] to 2. nums1 = [1,2,**2**,4,5,1], nums2 = [6,1,2,2,2,2]. ``` **Example 2:** ``` **Input:** nums1 = [1,1,1,1,1,1,1], nums2 = [6] **Output:** -1 **Explanation:** There is no way to decrease the sum of nums1 or to increase the sum of nums2 to make them equal. ``` **Example 3:** ``` **Input:** nums1 = [6,6], nums2 = [1] **Output:** 3 **Explanation:** You can make the sums of nums1 and nums2 equal with 3 operations. All indices are 0-indexed. - Change nums1[0] to 2. nums1 = [**2**,6], nums2 = [1]. - Change nums1[1] to 2. nums1 = [2,**2**], nums2 = [1]. - Change nums2[0] to 4. nums1 = [2,2], nums2 = [**4**]. ``` **Constraints:** `1 <= nums1.length, nums2.length <= 105` `1 <= nums1[i], nums2[i] <= 6`",
        "test_case": [
            {
                "label": "Example 1",
                "input": "nums1 = [1,2,3,4,5,6], nums2 = [1,1,2,2,2,2]",
                "output": "3 Explanation: You can make the sums of nums1 and nums2 equal with 3 operations. All indices are 0-indexed.\n- Change nums2[0] to 6. nums1 = [1,2,3,4,5,6], nums2 = [ 6 ,1,2,2,2,2].\n- Change nums1[5] to 1. nums1 = [1,2,3,4,5, 1 ], nums2 = [6,1,2,2,2,2].\n- Change nums1[2] to 2. nums1 = [1,2, 2 ,4,5,1], nums2 = [6,1,2,2,2,2]."
            },
            {
                "label": "Example 2",
                "input": "nums1 = [1,1,1,1,1,1,1], nums2 = [6]",
                "output": "-1 Explanation: There is no way to decrease the sum of nums1 or to increase the sum of nums2 to make them equal."
            },
            {
                "label": "Example 3",
                "input": "nums1 = [6,6], nums2 = [1]",
                "output": "3 Explanation: You can make the sums of nums1 and nums2 equal with 3 operations. All indices are 0-indexed. \n- Change nums1[0] to 2. nums1 = [ 2 ,6], nums2 = [1].\n- Change nums1[1] to 2. nums1 = [2, 2 ], nums2 = [1].\n- Change nums2[0] to 4. nums1 = [2,2], nums2 = [ 4 ]."
            }
        ],
        "elixir_template": "defmodule Solution do\n  @spec min_operations(nums1 :: [integer], nums2 :: [integer]) :: integer\n  def min_operations(nums1, nums2) do\n    \n  end\nend",
        "erlang_template": "-spec min_operations(Nums1 :: [integer()], Nums2 :: [integer()]) -> integer().\nmin_operations(Nums1, Nums2) ->\n  .",
        "scala_template": "object Solution {\n    def minOperations(nums1: Array[Int], nums2: Array[Int]): Int = {\n        \n    }\n}"
    },
    {
        "id": 1900,
        "name": "closest-dessert-cost",
        "difficulty": "Medium",
        "link": "https://leetcode.com/problems/closest-dessert-cost/",
        "task_description": "You would like to make dessert and are preparing to buy the ingredients. You have `n` ice cream base flavors and `m` types of toppings to choose from. You must follow these rules when making your dessert: There must be **exactly one** ice cream base. You can add **one or more** types of topping or have no toppings at all. There are **at most two** of **each type** of topping. You are given three inputs: `baseCosts`, an integer array of length `n`, where each `baseCosts[i]` represents the price of the `ith` ice cream base flavor. `toppingCosts`, an integer array of length `m`, where each `toppingCosts[i]` is the price of **one** of the `ith` topping. `target`, an integer representing your target price for dessert. You want to make a dessert with a total cost as close to `target` as possible. Return _the closest possible cost of the dessert to _`target`. If there are multiple, return _the **lower** one._ **Example 1:** ``` **Input:** baseCosts = [1,7], toppingCosts = [3,4], target = 10 **Output:** 10 **Explanation:** Consider the following combination (all 0-indexed): - Choose base 1: cost 7 - Take 1 of topping 0: cost 1 x 3 = 3 - Take 0 of topping 1: cost 0 x 4 = 0 Total: 7 + 3 + 0 = 10. ``` **Example 2:** ``` **Input:** baseCosts = [2,3], toppingCosts = [4,5,100], target = 18 **Output:** 17 **Explanation:** Consider the following combination (all 0-indexed): - Choose base 1: cost 3 - Take 1 of topping 0: cost 1 x 4 = 4 - Take 2 of topping 1: cost 2 x 5 = 10 - Take 0 of topping 2: cost 0 x 100 = 0 Total: 3 + 4 + 10 + 0 = 17. You cannot make a dessert with a total cost of 18. ``` **Example 3:** ``` **Input:** baseCosts = [3,10], toppingCosts = [2,5], target = 9 **Output:** 8 **Explanation:** It is possible to make desserts with cost 8 and 10. Return 8 as it is the lower cost. ``` **Constraints:** `n == baseCosts.length` `m == toppingCosts.length` `1 <= n, m <= 10` `1 <= baseCosts[i], toppingCosts[i] <= 104` `1 <= target <= 104`",
        "test_case": [
            {
                "label": "Example 1",
                "input": "baseCosts = [1,7], toppingCosts = [3,4], target = 10",
                "output": "10 Explanation: Consider the following combination (all 0-indexed):\n- Choose base 1: cost 7\n- Take 1 of topping 0: cost 1 x 3 = 3\n- Take 0 of topping 1: cost 0 x 4 = 0\nTotal: 7 + 3 + 0 = 10."
            },
            {
                "label": "Example 2",
                "input": "baseCosts = [2,3], toppingCosts = [4,5,100], target = 18",
                "output": "17 Explanation: Consider the following combination (all 0-indexed):\n- Choose base 1: cost 3\n- Take 1 of topping 0: cost 1 x 4 = 4\n- Take 2 of topping 1: cost 2 x 5 = 10\n- Take 0 of topping 2: cost 0 x 100 = 0\nTotal: 3 + 4 + 10 + 0 = 17. You cannot make a dessert with a total cost of 18."
            },
            {
                "label": "Example 3",
                "input": "baseCosts = [3,10], toppingCosts = [2,5], target = 9",
                "output": "8 Explanation: It is possible to make desserts with cost 8 and 10. Return 8 as it is the lower cost. Constraints: n == baseCosts.length m == toppingCosts.length 1 <= n, m <= 10 1 <= baseCosts[i], toppingCosts[i] <= 10 4 1 <= target <= 10 4"
            }
        ],
        "elixir_template": "defmodule Solution do\n  @spec closest_cost(base_costs :: [integer], topping_costs :: [integer], target :: integer) :: integer\n  def closest_cost(base_costs, topping_costs, target) do\n    \n  end\nend",
        "erlang_template": "-spec closest_cost(BaseCosts :: [integer()], ToppingCosts :: [integer()], Target :: integer()) -> integer().\nclosest_cost(BaseCosts, ToppingCosts, Target) ->\n  .",
        "scala_template": "object Solution {\n    def closestCost(baseCosts: Array[Int], toppingCosts: Array[Int], target: Int): Int = {\n        \n    }\n}"
    },
    {
        "id": 1899,
        "name": "count-items-matching-a-rule",
        "difficulty": "Easy",
        "link": "https://leetcode.com/problems/count-items-matching-a-rule/",
        "task_description": "You are given an array `items`, where each `items[i] = [typei, colori, namei]` describes the type, color, and name of the `ith` item. You are also given a rule represented by two strings, `ruleKey` and `ruleValue`. The `ith` item is said to match the rule if **one** of the following is true: `ruleKey == \"type\"` and `ruleValue == typei`. `ruleKey == \"color\"` and `ruleValue == colori`. `ruleKey == \"name\"` and `ruleValue == namei`. Return _the number of items that match the given rule_. **Example 1:** ``` **Input:** items = [[\"phone\",\"blue\",\"pixel\"],[\"computer\",\"silver\",\"lenovo\"],[\"phone\",\"gold\",\"iphone\"]], ruleKey = \"color\", ruleValue = \"silver\" **Output:** 1 **Explanation:** There is only one item matching the given rule, which is [\"computer\",\"silver\",\"lenovo\"]. ``` **Example 2:** ``` **Input:** items = [[\"phone\",\"blue\",\"pixel\"],[\"computer\",\"silver\",\"phone\"],[\"phone\",\"gold\",\"iphone\"]], ruleKey = \"type\", ruleValue = \"phone\" **Output:** 2 **Explanation:** There are only two items matching the given rule, which are [\"phone\",\"blue\",\"pixel\"] and [\"phone\",\"gold\",\"iphone\"]. Note that the item [\"computer\",\"silver\",\"phone\"] does not match. ``` **Constraints:** `1 <= items.length <= 104` `1 <= typei.length, colori.length, namei.length, ruleValue.length <= 10` `ruleKey` is equal to either `\"type\"`, `\"color\"`, or `\"name\"`. All strings consist only of lowercase letters.",
        "test_case": [
            {
                "label": "Example 1",
                "input": "items = [[\"phone\",\"blue\",\"pixel\"],[\"computer\",\"silver\",\"lenovo\"],[\"phone\",\"gold\",\"iphone\"]], ruleKey = \"color\", ruleValue = \"silver\"",
                "output": "1 Explanation: There is only one item matching the given rule, which is [\"computer\",\"silver\",\"lenovo\"]."
            },
            {
                "label": "Example 2",
                "input": "items = [[\"phone\",\"blue\",\"pixel\"],[\"computer\",\"silver\",\"phone\"],[\"phone\",\"gold\",\"iphone\"]], ruleKey = \"type\", ruleValue = \"phone\"",
                "output": "2 Explanation: There are only two items matching the given rule, which are [\"phone\",\"blue\",\"pixel\"] and [\"phone\",\"gold\",\"iphone\"]. Note that the item [\"computer\",\"silver\",\"phone\"] does not match."
            }
        ],
        "elixir_template": "defmodule Solution do\n  @spec count_matches(items :: [[String.t]], rule_key :: String.t, rule_value :: String.t) :: integer\n  def count_matches(items, rule_key, rule_value) do\n    \n  end\nend",
        "erlang_template": "-spec count_matches(Items :: [[unicode:unicode_binary()]], RuleKey :: unicode:unicode_binary(), RuleValue :: unicode:unicode_binary()) -> integer().\ncount_matches(Items, RuleKey, RuleValue) ->\n  .",
        "scala_template": "object Solution {\n    def countMatches(items: List[List[String]], ruleKey: String, ruleValue: String): Int = {\n        \n    }\n}"
    },
    {
        "id": 1897,
        "name": "maximize-palindrome-length-from-subsequences",
        "difficulty": "Hard",
        "link": "https://leetcode.com/problems/maximize-palindrome-length-from-subsequences/",
        "task_description": "You are given two strings, `word1` and `word2`. You want to construct a string in the following manner: Choose some **non-empty** subsequence `subsequence1` from `word1`. Choose some **non-empty** subsequence `subsequence2` from `word2`. Concatenate the subsequences: `subsequence1 + subsequence2`, to make the string. Return _the **length** of the longest **palindrome** that can be constructed in the described manner. _If no palindromes can be constructed, return `0`. A **subsequence** of a string `s` is a string that can be made by deleting some (possibly none) characters from `s` without changing the order of the remaining characters. A **palindrome** is a string that reads the same forward as well as backward. **Example 1:** ``` **Input:** word1 = \"cacb\", word2 = \"cbba\" **Output:** 5 **Explanation:** Choose \"ab\" from word1 and \"cba\" from word2 to make \"abcba\", which is a palindrome. ``` **Example 2:** ``` **Input:** word1 = \"ab\", word2 = \"ab\" **Output:** 3 **Explanation:** Choose \"ab\" from word1 and \"a\" from word2 to make \"aba\", which is a palindrome. ``` **Example 3:** ``` **Input:** word1 = \"aa\", word2 = \"bb\" **Output:** 0 **Explanation:** You cannot construct a palindrome from the described method, so return 0. ``` **Constraints:** `1 <= word1.length, word2.length <= 1000` `word1` and `word2` consist of lowercase English letters.",
        "test_case": [
            {
                "label": "Example 1",
                "input": "word1 = \"cacb\", word2 = \"cbba\"",
                "output": "5 Explanation: Choose \"ab\" from word1 and \"cba\" from word2 to make \"abcba\", which is a palindrome."
            },
            {
                "label": "Example 2",
                "input": "word1 = \"ab\", word2 = \"ab\"",
                "output": "3 Explanation: Choose \"ab\" from word1 and \"a\" from word2 to make \"aba\", which is a palindrome."
            },
            {
                "label": "Example 3",
                "input": "word1 = \"aa\", word2 = \"bb\"",
                "output": "0 Explanation: You cannot construct a palindrome from the described method, so return 0."
            }
        ],
        "elixir_template": "defmodule Solution do\n  @spec longest_palindrome(word1 :: String.t, word2 :: String.t) :: integer\n  def longest_palindrome(word1, word2) do\n    \n  end\nend",
        "erlang_template": "-spec longest_palindrome(Word1 :: unicode:unicode_binary(), Word2 :: unicode:unicode_binary()) -> integer().\nlongest_palindrome(Word1, Word2) ->\n  .",
        "scala_template": "object Solution {\n    def longestPalindrome(word1: String, word2: String): Int = {\n        \n    }\n}"
    },
    {
        "id": 1896,
        "name": "maximum-score-from-performing-multiplication-operations",
        "difficulty": "Hard",
        "link": "https://leetcode.com/problems/maximum-score-from-performing-multiplication-operations/",
        "task_description": "You are given two **0-indexed** integer arrays `nums` and `multipliers`** **of size `n` and `m` respectively, where `n >= m`. You begin with a score of `0`. You want to perform **exactly** `m` operations. On the `ith` operation (**0-indexed**) you will: Choose one integer `x` from **either the start or the end **of the array `nums`. Add `multipliers[i] * x` to your score. Note that `multipliers[0]` corresponds to the first operation, `multipliers[1]` to the second operation, and so on. Remove `x` from `nums`. Return _the **maximum** score after performing _`m` _operations._ **Example 1:** ``` **Input:** nums = [1,2,3], multipliers = [3,2,1] **Output:** 14 **Explanation:** An optimal solution is as follows: - Choose from the end, [1,2,**3**], adding 3 * 3 = 9 to the score. - Choose from the end, [1,**2**], adding 2 * 2 = 4 to the score. - Choose from the end, [**1**], adding 1 * 1 = 1 to the score. The total score is 9 + 4 + 1 = 14. ``` **Example 2:** ``` **Input:** nums = [-5,-3,-3,-2,7,1], multipliers = [-10,-5,3,4,6] **Output:** 102 **Explanation: **An optimal solution is as follows: - Choose from the start, [**-5**,-3,-3,-2,7,1], adding -5 * -10 = 50 to the score. - Choose from the start, [**-3**,-3,-2,7,1], adding -3 * -5 = 15 to the score. - Choose from the start, [**-3**,-2,7,1], adding -3 * 3 = -9 to the score. - Choose from the end, [-2,7,**1**], adding 1 * 4 = 4 to the score. - Choose from the end, [-2,**7**], adding 7 * 6 = 42 to the score. The total score is 50 + 15 - 9 + 4 + 42 = 102. ``` **Constraints:** `n == nums.length` `m == multipliers.length` `1 <= m <= 300` `m <= n <= 105`` ` `-1000 <= nums[i], multipliers[i] <= 1000`",
        "test_case": [
            {
                "label": "Example 1",
                "input": "nums = [1,2,3], multipliers = [3,2,1]",
                "output": "14 Explanation: An optimal solution is as follows:\n- Choose from the end, [1,2, 3 ], adding 3 * 3 = 9 to the score.\n- Choose from the end, [1, 2 ], adding 2 * 2 = 4 to the score.\n- Choose from the end, [ 1 ], adding 1 * 1 = 1 to the score.\nThe total score is 9 + 4 + 1 = 14."
            },
            {
                "label": "Example 2",
                "input": "nums = [-5,-3,-3,-2,7,1], multipliers = [-10,-5,3,4,6]",
                "output": "102 Explanation: An optimal solution is as follows:\n- Choose from the start, [ -5 ,-3,-3,-2,7,1], adding -5 * -10 = 50 to the score.\n- Choose from the start, [ -3 ,-3,-2,7,1], adding -3 * -5 = 15 to the score.\n- Choose from the start, [ -3 ,-2,7,1], adding -3 * 3 = -9 to the score.\n- Choose from the end, [-2,7, 1 ], adding 1 * 4 = 4 to the score.\n- Choose from the end, [-2, 7 ], adding 7 * 6 = 42 to the score. \nThe total score is 50 + 15 - 9 + 4 + 42 = 102. Constraints: n == nums.length m == multipliers.length 1 <= m <= 300 m <= n <= 10 5 -1000 <= nums[i], multipliers[i] <= 1000"
            }
        ],
        "elixir_template": "defmodule Solution do\n  @spec maximum_score(nums :: [integer], multipliers :: [integer]) :: integer\n  def maximum_score(nums, multipliers) do\n    \n  end\nend",
        "erlang_template": "-spec maximum_score(Nums :: [integer()], Multipliers :: [integer()]) -> integer().\nmaximum_score(Nums, Multipliers) ->\n  .",
        "scala_template": "object Solution {\n    def maximumScore(nums: Array[Int], multipliers: Array[Int]): Int = {\n        \n    }\n}"
    },
    {
        "id": 1895,
        "name": "minimum-number-of-operations-to-move-all-balls-to-each-box",
        "difficulty": "Medium",
        "link": "https://leetcode.com/problems/minimum-number-of-operations-to-move-all-balls-to-each-box/",
        "task_description": "You have `n` boxes. You are given a binary string `boxes` of length `n`, where `boxes[i]` is `'0'` if the `ith` box is **empty**, and `'1'` if it contains **one** ball. In one operation, you can move **one** ball from a box to an adjacent box. Box `i` is adjacent to box `j` if `abs(i - j) == 1`. Note that after doing so, there may be more than one ball in some boxes. Return an array `answer` of size `n`, where `answer[i]` is the **minimum** number of operations needed to move all the balls to the `ith` box. Each `answer[i]` is calculated considering the **initial** state of the boxes. **Example 1:** ``` **Input:** boxes = \"110\" **Output:** [1,1,3] **Explanation:** The answer for each box is as follows: 1) First box: you will have to move one ball from the second box to the first box in one operation. 2) Second box: you will have to move one ball from the first box to the second box in one operation. 3) Third box: you will have to move one ball from the first box to the third box in two operations, and move one ball from the second box to the third box in one operation. ``` **Example 2:** ``` **Input:** boxes = \"001011\" **Output:** [11,8,5,4,3,4] ``` **Constraints:** `n == boxes.length` `1 <= n <= 2000` `boxes[i]` is either `'0'` or `'1'`.",
        "test_case": [
            {
                "label": "Example 1",
                "input": "boxes = \"110\"",
                "output": "[1,1,3] Explanation: The answer for each box is as follows:\n1) First box: you will have to move one ball from the second box to the first box in one operation.\n2) Second box: you will have to move one ball from the first box to the second box in one operation.\n3) Third box: you will have to move one ball from the first box to the third box in two operations, and move one ball from the second box to the third box in one operation."
            },
            {
                "label": "Example 2",
                "input": "boxes = \"001011\"",
                "output": "[11,8,5,4,3,4] Constraints: n == boxes.length 1 <= n <= 2000 boxes[i] is either '0' or '1' ."
            }
        ],
        "elixir_template": "defmodule Solution do\n  @spec min_operations(boxes :: String.t) :: [integer]\n  def min_operations(boxes) do\n    \n  end\nend",
        "erlang_template": "-spec min_operations(Boxes :: unicode:unicode_binary()) -> [integer()].\nmin_operations(Boxes) ->\n  .",
        "scala_template": "object Solution {\n    def minOperations(boxes: String): Array[Int] = {\n        \n    }\n}"
    },
    {
        "id": 1894,
        "name": "merge-strings-alternately",
        "difficulty": "Easy",
        "link": "https://leetcode.com/problems/merge-strings-alternately/",
        "task_description": "You are given two strings `word1` and `word2`. Merge the strings by adding letters in alternating order, starting with `word1`. If a string is longer than the other, append the additional letters onto the end of the merged string. Return _the merged string._ **Example 1:** ``` **Input:** word1 = \"abc\", word2 = \"pqr\" **Output:** \"apbqcr\" **Explanation:** The merged string will be merged as so: word1: a b c word2: p q r merged: a p b q c r ``` **Example 2:** ``` **Input:** word1 = \"ab\", word2 = \"pqrs\" **Output:** \"apbqrs\" **Explanation:** Notice that as word2 is longer, \"rs\" is appended to the end. word1: a b word2: p q r s merged: a p b q r s ``` **Example 3:** ``` **Input:** word1 = \"abcd\", word2 = \"pq\" **Output:** \"apbqcd\" **Explanation:** Notice that as word1 is longer, \"cd\" is appended to the end. word1: a b c d word2: p q merged: a p b q c d ``` **Constraints:** `1 <= word1.length, word2.length <= 100` `word1` and `word2` consist of lowercase English letters.",
        "test_case": [
            {
                "label": "Example 1",
                "input": "word1 = \"abc\", word2 = \"pqr\"",
                "output": "\"apbqcr\" Explanation: The merged string will be merged as so:\r\nword1:  a   b   c\r\nword2:    p   q   r\r\nmerged: a p b q c r"
            },
            {
                "label": "Example 2",
                "input": "word1 = \"ab\", word2 = \"pqrs\"",
                "output": "\"apbqrs\" Explanation: Notice that as word2 is longer, \"rs\" is appended to the end.\r\nword1:  a   b \r\nword2:    p   q   r   s\r\nmerged: a p b q   r   s"
            },
            {
                "label": "Example 3",
                "input": "word1 = \"abcd\", word2 = \"pq\"",
                "output": "\"apbqcd\" Explanation: Notice that as word1 is longer, \"cd\" is appended to the end.\r\nword1:  a   b   c   d\r\nword2:    p   q \r\nmerged: a p b q c   d"
            }
        ],
        "elixir_template": "Elixir code template not available for this problem.",
        "erlang_template": "Elixir code template not available for this problem.",
        "scala_template": "object Solution {\n    def mergeAlternately(word1: String, word2: String): String = {\n        \n    }\n}"
    },
    {
        "id": 1891,
        "name": "count-pairs-of-nodes",
        "difficulty": "Hard",
        "link": "https://leetcode.com/problems/count-pairs-of-nodes/",
        "task_description": "You are given an undirected graph defined by an integer `n`, the number of nodes, and a 2D integer array `edges`, the edges in the graph, where `edges[i] = [ui, vi]` indicates that there is an **undirected** edge between `ui` and `vi`. You are also given an integer array `queries`. Let `incident(a, b)` be defined as the **number of edges** that are connected to **either** node `a` or `b`. The answer to the `jth` query is the **number of pairs** of nodes `(a, b)` that satisfy **both** of the following conditions: `a < b` `incident(a, b) > queries[j]` Return _an array _`answers`_ such that _`answers.length == queries.length`_ and _`answers[j]`_ is the answer of the _`jth`_ query_. Note that there can be **multiple edges** between the same two nodes. **Example 1:** ``` **Input:** n = 4, edges = [[1,2],[2,4],[1,3],[2,3],[2,1]], queries = [2,3] **Output:** [6,5] **Explanation:** The calculations for incident(a, b) are shown in the table above. The answers for each of the queries are as follows: - answers[0] = 6. All the pairs have an incident(a, b) value greater than 2. - answers[1] = 5. All the pairs except (3, 4) have an incident(a, b) value greater than 3. ``` **Example 2:** ``` **Input:** n = 5, edges = [[1,5],[1,5],[3,4],[2,5],[1,3],[5,1],[2,3],[2,5]], queries = [1,2,3,4,5] **Output:** [10,10,9,8,6] ``` **Constraints:** `2 <= n <= 2 * 104` `1 <= edges.length <= 105` `1 <= ui, vi <= n` `ui != vi` `1 <= queries.length <= 20` `0 <= queries[j] < edges.length`",
        "test_case": [
            {
                "label": "Example 1",
                "input": "n = 4, edges = [[1,2],[2,4],[1,3],[2,3],[2,1]], queries = [2,3]",
                "output": "[6,5] Explanation: The calculations for incident(a, b) are shown in the table above.\nThe answers for each of the queries are as follows:\n- answers[0] = 6. All the pairs have an incident(a, b) value greater than 2.\n- answers[1] = 5. All the pairs except (3, 4) have an incident(a, b) value greater than 3."
            },
            {
                "label": "Example 2",
                "input": "n = 5, edges = [[1,5],[1,5],[3,4],[2,5],[1,3],[5,1],[2,3],[2,5]], queries = [1,2,3,4,5]",
                "output": "[10,10,9,8,6]"
            }
        ],
        "elixir_template": "defmodule Solution do\n  @spec count_pairs(n :: integer, edges :: [[integer]], queries :: [integer]) :: [integer]\n  def count_pairs(n, edges, queries) do\n    \n  end\nend",
        "erlang_template": "-spec count_pairs(N :: integer(), Edges :: [[integer()]], Queries :: [integer()]) -> [integer()].\ncount_pairs(N, Edges, Queries) ->\n  .",
        "scala_template": "object Solution {\n    def countPairs(n: Int, edges: Array[Array[Int]], queries: Array[Int]): Array[Int] = {\n        \n    }\n}"
    },
    {
        "id": 1890,
        "name": "sum-of-beauty-of-all-substrings",
        "difficulty": "Medium",
        "link": "https://leetcode.com/problems/sum-of-beauty-of-all-substrings/",
        "task_description": "The **beauty** of a string is the difference in frequencies between the most frequent and least frequent characters. For example, the beauty of `\"abaacc\"` is `3 - 1 = 2`. Given a string `s`, return _the sum of **beauty** of all of its substrings._ **Example 1:** ``` **Input:** s = \"aabcb\" **Output:** 5 **Explanation: **The substrings with non-zero beauty are [\"aab\",\"aabc\",\"aabcb\",\"abcb\",\"bcb\"], each with beauty equal to 1. ``` **Example 2:** ``` **Input:** s = \"aabcbaa\" **Output:** 17 ``` **Constraints:** `1 <= s.length <= 500` `s` consists of only lowercase English letters.",
        "test_case": [
            {
                "label": "Example 1",
                "input": "s = \"aabcb\"",
                "output": "5 Explanation: The substrings with non-zero beauty are [\"aab\",\"aabc\",\"aabcb\",\"abcb\",\"bcb\"], each with beauty equal to 1."
            },
            {
                "label": "Example 2",
                "input": "s = \"aabcbaa\"",
                "output": "17"
            }
        ],
        "elixir_template": "defmodule Solution do\n  @spec beauty_sum(s :: String.t) :: integer\n  def beauty_sum(s) do\n    \n  end\nend",
        "erlang_template": "-spec beauty_sum(S :: unicode:unicode_binary()) -> integer().\nbeauty_sum(S) ->\n  .",
        "scala_template": "object Solution {\n    def beautySum(s: String): Int = {\n        \n    }\n}"
    },
    {
        "id": 1889,
        "name": "check-if-number-is-a-sum-of-powers-of-three",
        "difficulty": "Medium",
        "link": "https://leetcode.com/problems/check-if-number-is-a-sum-of-powers-of-three/",
        "task_description": "Given an integer `n`, return `true` _if it is possible to represent _`n`_ as the sum of distinct powers of three._ Otherwise, return `false`. An integer `y` is a power of three if there exists an integer `x` such that `y == 3x`. **Example 1:** ``` **Input:** n = 12 **Output:** true **Explanation:** 12 = 31 + 32 ``` **Example 2:** ``` **Input:** n = 91 **Output:** true **Explanation:** 91 = 30 + 32 + 34 ``` **Example 3:** ``` **Input:** n = 21 **Output:** false ``` **Constraints:** `1 <= n <= 107`",
        "test_case": [
            {
                "label": "Example 1",
                "input": "n = 12",
                "output": "true Explanation: 12 = 3 1 + 3 2"
            },
            {
                "label": "Example 2",
                "input": "n = 91",
                "output": "true Explanation: 91 = 3 0 + 3 2 + 3 4"
            },
            {
                "label": "Example 3",
                "input": "n = 21",
                "output": "false"
            }
        ],
        "elixir_template": "defmodule Solution do\n  @spec check_powers_of_three(n :: integer) :: boolean\n  def check_powers_of_three(n) do\n    \n  end\nend",
        "erlang_template": "-spec check_powers_of_three(N :: integer()) -> boolean().\ncheck_powers_of_three(N) ->\n  .",
        "scala_template": "object Solution {\n    def checkPowersOfThree(n: Int): Boolean = {\n        \n    }\n}"
    },
    {
        "id": 1888,
        "name": "find-nearest-point-that-has-the-same-x-or-y-coordinate",
        "difficulty": "Easy",
        "link": "https://leetcode.com/problems/find-nearest-point-that-has-the-same-x-or-y-coordinate/",
        "task_description": "You are given two integers, `x` and `y`, which represent your current location on a Cartesian grid: `(x, y)`. You are also given an array `points` where each `points[i] = [ai, bi]` represents that a point exists at `(ai, bi)`. A point is **valid** if it shares the same x-coordinate or the same y-coordinate as your location. Return _the index **(0-indexed)** of the **valid** point with the smallest **Manhattan distance** from your current location_. If there are multiple, return _the valid point with the **smallest** index_. If there are no valid points, return `-1`. The **Manhattan distance** between two points `(x1, y1)` and `(x2, y2)` is `abs(x1 - x2) + abs(y1 - y2)`. **Example 1:** ``` **Input:** x = 3, y = 4, points = [[1,2],[3,1],[2,4],[2,3],[4,4]] **Output:** 2 **Explanation:** Of all the points, only [3,1], [2,4] and [4,4] are valid. Of the valid points, [2,4] and [4,4] have the smallest Manhattan distance from your current location, with a distance of 1. [2,4] has the smallest index, so return 2. ``` **Example 2:** ``` **Input:** x = 3, y = 4, points = [[3,4]] **Output:** 0 **Explanation:** The answer is allowed to be on the same location as your current location. ``` **Example 3:** ``` **Input:** x = 3, y = 4, points = [[2,3]] **Output:** -1 **Explanation:** There are no valid points. ``` **Constraints:** `1 <= points.length <= 104` `points[i].length == 2` `1 <= x, y, ai, bi <= 104`",
        "test_case": [
            {
                "label": "Example 1",
                "input": "x = 3, y = 4, points = [[1,2],[3,1],[2,4],[2,3],[4,4]]",
                "output": "2 Explanation: Of all the points, only [3,1], [2,4] and [4,4] are valid. Of the valid points, [2,4] and [4,4] have the smallest Manhattan distance from your current location, with a distance of 1. [2,4] has the smallest index, so return 2."
            },
            {
                "label": "Example 2",
                "input": "x = 3, y = 4, points = [[3,4]]",
                "output": "0 Explanation: The answer is allowed to be on the same location as your current location."
            },
            {
                "label": "Example 3",
                "input": "x = 3, y = 4, points = [[2,3]]",
                "output": "-1 Explanation: There are no valid points."
            }
        ],
        "elixir_template": "defmodule Solution do\n  @spec nearest_valid_point(x :: integer, y :: integer, points :: [[integer]]) :: integer\n  def nearest_valid_point(x, y, points) do\n    \n  end\nend",
        "erlang_template": "-spec nearest_valid_point(X :: integer(), Y :: integer(), Points :: [[integer()]]) -> integer().\nnearest_valid_point(X, Y, Points) ->\n  .",
        "scala_template": "object Solution {\n    def nearestValidPoint(x: Int, y: Int, points: Array[Array[Int]]): Int = {\n        \n    }\n}"
    },
    {
        "id": 1887,
        "name": "minimum-degree-of-a-connected-trio-in-a-graph",
        "difficulty": "Hard",
        "link": "https://leetcode.com/problems/minimum-degree-of-a-connected-trio-in-a-graph/",
        "task_description": "You are given an undirected graph. You are given an integer `n` which is the number of nodes in the graph and an array `edges`, where each `edges[i] = [ui, vi]` indicates that there is an undirected edge between `ui` and `vi`. A **connected trio** is a set of **three** nodes where there is an edge between every pair of them. The **degree of a connected trio** is the number of edges where one endpoint is in the trio, and the other is not. Return _the **minimum** degree of a connected trio in the graph, or_ `-1` _if the graph has no connected trios._ **Example 1:** ``` **Input:** n = 6, edges = [[1,2],[1,3],[3,2],[4,1],[5,2],[3,6]] **Output:** 3 **Explanation:** There is exactly one trio, which is [1,2,3]. The edges that form its degree are bolded in the figure above. ``` **Example 2:** ``` **Input:** n = 7, edges = [[1,3],[4,1],[4,3],[2,5],[5,6],[6,7],[7,5],[2,6]] **Output:** 0 **Explanation:** There are exactly three trios: 1) [1,4,3] with degree 0. 2) [2,5,6] with degree 2. 3) [5,6,7] with degree 2. ``` **Constraints:** `2 <= n <= 400` `edges[i].length == 2` `1 <= edges.length <= n * (n-1) / 2` `1 <= ui, vi <= n` `ui != vi` There are no repeated edges.",
        "test_case": [
            {
                "label": "Example 1",
                "input": "n = 6, edges = [[1,2],[1,3],[3,2],[4,1],[5,2],[3,6]]",
                "output": "3 Explanation: There is exactly one trio, which is [1,2,3]. The edges that form its degree are bolded in the figure above."
            },
            {
                "label": "Example 2",
                "input": "n = 7, edges = [[1,3],[4,1],[4,3],[2,5],[5,6],[6,7],[7,5],[2,6]]",
                "output": "0 Explanation: There are exactly three trios:\n1) [1,4,3] with degree 0.\n2) [2,5,6] with degree 2.\n3) [5,6,7] with degree 2."
            }
        ],
        "elixir_template": "defmodule Solution do\n  @spec min_trio_degree(n :: integer, edges :: [[integer]]) :: integer\n  def min_trio_degree(n, edges) do\n    \n  end\nend",
        "erlang_template": "-spec min_trio_degree(N :: integer(), Edges :: [[integer()]]) -> integer().\nmin_trio_degree(N, Edges) ->\n  .",
        "scala_template": "object Solution {\n    def minTrioDegree(n: Int, edges: Array[Array[Int]]): Int = {\n        \n    }\n}"
    },
    {
        "id": 1886,
        "name": "minimum-limit-of-balls-in-a-bag",
        "difficulty": "Medium",
        "link": "https://leetcode.com/problems/minimum-limit-of-balls-in-a-bag/",
        "task_description": "You are given an integer array `nums` where the `ith` bag contains `nums[i]` balls. You are also given an integer `maxOperations`. You can perform the following operation at most `maxOperations` times: Take any bag of balls and divide it into two new bags with a **positive **number of balls. For example, a bag of `5` balls can become two new bags of `1` and `4` balls, or two new bags of `2` and `3` balls. Your penalty is the **maximum** number of balls in a bag. You want to **minimize** your penalty after the operations. Return _the minimum possible penalty after performing the operations_. **Example 1:** ``` **Input:** nums = [9], maxOperations = 2 **Output:** 3 **Explanation:** - Divide the bag with 9 balls into two bags of sizes 6 and 3. [**9**] -> [6,3]. - Divide the bag with 6 balls into two bags of sizes 3 and 3. [**6**,3] -> [3,3,3]. The bag with the most number of balls has 3 balls, so your penalty is 3 and you should return 3. ``` **Example 2:** ``` **Input:** nums = [2,4,8,2], maxOperations = 4 **Output:** 2 **Explanation:** - Divide the bag with 8 balls into two bags of sizes 4 and 4. [2,4,**8**,2] -> [2,4,4,4,2]. - Divide the bag with 4 balls into two bags of sizes 2 and 2. [2,**4**,4,4,2] -> [2,2,2,4,4,2]. - Divide the bag with 4 balls into two bags of sizes 2 and 2. [2,2,2,**4**,4,2] -> [2,2,2,2,2,4,2]. - Divide the bag with 4 balls into two bags of sizes 2 and 2. [2,2,2,2,2,**4**,2] -> [2,2,2,2,2,2,2,2]. The bag with the most number of balls has 2 balls, so your penalty is 2, and you should return 2. ``` **Constraints:** `1 <= nums.length <= 105` `1 <= maxOperations, nums[i] <= 109`",
        "test_case": [
            {
                "label": "Example 1",
                "input": "nums = [9], maxOperations = 2",
                "output": "3 Explanation: - Divide the bag with 9 balls into two bags of sizes 6 and 3. [ 9 ] -> [6,3].\n- Divide the bag with 6 balls into two bags of sizes 3 and 3. [ 6 ,3] -> [3,3,3].\nThe bag with the most number of balls has 3 balls, so your penalty is 3 and you should return 3."
            },
            {
                "label": "Example 2",
                "input": "nums = [2,4,8,2], maxOperations = 4",
                "output": "2 Explanation: - Divide the bag with 8 balls into two bags of sizes 4 and 4. [2,4, 8 ,2] -> [2,4,4,4,2].\n- Divide the bag with 4 balls into two bags of sizes 2 and 2. [2, 4 ,4,4,2] -> [2,2,2,4,4,2].\n- Divide the bag with 4 balls into two bags of sizes 2 and 2. [2,2,2, 4 ,4,2] -> [2,2,2,2,2,4,2].\n- Divide the bag with 4 balls into two bags of sizes 2 and 2. [2,2,2,2,2, 4 ,2] -> [2,2,2,2,2,2,2,2].\nThe bag with the most number of balls has 2 balls, so your penalty is 2, and you should return 2."
            }
        ],
        "elixir_template": "defmodule Solution do\n  @spec minimum_size(nums :: [integer], max_operations :: integer) :: integer\n  def minimum_size(nums, max_operations) do\n    \n  end\nend",
        "erlang_template": "-spec minimum_size(Nums :: [integer()], MaxOperations :: integer()) -> integer().\nminimum_size(Nums, MaxOperations) ->\n  .",
        "scala_template": "object Solution {\n    def minimumSize(nums: Array[Int], maxOperations: Int): Int = {\n        \n    }\n}"
    },
    {
        "id": 1885,
        "name": "count-number-of-homogenous-substrings",
        "difficulty": "Medium",
        "link": "https://leetcode.com/problems/count-number-of-homogenous-substrings/",
        "task_description": "Given a string `s`, return _the number of **homogenous** substrings of _`s`_._ Since the answer may be too large, return it **modulo** `109 + 7`. A string is **homogenous** if all the characters of the string are the same. A **substring** is a contiguous sequence of characters within a string. **Example 1:** ``` **Input:** s = \"abbcccaa\" **Output:** 13 **Explanation:** The homogenous substrings are listed as below: \"a\" appears 3 times. \"aa\" appears 1 time. \"b\" appears 2 times. \"bb\" appears 1 time. \"c\" appears 3 times. \"cc\" appears 2 times. \"ccc\" appears 1 time. 3 + 1 + 2 + 1 + 3 + 2 + 1 = 13. ``` **Example 2:** ``` **Input:** s = \"xy\" **Output:** 2 **Explanation:** The homogenous substrings are \"x\" and \"y\". ``` **Example 3:** ``` **Input:** s = \"zzzzz\" **Output:** 15 ``` **Constraints:** `1 <= s.length <= 105` `s` consists of lowercase letters.",
        "test_case": [
            {
                "label": "Example 1",
                "input": "s = \"abbcccaa\"",
                "output": "13 Explanation: The homogenous substrings are listed as below:\n\"a\"   appears 3 times.\n\"aa\"  appears 1 time.\n\"b\"   appears 2 times.\n\"bb\"  appears 1 time.\n\"c\"   appears 3 times.\n\"cc\"  appears 2 times.\n\"ccc\" appears 1 time.\n3 + 1 + 2 + 1 + 3 + 2 + 1 = 13."
            },
            {
                "label": "Example 2",
                "input": "s = \"xy\"",
                "output": "2 Explanation: The homogenous substrings are \"x\" and \"y\"."
            },
            {
                "label": "Example 3",
                "input": "s = \"zzzzz\"",
                "output": "15"
            }
        ],
        "elixir_template": "defmodule Solution do\n  @spec count_homogenous(s :: String.t) :: integer\n  def count_homogenous(s) do\n    \n  end\nend",
        "erlang_template": "-spec count_homogenous(S :: unicode:unicode_binary()) -> integer().\ncount_homogenous(S) ->\n  .",
        "scala_template": "object Solution {\n    def countHomogenous(s: String): Int = {\n        \n    }\n}"
    },
    {
        "id": 1884,
        "name": "minimum-changes-to-make-alternating-binary-string",
        "difficulty": "Easy",
        "link": "https://leetcode.com/problems/minimum-changes-to-make-alternating-binary-string/",
        "task_description": "You are given a string `s` consisting only of the characters `'0'` and `'1'`. In one operation, you can change any `'0'` to `'1'` or vice versa. The string is called alternating if no two adjacent characters are equal. For example, the string `\"010\"` is alternating, while the string `\"0100\"` is not. Return _the **minimum** number of operations needed to make_ `s` _alternating_. **Example 1:** ``` **Input:** s = \"0100\" **Output:** 1 **Explanation:** If you change the last character to '1', s will be \"0101\", which is alternating. ``` **Example 2:** ``` **Input:** s = \"10\" **Output:** 0 **Explanation:** s is already alternating. ``` **Example 3:** ``` **Input:** s = \"1111\" **Output:** 2 **Explanation:** You need two operations to reach \"0101\" or \"1010\". ``` **Constraints:** `1 <= s.length <= 104` `s[i]` is either `'0'` or `'1'`.",
        "test_case": [
            {
                "label": "Example 1",
                "input": "s = \"0100\"",
                "output": "1 Explanation: If you change the last character to '1', s will be \"0101\", which is alternating."
            },
            {
                "label": "Example 2",
                "input": "s = \"10\"",
                "output": "0 Explanation: s is already alternating."
            },
            {
                "label": "Example 3",
                "input": "s = \"1111\"",
                "output": "2 Explanation: You need two operations to reach \"0101\" or \"1010\"."
            }
        ],
        "elixir_template": "defmodule Solution do\n  @spec min_operations(s :: String.t) :: integer\n  def min_operations(s) do\n    \n  end\nend",
        "erlang_template": "-spec min_operations(S :: unicode:unicode_binary()) -> integer().\nmin_operations(S) ->\n  .",
        "scala_template": "object Solution {\n    def minOperations(s: String): Int = {\n        \n    }\n}"
    },
    {
        "id": 1881,
        "name": "closest-subsequence-sum",
        "difficulty": "Hard",
        "link": "https://leetcode.com/problems/closest-subsequence-sum/",
        "task_description": "You are given an integer array `nums` and an integer `goal`. You want to choose a subsequence of `nums` such that the sum of its elements is the closest possible to `goal`. That is, if the sum of the subsequence's elements is `sum`, then you want to **minimize the absolute difference** `abs(sum - goal)`. Return _the **minimum** possible value of_ `abs(sum - goal)`. Note that a subsequence of an array is an array formed by removing some elements **(possibly all or none)** of the original array. **Example 1:** ``` **Input:** nums = [5,-7,3,5], goal = 6 **Output:** 0 **Explanation:** Choose the whole array as a subsequence, with a sum of 6. This is equal to the goal, so the absolute difference is 0. ``` **Example 2:** ``` **Input:** nums = [7,-9,15,-2], goal = -5 **Output:** 1 **Explanation:** Choose the subsequence [7,-9,-2], with a sum of -4. The absolute difference is abs(-4 - (-5)) = abs(1) = 1, which is the minimum. ``` **Example 3:** ``` **Input:** nums = [1,2,3], goal = -7 **Output:** 7 ``` **Constraints:** `1 <= nums.length <= 40` `-107 <= nums[i] <= 107` `-109 <= goal <= 109`",
        "test_case": [
            {
                "label": "Example 1",
                "input": "nums = [5,-7,3,5], goal = 6",
                "output": "0 Explanation: Choose the whole array as a subsequence, with a sum of 6.\nThis is equal to the goal, so the absolute difference is 0."
            },
            {
                "label": "Example 2",
                "input": "nums = [7,-9,15,-2], goal = -5",
                "output": "1 Explanation: Choose the subsequence [7,-9,-2], with a sum of -4.\nThe absolute difference is abs(-4 - (-5)) = abs(1) = 1, which is the minimum."
            },
            {
                "label": "Example 3",
                "input": "nums = [1,2,3], goal = -7",
                "output": "7"
            }
        ],
        "elixir_template": "defmodule Solution do\n  @spec min_abs_difference(nums :: [integer], goal :: integer) :: integer\n  def min_abs_difference(nums, goal) do\n    \n  end\nend",
        "erlang_template": "-spec min_abs_difference(Nums :: [integer()], Goal :: integer()) -> integer().\nmin_abs_difference(Nums, Goal) ->\n  .",
        "scala_template": "object Solution {\n    def minAbsDifference(nums: Array[Int], goal: Int): Int = {\n        \n    }\n}"
    },
    {
        "id": 1880,
        "name": "largest-merge-of-two-strings",
        "difficulty": "Medium",
        "link": "https://leetcode.com/problems/largest-merge-of-two-strings/",
        "task_description": "You are given two strings `word1` and `word2`. You want to construct a string `merge` in the following way: while either `word1` or `word2` are non-empty, choose **one** of the following options: If `word1` is non-empty, append the **first** character in `word1` to `merge` and delete it from `word1`. For example, if `word1 = \"abc\" `and `merge = \"dv\"`, then after choosing this operation, `word1 = \"bc\"` and `merge = \"dva\"`. If `word2` is non-empty, append the **first** character in `word2` to `merge` and delete it from `word2`. For example, if `word2 = \"abc\" `and `merge = \"\"`, then after choosing this operation, `word2 = \"bc\"` and `merge = \"a\"`. Return _the lexicographically **largest** _`merge`_ you can construct_. A string `a` is lexicographically larger than a string `b` (of the same length) if in the first position where `a` and `b` differ, `a` has a character strictly larger than the corresponding character in `b`. For example, `\"abcd\"` is lexicographically larger than `\"abcc\"` because the first position they differ is at the fourth character, and `d` is greater than `c`. **Example 1:** ``` **Input:** word1 = \"cabaa\", word2 = \"bcaaa\" **Output:** \"cbcabaaaaa\" **Explanation:** One way to get the lexicographically largest merge is: - Take from word1: merge = \"c\", word1 = \"abaa\", word2 = \"bcaaa\" - Take from word2: merge = \"cb\", word1 = \"abaa\", word2 = \"caaa\" - Take from word2: merge = \"cbc\", word1 = \"abaa\", word2 = \"aaa\" - Take from word1: merge = \"cbca\", word1 = \"baa\", word2 = \"aaa\" - Take from word1: merge = \"cbcab\", word1 = \"aa\", word2 = \"aaa\" - Append the remaining 5 a's from word1 and word2 at the end of merge. ``` **Example 2:** ``` **Input:** word1 = \"abcabc\", word2 = \"abdcaba\" **Output:** \"abdcabcabcaba\" ``` **Constraints:** `1 <= word1.length, word2.length <= 3000` `word1` and `word2` consist only of lowercase English letters.",
        "test_case": [
            {
                "label": "Example 1",
                "input": "word1 = \"cabaa\", word2 = \"bcaaa\"",
                "output": "\"cbcabaaaaa\" Explanation: One way to get the lexicographically largest merge is:\n- Take from word1: merge = \"c\", word1 = \"abaa\", word2 = \"bcaaa\"\n- Take from word2: merge = \"cb\", word1 = \"abaa\", word2 = \"caaa\"\n- Take from word2: merge = \"cbc\", word1 = \"abaa\", word2 = \"aaa\"\n- Take from word1: merge = \"cbca\", word1 = \"baa\", word2 = \"aaa\"\n- Take from word1: merge = \"cbcab\", word1 = \"aa\", word2 = \"aaa\"\n- Append the remaining 5 a's from word1 and word2 at the end of merge."
            },
            {
                "label": "Example 2",
                "input": "word1 = \"abcabc\", word2 = \"abdcaba\"",
                "output": "\"abdcabcabcaba\""
            }
        ],
        "elixir_template": "defmodule Solution do\n  @spec largest_merge(word1 :: String.t, word2 :: String.t) :: String.t\n  def largest_merge(word1, word2) do\n    \n  end\nend",
        "erlang_template": "-spec largest_merge(Word1 :: unicode:unicode_binary(), Word2 :: unicode:unicode_binary()) -> unicode:unicode_binary().\nlargest_merge(Word1, Word2) ->\n  .",
        "scala_template": "object Solution {\n    def largestMerge(word1: String, word2: String): String = {\n        \n    }\n}"
    },
    {
        "id": 1879,
        "name": "maximum-score-from-removing-stones",
        "difficulty": "Medium",
        "link": "https://leetcode.com/problems/maximum-score-from-removing-stones/",
        "task_description": "You are playing a solitaire game with **three piles** of stones of sizes `a`\u200b\u200b\u200b\u200b\u200b\u200b, `b`,\u200b\u200b\u200b\u200b\u200b\u200b and `c`\u200b\u200b\u200b\u200b\u200b\u200b respectively. Each turn you choose two **different non-empty **piles, take one stone from each, and add `1` point to your score. The game stops when there are **fewer than two non-empty** piles (meaning there are no more available moves). Given three integers `a`\u200b\u200b\u200b\u200b\u200b, `b`,\u200b\u200b\u200b\u200b\u200b and `c`\u200b\u200b\u200b\u200b\u200b, return _the_ **_maximum_ **_**score** you can get._ **Example 1:** ``` **Input:** a = 2, b = 4, c = 6 **Output:** 6 **Explanation:** The starting state is (2, 4, 6). One optimal set of moves is: - Take from 1st and 3rd piles, state is now (1, 4, 5) - Take from 1st and 3rd piles, state is now (0, 4, 4) - Take from 2nd and 3rd piles, state is now (0, 3, 3) - Take from 2nd and 3rd piles, state is now (0, 2, 2) - Take from 2nd and 3rd piles, state is now (0, 1, 1) - Take from 2nd and 3rd piles, state is now (0, 0, 0) There are fewer than two non-empty piles, so the game ends. Total: 6 points. ``` **Example 2:** ``` **Input:** a = 4, b = 4, c = 6 **Output:** 7 **Explanation:** The starting state is (4, 4, 6). One optimal set of moves is: - Take from 1st and 2nd piles, state is now (3, 3, 6) - Take from 1st and 3rd piles, state is now (2, 3, 5) - Take from 1st and 3rd piles, state is now (1, 3, 4) - Take from 1st and 3rd piles, state is now (0, 3, 3) - Take from 2nd and 3rd piles, state is now (0, 2, 2) - Take from 2nd and 3rd piles, state is now (0, 1, 1) - Take from 2nd and 3rd piles, state is now (0, 0, 0) There are fewer than two non-empty piles, so the game ends. Total: 7 points. ``` **Example 3:** ``` **Input:** a = 1, b = 8, c = 8 **Output:** 8 **Explanation:** One optimal set of moves is to take from the 2nd and 3rd piles for 8 turns until they are empty. After that, there are fewer than two non-empty piles, so the game ends. ``` **Constraints:** `1 <= a, b, c <= 105`",
        "test_case": [
            {
                "label": "Example 1",
                "input": "a = 2, b = 4, c = 6",
                "output": "6 Explanation: The starting state is (2, 4, 6). One optimal set of moves is:\n- Take from 1st and 3rd piles, state is now (1, 4, 5)\n- Take from 1st and 3rd piles, state is now (0, 4, 4)\n- Take from 2nd and 3rd piles, state is now (0, 3, 3)\n- Take from 2nd and 3rd piles, state is now (0, 2, 2)\n- Take from 2nd and 3rd piles, state is now (0, 1, 1)\n- Take from 2nd and 3rd piles, state is now (0, 0, 0)\nThere are fewer than two non-empty piles, so the game ends. Total: 6 points."
            },
            {
                "label": "Example 2",
                "input": "a = 4, b = 4, c = 6",
                "output": "7 Explanation: The starting state is (4, 4, 6). One optimal set of moves is:\n- Take from 1st and 2nd piles, state is now (3, 3, 6)\n- Take from 1st and 3rd piles, state is now (2, 3, 5)\n- Take from 1st and 3rd piles, state is now (1, 3, 4)\n- Take from 1st and 3rd piles, state is now (0, 3, 3)\n- Take from 2nd and 3rd piles, state is now (0, 2, 2)\n- Take from 2nd and 3rd piles, state is now (0, 1, 1)\n- Take from 2nd and 3rd piles, state is now (0, 0, 0)\nThere are fewer than two non-empty piles, so the game ends. Total: 7 points."
            },
            {
                "label": "Example 3",
                "input": "a = 1, b = 8, c = 8",
                "output": "8 Explanation: One optimal set of moves is to take from the 2nd and 3rd piles for 8 turns until they are empty.\nAfter that, there are fewer than two non-empty piles, so the game ends."
            }
        ],
        "elixir_template": "defmodule Solution do\n  @spec maximum_score(a :: integer, b :: integer, c :: integer) :: integer\n  def maximum_score(a, b, c) do\n    \n  end\nend",
        "erlang_template": "-spec maximum_score(A :: integer(), B :: integer(), C :: integer()) -> integer().\nmaximum_score(A, B, C) ->\n  .",
        "scala_template": "object Solution {\n    def maximumScore(a: Int, b: Int, c: Int): Int = {\n        \n    }\n}"
    },
    {
        "id": 1878,
        "name": "check-if-array-is-sorted-and-rotated",
        "difficulty": "Easy",
        "link": "https://leetcode.com/problems/check-if-array-is-sorted-and-rotated/",
        "task_description": "Given an array `nums`, return `true`_ if the array was originally sorted in non-decreasing order, then rotated **some** number of positions (including zero)_. Otherwise, return `false`. There may be **duplicates** in the original array. **Note:** An array `A` rotated by `x` positions results in an array `B` of the same length such that `A[i] == B[(i+x) % A.length]`, where `%` is the modulo operation. **Example 1:** ``` **Input:** nums = [3,4,5,1,2] **Output:** true **Explanation:** [1,2,3,4,5] is the original sorted array. You can rotate the array by x = 3 positions to begin on the the element of value 3: [3,4,5,1,2]. ``` **Example 2:** ``` **Input:** nums = [2,1,3,4] **Output:** false **Explanation:** There is no sorted array once rotated that can make nums. ``` **Example 3:** ``` **Input:** nums = [1,2,3] **Output:** true **Explanation:** [1,2,3] is the original sorted array. You can rotate the array by x = 0 positions (i.e. no rotation) to make nums. ``` **Constraints:** `1 <= nums.length <= 100` `1 <= nums[i] <= 100`",
        "test_case": [
            {
                "label": "Example 1",
                "input": "nums = [3,4,5,1,2]",
                "output": "true Explanation: [1,2,3,4,5] is the original sorted array.\nYou can rotate the array by x = 3 positions to begin on the the element of value 3: [3,4,5,1,2]."
            },
            {
                "label": "Example 2",
                "input": "nums = [2,1,3,4]",
                "output": "false Explanation: There is no sorted array once rotated that can make nums."
            },
            {
                "label": "Example 3",
                "input": "nums = [1,2,3]",
                "output": "true Explanation: [1,2,3] is the original sorted array.\nYou can rotate the array by x = 0 positions (i.e. no rotation) to make nums."
            }
        ],
        "elixir_template": "defmodule Solution do\n  @spec check(nums :: [integer]) :: boolean\n  def check(nums) do\n    \n  end\nend",
        "erlang_template": "-spec check(Nums :: [integer()]) -> boolean().\ncheck(Nums) ->\n  .",
        "scala_template": "object Solution {\n    def check(nums: Array[Int]): Boolean = {\n        \n    }\n}"
    },
    {
        "id": 1876,
        "name": "map-of-highest-peak",
        "difficulty": "Medium",
        "link": "https://leetcode.com/problems/map-of-highest-peak/",
        "task_description": "You are given an integer matrix `isWater` of size `m x n` that represents a map of **land** and **water** cells. If `isWater[i][j] == 0`, cell `(i, j)` is a **land** cell. If `isWater[i][j] == 1`, cell `(i, j)` is a **water** cell. You must assign each cell a height in a way that follows these rules: The height of each cell must be non-negative. If the cell is a **water** cell, its height must be `0`. Any two adjacent cells must have an absolute height difference of **at most** `1`. A cell is adjacent to another cell if the former is directly north, east, south, or west of the latter (i.e., their sides are touching). Find an assignment of heights such that the maximum height in the matrix is **maximized**. Return _an integer matrix _`height`_ of size _`m x n`_ where _`height[i][j]`_ is cell _`(i, j)`_'s height. If there are multiple solutions, return **any** of them_. **Example 1:** **** ``` **Input:** isWater = [[0,1],[0,0]] **Output:** [[1,0],[2,1]] **Explanation:** The image shows the assigned heights of each cell. The blue cell is the water cell, and the green cells are the land cells. ``` **Example 2:** **** ``` **Input:** isWater = [[0,0,1],[1,0,0],[0,0,0]] **Output:** [[1,1,0],[0,1,1],[1,2,2]] **Explanation:** A height of 2 is the maximum possible height of any assignment. Any height assignment that has a maximum height of 2 while still meeting the rules will also be accepted. ``` **Constraints:** `m == isWater.length` `n == isWater[i].length` `1 <= m, n <= 1000` `isWater[i][j]` is `0` or `1`. There is at least **one** water cell.",
        "test_case": [
            {
                "label": "Example 1",
                "input": "isWater = [[0,1],[0,0]]",
                "output": "[[1,0],[2,1]] Explanation: The image shows the assigned heights of each cell.\nThe blue cell is the water cell, and the green cells are the land cells."
            },
            {
                "label": "Example 2",
                "input": "isWater = [[0,0,1],[1,0,0],[0,0,0]]",
                "output": "[[1,1,0],[0,1,1],[1,2,2]] Explanation: A height of 2 is the maximum possible height of any assignment.\nAny height assignment that has a maximum height of 2 while still meeting the rules will also be accepted. Constraints: m == isWater.length n == isWater[i].length 1 <= m, n <= 1000 isWater[i][j] is 0 or 1 . There is at least one water cell."
            }
        ],
        "elixir_template": "defmodule Solution do\n  @spec highest_peak(is_water :: [[integer]]) :: [[integer]]\n  def highest_peak(is_water) do\n    \n  end\nend",
        "erlang_template": "-spec highest_peak(IsWater :: [[integer()]]) -> [[integer()]].\nhighest_peak(IsWater) ->\n  .",
        "scala_template": "object Solution {\n    def highestPeak(isWater: Array[Array[Int]]): Array[Array[Int]] = {\n        \n    }\n}"
    },
    {
        "id": 1875,
        "name": "tree-of-coprimes",
        "difficulty": "Hard",
        "link": "https://leetcode.com/problems/tree-of-coprimes/",
        "task_description": "There is a tree (i.e., a connected, undirected graph that has no cycles) consisting of `n` nodes numbered from `0` to `n - 1` and exactly `n - 1` edges. Each node has a value associated with it, and the **root** of the tree is node `0`. To represent this tree, you are given an integer array `nums` and a 2D array `edges`. Each `nums[i]` represents the `ith` node's value, and each `edges[j] = [uj, vj]` represents an edge between nodes `uj` and `vj` in the tree. Two values `x` and `y` are **coprime** if `gcd(x, y) == 1` where `gcd(x, y)` is the **greatest common divisor** of `x` and `y`. An ancestor of a node `i` is any other node on the shortest path from node `i` to the **root**. A node is **not **considered an ancestor of itself. Return _an array _`ans`_ of size _`n`, _where _`ans[i]`_ is the closest ancestor to node _`i`_ such that _`nums[i]` _and _`nums[ans[i]]` are **coprime**, or `-1`_ if there is no such ancestor_. **Example 1:** **** ``` **Input:** nums = [2,3,3,2], edges = [[0,1],[1,2],[1,3]] **Output:** [-1,0,0,1] **Explanation:** In the above figure, each node's value is in parentheses. - Node 0 has no coprime ancestors. - Node 1 has only one ancestor, node 0. Their values are coprime (gcd(2,3) == 1). - Node 2 has two ancestors, nodes 1 and 0. Node 1's value is not coprime (gcd(3,3) == 3), but node 0's value is (gcd(2,3) == 1), so node 0 is the closest valid ancestor. - Node 3 has two ancestors, nodes 1 and 0. It is coprime with node 1 (gcd(3,2) == 1), so node 1 is its closest valid ancestor. ``` **Example 2:** ``` **Input:** nums = [5,6,10,2,3,6,15], edges = [[0,1],[0,2],[1,3],[1,4],[2,5],[2,6]] **Output:** [-1,0,-1,0,0,0,-1] ``` **Constraints:** `nums.length == n` `1 <= nums[i] <= 50` `1 <= n <= 105` `edges.length == n - 1` `edges[j].length == 2` `0 <= uj, vj < n` `uj != vj`",
        "test_case": [
            {
                "label": "Example 1",
                "input": "nums = [2,3,3,2], edges = [[0,1],[1,2],[1,3]]",
                "output": "[-1,0,0,1] Explanation: In the above figure, each node's value is in parentheses.\n- Node 0 has no coprime ancestors.\n- Node 1 has only one ancestor, node 0. Their values are coprime (gcd(2,3) == 1).\n- Node 2 has two ancestors, nodes 1 and 0. Node 1's value is not coprime (gcd(3,3) == 3), but node 0's\n  value is (gcd(2,3) == 1), so node 0 is the closest valid ancestor.\n- Node 3 has two ancestors, nodes 1 and 0. It is coprime with node 1 (gcd(3,2) == 1), so node 1 is its\n  closest valid ancestor."
            },
            {
                "label": "Example 2",
                "input": "nums = [5,6,10,2,3,6,15], edges = [[0,1],[0,2],[1,3],[1,4],[2,5],[2,6]]",
                "output": "[-1,0,-1,0,0,0,-1] Constraints: nums.length == n 1 <= nums[i] <= 50 1 <= n <= 10 5 edges.length == n - 1 edges[j].length == 2 0 <= u j , v j < n u j != v j"
            }
        ],
        "elixir_template": "defmodule Solution do\n  @spec get_coprimes(nums :: [integer], edges :: [[integer]]) :: [integer]\n  def get_coprimes(nums, edges) do\n    \n  end\nend",
        "erlang_template": "-spec get_coprimes(Nums :: [integer()], Edges :: [[integer()]]) -> [integer()].\nget_coprimes(Nums, Edges) ->\n  .",
        "scala_template": "object Solution {\n    def getCoprimes(nums: Array[Int], edges: Array[Array[Int]]): Array[Int] = {\n        \n    }\n}"
    },
    {
        "id": 1874,
        "name": "form-array-by-concatenating-subarrays-of-another-array",
        "difficulty": "Medium",
        "link": "https://leetcode.com/problems/form-array-by-concatenating-subarrays-of-another-array/",
        "task_description": "You are given a 2D integer array `groups` of length `n`. You are also given an integer array `nums`. You are asked if you can choose `n` **disjoint **subarrays from the array `nums` such that the `ith` subarray is equal to `groups[i]` (0-indexed), and if `i > 0`, the `(i-1)th` subarray appears **before** the `ith` subarray in `nums` (i.e. the subarrays must be in the same order as `groups`). Return `true` _if you can do this task, and_ `false` _otherwise_. Note that the subarrays are **disjoint** if and only if there is no index `k` such that `nums[k]` belongs to more than one subarray. A subarray is a contiguous sequence of elements within an array. **Example 1:** ``` **Input:** groups = [[1,-1,-1],[3,-2,0]], nums = [1,-1,0,1,-1,-1,3,-2,0] **Output:** true **Explanation:** You can choose the 0th subarray as [1,-1,0,**1,-1,-1**,3,-2,0] and the 1st one as [1,-1,0,1,-1,-1,**3,-2,0**]. These subarrays are disjoint as they share no common nums[k] element. ``` **Example 2:** ``` **Input:** groups = [[10,-2],[1,2,3,4]], nums = [1,2,3,4,10,-2] **Output:** false **Explanation: **Note that choosing the subarrays [**1,2,3,4**,10,-2] and [1,2,3,4,**10,-2**] is incorrect because they are not in the same order as in groups. [10,-2] must come before [1,2,3,4]. ``` **Example 3:** ``` **Input:** groups = [[1,2,3],[3,4]], nums = [7,7,1,2,3,4,7,7] **Output:** false **Explanation: **Note that choosing the subarrays [7,7,**1,2,3**,4,7,7] and [7,7,1,2,**3,4**,7,7] is invalid because they are not disjoint. They share a common elements nums[4] (0-indexed). ``` **Constraints:** `groups.length == n` `1 <= n <= 103` `1 <= groups[i].length, sum(groups[i].length) <= 103` `1 <= nums.length <= 103` `-107 <= groups[i][j], nums[k] <= 107`",
        "test_case": [
            {
                "label": "Example 1",
                "input": "groups = [[1,-1,-1],[3,-2,0]], nums = [1,-1,0,1,-1,-1,3,-2,0]",
                "output": "true Explanation: You can choose the 0 th subarray as [1,-1,0, 1,-1,-1 ,3,-2,0] and the 1 st one as [1,-1,0,1,-1,-1, 3,-2,0 ].\nThese subarrays are disjoint as they share no common nums[k] element."
            },
            {
                "label": "Example 2",
                "input": "groups = [[10,-2],[1,2,3,4]], nums = [1,2,3,4,10,-2]",
                "output": "false Explanation: Note that choosing the subarrays [ 1,2,3,4 ,10,-2] and [1,2,3,4, 10,-2 ] is incorrect because they are not in the same order as in groups.\n[10,-2] must come before [1,2,3,4]."
            },
            {
                "label": "Example 3",
                "input": "groups = [[1,2,3],[3,4]], nums = [7,7,1,2,3,4,7,7]",
                "output": "false Explanation: Note that choosing the subarrays [7,7, 1,2,3 ,4,7,7] and [7,7,1,2, 3,4 ,7,7] is invalid because they are not disjoint.\nThey share a common elements nums[4] (0-indexed). Constraints: groups.length == n 1 <= n <= 10 3 1 <= groups[i].length, sum(groups[i].length) <= 10 3 1 <= nums.length <= 10 3 -10 7 <= groups[i][j], nums[k] <= 10 7"
            }
        ],
        "elixir_template": "defmodule Solution do\n  @spec can_choose(groups :: [[integer]], nums :: [integer]) :: boolean\n  def can_choose(groups, nums) do\n    \n  end\nend",
        "erlang_template": "-spec can_choose(Groups :: [[integer()]], Nums :: [integer()]) -> boolean().\ncan_choose(Groups, Nums) ->\n  .",
        "scala_template": "object Solution {\n    def canChoose(groups: Array[Array[Int]], nums: Array[Int]): Boolean = {\n        \n    }\n}"
    },
    {
        "id": 1873,
        "name": "longest-nice-substring",
        "difficulty": "Easy",
        "link": "https://leetcode.com/problems/longest-nice-substring/",
        "task_description": "A string `s` is **nice** if, for every letter of the alphabet that `s` contains, it appears **both** in uppercase and lowercase. For example, `\"abABB\"` is nice because `'A'` and `'a'` appear, and `'B'` and `'b'` appear. However, `\"abA\"` is not because `'b'` appears, but `'B'` does not. Given a string `s`, return _the longest **substring** of `s` that is **nice**. If there are multiple, return the substring of the **earliest** occurrence. If there are none, return an empty string_. **Example 1:** ``` **Input:** s = \"YazaAay\" **Output:** \"aAa\" **Explanation: **\"aAa\" is a nice string because 'A/a' is the only letter of the alphabet in s, and both 'A' and 'a' appear. \"aAa\" is the longest nice substring. ``` **Example 2:** ``` **Input:** s = \"Bb\" **Output:** \"Bb\" **Explanation:** \"Bb\" is a nice string because both 'B' and 'b' appear. The whole string is a substring. ``` **Example 3:** ``` **Input:** s = \"c\" **Output:** \"\" **Explanation:** There are no nice substrings. ``` **Constraints:** `1 <= s.length <= 100` `s` consists of uppercase and lowercase English letters.",
        "test_case": [
            {
                "label": "Example 1",
                "input": "s = \"YazaAay\"",
                "output": "\"aAa\" Explanation: \"aAa\" is a nice string because 'A/a' is the only letter of the alphabet in s, and both 'A' and 'a' appear.\n\"aAa\" is the longest nice substring."
            },
            {
                "label": "Example 2",
                "input": "s = \"Bb\"",
                "output": "\"Bb\" Explanation: \"Bb\" is a nice string because both 'B' and 'b' appear. The whole string is a substring."
            },
            {
                "label": "Example 3",
                "input": "s = \"c\"",
                "output": "\"\" Explanation: There are no nice substrings."
            }
        ],
        "elixir_template": "defmodule Solution do\n  @spec longest_nice_substring(s :: String.t) :: String.t\n  def longest_nice_substring(s) do\n    \n  end\nend",
        "erlang_template": "-spec longest_nice_substring(S :: unicode:unicode_binary()) -> unicode:unicode_binary().\nlongest_nice_substring(S) ->\n  .",
        "scala_template": "object Solution {\n    def longestNiceSubstring(s: String): String = {\n        \n    }\n}"
    },
    {
        "id": 1872,
        "name": "can-you-eat-your-favorite-candy-on-your-favorite-day",
        "difficulty": "Medium",
        "link": "https://leetcode.com/problems/can-you-eat-your-favorite-candy-on-your-favorite-day/",
        "task_description": "You are given a **(0-indexed)** array of positive integers `candiesCount` where `candiesCount[i]` represents the number of candies of the `ith` type you have. You are also given a 2D array `queries` where `queries[i] = [favoriteTypei, favoriteDayi, dailyCapi]`. You play a game with the following rules: You start eating candies on day `**0**`. You cannot eat **any** candy of type `i` unless you have eaten **all** candies of type `i - 1`. You must eat **at least** **one** candy per day until you have eaten all the candies. Construct a boolean array `answer` such that `answer.length == queries.length` and `answer[i]` is `true` if you can eat a candy of type `favoriteTypei` on day `favoriteDayi` without eating **more than** `dailyCapi` candies on **any** day, and `false` otherwise. Note that you can eat different types of candy on the same day, provided that you follow rule 2. Return _the constructed array _`answer`. **Example 1:** ``` **Input:** candiesCount = [7,4,5,3,8], queries = [[0,2,2],[4,2,4],[2,13,1000000000]] **Output:** [true,false,true] **Explanation:** 1- If you eat 2 candies (type 0) on day 0 and 2 candies (type 0) on day 1, you will eat a candy of type 0 on day 2. 2- You can eat at most 4 candies each day. If you eat 4 candies every day, you will eat 4 candies (type 0) on day 0 and 4 candies (type 0 and type 1) on day 1. On day 2, you can only eat 4 candies (type 1 and type 2), so you cannot eat a candy of type 4 on day 2. 3- If you eat 1 candy each day, you will eat a candy of type 2 on day 13. ``` **Example 2:** ``` **Input:** candiesCount = [5,2,6,4,1], queries = [[3,1,2],[4,10,3],[3,10,100],[4,100,30],[1,3,1]] **Output:** [false,true,true,false,false] ``` **Constraints:** `1 <= candiesCount.length <= 105` `1 <= candiesCount[i] <= 105` `1 <= queries.length <= 105` `queries[i].length == 3` `0 <= favoriteTypei < candiesCount.length` `0 <= favoriteDayi <= 109` `1 <= dailyCapi <= 109`",
        "test_case": [
            {
                "label": "Example 1",
                "input": "candiesCount = [7,4,5,3,8], queries = [[0,2,2],[4,2,4],[2,13,1000000000]]",
                "output": "[true,false,true] Explanation: 1- If you eat 2 candies (type 0) on day 0 and 2 candies (type 0) on day 1, you will eat a candy of type 0 on day 2.\n2- You can eat at most 4 candies each day.\n   If you eat 4 candies every day, you will eat 4 candies (type 0) on day 0 and 4 candies (type 0 and type 1) on day 1.\n   On day 2, you can only eat 4 candies (type 1 and type 2), so you cannot eat a candy of type 4 on day 2.\n3- If you eat 1 candy each day, you will eat a candy of type 2 on day 13."
            },
            {
                "label": "Example 2",
                "input": "candiesCount = [5,2,6,4,1], queries = [[3,1,2],[4,10,3],[3,10,100],[4,100,30],[1,3,1]]",
                "output": "[false,true,true,false,false]"
            }
        ],
        "elixir_template": "defmodule Solution do\n  @spec can_eat(candies_count :: [integer], queries :: [[integer]]) :: [boolean]\n  def can_eat(candies_count, queries) do\n    \n  end\nend",
        "erlang_template": "-spec can_eat(CandiesCount :: [integer()], Queries :: [[integer()]]) -> [boolean()].\ncan_eat(CandiesCount, Queries) ->\n  .",
        "scala_template": "object Solution {\n    def canEat(candiesCount: Array[Int], queries: Array[Array[Int]]): Array[Boolean] = {\n        \n    }\n}"
    },
    {
        "id": 1871,
        "name": "palindrome-partitioning-iv",
        "difficulty": "Hard",
        "link": "https://leetcode.com/problems/palindrome-partitioning-iv/",
        "task_description": "Given a string `s`, return `true` _if it is possible to split the string_ `s` _into three **non-empty** palindromic substrings. Otherwise, return _`false`.\u200b\u200b\u200b\u200b\u200b A string is said to be palindrome if it the same string when reversed. **Example 1:** ``` **Input:** s = \"abcbdd\" **Output:** true **Explanation: **\"abcbdd\" = \"a\" + \"bcb\" + \"dd\", and all three substrings are palindromes. ``` **Example 2:** ``` **Input:** s = \"bcbddxy\" **Output:** false **Explanation: **s cannot be split into 3 palindromes. ``` **Constraints:** `3 <= s.length <= 2000` `s`\u200b\u200b\u200b\u200b\u200b\u200b consists only of lowercase English letters.",
        "test_case": [
            {
                "label": "Example 1",
                "input": "s = \"abcbdd\"",
                "output": "true Explanation: \"abcbdd\" = \"a\" + \"bcb\" + \"dd\", and all three substrings are palindromes."
            },
            {
                "label": "Example 2",
                "input": "s = \"bcbddxy\"",
                "output": "false Explanation: s cannot be split into 3 palindromes."
            }
        ],
        "elixir_template": "defmodule Solution do\n  @spec check_partitioning(s :: String.t) :: boolean\n  def check_partitioning(s) do\n    \n  end\nend",
        "erlang_template": "-spec check_partitioning(S :: unicode:unicode_binary()) -> boolean().\ncheck_partitioning(S) ->\n  .",
        "scala_template": "object Solution {\n    def checkPartitioning(s: String): Boolean = {\n        \n    }\n}"
    },
    {
        "id": 1866,
        "name": "restore-the-array-from-adjacent-pairs",
        "difficulty": "Medium",
        "link": "https://leetcode.com/problems/restore-the-array-from-adjacent-pairs/",
        "task_description": "There is an integer array `nums` that consists of `n` **unique **elements, but you have forgotten it. However, you do remember every pair of adjacent elements in `nums`. You are given a 2D integer array `adjacentPairs` of size `n - 1` where each `adjacentPairs[i] = [ui, vi]` indicates that the elements `ui` and `vi` are adjacent in `nums`. It is guaranteed that every adjacent pair of elements `nums[i]` and `nums[i+1]` will exist in `adjacentPairs`, either as `[nums[i], nums[i+1]]` or `[nums[i+1], nums[i]]`. The pairs can appear **in any order**. Return _the original array _`nums`_. If there are multiple solutions, return **any of them**_. **Example 1:** ``` **Input:** adjacentPairs = [[2,1],[3,4],[3,2]] **Output:** [1,2,3,4] **Explanation:** This array has all its adjacent pairs in adjacentPairs. Notice that adjacentPairs[i] may not be in left-to-right order. ``` **Example 2:** ``` **Input:** adjacentPairs = [[4,-2],[1,4],[-3,1]] **Output:** [-2,4,1,-3] **Explanation:** There can be negative numbers. Another solution is [-3,1,4,-2], which would also be accepted. ``` **Example 3:** ``` **Input:** adjacentPairs = [[100000,-100000]] **Output:** [100000,-100000] ``` **Constraints:** `nums.length == n` `adjacentPairs.length == n - 1` `adjacentPairs[i].length == 2` `2 <= n <= 105` `-105 <= nums[i], ui, vi <= 105` There exists some `nums` that has `adjacentPairs` as its pairs.",
        "test_case": [
            {
                "label": "Example 1",
                "input": "adjacentPairs = [[2,1],[3,4],[3,2]]",
                "output": "[1,2,3,4] Explanation: This array has all its adjacent pairs in adjacentPairs.\nNotice that adjacentPairs[i] may not be in left-to-right order."
            },
            {
                "label": "Example 2",
                "input": "adjacentPairs = [[4,-2],[1,4],[-3,1]]",
                "output": "[-2,4,1,-3] Explanation: There can be negative numbers.\nAnother solution is [-3,1,4,-2], which would also be accepted."
            },
            {
                "label": "Example 3",
                "input": "adjacentPairs = [[100000,-100000]]",
                "output": "[100000,-100000] Constraints: nums.length == n adjacentPairs.length == n - 1 adjacentPairs[i].length == 2 2 <= n <= 10 5 -10 5 <= nums[i], u i , v i <= 10 5 There exists some nums that has adjacentPairs as its pairs."
            }
        ],
        "elixir_template": "defmodule Solution do\n  @spec restore_array(adjacent_pairs :: [[integer]]) :: [integer]\n  def restore_array(adjacent_pairs) do\n    \n  end\nend",
        "erlang_template": "-spec restore_array(AdjacentPairs :: [[integer()]]) -> [integer()].\nrestore_array(AdjacentPairs) ->\n  .",
        "scala_template": "object Solution {\n    def restoreArray(adjacentPairs: Array[Array[Int]]): Array[Int] = {\n        \n    }\n}"
    },
    {
        "id": 1861,
        "name": "building-boxes",
        "difficulty": "Hard",
        "link": "https://leetcode.com/problems/building-boxes/",
        "task_description": "You have a cubic storeroom where the width, length, and height of the room are all equal to `n` units. You are asked to place `n` boxes in this room where each box is a cube of unit side length. There are however some rules to placing the boxes: You can place the boxes anywhere on the floor. If box `x` is placed on top of the box `y`, then each side of the four vertical sides of the box `y` **must** either be adjacent to another box or to a wall. Given an integer `n`, return_ the **minimum** possible number of boxes touching the floor._ **Example 1:** ``` **Input:** n = 3 **Output:** 3 **Explanation:** The figure above is for the placement of the three boxes. These boxes are placed in the corner of the room, where the corner is on the left side. ``` **Example 2:** ``` **Input:** n = 4 **Output:** 3 **Explanation:** The figure above is for the placement of the four boxes. These boxes are placed in the corner of the room, where the corner is on the left side. ``` **Example 3:** ``` **Input:** n = 10 **Output:** 6 **Explanation:** The figure above is for the placement of the ten boxes. These boxes are placed in the corner of the room, where the corner is on the back side. ``` **Constraints:** `1 <= n <= 109`",
        "test_case": [
            {
                "label": "Example 1",
                "input": "n = 3",
                "output": "3 Explanation: The figure above is for the placement of the three boxes.\nThese boxes are placed in the corner of the room, where the corner is on the left side."
            },
            {
                "label": "Example 2",
                "input": "n = 4",
                "output": "3 Explanation: The figure above is for the placement of the four boxes.\nThese boxes are placed in the corner of the room, where the corner is on the left side."
            },
            {
                "label": "Example 3",
                "input": "n = 10",
                "output": "6 Explanation: The figure above is for the placement of the ten boxes.\nThese boxes are placed in the corner of the room, where the corner is on the back side."
            }
        ],
        "elixir_template": "defmodule Solution do\n  @spec minimum_boxes(n :: integer) :: integer\n  def minimum_boxes(n) do\n    \n  end\nend",
        "erlang_template": "-spec minimum_boxes(N :: integer()) -> integer().\nminimum_boxes(N) ->\n  .",
        "scala_template": "object Solution {\n    def minimumBoxes(n: Int): Int = {\n        \n    }\n}"
    },
    {
        "id": 1860,
        "name": "find-kth-largest-xor-coordinate-value",
        "difficulty": "Medium",
        "link": "https://leetcode.com/problems/find-kth-largest-xor-coordinate-value/",
        "task_description": "You are given a 2D `matrix` of size `m x n`, consisting of non-negative integers. You are also given an integer `k`. The **value** of coordinate `(a, b)` of the matrix is the XOR of all `matrix[i][j]` where `0 <= i <= a < m` and `0 <= j <= b < n` **(0-indexed)**. Find the `kth` largest value **(1-indexed)** of all the coordinates of `matrix`. **Example 1:** ``` **Input:** matrix = [[5,2],[1,6]], k = 1 **Output:** 7 **Explanation:** The value of coordinate (0,1) is 5 XOR 2 = 7, which is the largest value. ``` **Example 2:** ``` **Input:** matrix = [[5,2],[1,6]], k = 2 **Output:** 5 **Explanation:** The value of coordinate (0,0) is 5 = 5, which is the 2nd largest value. ``` **Example 3:** ``` **Input:** matrix = [[5,2],[1,6]], k = 3 **Output:** 4 **Explanation:** The value of coordinate (1,0) is 5 XOR 1 = 4, which is the 3rd largest value. ``` **Constraints:** `m == matrix.length` `n == matrix[i].length` `1 <= m, n <= 1000` `0 <= matrix[i][j] <= 106` `1 <= k <= m * n`",
        "test_case": [
            {
                "label": "Example 1",
                "input": "matrix = [[5,2],[1,6]], k = 1",
                "output": "7 Explanation: The value of coordinate (0,1) is 5 XOR 2 = 7, which is the largest value."
            },
            {
                "label": "Example 2",
                "input": "matrix = [[5,2],[1,6]], k = 2",
                "output": "5 Explanation: The value of coordinate (0,0) is 5 = 5, which is the 2nd largest value."
            },
            {
                "label": "Example 3",
                "input": "matrix = [[5,2],[1,6]], k = 3",
                "output": "4 Explanation: The value of coordinate (1,0) is 5 XOR 1 = 4, which is the 3rd largest value. Constraints: m == matrix.length n == matrix[i].length 1 <= m, n <= 1000 0 <= matrix[i][j] <= 10 6 1 <= k <= m * n"
            }
        ],
        "elixir_template": "defmodule Solution do\n  @spec kth_largest_value(matrix :: [[integer]], k :: integer) :: integer\n  def kth_largest_value(matrix, k) do\n    \n  end\nend",
        "erlang_template": "-spec kth_largest_value(Matrix :: [[integer()]], K :: integer()) -> integer().\nkth_largest_value(Matrix, K) ->\n  .",
        "scala_template": "object Solution {\n    def kthLargestValue(matrix: Array[Array[Int]], k: Int): Int = {\n        \n    }\n}"
    },
    {
        "id": 1859,
        "name": "change-minimum-characters-to-satisfy-one-of-three-conditions",
        "difficulty": "Medium",
        "link": "https://leetcode.com/problems/change-minimum-characters-to-satisfy-one-of-three-conditions/",
        "task_description": "You are given two strings `a` and `b` that consist of lowercase letters. In one operation, you can change any character in `a` or `b` to **any lowercase letter**. Your goal is to satisfy **one** of the following three conditions: **Every** letter in `a` is **strictly less** than **every** letter in `b` in the alphabet. **Every** letter in `b` is **strictly less** than **every** letter in `a` in the alphabet. **Both** `a` and `b` consist of **only one** distinct letter. Return _the **minimum** number of operations needed to achieve your goal._ **Example 1:** ``` **Input:** a = \"aba\", b = \"caa\" **Output:** 2 **Explanation:** Consider the best way to make each condition true: 1) Change b to \"ccc\" in 2 operations, then every letter in a is less than every letter in b. 2) Change a to \"bbb\" and b to \"aaa\" in 3 operations, then every letter in b is less than every letter in a. 3) Change a to \"aaa\" and b to \"aaa\" in 2 operations, then a and b consist of one distinct letter. The best way was done in 2 operations (either condition 1 or condition 3). ``` **Example 2:** ``` **Input:** a = \"dabadd\", b = \"cda\" **Output:** 3 **Explanation:** The best way is to make condition 1 true by changing b to \"eee\". ``` **Constraints:** `1 <= a.length, b.length <= 105` `a` and `b` consist only of lowercase letters.",
        "test_case": [
            {
                "label": "Example 1",
                "input": "a = \"aba\", b = \"caa\"",
                "output": "2 Explanation: Consider the best way to make each condition true:\n1) Change b to \"ccc\" in 2 operations, then every letter in a is less than every letter in b.\n2) Change a to \"bbb\" and b to \"aaa\" in 3 operations, then every letter in b is less than every letter in a.\n3) Change a to \"aaa\" and b to \"aaa\" in 2 operations, then a and b consist of one distinct letter.\nThe best way was done in 2 operations (either condition 1 or condition 3)."
            },
            {
                "label": "Example 2",
                "input": "a = \"dabadd\", b = \"cda\"",
                "output": "3 Explanation: The best way is to make condition 1 true by changing b to \"eee\"."
            }
        ],
        "elixir_template": "defmodule Solution do\n  @spec min_characters(a :: String.t, b :: String.t) :: integer\n  def min_characters(a, b) do\n    \n  end\nend",
        "erlang_template": "-spec min_characters(A :: unicode:unicode_binary(), B :: unicode:unicode_binary()) -> integer().\nmin_characters(A, B) ->\n  .",
        "scala_template": "object Solution {\n    def minCharacters(a: String, b: String): Int = {\n        \n    }\n}"
    },
    {
        "id": 1858,
        "name": "latest-time-by-replacing-hidden-digits",
        "difficulty": "Easy",
        "link": "https://leetcode.com/problems/latest-time-by-replacing-hidden-digits/",
        "task_description": "You are given a string `time` in the form of ` hh:mm`, where some of the digits in the string are hidden (represented by `?`). The valid times are those inclusively between `00:00` and `23:59`. Return _the latest valid time you can get from_ `time`_ by replacing the hidden_ _digits_. **Example 1:** ``` **Input:** time = \"2?:?0\" **Output:** \"23:50\" **Explanation:** The latest hour beginning with the digit '2' is 23 and the latest minute ending with the digit '0' is 50. ``` **Example 2:** ``` **Input:** time = \"0?:3?\" **Output:** \"09:39\" ``` **Example 3:** ``` **Input:** time = \"1?:22\" **Output:** \"19:22\" ``` **Constraints:** `time` is in the format `hh:mm`. It is guaranteed that you can produce a valid time from the given string.",
        "test_case": [
            {
                "label": "Example 1",
                "input": "time = \"2?:?0\"",
                "output": "\"23:50\" Explanation: The latest hour beginning with the digit '2' is 23 and the latest minute ending with the digit '0' is 50."
            },
            {
                "label": "Example 2",
                "input": "time = \"0?:3?\"",
                "output": "\"09:39\""
            },
            {
                "label": "Example 3",
                "input": "time = \"1?:22\"",
                "output": "\"19:22\" Constraints: time is in the format hh:mm . It is guaranteed that you can produce a valid time from the given string."
            }
        ],
        "elixir_template": "defmodule Solution do\n  @spec maximum_time(time :: String.t) :: String.t\n  def maximum_time(time) do\n    \n  end\nend",
        "erlang_template": "-spec maximum_time(Time :: unicode:unicode_binary()) -> unicode:unicode_binary().\nmaximum_time(Time) ->\n  .",
        "scala_template": "object Solution {\n    def maximumTime(time: String): String = {\n        \n    }\n}"
    },
    {
        "id": 1851,
        "name": "maximum-number-of-events-that-can-be-attended-ii",
        "difficulty": "Hard",
        "link": "https://leetcode.com/problems/maximum-number-of-events-that-can-be-attended-ii/",
        "task_description": "You are given an array of `events` where `events[i] = [startDayi, endDayi, valuei]`. The `ith` event starts at `startDayi` and ends at `endDayi`, and if you attend this event, you will receive a value of `valuei`. You are also given an integer `k` which represents the maximum number of events you can attend. You can only attend one event at a time. If you choose to attend an event, you must attend the **entire** event. Note that the end day is **inclusive**: that is, you cannot attend two events where one of them starts and the other ends on the same day. Return _the **maximum sum** of values that you can receive by attending events._ **Example 1:** ``` **Input:** events = [[1,2,4],[3,4,3],[2,3,1]], k = 2 **Output:** 7 **Explanation: **Choose the green events, 0 and 1 (0-indexed) for a total value of 4 + 3 = 7. ``` **Example 2:** ``` **Input:** events = [[1,2,4],[3,4,3],[2,3,10]], k = 2 **Output:** 10 **Explanation:** Choose event 2 for a total value of 10. Notice that you cannot attend any other event as they overlap, and that you do **not** have to attend k events. ``` **Example 3:** **** ``` **Input:** events = [[1,1,1],[2,2,2],[3,3,3],[4,4,4]], k = 3 **Output:** 9 **Explanation:** Although the events do not overlap, you can only attend 3 events. Pick the highest valued three. ``` **Constraints:** `1 <= k <= events.length` `1 <= k * events.length <= 106` `1 <= startDayi <= endDayi <= 109` `1 <= valuei <= 106`",
        "test_case": [
            {
                "label": "Example 1",
                "input": "events = [[1,2,4],[3,4,3],[2,3,1]], k = 2",
                "output": "7 Explanation: Choose the green events, 0 and 1 (0-indexed) for a total value of 4 + 3 = 7."
            },
            {
                "label": "Example 2",
                "input": "events = [[1,2,4],[3,4,3],[2,3,10]], k = 2",
                "output": "10 Explanation: Choose event 2 for a total value of 10.\nNotice that you cannot attend any other event as they overlap, and that you do not have to attend k events."
            },
            {
                "label": "Example 3",
                "input": "events = [[1,1,1],[2,2,2],[3,3,3],[4,4,4]], k = 3",
                "output": "9 Explanation: Although the events do not overlap, you can only attend 3 events. Pick the highest valued three."
            }
        ],
        "elixir_template": "defmodule Solution do\n  @spec max_value(events :: [[integer]], k :: integer) :: integer\n  def max_value(events, k) do\n    \n  end\nend",
        "erlang_template": "-spec max_value(Events :: [[integer()]], K :: integer()) -> integer().\nmax_value(Events, K) ->\n  .",
        "scala_template": "object Solution {\n    def maxValue(events: Array[Array[Int]], k: Int): Int = {\n        \n    }\n}"
    },
    {
        "id": 1850,
        "name": "minimum-length-of-string-after-deleting-similar-ends",
        "difficulty": "Medium",
        "link": "https://leetcode.com/problems/minimum-length-of-string-after-deleting-similar-ends/",
        "task_description": "Given a string `s` consisting only of characters `'a'`, `'b'`, and `'c'`. You are asked to apply the following algorithm on the string any number of times: Pick a **non-empty** prefix from the string `s` where all the characters in the prefix are equal. Pick a **non-empty** suffix from the string `s` where all the characters in this suffix are equal. The prefix and the suffix should not intersect at any index. The characters from the prefix and suffix must be the same. Delete both the prefix and the suffix. Return _the **minimum length** of _`s` _after performing the above operation any number of times (possibly zero times)_. **Example 1:** ``` **Input:** s = \"ca\" **Output:** 2 **Explanation: **You can't remove any characters, so the string stays as is. ``` **Example 2:** ``` **Input:** s = \"cabaabac\" **Output:** 0 **Explanation:** An optimal sequence of operations is: - Take prefix = \"c\" and suffix = \"c\" and remove them, s = \"abaaba\". - Take prefix = \"a\" and suffix = \"a\" and remove them, s = \"baab\". - Take prefix = \"b\" and suffix = \"b\" and remove them, s = \"aa\". - Take prefix = \"a\" and suffix = \"a\" and remove them, s = \"\". ``` **Example 3:** ``` **Input:** s = \"aabccabba\" **Output:** 3 **Explanation:** An optimal sequence of operations is: - Take prefix = \"aa\" and suffix = \"a\" and remove them, s = \"bccabb\". - Take prefix = \"b\" and suffix = \"bb\" and remove them, s = \"cca\". ``` **Constraints:** `1 <= s.length <= 105` `s` only consists of characters `'a'`, `'b'`, and `'c'`.",
        "test_case": [
            {
                "label": "Example 1",
                "input": "s = \"ca\"",
                "output": "2 Explanation: You can't remove any characters, so the string stays as is."
            },
            {
                "label": "Example 2",
                "input": "s = \"cabaabac\"",
                "output": "0 Explanation: An optimal sequence of operations is:\n- Take prefix = \"c\" and suffix = \"c\" and remove them, s = \"abaaba\".\n- Take prefix = \"a\" and suffix = \"a\" and remove them, s = \"baab\".\n- Take prefix = \"b\" and suffix = \"b\" and remove them, s = \"aa\".\n- Take prefix = \"a\" and suffix = \"a\" and remove them, s = \"\"."
            },
            {
                "label": "Example 3",
                "input": "s = \"aabccabba\"",
                "output": "3 Explanation: An optimal sequence of operations is:\n- Take prefix = \"aa\" and suffix = \"a\" and remove them, s = \"bccabb\".\n- Take prefix = \"b\" and suffix = \"bb\" and remove them, s = \"cca\"."
            }
        ],
        "elixir_template": "defmodule Solution do\n  @spec minimum_length(s :: String.t) :: integer\n  def minimum_length(s) do\n    \n  end\nend",
        "erlang_template": "-spec minimum_length(S :: unicode:unicode_binary()) -> integer().\nminimum_length(S) ->\n  .",
        "scala_template": "object Solution {\n    def minimumLength(s: String): Int = {\n        \n    }\n}"
    },
    {
        "id": 1849,
        "name": "maximum-absolute-sum-of-any-subarray",
        "difficulty": "Medium",
        "link": "https://leetcode.com/problems/maximum-absolute-sum-of-any-subarray/",
        "task_description": "You are given an integer array `nums`. The **absolute sum** of a subarray `[numsl, numsl+1, ..., numsr-1, numsr]` is `abs(numsl + numsl+1 + ... + numsr-1 + numsr)`. Return _the **maximum** absolute sum of any **(possibly empty)** subarray of _`nums`. Note that `abs(x)` is defined as follows: If `x` is a negative integer, then `abs(x) = -x`. If `x` is a non-negative integer, then `abs(x) = x`. **Example 1:** ``` **Input:** nums = [1,-3,2,3,-4] **Output:** 5 **Explanation:** The subarray [2,3] has absolute sum = abs(2+3) = abs(5) = 5. ``` **Example 2:** ``` **Input:** nums = [2,-5,1,-4,3,-2] **Output:** 8 **Explanation:** The subarray [-5,1,-4] has absolute sum = abs(-5+1-4) = abs(-8) = 8. ``` **Constraints:** `1 <= nums.length <= 105` `-104 <= nums[i] <= 104`",
        "test_case": [
            {
                "label": "Example 1",
                "input": "nums = [1,-3,2,3,-4]",
                "output": "5 Explanation: The subarray [2,3] has absolute sum = abs(2+3) = abs(5) = 5."
            },
            {
                "label": "Example 2",
                "input": "nums = [2,-5,1,-4,3,-2]",
                "output": "8 Explanation: The subarray [-5,1,-4] has absolute sum = abs(-5+1-4) = abs(-8) = 8."
            }
        ],
        "elixir_template": "defmodule Solution do\n  @spec max_absolute_sum(nums :: [integer]) :: integer\n  def max_absolute_sum(nums) do\n    \n  end\nend",
        "erlang_template": "-spec max_absolute_sum(Nums :: [integer()]) -> integer().\nmax_absolute_sum(Nums) ->\n  .",
        "scala_template": "object Solution {\n    def maxAbsoluteSum(nums: Array[Int]): Int = {\n        \n    }\n}"
    },
    {
        "id": 1848,
        "name": "sum-of-unique-elements",
        "difficulty": "Easy",
        "link": "https://leetcode.com/problems/sum-of-unique-elements/",
        "task_description": "You are given an integer array `nums`. The unique elements of an array are the elements that appear **exactly once** in the array. Return _the **sum** of all the unique elements of _`nums`. **Example 1:** ``` **Input:** nums = [1,2,3,2] **Output:** 4 **Explanation:** The unique elements are [1,3], and the sum is 4. ``` **Example 2:** ``` **Input:** nums = [1,1,1,1,1] **Output:** 0 **Explanation:** There are no unique elements, and the sum is 0. ``` **Example 3:** ``` **Input:** nums = [1,2,3,4,5] **Output:** 15 **Explanation:** The unique elements are [1,2,3,4,5], and the sum is 15. ``` **Constraints:** `1 <= nums.length <= 100` `1 <= nums[i] <= 100`",
        "test_case": [
            {
                "label": "Example 1",
                "input": "nums = [1,2,3,2]",
                "output": "4 Explanation: The unique elements are [1,3], and the sum is 4."
            },
            {
                "label": "Example 2",
                "input": "nums = [1,1,1,1,1]",
                "output": "0 Explanation: There are no unique elements, and the sum is 0."
            },
            {
                "label": "Example 3",
                "input": "nums = [1,2,3,4,5]",
                "output": "15 Explanation: The unique elements are [1,2,3,4,5], and the sum is 15."
            }
        ],
        "elixir_template": "defmodule Solution do\n  @spec sum_of_unique(nums :: [integer]) :: integer\n  def sum_of_unique(nums) do\n    \n  end\nend",
        "erlang_template": "-spec sum_of_unique(Nums :: [integer()]) -> integer().\nsum_of_unique(Nums) ->\n  .",
        "scala_template": "object Solution {\n    def sumOfUnique(nums: Array[Int]): Int = {\n        \n    }\n}"
    },
    {
        "id": 1845,
        "name": "largest-submatrix-with-rearrangements",
        "difficulty": "Medium",
        "link": "https://leetcode.com/problems/largest-submatrix-with-rearrangements/",
        "task_description": "You are given a binary matrix `matrix` of size `m x n`, and you are allowed to rearrange the **columns** of the `matrix` in any order. Return _the area of the largest submatrix within _`matrix`_ where **every** element of the submatrix is _`1`_ after reordering the columns optimally._ **Example 1:** ``` **Input:** matrix = [[0,0,1],[1,1,1],[1,0,1]] **Output:** 4 **Explanation:** You can rearrange the columns as shown above. The largest submatrix of 1s, in bold, has an area of 4. ``` **Example 2:** ``` **Input:** matrix = [[1,0,1,0,1]] **Output:** 3 **Explanation:** You can rearrange the columns as shown above. The largest submatrix of 1s, in bold, has an area of 3. ``` **Example 3:** ``` **Input:** matrix = [[1,1,0],[1,0,1]] **Output:** 2 **Explanation:** Notice that you must rearrange entire columns, and there is no way to make a submatrix of 1s larger than an area of 2. ``` **Constraints:** `m == matrix.length` `n == matrix[i].length` `1 <= m * n <= 105` `matrix[i][j]` is either `0` or `1`.",
        "test_case": [
            {
                "label": "Example 1",
                "input": "matrix = [[0,0,1],[1,1,1],[1,0,1]]",
                "output": "4 Explanation: You can rearrange the columns as shown above.\nThe largest submatrix of 1s, in bold, has an area of 4."
            },
            {
                "label": "Example 2",
                "input": "matrix = [[1,0,1,0,1]]",
                "output": "3 Explanation: You can rearrange the columns as shown above.\nThe largest submatrix of 1s, in bold, has an area of 3."
            },
            {
                "label": "Example 3",
                "input": "matrix = [[1,1,0],[1,0,1]]",
                "output": "2 Explanation: Notice that you must rearrange entire columns, and there is no way to make a submatrix of 1s larger than an area of 2. Constraints: m == matrix.length n == matrix[i].length 1 <= m * n <= 10 5 matrix[i][j] is either 0 or 1 ."
            }
        ],
        "elixir_template": "defmodule Solution do\n  @spec largest_submatrix(matrix :: [[integer]]) :: integer\n  def largest_submatrix(matrix) do\n    \n  end\nend",
        "erlang_template": "-spec largest_submatrix(Matrix :: [[integer()]]) -> integer().\nlargest_submatrix(Matrix) ->\n  .",
        "scala_template": "object Solution {\n    def largestSubmatrix(matrix: Array[Array[Int]]): Int = {\n        \n    }\n}"
    },
    {
        "id": 1844,
        "name": "maximum-number-of-balls-in-a-box",
        "difficulty": "Easy",
        "link": "https://leetcode.com/problems/maximum-number-of-balls-in-a-box/",
        "task_description": "You are working in a ball factory where you have `n` balls numbered from `lowLimit` up to `highLimit` **inclusive** (i.e., `n == highLimit - lowLimit + 1`), and an infinite number of boxes numbered from `1` to `infinity`. Your job at this factory is to put each ball in the box with a number equal to the sum of digits of the ball's number. For example, the ball number `321` will be put in the box number `3 + 2 + 1 = 6` and the ball number `10` will be put in the box number `1 + 0 = 1`. Given two integers `lowLimit` and `highLimit`, return_ the number of balls in the box with the most balls._ **Example 1:** ``` **Input:** lowLimit = 1, highLimit = 10 **Output:** 2 **Explanation:** Box Number: 1 2 3 4 5 6 7 8 9 10 11 ... Ball Count: 2 1 1 1 1 1 1 1 1 0 0 ... Box 1 has the most number of balls with 2 balls. ``` **Example 2:** ``` **Input:** lowLimit = 5, highLimit = 15 **Output:** 2 **Explanation:** Box Number: 1 2 3 4 5 6 7 8 9 10 11 ... Ball Count: 1 1 1 1 2 2 1 1 1 0 0 ... Boxes 5 and 6 have the most number of balls with 2 balls in each. ``` **Example 3:** ``` **Input:** lowLimit = 19, highLimit = 28 **Output:** 2 **Explanation:** Box Number: 1 2 3 4 5 6 7 8 9 10 11 12 ... Ball Count: 0 1 1 1 1 1 1 1 1 2 0 0 ... Box 10 has the most number of balls with 2 balls. ``` **Constraints:** `1 <= lowLimit <= highLimit <= 105`",
        "test_case": [
            {
                "label": "Example 1",
                "input": "lowLimit = 1, highLimit = 10",
                "output": "2 Explanation: Box Number:  1 2 3 4 5 6 7 8 9 10 11 ...\nBall Count:  2 1 1 1 1 1 1 1 1 0  0  ...\nBox 1 has the most number of balls with 2 balls."
            },
            {
                "label": "Example 2",
                "input": "lowLimit = 5, highLimit = 15",
                "output": "2 Explanation: Box Number:  1 2 3 4 5 6 7 8 9 10 11 ...\nBall Count:  1 1 1 1 2 2 1 1 1 0  0  ...\nBoxes 5 and 6 have the most number of balls with 2 balls in each."
            },
            {
                "label": "Example 3",
                "input": "lowLimit = 19, highLimit = 28",
                "output": "2 Explanation: Box Number:  1 2 3 4 5 6 7 8 9 10 11 12 ...\nBall Count:  0 1 1 1 1 1 1 1 1 2  0  0  ...\nBox 10 has the most number of balls with 2 balls."
            }
        ],
        "elixir_template": "defmodule Solution do\n  @spec count_balls(low_limit :: integer, high_limit :: integer) :: integer\n  def count_balls(low_limit, high_limit) do\n    \n  end\nend",
        "erlang_template": "-spec count_balls(LowLimit :: integer(), HighLimit :: integer()) -> integer().\ncount_balls(LowLimit, HighLimit) ->\n  .",
        "scala_template": "object Solution {\n    def countBalls(lowLimit: Int, highLimit: Int): Int = {\n        \n    }\n}"
    },
    {
        "id": 1843,
        "name": "number-of-rectangles-that-can-form-the-largest-square",
        "difficulty": "Easy",
        "link": "https://leetcode.com/problems/number-of-rectangles-that-can-form-the-largest-square/",
        "task_description": "You are given an array `rectangles` where `rectangles[i] = [li, wi]` represents the `ith` rectangle of length `li` and width `wi`. You can cut the `ith` rectangle to form a square with a side length of `k` if both `k <= li` and `k <= wi`. For example, if you have a rectangle `[4,6]`, you can cut it to get a square with a side length of at most `4`. Let `maxLen` be the side length of the **largest** square you can obtain from any of the given rectangles. Return _the **number** of rectangles that can make a square with a side length of _`maxLen`. **Example 1:** ``` **Input:** rectangles = [[5,8],[3,9],[5,12],[16,5]] **Output:** 3 **Explanation:** The largest squares you can get from each rectangle are of lengths [5,3,5,5]. The largest possible square is of length 5, and you can get it out of 3 rectangles. ``` **Example 2:** ``` **Input:** rectangles = [[2,3],[3,7],[4,3],[3,7]] **Output:** 3 ``` **Constraints:** `1 <= rectangles.length <= 1000` `rectangles[i].length == 2` `1 <= li, wi <= 109` `li != wi`",
        "test_case": [
            {
                "label": "Example 1",
                "input": "rectangles = [[5,8],[3,9],[5,12],[16,5]]",
                "output": "3 Explanation: The largest squares you can get from each rectangle are of lengths [5,3,5,5].\r\nThe largest possible square is of length 5, and you can get it out of 3 rectangles."
            },
            {
                "label": "Example 2",
                "input": "rectangles = [[2,3],[3,7],[4,3],[3,7]]",
                "output": "3"
            }
        ],
        "elixir_template": "Elixir code template not available for this problem.",
        "erlang_template": "Elixir code template not available for this problem.",
        "scala_template": "object Solution {\n    def countGoodRectangles(rectangles: Array[Array[Int]]): Int = {\n        \n    }\n}"
    },
    {
        "id": 1840,
        "name": "minimize-hamming-distance-after-swap-operations",
        "difficulty": "Medium",
        "link": "https://leetcode.com/problems/minimize-hamming-distance-after-swap-operations/",
        "task_description": "You are given two integer arrays, `source` and `target`, both of length `n`. You are also given an array `allowedSwaps` where each `allowedSwaps[i] = [ai, bi]` indicates that you are allowed to swap the elements at index `ai` and index `bi` **(0-indexed)** of array `source`. Note that you can swap elements at a specific pair of indices **multiple** times and in **any** order. The **Hamming distance** of two arrays of the same length, `source` and `target`, is the number of positions where the elements are different. Formally, it is the number of indices `i` for `0 <= i <= n-1` where `source[i] != target[i]` **(0-indexed)**. Return _the **minimum Hamming distance** of _`source`_ and _`target`_ after performing **any** amount of swap operations on array _`source`_._ **Example 1:** ``` **Input:** source = [1,2,3,4], target = [2,1,4,5], allowedSwaps = [[0,1],[2,3]] **Output:** 1 **Explanation:** source can be transformed the following way: - Swap indices 0 and 1: source = [2,1,3,4] - Swap indices 2 and 3: source = [2,1,4,3] The Hamming distance of source and target is 1 as they differ in 1 position: index 3. ``` **Example 2:** ``` **Input:** source = [1,2,3,4], target = [1,3,2,4], allowedSwaps = [] **Output:** 2 **Explanation:** There are no allowed swaps. The Hamming distance of source and target is 2 as they differ in 2 positions: index 1 and index 2. ``` **Example 3:** ``` **Input:** source = [5,1,2,4,3], target = [1,5,4,2,3], allowedSwaps = [[0,4],[4,2],[1,3],[1,4]] **Output:** 0 ``` **Constraints:** `n == source.length == target.length` `1 <= n <= 105` `1 <= source[i], target[i] <= 105` `0 <= allowedSwaps.length <= 105` `allowedSwaps[i].length == 2` `0 <= ai, bi <= n - 1` `ai != bi`",
        "test_case": [
            {
                "label": "Example 1",
                "input": "source = [1,2,3,4], target = [2,1,4,5], allowedSwaps = [[0,1],[2,3]]",
                "output": "1 Explanation: source can be transformed the following way:\n- Swap indices 0 and 1: source = [ 2 , 1 ,3,4]\n- Swap indices 2 and 3: source = [2,1, 4 , 3 ]\nThe Hamming distance of source and target is 1 as they differ in 1 position: index 3."
            },
            {
                "label": "Example 2",
                "input": "source = [1,2,3,4], target = [1,3,2,4], allowedSwaps = []",
                "output": "2 Explanation: There are no allowed swaps.\nThe Hamming distance of source and target is 2 as they differ in 2 positions: index 1 and index 2."
            },
            {
                "label": "Example 3",
                "input": "source = [5,1,2,4,3], target = [1,5,4,2,3], allowedSwaps = [[0,4],[4,2],[1,3],[1,4]]",
                "output": "0 Constraints: n == source.length == target.length 1 <= n <= 10 5 1 <= source[i], target[i] <= 10 5 0 <= allowedSwaps.length <= 10 5 allowedSwaps[i].length == 2 0 <= a i , b i <= n - 1 a i != b i"
            }
        ],
        "elixir_template": "defmodule Solution do\n  @spec minimum_hamming_distance(source :: [integer], target :: [integer], allowed_swaps :: [[integer]]) :: integer\n  def minimum_hamming_distance(source, target, allowed_swaps) do\n    \n  end\nend",
        "erlang_template": "-spec minimum_hamming_distance(Source :: [integer()], Target :: [integer()], AllowedSwaps :: [[integer()]]) -> integer().\nminimum_hamming_distance(Source, Target, AllowedSwaps) ->\n  .",
        "scala_template": "object Solution {\n    def minimumHammingDistance(source: Array[Int], target: Array[Int], allowedSwaps: Array[Array[Int]]): Int = {\n        \n    }\n}"
    },
    {
        "id": 1839,
        "name": "decode-xored-array",
        "difficulty": "Easy",
        "link": "https://leetcode.com/problems/decode-xored-array/",
        "task_description": "There is a **hidden** integer array `arr` that consists of `n` non-negative integers. It was encoded into another integer array `encoded` of length `n - 1`, such that `encoded[i] = arr[i] XOR arr[i + 1]`. For example, if `arr = [1,0,2,1]`, then `encoded = [1,2,3]`. You are given the `encoded` array. You are also given an integer `first`, that is the first element of `arr`, i.e. `arr[0]`. Return _the original array_ `arr`. It can be proved that the answer exists and is unique. **Example 1:** ``` **Input:** encoded = [1,2,3], first = 1 **Output:** [1,0,2,1] **Explanation:** If arr = [1,0,2,1], then first = 1 and encoded = [1 XOR 0, 0 XOR 2, 2 XOR 1] = [1,2,3] ``` **Example 2:** ``` **Input:** encoded = [6,2,7,3], first = 4 **Output:** [4,2,0,7,4] ``` **Constraints:** `2 <= n <= 104` `encoded.length == n - 1` `0 <= encoded[i] <= 105` `0 <= first <= 105`",
        "test_case": [
            {
                "label": "Example 1",
                "input": "encoded = [1,2,3], first = 1",
                "output": "[1,0,2,1] Explanation: If arr = [1,0,2,1], then first = 1 and encoded = [1 XOR 0, 0 XOR 2, 2 XOR 1] = [1,2,3]"
            },
            {
                "label": "Example 2",
                "input": "encoded = [6,2,7,3], first = 4",
                "output": "[4,2,0,7,4]"
            }
        ],
        "elixir_template": "defmodule Solution do\n  @spec decode(encoded :: [integer], first :: integer) :: [integer]\n  def decode(encoded, first) do\n    \n  end\nend",
        "erlang_template": "-spec decode(Encoded :: [integer()], First :: integer()) -> [integer()].\ndecode(Encoded, First) ->\n  .",
        "scala_template": "object Solution {\n    def decode(encoded: Array[Int], first: Int): Array[Int] = {\n        \n    }\n}"
    },
    {
        "id": 1836,
        "name": "count-ways-to-make-array-with-product",
        "difficulty": "Hard",
        "link": "https://leetcode.com/problems/count-ways-to-make-array-with-product/",
        "task_description": "You are given a 2D integer array, `queries`. For each `queries[i]`, where `queries[i] = [ni, ki]`, find the number of different ways you can place positive integers into an array of size `ni` such that the product of the integers is `ki`. As the number of ways may be too large, the answer to the `ith` query is the number of ways **modulo** `109 + 7`. Return _an integer array _`answer`_ where _`answer.length == queries.length`_, and _`answer[i]`_ is the answer to the _`ith`_ query._ **Example 1:** ``` **Input:** queries = [[2,6],[5,1],[73,660]] **Output:** [4,1,50734910] **Explanation:** Each query is independent. [2,6]: There are 4 ways to fill an array of size 2 that multiply to 6: [1,6], [2,3], [3,2], [6,1]. [5,1]: There is 1 way to fill an array of size 5 that multiply to 1: [1,1,1,1,1]. [73,660]: There are 1050734917 ways to fill an array of size 73 that multiply to 660. 1050734917 modulo 109 + 7 = 50734910. ``` **Example 2:** ``` **Input:** queries = [[1,1],[2,2],[3,3],[4,4],[5,5]] **Output:** [1,2,3,10,5] ``` **Constraints:** `1 <= queries.length <= 104 ` `1 <= ni, ki <= 104`",
        "test_case": [
            {
                "label": "Example 1",
                "input": "queries = [[2,6],[5,1],[73,660]]",
                "output": "[4,1,50734910] Explanation: Each query is independent.\n[2,6]: There are 4 ways to fill an array of size 2 that multiply to 6: [1,6], [2,3], [3,2], [6,1].\n[5,1]: There is 1 way to fill an array of size 5 that multiply to 1: [1,1,1,1,1].\n[73,660]: There are 1050734917 ways to fill an array of size 73 that multiply to 660. 1050734917 modulo 10 9 + 7 = 50734910."
            },
            {
                "label": "Example 2",
                "input": "queries = [[1,1],[2,2],[3,3],[4,4],[5,5]]",
                "output": "[1,2,3,10,5]"
            }
        ],
        "elixir_template": "defmodule Solution do\n  @spec ways_to_fill_array(queries :: [[integer]]) :: [integer]\n  def ways_to_fill_array(queries) do\n    \n  end\nend",
        "erlang_template": "-spec ways_to_fill_array(Queries :: [[integer()]]) -> [integer()].\nways_to_fill_array(Queries) ->\n  .",
        "scala_template": "object Solution {\n    def waysToFillArray(queries: Array[Array[Int]]): Array[Int] = {\n        \n    }\n}"
    },
    {
        "id": 1835,
        "name": "decode-xored-permutation",
        "difficulty": "Medium",
        "link": "https://leetcode.com/problems/decode-xored-permutation/",
        "task_description": "There is an integer array `perm` that is a permutation of the first `n` positive integers, where `n` is always **odd**. It was encoded into another integer array `encoded` of length `n - 1`, such that `encoded[i] = perm[i] XOR perm[i + 1]`. For example, if `perm = [1,3,2]`, then `encoded = [2,1]`. Given the `encoded` array, return _the original array_ `perm`. It is guaranteed that the answer exists and is unique. **Example 1:** ``` **Input:** encoded = [3,1] **Output:** [1,2,3] **Explanation:** If perm = [1,2,3], then encoded = [1 XOR 2,2 XOR 3] = [3,1] ``` **Example 2:** ``` **Input:** encoded = [6,5,4,6] **Output:** [2,4,1,5,3] ``` **Constraints:** `3 <= n < 105` `n` is odd. `encoded.length == n - 1`",
        "test_case": [
            {
                "label": "Example 1",
                "input": "encoded = [3,1]",
                "output": "[1,2,3] Explanation: If perm = [1,2,3], then encoded = [1 XOR 2,2 XOR 3] = [3,1]"
            },
            {
                "label": "Example 2",
                "input": "encoded = [6,5,4,6]",
                "output": "[2,4,1,5,3]"
            }
        ],
        "elixir_template": "defmodule Solution do\n  @spec decode(encoded :: [integer]) :: [integer]\n  def decode(encoded) do\n    \n  end\nend",
        "erlang_template": "-spec decode(Encoded :: [integer()]) -> [integer()].\ndecode(Encoded) ->\n  .",
        "scala_template": "object Solution {\n    def decode(encoded: Array[Int]): Array[Int] = {\n        \n    }\n}"
    },
    {
        "id": 1834,
        "name": "minimum-number-of-people-to-teach",
        "difficulty": "Medium",
        "link": "https://leetcode.com/problems/minimum-number-of-people-to-teach/",
        "task_description": "On a social network consisting of `m` users and some friendships between users, two users can communicate with each other if they know a common language. You are given an integer `n`, an array `languages`, and an array `friendships` where: There are `n` languages numbered `1` through `n`, `languages[i]` is the set of languages the `i\u200b\u200b\u200b\u200b\u200b\u200bth`\u200b\u200b\u200b\u200b user knows, and `friendships[i] = [u\u200b\u200b\u200b\u200b\u200b\u200bi\u200b\u200b\u200b, v\u200b\u200b\u200b\u200b\u200b\u200bi]` denotes a friendship between the users `u\u200b\u200b\u200b\u200b\u200b\u200b\u200b\u200b\u200b\u200b\u200bi`\u200b\u200b\u200b\u200b\u200b and `vi`. You can choose **one** language and teach it to some users so that all friends can communicate with each other. Return the **minimum** number of users you need to teach. Note that friendships are not transitive, meaning if `x` is a friend of `y` and `y` is a friend of `z`, this doesn't guarantee that `x` is a friend of `z`. **Example 1:** ``` **Input:** n = 2, languages = [[1],[2],[1,2]], friendships = [[1,2],[1,3],[2,3]] **Output:** 1 **Explanation:** You can either teach user 1 the second language or user 2 the first language. ``` **Example 2:** ``` **Input:** n = 3, languages = [[2],[1,3],[1,2],[3]], friendships = [[1,4],[1,2],[3,4],[2,3]] **Output:** 2 **Explanation:** Teach the third language to users 1 and 3, yielding two users to teach. ``` **Constraints:** `2 <= n <= 500` `languages.length == m` `1 <= m <= 500` `1 <= languages[i].length <= n` `1 <= languages[i][j] <= n` `1 <= u\u200b\u200b\u200b\u200b\u200b\u200bi < v\u200b\u200b\u200b\u200b\u200b\u200bi <= languages.length` `1 <= friendships.length <= 500` All tuples `(u\u200b\u200b\u200b\u200b\u200bi, v\u200b\u200b\u200b\u200b\u200b\u200bi)` are unique `languages[i]` contains only unique values",
        "test_case": [
            {
                "label": "Example 1",
                "input": "n = 2, languages = [[1],[2],[1,2]], friendships = [[1,2],[1,3],[2,3]]",
                "output": "1 Explanation: You can either teach user 1 the second language or user 2 the first language."
            },
            {
                "label": "Example 2",
                "input": "n = 3, languages = [[2],[1,3],[1,2],[3]], friendships = [[1,4],[1,2],[3,4],[2,3]]",
                "output": "2 Explanation: Teach the third language to users 1 and 3, yielding two users to teach."
            }
        ],
        "elixir_template": "defmodule Solution do\n  @spec minimum_teachings(n :: integer, languages :: [[integer]], friendships :: [[integer]]) :: integer\n  def minimum_teachings(n, languages, friendships) do\n    \n  end\nend",
        "erlang_template": "-spec minimum_teachings(N :: integer(), Languages :: [[integer()]], Friendships :: [[integer()]]) -> integer().\nminimum_teachings(N, Languages, Friendships) ->\n  .",
        "scala_template": "object Solution {\n    def minimumTeachings(n: Int, languages: Array[Array[Int]], friendships: Array[Array[Int]]): Int = {\n        \n    }\n}"
    },
    {
        "id": 1833,
        "name": "find-the-highest-altitude",
        "difficulty": "Easy",
        "link": "https://leetcode.com/problems/find-the-highest-altitude/",
        "task_description": "There is a biker going on a road trip. The road trip consists of `n + 1` points at different altitudes. The biker starts his trip on point `0` with altitude equal `0`. You are given an integer array `gain` of length `n` where `gain[i]` is the **net gain in altitude** between points `i`\u200b\u200b\u200b\u200b\u200b\u200b and `i + 1` for all (`0 <= i < n)`. Return _the **highest altitude** of a point._ **Example 1:** ``` **Input:** gain = [-5,1,5,0,-7] **Output:** 1 **Explanation:** The altitudes are [0,-5,-4,1,1,-6]. The highest is 1. ``` **Example 2:** ``` **Input:** gain = [-4,-3,-2,-1,4,3,2] **Output:** 0 **Explanation:** The altitudes are [0,-4,-7,-9,-10,-6,-3,-1]. The highest is 0. ``` **Constraints:** `n == gain.length` `1 <= n <= 100` `-100 <= gain[i] <= 100`",
        "test_case": [
            {
                "label": "Example 1",
                "input": "gain = [-5,1,5,0,-7]",
                "output": "1 Explanation: The altitudes are [0,-5,-4,1,1,-6]. The highest is 1."
            },
            {
                "label": "Example 2",
                "input": "gain = [-4,-3,-2,-1,4,3,2]",
                "output": "0 Explanation: The altitudes are [0,-4,-7,-9,-10,-6,-3,-1]. The highest is 0. Constraints: n == gain.length 1 <= n <= 100 -100 <= gain[i] <= 100"
            }
        ],
        "elixir_template": "defmodule Solution do\n  @spec largest_altitude(gain :: [integer]) :: integer\n  def largest_altitude(gain) do\n    \n  end\nend",
        "erlang_template": "-spec largest_altitude(Gain :: [integer()]) -> integer().\nlargest_altitude(Gain) ->\n  .",
        "scala_template": "object Solution {\n    def largestAltitude(gain: Array[Int]): Int = {\n        \n    }\n}"
    },
    {
        "id": 1832,
        "name": "minimum-operations-to-make-a-subsequence",
        "difficulty": "Hard",
        "link": "https://leetcode.com/problems/minimum-operations-to-make-a-subsequence/",
        "task_description": "You are given an array `target` that consists of **distinct** integers and another integer array `arr` that **can** have duplicates. In one operation, you can insert any integer at any position in `arr`. For example, if `arr = [1,4,1,2]`, you can add `3` in the middle and make it `[1,4,3,1,2]`. Note that you can insert the integer at the very beginning or end of the array. Return _the **minimum** number of operations needed to make _`target`_ a **subsequence** of _`arr`_._ A **subsequence** of an array is a new array generated from the original array by deleting some elements (possibly none) without changing the remaining elements' relative order. For example, `[2,7,4]` is a subsequence of `[4,2,3,7,2,1,4]` (the underlined elements), while `[2,4,2]` is not. **Example 1:** ``` **Input:** target = [5,1,3], `arr` = [9,4,2,3,4] **Output:** 2 **Explanation:** You can add 5 and 1 in such a way that makes `arr` = [5,9,4,1,2,3,4], then target will be a subsequence of `arr`. ``` **Example 2:** ``` **Input:** target = [6,4,8,1,3,2], `arr` = [4,7,6,2,3,8,6,1] **Output:** 3 ``` **Constraints:** `1 <= target.length, arr.length <= 105` `1 <= target[i], arr[i] <= 109` `target` contains no duplicates.",
        "test_case": [
            {
                "label": "Example 1",
                "input": "target = [5,1,3], arr = [9,4,2,3,4]",
                "output": "2 Explanation: You can add 5 and 1 in such a way that makes arr = [ 5 ,9,4, 1 ,2,3,4], then target will be a subsequence of arr ."
            },
            {
                "label": "Example 2",
                "input": "target = [6,4,8,1,3,2], arr = [4,7,6,2,3,8,6,1]",
                "output": "3"
            }
        ],
        "elixir_template": "defmodule Solution do\n  @spec min_operations(target :: [integer], arr :: [integer]) :: integer\n  def min_operations(target, arr) do\n    \n  end\nend",
        "erlang_template": "-spec min_operations(Target :: [integer()], Arr :: [integer()]) -> integer().\nmin_operations(Target, Arr) ->\n  .",
        "scala_template": "object Solution {\n    def minOperations(target: Array[Int], arr: Array[Int]): Int = {\n        \n    }\n}"
    },
    {
        "id": 1831,
        "name": "ways-to-split-array-into-three-subarrays",
        "difficulty": "Medium",
        "link": "https://leetcode.com/problems/ways-to-split-array-into-three-subarrays/",
        "task_description": "A split of an integer array is **good** if: The array is split into three **non-empty** contiguous subarrays - named `left`, `mid`, `right` respectively from left to right. The sum of the elements in `left` is less than or equal to the sum of the elements in `mid`, and the sum of the elements in `mid` is less than or equal to the sum of the elements in `right`. Given `nums`, an array of **non-negative** integers, return _the number of **good** ways to split_ `nums`. As the number may be too large, return it **modulo** `109 + 7`. **Example 1:** ``` **Input:** nums = [1,1,1] **Output:** 1 **Explanation:** The only good way to split nums is [1] [1] [1]. ``` **Example 2:** ``` **Input:** nums = [1,2,2,2,5,0] **Output:** 3 **Explanation:** There are three good ways of splitting nums: [1] [2] [2,2,5,0] [1] [2,2] [2,5,0] [1,2] [2,2] [5,0] ``` **Example 3:** ``` **Input:** nums = [3,2,1] **Output:** 0 **Explanation:** There is no good way to split nums. ``` **Constraints:** `3 <= nums.length <= 105` `0 <= nums[i] <= 104`",
        "test_case": [
            {
                "label": "Example 1",
                "input": "nums = [1,1,1]",
                "output": "1 Explanation: The only good way to split nums is [1] [1] [1]."
            },
            {
                "label": "Example 2",
                "input": "nums = [1,2,2,2,5,0]",
                "output": "3 Explanation: There are three good ways of splitting nums:\n[1] [2] [2,2,5,0]\n[1] [2,2] [2,5,0]\n[1,2] [2,2] [5,0]"
            },
            {
                "label": "Example 3",
                "input": "nums = [3,2,1]",
                "output": "0 Explanation: There is no good way to split nums."
            }
        ],
        "elixir_template": "defmodule Solution do\n  @spec ways_to_split(nums :: [integer]) :: integer\n  def ways_to_split(nums) do\n    \n  end\nend",
        "erlang_template": "-spec ways_to_split(Nums :: [integer()]) -> integer().\nways_to_split(Nums) ->\n  .",
        "scala_template": "object Solution {\n    def waysToSplit(nums: Array[Int]): Int = {\n        \n    }\n}"
    },
    {
        "id": 1830,
        "name": "count-good-meals",
        "difficulty": "Medium",
        "link": "https://leetcode.com/problems/count-good-meals/",
        "task_description": "A **good meal** is a meal that contains **exactly two different food items** with a sum of deliciousness equal to a power of two. You can pick **any** two different foods to make a good meal. Given an array of integers `deliciousness` where `deliciousness[i]` is the deliciousness of the `i\u200b\u200b\u200b\u200b\u200b\u200bth\u200b\u200b\u200b\u200b`\u200b\u200b\u200b\u200b item of food, return _the number of different **good meals** you can make from this list modulo_ `109 + 7`. Note that items with different indices are considered different even if they have the same deliciousness value. **Example 1:** ``` **Input:** deliciousness = [1,3,5,7,9] **Output:** 4 **Explanation: **The good meals are (1,3), (1,7), (3,5) and, (7,9). Their respective sums are 4, 8, 8, and 16, all of which are powers of 2. ``` **Example 2:** ``` **Input:** deliciousness = [1,1,1,3,3,3,7] **Output:** 15 **Explanation: **The good meals are (1,1) with 3 ways, (1,3) with 9 ways, and (1,7) with 3 ways. ``` **Constraints:** `1 <= deliciousness.length <= 105` `0 <= deliciousness[i] <= 220`",
        "test_case": [
            {
                "label": "Example 1",
                "input": "deliciousness = [1,3,5,7,9]",
                "output": "4 Explanation: The good meals are (1,3), (1,7), (3,5) and, (7,9).\nTheir respective sums are 4, 8, 8, and 16, all of which are powers of 2."
            },
            {
                "label": "Example 2",
                "input": "deliciousness = [1,1,1,3,3,3,7]",
                "output": "15 Explanation: The good meals are (1,1) with 3 ways, (1,3) with 9 ways, and (1,7) with 3 ways."
            }
        ],
        "elixir_template": "defmodule Solution do\n  @spec count_pairs(deliciousness :: [integer]) :: integer\n  def count_pairs(deliciousness) do\n    \n  end\nend",
        "erlang_template": "-spec count_pairs(Deliciousness :: [integer()]) -> integer().\ncount_pairs(Deliciousness) ->\n  .",
        "scala_template": "object Solution {\n    def countPairs(deliciousness: Array[Int]): Int = {\n        \n    }\n}"
    },
    {
        "id": 1829,
        "name": "maximum-units-on-a-truck",
        "difficulty": "Easy",
        "link": "https://leetcode.com/problems/maximum-units-on-a-truck/",
        "task_description": "You are assigned to put some amount of boxes onto **one truck**. You are given a 2D array `boxTypes`, where `boxTypes[i] = [numberOfBoxesi, numberOfUnitsPerBoxi]`: `numberOfBoxesi` is the number of boxes of type `i`. `numberOfUnitsPerBoxi` is the number of units in each box of the type `i`. You are also given an integer `truckSize`, which is the **maximum** number of **boxes** that can be put on the truck. You can choose any boxes to put on the truck as long as the number of boxes does not exceed `truckSize`. Return _the **maximum** total number of **units** that can be put on the truck._ **Example 1:** ``` **Input:** boxTypes = [[1,3],[2,2],[3,1]], truckSize = 4 **Output:** 8 **Explanation:** There are: - 1 box of the first type that contains 3 units. - 2 boxes of the second type that contain 2 units each. - 3 boxes of the third type that contain 1 unit each. You can take all the boxes of the first and second types, and one box of the third type. The total number of units will be = (1 * 3) + (2 * 2) + (1 * 1) = 8. ``` **Example 2:** ``` **Input:** boxTypes = [[5,10],[2,5],[4,7],[3,9]], truckSize = 10 **Output:** 91 ``` **Constraints:** `1 <= boxTypes.length <= 1000` `1 <= numberOfBoxesi, numberOfUnitsPerBoxi <= 1000` `1 <= truckSize <= 106`",
        "test_case": [
            {
                "label": "Example 1",
                "input": "boxTypes = [[1,3],[2,2],[3,1]], truckSize = 4",
                "output": "8 Explanation: There are:\n- 1 box of the first type that contains 3 units.\n- 2 boxes of the second type that contain 2 units each.\n- 3 boxes of the third type that contain 1 unit each.\nYou can take all the boxes of the first and second types, and one box of the third type.\nThe total number of units will be = (1 * 3) + (2 * 2) + (1 * 1) = 8."
            },
            {
                "label": "Example 2",
                "input": "boxTypes = [[5,10],[2,5],[4,7],[3,9]], truckSize = 10",
                "output": "91"
            }
        ],
        "elixir_template": "defmodule Solution do\n  @spec maximum_units(box_types :: [[integer]], truck_size :: integer) :: integer\n  def maximum_units(box_types, truck_size) do\n    \n  end\nend",
        "erlang_template": "-spec maximum_units(BoxTypes :: [[integer()]], TruckSize :: integer()) -> integer().\nmaximum_units(BoxTypes, TruckSize) ->\n  .",
        "scala_template": "object Solution {\n    def maximumUnits(boxTypes: Array[Array[Int]], truckSize: Int): Int = {\n        \n    }\n}"
    },
    {
        "id": 1826,
        "name": "maximum-xor-with-an-element-from-array",
        "difficulty": "Hard",
        "link": "https://leetcode.com/problems/maximum-xor-with-an-element-from-array/",
        "task_description": "You are given an array `nums` consisting of non-negative integers. You are also given a `queries` array, where `queries[i] = [xi, mi]`. The answer to the `ith` query is the maximum bitwise `XOR` value of `xi` and any element of `nums` that does not exceed `mi`. In other words, the answer is `max(nums[j] XOR xi)` for all `j` such that `nums[j] <= mi`. If all elements in `nums` are larger than `mi`, then the answer is `-1`. Return _an integer array _`answer`_ where _`answer.length == queries.length`_ and _`answer[i]`_ is the answer to the _`ith`_ query._ **Example 1:** ``` **Input:** nums = [0,1,2,3,4], queries = [[3,1],[1,3],[5,6]] **Output:** [3,3,7] **Explanation:** 1) 0 and 1 are the only two integers not greater than 1. 0 XOR 3 = 3 and 1 XOR 3 = 2. The larger of the two is 3. 2) 1 XOR 2 = 3. 3) 5 XOR 2 = 7. ``` **Example 2:** ``` **Input:** nums = [5,2,4,6,6,3], queries = [[12,4],[8,1],[6,3]] **Output:** [15,-1,5] ``` **Constraints:** `1 <= nums.length, queries.length <= 105` `queries[i].length == 2` `0 <= nums[j], xi, mi <= 109`",
        "test_case": [
            {
                "label": "Example 1",
                "input": "nums = [0,1,2,3,4], queries = [[3,1],[1,3],[5,6]]",
                "output": "[3,3,7] Explanation: 1) 0 and 1 are the only two integers not greater than 1. 0 XOR 3 = 3 and 1 XOR 3 = 2. The larger of the two is 3.\n2) 1 XOR 2 = 3.\n3) 5 XOR 2 = 7."
            },
            {
                "label": "Example 2",
                "input": "nums = [5,2,4,6,6,3], queries = [[12,4],[8,1],[6,3]]",
                "output": "[15,-1,5]"
            }
        ],
        "elixir_template": "defmodule Solution do\n  @spec maximize_xor(nums :: [integer], queries :: [[integer]]) :: [integer]\n  def maximize_xor(nums, queries) do\n    \n  end\nend",
        "erlang_template": "-spec maximize_xor(Nums :: [integer()], Queries :: [[integer()]]) -> [integer()].\nmaximize_xor(Nums, Queries) ->\n  .",
        "scala_template": "object Solution {\n    def maximizeXor(nums: Array[Int], queries: Array[Array[Int]]): Array[Int] = {\n        \n    }\n}"
    },
    {
        "id": 1825,
        "name": "find-minimum-time-to-finish-all-jobs",
        "difficulty": "Hard",
        "link": "https://leetcode.com/problems/find-minimum-time-to-finish-all-jobs/",
        "task_description": "You are given an integer array `jobs`, where `jobs[i]` is the amount of time it takes to complete the `ith` job. There are `k` workers that you can assign jobs to. Each job should be assigned to **exactly** one worker. The **working time** of a worker is the sum of the time it takes to complete all jobs assigned to them. Your goal is to devise an optimal assignment such that the **maximum working time** of any worker is **minimized**. _Return the **minimum** possible **maximum working time** of any assignment. _ **Example 1:** ``` **Input:** jobs = [3,2,3], k = 3 **Output:** 3 **Explanation:** By assigning each person one job, the maximum time is 3. ``` **Example 2:** ``` **Input:** jobs = [1,2,4,7,8], k = 2 **Output:** 11 **Explanation:** Assign the jobs the following way: Worker 1: 1, 2, 8 (working time = 1 + 2 + 8 = 11) Worker 2: 4, 7 (working time = 4 + 7 = 11) The maximum working time is 11. ``` **Constraints:** `1 <= k <= jobs.length <= 12` `1 <= jobs[i] <= 107`",
        "test_case": [
            {
                "label": "Example 1",
                "input": "jobs = [3,2,3], k = 3",
                "output": "3 Explanation: By assigning each person one job, the maximum time is 3."
            },
            {
                "label": "Example 2",
                "input": "jobs = [1,2,4,7,8], k = 2",
                "output": "11 Explanation: Assign the jobs the following way:\nWorker 1: 1, 2, 8 (working time = 1 + 2 + 8 = 11)\nWorker 2: 4, 7 (working time = 4 + 7 = 11)\nThe maximum working time is 11."
            }
        ],
        "elixir_template": "defmodule Solution do\n  @spec minimum_time_required(jobs :: [integer], k :: integer) :: integer\n  def minimum_time_required(jobs, k) do\n    \n  end\nend",
        "erlang_template": "-spec minimum_time_required(Jobs :: [integer()], K :: integer()) -> integer().\nminimum_time_required(Jobs, K) ->\n  .",
        "scala_template": "object Solution {\n    def minimumTimeRequired(jobs: Array[Int], k: Int): Int = {\n        \n    }\n}"
    },
    {
        "id": 1824,
        "name": "maximum-number-of-eaten-apples",
        "difficulty": "Medium",
        "link": "https://leetcode.com/problems/maximum-number-of-eaten-apples/",
        "task_description": "There is a special kind of apple tree that grows apples every day for `n` days. On the `ith` day, the tree grows `apples[i]` apples that will rot after `days[i]` days, that is on day `i + days[i]` the apples will be rotten and cannot be eaten. On some days, the apple tree does not grow any apples, which are denoted by `apples[i] == 0` and `days[i] == 0`. You decided to eat **at most** one apple a day (to keep the doctors away). Note that you can keep eating after the first `n` days. Given two integer arrays `days` and `apples` of length `n`, return _the maximum number of apples you can eat._ **Example 1:** ``` **Input:** apples = [1,2,3,5,2], days = [3,2,1,4,2] **Output:** 7 **Explanation:** You can eat 7 apples: - On the first day, you eat an apple that grew on the first day. - On the second day, you eat an apple that grew on the second day. - On the third day, you eat an apple that grew on the second day. After this day, the apples that grew on the third day rot. - On the fourth to the seventh days, you eat apples that grew on the fourth day. ``` **Example 2:** ``` **Input:** apples = [3,0,0,0,0,2], days = [3,0,0,0,0,2] **Output:** 5 **Explanation:** You can eat 5 apples: - On the first to the third day you eat apples that grew on the first day. - Do nothing on the fouth and fifth days. - On the sixth and seventh days you eat apples that grew on the sixth day. ``` **Constraints:** `n == apples.length == days.length` `1 <= n <= 2 * 104` `0 <= apples[i], days[i] <= 2 * 104` `days[i] = 0` if and only if `apples[i] = 0`.",
        "test_case": [
            {
                "label": "Example 1",
                "input": "apples = [1,2,3,5,2], days = [3,2,1,4,2]",
                "output": "7 Explanation: You can eat 7 apples:\n- On the first day, you eat an apple that grew on the first day.\n- On the second day, you eat an apple that grew on the second day.\n- On the third day, you eat an apple that grew on the second day. After this day, the apples that grew on the third day rot.\n- On the fourth to the seventh days, you eat apples that grew on the fourth day."
            },
            {
                "label": "Example 2",
                "input": "apples = [3,0,0,0,0,2], days = [3,0,0,0,0,2]",
                "output": "5 Explanation: You can eat 5 apples:\n- On the first to the third day you eat apples that grew on the first day.\n- Do nothing on the fouth and fifth days.\n- On the sixth and seventh days you eat apples that grew on the sixth day. Constraints: n == apples.length == days.length 1 <= n <= 2 * 10 4 0 <= apples[i], days[i] <= 2 * 10 4 days[i] = 0 if and only if apples[i] = 0 ."
            }
        ],
        "elixir_template": "defmodule Solution do\n  @spec eaten_apples(apples :: [integer], days :: [integer]) :: integer\n  def eaten_apples(apples, days) do\n    \n  end\nend",
        "erlang_template": "-spec eaten_apples(Apples :: [integer()], Days :: [integer()]) -> integer().\neaten_apples(Apples, Days) ->\n  .",
        "scala_template": "object Solution {\n    def eatenApples(apples: Array[Int], days: Array[Int]): Int = {\n        \n    }\n}"
    },
    {
        "id": 1823,
        "name": "determine-if-string-halves-are-alike",
        "difficulty": "Easy",
        "link": "https://leetcode.com/problems/determine-if-string-halves-are-alike/",
        "task_description": "You are given a string `s` of even length. Split this string into two halves of equal lengths, and let `a` be the first half and `b` be the second half. Two strings are **alike** if they have the same number of vowels (`'a'`, `'e'`, `'i'`, `'o'`, `'u'`, `'A'`, `'E'`, `'I'`, `'O'`, `'U'`). Notice that `s` contains uppercase and lowercase letters. Return `true`_ if _`a`_ and _`b`_ are **alike**_. Otherwise, return `false`. **Example 1:** ``` **Input:** s = \"book\" **Output:** true **Explanation:** a = \"bo\" and b = \"ok\". a has 1 vowel and b has 1 vowel. Therefore, they are alike. ``` **Example 2:** ``` **Input:** s = \"textbook\" **Output:** false **Explanation:** a = \"text\" and b = \"book\". a has 1 vowel whereas b has 2. Therefore, they are not alike. Notice that the vowel o is counted twice. ``` **Constraints:** `2 <= s.length <= 1000` `s.length` is even. `s` consists of **uppercase and lowercase** letters.",
        "test_case": [
            {
                "label": "Example 1",
                "input": "s = \"book\"",
                "output": "true Explanation: a = \"b o \" and b = \" o k\". a has 1 vowel and b has 1 vowel. Therefore, they are alike."
            },
            {
                "label": "Example 2",
                "input": "s = \"textbook\"",
                "output": "false Explanation: a = \"t e xt\" and b = \"b oo k\". a has 1 vowel whereas b has 2. Therefore, they are not alike.\nNotice that the vowel o is counted twice."
            }
        ],
        "elixir_template": "defmodule Solution do\n  @spec halves_are_alike(s :: String.t) :: boolean\n  def halves_are_alike(s) do\n    \n  end\nend",
        "erlang_template": "-spec halves_are_alike(S :: unicode:unicode_binary()) -> boolean().\nhalves_are_alike(S) ->\n  .",
        "scala_template": "object Solution {\n    def halvesAreAlike(s: String): Boolean = {\n        \n    }\n}"
    },
    {
        "id": 1820,
        "name": "number-of-ways-to-reconstruct-a-tree",
        "difficulty": "Hard",
        "link": "https://leetcode.com/problems/number-of-ways-to-reconstruct-a-tree/",
        "task_description": "You are given an array `pairs`, where `pairs[i] = [xi, yi]`, and: There are no duplicates. `xi < yi` Let `ways` be the number of rooted trees that satisfy the following conditions: The tree consists of nodes whose values appeared in `pairs`. A pair `[xi, yi]` exists in `pairs` **if and only if** `xi` is an ancestor of `yi` or `yi` is an ancestor of `xi`. **Note:** the tree does not have to be a binary tree. Two ways are considered to be different if there is at least one node that has different parents in both ways. Return: `0` if `ways == 0` `1` if `ways == 1` `2` if `ways > 1` A **rooted tree** is a tree that has a single root node, and all edges are oriented to be outgoing from the root. An **ancestor** of a node is any node on the path from the root to that node (excluding the node itself). The root has no ancestors. **Example 1:** ``` **Input:** pairs = [[1,2],[2,3]] **Output:** 1 **Explanation:** There is exactly one valid rooted tree, which is shown in the above figure. ``` **Example 2:** ``` **Input:** pairs = [[1,2],[2,3],[1,3]] **Output:** 2 **Explanation:** There are multiple valid rooted trees. Three of them are shown in the above figures. ``` **Example 3:** ``` **Input:** pairs = [[1,2],[2,3],[2,4],[1,5]] **Output:** 0 **Explanation:** There are no valid rooted trees. ``` **Constraints:** `1 <= pairs.length <= 105` `1 <= xi < yi <= 500` The elements in `pairs` are unique.",
        "test_case": [
            {
                "label": "Example 1",
                "input": "pairs = [[1,2],[2,3]]",
                "output": "1 Explanation: There is exactly one valid rooted tree, which is shown in the above figure."
            },
            {
                "label": "Example 2",
                "input": "pairs = [[1,2],[2,3],[1,3]]",
                "output": "2 Explanation: There are multiple valid rooted trees. Three of them are shown in the above figures."
            },
            {
                "label": "Example 3",
                "input": "pairs = [[1,2],[2,3],[2,4],[1,5]]",
                "output": "0 Explanation: There are no valid rooted trees."
            }
        ],
        "elixir_template": "defmodule Solution do\n  @spec check_ways(pairs :: [[integer]]) :: integer\n  def check_ways(pairs) do\n    \n  end\nend",
        "erlang_template": "-spec check_ways(Pairs :: [[integer()]]) -> integer().\ncheck_ways(Pairs) ->\n  .",
        "scala_template": "object Solution {\n    def checkWays(pairs: Array[Array[Int]]): Int = {\n        \n    }\n}"
    },
    {
        "id": 1819,
        "name": "construct-the-lexicographically-largest-valid-sequence",
        "difficulty": "Medium",
        "link": "https://leetcode.com/problems/construct-the-lexicographically-largest-valid-sequence/",
        "task_description": "Given an integer `n`, find a sequence that satisfies all of the following: The integer `1` occurs once in the sequence. Each integer between `2` and `n` occurs twice in the sequence. For every integer `i` between `2` and `n`, the **distance** between the two occurrences of `i` is exactly `i`. The **distance** between two numbers on the sequence, `a[i]` and `a[j]`, is the absolute difference of their indices, `|j - i|`. Return _the **lexicographically largest** sequence__. It is guaranteed that under the given constraints, there is always a solution. _ A sequence `a` is lexicographically larger than a sequence `b` (of the same length) if in the first position where `a` and `b` differ, sequence `a` has a number greater than the corresponding number in `b`. For example, `[0,1,9,0]` is lexicographically larger than `[0,1,5,6]` because the first position they differ is at the third number, and `9` is greater than `5`. **Example 1:** ``` **Input:** n = 3 **Output:** [3,1,2,3,2] **Explanation:** [2,3,2,1,3] is also a valid sequence, but [3,1,2,3,2] is the lexicographically largest valid sequence. ``` **Example 2:** ``` **Input:** n = 5 **Output:** [5,3,1,4,3,5,2,4,2] ``` **Constraints:** `1 <= n <= 20`",
        "test_case": [
            {
                "label": "Example 1",
                "input": "n = 3",
                "output": "[3,1,2,3,2] Explanation: [2,3,2,1,3] is also a valid sequence, but [3,1,2,3,2] is the lexicographically largest valid sequence."
            },
            {
                "label": "Example 2",
                "input": "n = 5",
                "output": "[5,3,1,4,3,5,2,4,2]"
            }
        ],
        "elixir_template": "defmodule Solution do\n  @spec construct_distanced_sequence(n :: integer) :: [integer]\n  def construct_distanced_sequence(n) do\n    \n  end\nend",
        "erlang_template": "-spec construct_distanced_sequence(N :: integer()) -> [integer()].\nconstruct_distanced_sequence(N) ->\n  .",
        "scala_template": "object Solution {\n    def constructDistancedSequence(n: Int): Array[Int] = {\n        \n    }\n}"
    },
    {
        "id": 1818,
        "name": "maximum-score-from-removing-substrings",
        "difficulty": "Medium",
        "link": "https://leetcode.com/problems/maximum-score-from-removing-substrings/",
        "task_description": "You are given a string `s` and two integers `x` and `y`. You can perform two types of operations any number of times. Remove substring `\"ab\"` and gain `x` points. For example, when removing `\"ab\"` from `\"cabxbae\"` it becomes `\"cxbae\"`. Remove substring `\"ba\"` and gain `y` points. For example, when removing `\"ba\"` from `\"cabxbae\"` it becomes `\"cabxe\"`. Return _the maximum points you can gain after applying the above operations on_ `s`. **Example 1:** ``` **Input:** s = \"cdbcbbaaabab\", x = 4, y = 5 **Output:** 19 **Explanation:** - Remove the \"ba\" underlined in \"cdbcbbaaabab\". Now, s = \"cdbcbbaaab\" and 5 points are added to the score. - Remove the \"ab\" underlined in \"cdbcbbaaab\". Now, s = \"cdbcbbaa\" and 4 points are added to the score. - Remove the \"ba\" underlined in \"cdbcbbaa\". Now, s = \"cdbcba\" and 5 points are added to the score. - Remove the \"ba\" underlined in \"cdbcba\". Now, s = \"cdbc\" and 5 points are added to the score. Total score = 5 + 4 + 5 + 5 = 19. ``` **Example 2:** ``` **Input:** s = \"aabbaaxybbaabb\", x = 5, y = 4 **Output:** 20 ``` **Constraints:** `1 <= s.length <= 105` `1 <= x, y <= 104` `s` consists of lowercase English letters.",
        "test_case": [
            {
                "label": "Example 1",
                "input": "s = \"cdbcbbaaabab\", x = 4, y = 5",
                "output": "19 Explanation: - Remove the \"ba\" underlined in \"cdbcbbaaa ba b\". Now, s = \"cdbcbbaaab\" and 5 points are added to the score.\n- Remove the \"ab\" underlined in \"cdbcbbaa ab \". Now, s = \"cdbcbbaa\" and 4 points are added to the score.\n- Remove the \"ba\" underlined in \"cdbcb ba a\". Now, s = \"cdbcba\" and 5 points are added to the score.\n- Remove the \"ba\" underlined in \"cdbc ba \". Now, s = \"cdbc\" and 5 points are added to the score.\nTotal score = 5 + 4 + 5 + 5 = 19."
            },
            {
                "label": "Example 2",
                "input": "s = \"aabbaaxybbaabb\", x = 5, y = 4",
                "output": "20"
            }
        ],
        "elixir_template": "defmodule Solution do\n  @spec maximum_gain(s :: String.t, x :: integer, y :: integer) :: integer\n  def maximum_gain(s, x, y) do\n    \n  end\nend",
        "erlang_template": "-spec maximum_gain(S :: unicode:unicode_binary(), X :: integer(), Y :: integer()) -> integer().\nmaximum_gain(S, X, Y) ->\n  .",
        "scala_template": "object Solution {\n    def maximumGain(s: String, x: Int, y: Int): Int = {\n        \n    }\n}"
    },
    {
        "id": 1817,
        "name": "calculate-money-in-leetcode-bank",
        "difficulty": "Easy",
        "link": "https://leetcode.com/problems/calculate-money-in-leetcode-bank/",
        "task_description": "Hercy wants to save money for his first car. He puts money in the Leetcode bank **every day**. He starts by putting in `$1` on Monday, the first day. Every day from Tuesday to Sunday, he will put in `$1` more than the day before. On every subsequent Monday, he will put in `$1` more than the **previous Monday**. Given `n`, return _the total amount of money he will have in the Leetcode bank at the end of the _`nth`_ day._ **Example 1:** ``` **Input:** n = 4 **Output:** 10 **Explanation:** After the 4th day, the total is 1 + 2 + 3 + 4 = 10. ``` **Example 2:** ``` **Input:** n = 10 **Output:** 37 **Explanation:** After the 10th day, the total is (1 + 2 + 3 + 4 + 5 + 6 + 7) + (2 + 3 + 4) = 37. Notice that on the 2nd Monday, Hercy only puts in $2. ``` **Example 3:** ``` **Input:** n = 20 **Output:** 96 **Explanation:** After the 20th day, the total is (1 + 2 + 3 + 4 + 5 + 6 + 7) + (2 + 3 + 4 + 5 + 6 + 7 + 8) + (3 + 4 + 5 + 6 + 7 + 8) = 96. ``` **Constraints:** `1 <= n <= 1000`",
        "test_case": [
            {
                "label": "Example 1",
                "input": "n = 4",
                "output": "10 Explanation: After the 4 th day, the total is 1 + 2 + 3 + 4 = 10."
            },
            {
                "label": "Example 2",
                "input": "n = 10",
                "output": "37 Explanation: After the 10 th day, the total is (1 + 2 + 3 + 4 + 5 + 6 + 7) + (2 + 3 + 4) = 37. Notice that on the 2 nd Monday, Hercy only puts in $2."
            },
            {
                "label": "Example 3",
                "input": "n = 20",
                "output": "96 Explanation: After the 20 th day, the total is (1 + 2 + 3 + 4 + 5 + 6 + 7) + (2 + 3 + 4 + 5 + 6 + 7 + 8) + (3 + 4 + 5 + 6 + 7 + 8) = 96."
            }
        ],
        "elixir_template": "defmodule Solution do\n  @spec total_money(n :: integer) :: integer\n  def total_money(n) do\n    \n  end\nend",
        "erlang_template": "-spec total_money(N :: integer()) -> integer().\ntotal_money(N) ->\n  .",
        "scala_template": "object Solution {\n    def totalMoney(n: Int): Int = {\n        \n    }\n}"
    },
    {
        "id": 1815,
        "name": "checking-existence-of-edge-length-limited-paths",
        "difficulty": "Hard",
        "link": "https://leetcode.com/problems/checking-existence-of-edge-length-limited-paths/",
        "task_description": "An undirected graph of `n` nodes is defined by `edgeList`, where `edgeList[i] = [ui, vi, disi]` denotes an edge between nodes `ui` and `vi` with distance `disi`. Note that there may be **multiple** edges between two nodes. Given an array `queries`, where `queries[j] = [pj, qj, limitj]`, your task is to determine for each `queries[j]` whether there is a path between `pj` and `qj` such that each edge on the path has a distance **strictly less than** `limitj` . Return _a **boolean array** _`answer`_, where _`answer.length == queries.length` _and the _`jth` _value of _`answer` _is _`true`_ if there is a path for _`queries[j]`_ is _`true`_, and _`false`_ otherwise_. **Example 1:** ``` **Input:** n = 3, edgeList = [[0,1,2],[1,2,4],[2,0,8],[1,0,16]], queries = [[0,1,2],[0,2,5]] **Output:** [false,true] **Explanation:** The above figure shows the given graph. Note that there are two overlapping edges between 0 and 1 with distances 2 and 16. For the first query, between 0 and 1 there is no path where each distance is less than 2, thus we return false for this query. For the second query, there is a path (0 -> 1 -> 2) of two edges with distances less than 5, thus we return true for this query. ``` **Example 2:** ``` **Input:** n = 5, edgeList = [[0,1,10],[1,2,5],[2,3,9],[3,4,13]], queries = [[0,4,14],[1,4,13]] **Output:** [true,false] **Explanation:** The above figure shows the given graph. ``` **Constraints:** `2 <= n <= 105` `1 <= edgeList.length, queries.length <= 105` `edgeList[i].length == 3` `queries[j].length == 3` `0 <= ui, vi, pj, qj <= n - 1` `ui != vi` `pj != qj` `1 <= disi, limitj <= 109` There may be **multiple** edges between two nodes.",
        "test_case": [
            {
                "label": "Example 1",
                "input": "n = 3, edgeList = [[0,1,2],[1,2,4],[2,0,8],[1,0,16]], queries = [[0,1,2],[0,2,5]]",
                "output": "[false,true] Explanation: The above figure shows the given graph. Note that there are two overlapping edges between 0 and 1 with distances 2 and 16.\nFor the first query, between 0 and 1 there is no path where each distance is less than 2, thus we return false for this query.\nFor the second query, there is a path (0 -> 1 -> 2) of two edges with distances less than 5, thus we return true for this query."
            },
            {
                "label": "Example 2",
                "input": "n = 5, edgeList = [[0,1,10],[1,2,5],[2,3,9],[3,4,13]], queries = [[0,4,14],[1,4,13]]",
                "output": "[true,false] Explanation: The above figure shows the given graph."
            }
        ],
        "elixir_template": "defmodule Solution do\n  @spec distance_limited_paths_exist(n :: integer, edge_list :: [[integer]], queries :: [[integer]]) :: [boolean]\n  def distance_limited_paths_exist(n, edge_list, queries) do\n    \n  end\nend",
        "erlang_template": "-spec distance_limited_paths_exist(N :: integer(), EdgeList :: [[integer()]], Queries :: [[integer()]]) -> [boolean()].\ndistance_limited_paths_exist(N, EdgeList, Queries) ->\n  .",
        "scala_template": "object Solution {\n    def distanceLimitedPathsExist(n: Int, edgeList: Array[Array[Int]], queries: Array[Array[Int]]): Array[Boolean] = {\n        \n    }\n}"
    },
    {
        "id": 1814,
        "name": "jump-game-vi",
        "difficulty": "Medium",
        "link": "https://leetcode.com/problems/jump-game-vi/",
        "task_description": "You are given a **0-indexed** integer array `nums` and an integer `k`. You are initially standing at index `0`. In one move, you can jump at most `k` steps forward without going outside the boundaries of the array. That is, you can jump from index `i` to any index in the range `[i + 1, min(n - 1, i + k)]` **inclusive**. You want to reach the last index of the array (index `n - 1`). Your **score** is the **sum** of all `nums[j]` for each index `j` you visited in the array. Return _the **maximum score** you can get_. **Example 1:** ``` **Input:** nums = [1,-1,-2,4,-7,3], k = 2 **Output:** 7 **Explanation:** You can choose your jumps forming the subsequence [1,-1,4,3] (underlined above). The sum is 7. ``` **Example 2:** ``` **Input:** nums = [10,-5,-2,4,0,3], k = 3 **Output:** 17 **Explanation:** You can choose your jumps forming the subsequence [10,4,3] (underlined above). The sum is 17. ``` **Example 3:** ``` **Input:** nums = [1,-5,-20,4,-1,3,-6,-3], k = 2 **Output:** 0 ``` **Constraints:** `1 <= nums.length, k <= 105` `-104 <= nums[i] <= 104`",
        "test_case": [
            {
                "label": "Example 1",
                "input": "nums = [ 1 , -1 ,-2, 4 ,-7, 3 ], k = 2",
                "output": "7 Explanation: You can choose your jumps forming the subsequence [1,-1,4,3] (underlined above). The sum is 7."
            },
            {
                "label": "Example 2",
                "input": "nums = [ 10 ,-5,-2, 4 ,0, 3 ], k = 3",
                "output": "17 Explanation: You can choose your jumps forming the subsequence [10,4,3] (underlined above). The sum is 17."
            },
            {
                "label": "Example 3",
                "input": "nums = [1,-5,-20,4,-1,3,-6,-3], k = 2",
                "output": "0"
            }
        ],
        "elixir_template": "defmodule Solution do\n  @spec max_result(nums :: [integer], k :: integer) :: integer\n  def max_result(nums, k) do\n    \n  end\nend",
        "erlang_template": "-spec max_result(Nums :: [integer()], K :: integer()) -> integer().\nmax_result(Nums, K) ->\n  .",
        "scala_template": "object Solution {\n    def maxResult(nums: Array[Int], k: Int): Int = {\n        \n    }\n}"
    },
    {
        "id": 1813,
        "name": "maximum-erasure-value",
        "difficulty": "Medium",
        "link": "https://leetcode.com/problems/maximum-erasure-value/",
        "task_description": "You are given an array of positive integers `nums` and want to erase a subarray containing **unique elements**. The **score** you get by erasing the subarray is equal to the **sum** of its elements. Return _the **maximum score** you can get by erasing **exactly one** subarray._ An array `b` is called to be a subarray of `a` if it forms a contiguous subsequence of `a`, that is, if it is equal to `a[l],a[l+1],...,a[r]` for some `(l,r)`. **Example 1:** ``` **Input:** nums = [4,2,4,5,6] **Output:** 17 **Explanation:** The optimal subarray here is [2,4,5,6]. ``` **Example 2:** ``` **Input:** nums = [5,2,1,2,5,2,1,2,5] **Output:** 8 **Explanation:** The optimal subarray here is [5,2,1] or [1,2,5]. ``` **Constraints:** `1 <= nums.length <= 105` `1 <= nums[i] <= 104`",
        "test_case": [
            {
                "label": "Example 1",
                "input": "nums = [4,2,4,5,6]",
                "output": "17 Explanation: The optimal subarray here is [2,4,5,6]."
            },
            {
                "label": "Example 2",
                "input": "nums = [5,2,1,2,5,2,1,2,5]",
                "output": "8 Explanation: The optimal subarray here is [5,2,1] or [1,2,5]."
            }
        ],
        "elixir_template": "defmodule Solution do\n  @spec maximum_unique_subarray(nums :: [integer]) :: integer\n  def maximum_unique_subarray(nums) do\n    \n  end\nend",
        "erlang_template": "-spec maximum_unique_subarray(Nums :: [integer()]) -> integer().\nmaximum_unique_subarray(Nums) ->\n  .",
        "scala_template": "object Solution {\n    def maximumUniqueSubarray(nums: Array[Int]): Int = {\n        \n    }\n}"
    },
    {
        "id": 1812,
        "name": "reformat-phone-number",
        "difficulty": "Easy",
        "link": "https://leetcode.com/problems/reformat-phone-number/",
        "task_description": "You are given a phone number as a string `number`. `number` consists of digits, spaces `' '`, and/or dashes `'-'`. You would like to reformat the phone number in a certain manner. Firstly, **remove** all spaces and dashes. Then, **group** the digits from left to right into blocks of length 3 **until** there are 4 or fewer digits. The final digits are then grouped as follows: 2 digits: A single block of length 2. 3 digits: A single block of length 3. 4 digits: Two blocks of length 2 each. The blocks are then joined by dashes. Notice that the reformatting process should **never** produce any blocks of length 1 and produce **at most** two blocks of length 2. Return _the phone number after formatting._ **Example 1:** ``` **Input:** number = \"1-23-45 6\" **Output:** \"123-456\" **Explanation:** The digits are \"123456\". Step 1: There are more than 4 digits, so group the next 3 digits. The 1st block is \"123\". Step 2: There are 3 digits remaining, so put them in a single block of length 3. The 2nd block is \"456\". Joining the blocks gives \"123-456\". ``` **Example 2:** ``` **Input:** number = \"123 4-567\" **Output:** \"123-45-67\" **Explanation: **The digits are \"1234567\". Step 1: There are more than 4 digits, so group the next 3 digits. The 1st block is \"123\". Step 2: There are 4 digits left, so split them into two blocks of length 2. The blocks are \"45\" and \"67\". Joining the blocks gives \"123-45-67\". ``` **Example 3:** ``` **Input:** number = \"123 4-5678\" **Output:** \"123-456-78\" **Explanation:** The digits are \"12345678\". Step 1: The 1st block is \"123\". Step 2: The 2nd block is \"456\". Step 3: There are 2 digits left, so put them in a single block of length 2. The 3rd block is \"78\". Joining the blocks gives \"123-456-78\". ``` **Constraints:** `2 <= number.length <= 100` `number` consists of digits and the characters `'-'` and `' '`. There are at least **two** digits in `number`.",
        "test_case": [
            {
                "label": "Example 1",
                "input": "number = \"1-23-45 6\"",
                "output": "\"123-456\" Explanation: The digits are \"123456\".\nStep 1: There are more than 4 digits, so group the next 3 digits. The 1st block is \"123\".\nStep 2: There are 3 digits remaining, so put them in a single block of length 3. The 2nd block is \"456\".\nJoining the blocks gives \"123-456\"."
            },
            {
                "label": "Example 2",
                "input": "number = \"123 4-567\"",
                "output": "\"123-45-67\" Explanation: The digits are \"1234567\".\nStep 1: There are more than 4 digits, so group the next 3 digits. The 1st block is \"123\".\nStep 2: There are 4 digits left, so split them into two blocks of length 2. The blocks are \"45\" and \"67\".\nJoining the blocks gives \"123-45-67\"."
            },
            {
                "label": "Example 3",
                "input": "number = \"123 4-5678\"",
                "output": "\"123-456-78\" Explanation: The digits are \"12345678\".\nStep 1: The 1st block is \"123\".\nStep 2: The 2nd block is \"456\".\nStep 3: There are 2 digits left, so put them in a single block of length 2. The 3rd block is \"78\".\nJoining the blocks gives \"123-456-78\"."
            }
        ],
        "elixir_template": "defmodule Solution do\n  @spec reformat_number(number :: String.t) :: String.t\n  def reformat_number(number) do\n    \n  end\nend",
        "erlang_template": "-spec reformat_number(Number :: unicode:unicode_binary()) -> unicode:unicode_binary().\nreformat_number(Number) ->\n  .",
        "scala_template": "object Solution {\n    def reformatNumber(number: String): String = {\n        \n    }\n}"
    },
    {
        "id": 1808,
        "name": "stone-game-vii",
        "difficulty": "Medium",
        "link": "https://leetcode.com/problems/stone-game-vii/",
        "task_description": "Alice and Bob take turns playing a game, with **Alice starting first**. There are `n` stones arranged in a row. On each player's turn, they can **remove** either the leftmost stone or the rightmost stone from the row and receive points equal to the **sum** of the remaining stones' values in the row. The winner is the one with the higher score when there are no stones left to remove. Bob found that he will always lose this game (poor Bob, he always loses), so he decided to **minimize the score's difference**. Alice's goal is to **maximize the difference** in the score. Given an array of integers `stones` where `stones[i]` represents the value of the `ith` stone **from the left**, return _the **difference** in Alice and Bob's score if they both play **optimally**._ **Example 1:** ``` **Input:** stones = [5,3,1,4,2] **Output:** 6 **Explanation:** - Alice removes 2 and gets 5 + 3 + 1 + 4 = 13 points. Alice = 13, Bob = 0, stones = [5,3,1,4]. - Bob removes 5 and gets 3 + 1 + 4 = 8 points. Alice = 13, Bob = 8, stones = [3,1,4]. - Alice removes 3 and gets 1 + 4 = 5 points. Alice = 18, Bob = 8, stones = [1,4]. - Bob removes 1 and gets 4 points. Alice = 18, Bob = 12, stones = [4]. - Alice removes 4 and gets 0 points. Alice = 18, Bob = 12, stones = []. The score difference is 18 - 12 = 6. ``` **Example 2:** ``` **Input:** stones = [7,90,5,1,100,10,10,2] **Output:** 122 ``` **Constraints:** `n == stones.length` `2 <= n <= 1000` `1 <= stones[i] <= 1000`",
        "test_case": [
            {
                "label": "Example 1",
                "input": "stones = [5,3,1,4,2]",
                "output": "6 Explanation: - Alice removes 2 and gets 5 + 3 + 1 + 4 = 13 points. Alice = 13, Bob = 0, stones = [5,3,1,4].\n- Bob removes 5 and gets 3 + 1 + 4 = 8 points. Alice = 13, Bob = 8, stones = [3,1,4].\n- Alice removes 3 and gets 1 + 4 = 5 points. Alice = 18, Bob = 8, stones = [1,4].\n- Bob removes 1 and gets 4 points. Alice = 18, Bob = 12, stones = [4].\n- Alice removes 4 and gets 0 points. Alice = 18, Bob = 12, stones = [].\nThe score difference is 18 - 12 = 6."
            },
            {
                "label": "Example 2",
                "input": "stones = [7,90,5,1,100,10,10,2]",
                "output": "122 Constraints: n == stones.length 2 <= n <= 1000 1 <= stones[i] <= 1000"
            }
        ],
        "elixir_template": "Elixir code template not available for this problem.",
        "erlang_template": "Elixir code template not available for this problem.",
        "scala_template": "object Solution {\n    def stoneGameVII(stones: Array[Int]): Int = {\n        \n    }\n}"
    },
    {
        "id": 1807,
        "name": "partitioning-into-minimum-number-of-deci-binary-numbers",
        "difficulty": "Medium",
        "link": "https://leetcode.com/problems/partitioning-into-minimum-number-of-deci-binary-numbers/",
        "task_description": "A decimal number is called **deci-binary** if each of its digits is either `0` or `1` without any leading zeros. For example, `101` and `1100` are **deci-binary**, while `112` and `3001` are not. Given a string `n` that represents a positive decimal integer, return _the **minimum** number of positive **deci-binary** numbers needed so that they sum up to _`n`_._ **Example 1:** ``` **Input:** n = \"32\" **Output:** 3 **Explanation:** 10 + 11 + 11 = 32 ``` **Example 2:** ``` **Input:** n = \"82734\" **Output:** 8 ``` **Example 3:** ``` **Input:** n = \"27346209830709182346\" **Output:** 9 ``` **Constraints:** `1 <= n.length <= 105` `n` consists of only digits. `n` does not contain any leading zeros and represents a positive integer.",
        "test_case": [
            {
                "label": "Example 1",
                "input": "n = \"32\"",
                "output": "3 Explanation: 10 + 11 + 11 = 32"
            },
            {
                "label": "Example 2",
                "input": "n = \"82734\"",
                "output": "8"
            },
            {
                "label": "Example 3",
                "input": "n = \"27346209830709182346\"",
                "output": "9"
            }
        ],
        "elixir_template": "defmodule Solution do\n  @spec min_partitions(n :: String.t) :: integer\n  def min_partitions(n) do\n    \n  end\nend",
        "erlang_template": "-spec min_partitions(N :: unicode:unicode_binary()) -> integer().\nmin_partitions(N) ->\n  .",
        "scala_template": "object Solution {\n    def minPartitions(n: String): Int = {\n        \n    }\n}"
    },
    {
        "id": 1806,
        "name": "count-of-matches-in-tournament",
        "difficulty": "Easy",
        "link": "https://leetcode.com/problems/count-of-matches-in-tournament/",
        "task_description": "You are given an integer `n`, the number of teams in a tournament that has strange rules: If the current number of teams is **even**, each team gets paired with another team. A total of `n / 2` matches are played, and `n / 2` teams advance to the next round. If the current number of teams is **odd**, one team randomly advances in the tournament, and the rest gets paired. A total of `(n - 1) / 2` matches are played, and `(n - 1) / 2 + 1` teams advance to the next round. Return _the number of matches played in the tournament until a winner is decided._ **Example 1:** ``` **Input:** n = 7 **Output:** 6 **Explanation:** Details of the tournament: - 1st Round: Teams = 7, Matches = 3, and 4 teams advance. - 2nd Round: Teams = 4, Matches = 2, and 2 teams advance. - 3rd Round: Teams = 2, Matches = 1, and 1 team is declared the winner. Total number of matches = 3 + 2 + 1 = 6. ``` **Example 2:** ``` **Input:** n = 14 **Output:** 13 **Explanation:** Details of the tournament: - 1st Round: Teams = 14, Matches = 7, and 7 teams advance. - 2nd Round: Teams = 7, Matches = 3, and 4 teams advance. - 3rd Round: Teams = 4, Matches = 2, and 2 teams advance. - 4th Round: Teams = 2, Matches = 1, and 1 team is declared the winner. Total number of matches = 7 + 3 + 2 + 1 = 13. ``` **Constraints:** `1 <= n <= 200`",
        "test_case": [
            {
                "label": "Example 1",
                "input": "n = 7",
                "output": "6 Explanation: Details of the tournament: \n- 1st Round: Teams = 7, Matches = 3, and 4 teams advance.\n- 2nd Round: Teams = 4, Matches = 2, and 2 teams advance.\n- 3rd Round: Teams = 2, Matches = 1, and 1 team is declared the winner.\nTotal number of matches = 3 + 2 + 1 = 6."
            },
            {
                "label": "Example 2",
                "input": "n = 14",
                "output": "13 Explanation: Details of the tournament:\n- 1st Round: Teams = 14, Matches = 7, and 7 teams advance.\n- 2nd Round: Teams = 7, Matches = 3, and 4 teams advance.\n- 3rd Round: Teams = 4, Matches = 2, and 2 teams advance.\n- 4th Round: Teams = 2, Matches = 1, and 1 team is declared the winner.\nTotal number of matches = 7 + 3 + 2 + 1 = 13."
            }
        ],
        "elixir_template": "Elixir code template not available for this problem.",
        "erlang_template": "Elixir code template not available for this problem.",
        "scala_template": "object Solution {\n    def numberOfMatches(n: Int): Int = {\n        \n    }\n}"
    },
    {
        "id": 1805,
        "name": "minimum-adjacent-swaps-for-k-consecutive-ones",
        "difficulty": "Hard",
        "link": "https://leetcode.com/problems/minimum-adjacent-swaps-for-k-consecutive-ones/",
        "task_description": "You are given an integer array, `nums`, and an integer `k`. `nums` comprises of only `0`'s and `1`'s. In one move, you can choose two **adjacent** indices and swap their values. Return _the **minimum** number of moves required so that _`nums`_ has _`k`_ **consecutive** _`1`_'s_. **Example 1:** ``` **Input:** nums = [1,0,0,1,0,1], k = 2 **Output:** 1 **Explanation:** In 1 move, nums could be [1,0,0,0,1,1] and have 2 consecutive 1's. ``` **Example 2:** ``` **Input:** nums = [1,0,0,0,0,0,1,1], k = 3 **Output:** 5 **Explanation:** In 5 moves, the leftmost 1 can be shifted right until nums = [0,0,0,0,0,1,1,1]. ``` **Example 3:** ``` **Input:** nums = [1,1,0,1], k = 2 **Output:** 0 **Explanation:** nums already has 2 consecutive 1's. ``` **Constraints:** `1 <= nums.length <= 105` `nums[i]` is `0` or `1`. `1 <= k <= sum(nums)`",
        "test_case": [
            {
                "label": "Example 1",
                "input": "nums = [1,0,0,1,0,1], k = 2",
                "output": "1 Explanation: In 1 move, nums could be [1,0,0,0, 1 , 1 ] and have 2 consecutive 1's."
            },
            {
                "label": "Example 2",
                "input": "nums = [1,0,0,0,0,0,1,1], k = 3",
                "output": "5 Explanation: In 5 moves, the leftmost 1 can be shifted right until nums = [0,0,0,0,0, 1 , 1 , 1 ]."
            },
            {
                "label": "Example 3",
                "input": "nums = [1,1,0,1], k = 2",
                "output": "0 Explanation: nums already has 2 consecutive 1's."
            }
        ],
        "elixir_template": "defmodule Solution do\n  @spec min_moves(nums :: [integer], k :: integer) :: integer\n  def min_moves(nums, k) do\n    \n  end\nend",
        "erlang_template": "-spec min_moves(Nums :: [integer()], K :: integer()) -> integer().\nmin_moves(Nums, K) ->\n  .",
        "scala_template": "object Solution {\n    def minMoves(nums: Array[Int], k: Int): Int = {\n        \n    }\n}"
    },
    {
        "id": 1804,
        "name": "maximum-binary-string-after-change",
        "difficulty": "Medium",
        "link": "https://leetcode.com/problems/maximum-binary-string-after-change/",
        "task_description": "You are given a binary string `binary` consisting of only `0`'s or `1`'s. You can apply each of the following operations any number of times: Operation 1: If the number contains the substring `\"00\"`, you can replace it with `\"10\"`. For example, `\"00010\" -> \"10010`\" Operation 2: If the number contains the substring `\"10\"`, you can replace it with `\"01\"`. For example, `\"00010\" -> \"00001\"` _Return the **maximum binary string** you can obtain after any number of operations. Binary string `x` is greater than binary string `y` if `x`'s decimal representation is greater than `y`'s decimal representation._ **Example 1:** ``` **Input:** binary = \"000110\" **Output:** \"111011\" **Explanation:** A valid transformation sequence can be: \"000110\" -> \"000101\" \"000101\" -> \"100101\" \"100101\" -> \"110101\" \"110101\" -> \"110011\" \"110011\" -> \"111011\" ``` **Example 2:** ``` **Input:** binary = \"01\" **Output:** \"01\" **Explanation:** \"01\" cannot be transformed any further. ``` **Constraints:** `1 <= binary.length <= 105` `binary` consist of `'0'` and `'1'`.",
        "test_case": [
            {
                "label": "Example 1",
                "input": "binary = \"000110\"",
                "output": "\"111011\" Explanation: A valid transformation sequence can be:\n\"0001 10 \" -> \"0001 01 \" \n\" 00 0101\" -> \" 10 0101\" \n\"1 00 101\" -> \"1 10 101\" \n\"110 10 1\" -> \"110 01 1\" \n\"11 00 11\" -> \"11 10 11\""
            },
            {
                "label": "Example 2",
                "input": "binary = \"01\"",
                "output": "\"01\" Explanation: \"01\" cannot be transformed any further."
            }
        ],
        "elixir_template": "defmodule Solution do\n  @spec maximum_binary_string(binary :: String.t) :: String.t\n  def maximum_binary_string(binary) do\n    \n  end\nend",
        "erlang_template": "-spec maximum_binary_string(Binary :: unicode:unicode_binary()) -> unicode:unicode_binary().\nmaximum_binary_string(Binary) ->\n  .",
        "scala_template": "object Solution {\n    def maximumBinaryString(binary: String): String = {\n        \n    }\n}"
    },
    {
        "id": 1803,
        "name": "average-waiting-time",
        "difficulty": "Medium",
        "link": "https://leetcode.com/problems/average-waiting-time/",
        "task_description": "There is a restaurant with a single chef. You are given an array `customers`, where `customers[i] = [arrivali, timei]:` `arrivali` is the arrival time of the `ith` customer. The arrival times are sorted in **non-decreasing** order. `timei` is the time needed to prepare the order of the `ith` customer. When a customer arrives, he gives the chef his order, and the chef starts preparing it once he is idle. The customer waits till the chef finishes preparing his order. The chef does not prepare food for more than one customer at a time. The chef prepares food for customers **in the order they were given in the input**. Return _the **average** waiting time of all customers_. Solutions within `10-5` from the actual answer are considered accepted. **Example 1:** ``` **Input:** customers = [[1,2],[2,5],[4,3]] **Output:** 5.00000 **Explanation: **1) The first customer arrives at time 1, the chef takes his order and starts preparing it immediately at time 1, and finishes at time 3, so the waiting time of the first customer is 3 - 1 = 2. 2) The second customer arrives at time 2, the chef takes his order and starts preparing it at time 3, and finishes at time 8, so the waiting time of the second customer is 8 - 2 = 6. 3) The third customer arrives at time 4, the chef takes his order and starts preparing it at time 8, and finishes at time 11, so the waiting time of the third customer is 11 - 4 = 7. So the average waiting time = (2 + 6 + 7) / 3 = 5. ``` **Example 2:** ``` **Input:** customers = [[5,2],[5,4],[10,3],[20,1]] **Output:** 3.25000 **Explanation: **1) The first customer arrives at time 5, the chef takes his order and starts preparing it immediately at time 5, and finishes at time 7, so the waiting time of the first customer is 7 - 5 = 2. 2) The second customer arrives at time 5, the chef takes his order and starts preparing it at time 7, and finishes at time 11, so the waiting time of the second customer is 11 - 5 = 6. 3) The third customer arrives at time 10, the chef takes his order and starts preparing it at time 11, and finishes at time 14, so the waiting time of the third customer is 14 - 10 = 4. 4) The fourth customer arrives at time 20, the chef takes his order and starts preparing it immediately at time 20, and finishes at time 21, so the waiting time of the fourth customer is 21 - 20 = 1. So the average waiting time = (2 + 6 + 4 + 1) / 4 = 3.25. ``` **Constraints:** `1 <= customers.length <= 105` `1 <= arrivali, timei <= 104` `arrivali <= arrivali+1`",
        "test_case": [
            {
                "label": "Example 1",
                "input": "customers = [[1,2],[2,5],[4,3]]",
                "output": "5.00000 Explanation: 1) The first customer arrives at time 1, the chef takes his order and starts preparing it immediately at time 1, and finishes at time 3, so the waiting time of the first customer is 3 - 1 = 2.\n2) The second customer arrives at time 2, the chef takes his order and starts preparing it at time 3, and finishes at time 8, so the waiting time of the second customer is 8 - 2 = 6.\n3) The third customer arrives at time 4, the chef takes his order and starts preparing it at time 8, and finishes at time 11, so the waiting time of the third customer is 11 - 4 = 7.\nSo the average waiting time = (2 + 6 + 7) / 3 = 5."
            },
            {
                "label": "Example 2",
                "input": "customers = [[5,2],[5,4],[10,3],[20,1]]",
                "output": "3.25000 Explanation: 1) The first customer arrives at time 5, the chef takes his order and starts preparing it immediately at time 5, and finishes at time 7, so the waiting time of the first customer is 7 - 5 = 2.\n2) The second customer arrives at time 5, the chef takes his order and starts preparing it at time 7, and finishes at time 11, so the waiting time of the second customer is 11 - 5 = 6.\n3) The third customer arrives at time 10, the chef takes his order and starts preparing it at time 11, and finishes at time 14, so the waiting time of the third customer is 14 - 10 = 4.\n4) The fourth customer arrives at time 20, the chef takes his order and starts preparing it immediately at time 20, and finishes at time 21, so the waiting time of the fourth customer is 21 - 20 = 1.\nSo the average waiting time = (2 + 6 + 4 + 1) / 4 = 3.25."
            }
        ],
        "elixir_template": "defmodule Solution do\n  @spec average_waiting_time(customers :: [[integer]]) :: float\n  def average_waiting_time(customers) do\n    \n  end\nend",
        "erlang_template": "-spec average_waiting_time(Customers :: [[integer()]]) -> float().\naverage_waiting_time(Customers) ->\n  .",
        "scala_template": "object Solution {\n    def averageWaitingTime(customers: Array[Array[Int]]): Double = {\n        \n    }\n}"
    },
    {
        "id": 1802,
        "name": "number-of-students-unable-to-eat-lunch",
        "difficulty": "Easy",
        "link": "https://leetcode.com/problems/number-of-students-unable-to-eat-lunch/",
        "task_description": "The school cafeteria offers circular and square sandwiches at lunch break, referred to by numbers `0` and `1` respectively. All students stand in a queue. Each student either prefers square or circular sandwiches. The number of sandwiches in the cafeteria is equal to the number of students. The sandwiches are placed in a **stack**. At each step: If the student at the front of the queue **prefers** the sandwich on the top of the stack, they will **take it** and leave the queue. Otherwise, they will **leave it** and go to the queue's end. This continues until none of the queue students want to take the top sandwich and are thus unable to eat. You are given two integer arrays `students` and `sandwiches` where `sandwiches[i]` is the type of the `i\u200b\u200b\u200b\u200b\u200b\u200bth` sandwich in the stack (`i = 0` is the top of the stack) and `students[j]` is the preference of the `j\u200b\u200b\u200b\u200b\u200b\u200bth` student in the initial queue (`j = 0` is the front of the queue). Return _the number of students that are unable to eat._ **Example 1:** ``` **Input:** students = [1,1,0,0], sandwiches = [0,1,0,1] **Output:** 0** Explanation:** - Front student leaves the top sandwich and returns to the end of the line making students = [1,0,0,1]. - Front student leaves the top sandwich and returns to the end of the line making students = [0,0,1,1]. - Front student takes the top sandwich and leaves the line making students = [0,1,1] and sandwiches = [1,0,1]. - Front student leaves the top sandwich and returns to the end of the line making students = [1,1,0]. - Front student takes the top sandwich and leaves the line making students = [1,0] and sandwiches = [0,1]. - Front student leaves the top sandwich and returns to the end of the line making students = [0,1]. - Front student takes the top sandwich and leaves the line making students = [1] and sandwiches = [1]. - Front student takes the top sandwich and leaves the line making students = [] and sandwiches = []. Hence all students are able to eat. ``` **Example 2:** ``` **Input:** students = [1,1,1,0,0,1], sandwiches = [1,0,0,0,1,1] **Output:** 3 ``` **Constraints:** `1 <= students.length, sandwiches.length <= 100` `students.length == sandwiches.length` `sandwiches[i]` is `0` or `1`. `students[i]` is `0` or `1`.",
        "test_case": [
            {
                "label": "Example 1",
                "input": "students = [1,1,0,0], sandwiches = [0,1,0,1]",
                "output": "0 Explanation: - Front student leaves the top sandwich and returns to the end of the line making students = [1,0,0,1].\n- Front student leaves the top sandwich and returns to the end of the line making students = [0,0,1,1].\n- Front student takes the top sandwich and leaves the line making students = [0,1,1] and sandwiches = [1,0,1].\n- Front student leaves the top sandwich and returns to the end of the line making students = [1,1,0].\n- Front student takes the top sandwich and leaves the line making students = [1,0] and sandwiches = [0,1].\n- Front student leaves the top sandwich and returns to the end of the line making students = [0,1].\n- Front student takes the top sandwich and leaves the line making students = [1] and sandwiches = [1].\n- Front student takes the top sandwich and leaves the line making students = [] and sandwiches = [].\nHence all students are able to eat."
            },
            {
                "label": "Example 2",
                "input": "students = [1,1,1,0,0,1], sandwiches = [1,0,0,0,1,1]",
                "output": "3"
            }
        ],
        "elixir_template": "defmodule Solution do\n  @spec count_students(students :: [integer], sandwiches :: [integer]) :: integer\n  def count_students(students, sandwiches) do\n    \n  end\nend",
        "erlang_template": "-spec count_students(Students :: [integer()], Sandwiches :: [integer()]) -> integer().\ncount_students(Students, Sandwiches) ->\n  .",
        "scala_template": "object Solution {\n    def countStudents(students: Array[Int], sandwiches: Array[Int]): Int = {\n        \n    }\n}"
    },
    {
        "id": 1800,
        "name": "concatenation-of-consecutive-binary-numbers",
        "difficulty": "Medium",
        "link": "https://leetcode.com/problems/concatenation-of-consecutive-binary-numbers/",
        "task_description": "Given an integer `n`, return _the **decimal value** of the binary string formed by concatenating the binary representations of _`1`_ to _`n`_ in order, **modulo **_`109 + 7`. **Example 1:** ``` **Input:** n = 1 **Output:** 1 **Explanation: **\"1\" in binary corresponds to the decimal value 1. ``` **Example 2:** ``` **Input:** n = 3 **Output:** 27 **Explanation: **In binary, 1, 2, and 3 corresponds to \"1\", \"10\", and \"11\". After concatenating them, we have \"11011\", which corresponds to the decimal value 27. ``` **Example 3:** ``` **Input:** n = 12 **Output:** 505379714 **Explanation**: The concatenation results in \"1101110010111011110001001101010111100\". The decimal value of that is 118505380540. After modulo 109 + 7, the result is 505379714. ``` **Constraints:** `1 <= n <= 105`",
        "test_case": [
            {
                "label": "Example 1",
                "input": "n = 1",
                "output": "1 Explanation: \"1\" in binary corresponds to the decimal value 1."
            },
            {
                "label": "Example 2",
                "input": "n = 3",
                "output": "27 Explanation: In binary, 1, 2, and 3 corresponds to \"1\", \"10\", and \"11\".\nAfter concatenating them, we have \"11011\", which corresponds to the decimal value 27."
            },
            {
                "label": "Example 3",
                "input": "n = 12",
                "output": "505379714 Explanation : The concatenation results in \"1101110010111011110001001101010111100\".\nThe decimal value of that is 118505380540.\nAfter modulo 10 9 + 7, the result is 505379714."
            }
        ],
        "elixir_template": "Elixir code template not available for this problem.",
        "erlang_template": "Elixir code template not available for this problem.",
        "scala_template": "object Solution {\n    def concatenatedBinary(n: Int): Int = {\n        \n    }\n}"
    },
    {
        "id": 1799,
        "name": "minimum-incompatibility",
        "difficulty": "Hard",
        "link": "https://leetcode.com/problems/minimum-incompatibility/",
        "task_description": "You are given an integer array `nums`\u200b\u200b\u200b and an integer `k`. You are asked to distribute this array into `k` subsets of **equal size** such that there are no two equal elements in the same subset. A subset's **incompatibility** is the difference between the maximum and minimum elements in that array. Return _the **minimum possible sum of incompatibilities** of the _`k` _subsets after distributing the array optimally, or return _`-1`_ if it is not possible._ A subset is a group integers that appear in the array with no particular order. **Example 1:** ``` **Input:** nums = [1,2,1,4], k = 2 **Output:** 4 **Explanation:** The optimal distribution of subsets is [1,2] and [1,4]. The incompatibility is (2-1) + (4-1) = 4. Note that [1,1] and [2,4] would result in a smaller sum, but the first subset contains 2 equal elements. ``` **Example 2:** ``` **Input:** nums = [6,3,8,1,3,1,2,2], k = 4 **Output:** 6 **Explanation:** The optimal distribution of subsets is [1,2], [2,3], [6,8], and [1,3]. The incompatibility is (2-1) + (3-2) + (8-6) + (3-1) = 6. ``` **Example 3:** ``` **Input:** nums = [5,3,3,6,3,3], k = 3 **Output:** -1 **Explanation:** It is impossible to distribute nums into 3 subsets where no two elements are equal in the same subset. ``` **Constraints:** `1 <= k <= nums.length <= 16` `nums.length` is divisible by `k` `1 <= nums[i] <= nums.length`",
        "test_case": [
            {
                "label": "Example 1",
                "input": "nums = [1,2,1,4], k = 2",
                "output": "4 Explanation: The optimal distribution of subsets is [1,2] and [1,4].\nThe incompatibility is (2-1) + (4-1) = 4.\nNote that [1,1] and [2,4] would result in a smaller sum, but the first subset contains 2 equal elements."
            },
            {
                "label": "Example 2",
                "input": "nums = [6,3,8,1,3,1,2,2], k = 4",
                "output": "6 Explanation: The optimal distribution of subsets is [1,2], [2,3], [6,8], and [1,3].\nThe incompatibility is (2-1) + (3-2) + (8-6) + (3-1) = 6."
            },
            {
                "label": "Example 3",
                "input": "nums = [5,3,3,6,3,3], k = 3",
                "output": "-1 Explanation: It is impossible to distribute nums into 3 subsets where no two elements are equal in the same subset."
            }
        ],
        "elixir_template": "defmodule Solution do\n  @spec minimum_incompatibility(nums :: [integer], k :: integer) :: integer\n  def minimum_incompatibility(nums, k) do\n    \n  end\nend",
        "erlang_template": "-spec minimum_incompatibility(Nums :: [integer()], K :: integer()) -> integer().\nminimum_incompatibility(Nums, K) ->\n  .",
        "scala_template": "object Solution {\n    def minimumIncompatibility(nums: Array[Int], k: Int): Int = {\n        \n    }\n}"
    },
    {
        "id": 1798,
        "name": "max-number-of-k-sum-pairs",
        "difficulty": "Medium",
        "link": "https://leetcode.com/problems/max-number-of-k-sum-pairs/",
        "task_description": "You are given an integer array `nums` and an integer `k`. In one operation, you can pick two numbers from the array whose sum equals `k` and remove them from the array. Return _the maximum number of operations you can perform on the array_. **Example 1:** ``` **Input:** nums = [1,2,3,4], k = 5 **Output:** 2 **Explanation:** Starting with nums = [1,2,3,4]: - Remove numbers 1 and 4, then nums = [2,3] - Remove numbers 2 and 3, then nums = [] There are no more pairs that sum up to 5, hence a total of 2 operations. ``` **Example 2:** ``` **Input:** nums = [3,1,3,4,3], k = 6 **Output:** 1 **Explanation:** Starting with nums = [3,1,3,4,3]: - Remove the first two 3's, then nums = [1,4,3] There are no more pairs that sum up to 6, hence a total of 1 operation. ``` **Constraints:** `1 <= nums.length <= 105` `1 <= nums[i] <= 109` `1 <= k <= 109`",
        "test_case": [
            {
                "label": "Example 1",
                "input": "nums = [1,2,3,4], k = 5",
                "output": "2 Explanation: Starting with nums = [1,2,3,4]:\n- Remove numbers 1 and 4, then nums = [2,3]\n- Remove numbers 2 and 3, then nums = []\nThere are no more pairs that sum up to 5, hence a total of 2 operations."
            },
            {
                "label": "Example 2",
                "input": "nums = [3,1,3,4,3], k = 6",
                "output": "1 Explanation: Starting with nums = [3,1,3,4,3]:\n- Remove the first two 3's, then nums = [1,4,3]\nThere are no more pairs that sum up to 6, hence a total of 1 operation."
            }
        ],
        "elixir_template": "Elixir code template not available for this problem.",
        "erlang_template": "Elixir code template not available for this problem.",
        "scala_template": "object Solution {\n    def maxOperations(nums: Array[Int], k: Int): Int = {\n        \n    }\n}"
    },
    {
        "id": 1797,
        "name": "goal-parser-interpretation",
        "difficulty": "Easy",
        "link": "https://leetcode.com/problems/goal-parser-interpretation/",
        "task_description": "You own a **Goal Parser** that can interpret a string `command`. The `command` consists of an alphabet of `\"G\"`, `\"()\"` and/or `\"(al)\"` in some order. The Goal Parser will interpret `\"G\"` as the string `\"G\"`, `\"()\"` as the string `\"o\"`, and `\"(al)\"` as the string `\"al\"`. The interpreted strings are then concatenated in the original order. Given the string `command`, return _the **Goal Parser**'s interpretation of _`command`. **Example 1:** ``` **Input:** command = \"G()(al)\" **Output:** \"Goal\" **Explanation:** The Goal Parser interprets the command as follows: G -> G () -> o (al) -> al The final concatenated result is \"Goal\". ``` **Example 2:** ``` **Input:** command = \"G()()()()(al)\" **Output:** \"Gooooal\" ``` **Example 3:** ``` **Input:** command = \"(al)G(al)()()G\" **Output:** \"alGalooG\" ``` **Constraints:** `1 <= command.length <= 100` `command` consists of `\"G\"`, `\"()\"`, and/or `\"(al)\"` in some order.",
        "test_case": [
            {
                "label": "Example 1",
                "input": "command = \"G()(al)\"",
                "output": "\"Goal\" Explanation: The Goal Parser interprets the command as follows:\nG -> G\n() -> o\n(al) -> al\nThe final concatenated result is \"Goal\"."
            },
            {
                "label": "Example 2",
                "input": "command = \"G()()()()(al)\"",
                "output": "\"Gooooal\""
            },
            {
                "label": "Example 3",
                "input": "command = \"(al)G(al)()()G\"",
                "output": "\"alGalooG\""
            }
        ],
        "elixir_template": "Elixir code template not available for this problem.",
        "erlang_template": "Elixir code template not available for this problem.",
        "scala_template": "object Solution {\n    def interpret(command: String): String = {\n        \n    }\n}"
    },
    {
        "id": 1794,
        "name": "minimize-deviation-in-array",
        "difficulty": "Hard",
        "link": "https://leetcode.com/problems/minimize-deviation-in-array/",
        "task_description": "You are given an array `nums` of `n` positive integers. You can perform two types of operations on any element of the array any number of times: If the element is **even**, **divide** it by `2`. For example, if the array is `[1,2,3,4]`, then you can do this operation on the last element, and the array will be `[1,2,3,2].` If the element is **odd**, **multiply** it by `2`. For example, if the array is `[1,2,3,4]`, then you can do this operation on the first element, and the array will be `[2,2,3,4].` The **deviation** of the array is the **maximum difference** between any two elements in the array. Return _the **minimum deviation** the array can have after performing some number of operations._ **Example 1:** ``` **Input:** nums = [1,2,3,4] **Output:** 1 **Explanation:** You can transform the array to [1,2,3,2], then to [2,2,3,2], then the deviation will be 3 - 2 = 1. ``` **Example 2:** ``` **Input:** nums = [4,1,5,20,3] **Output:** 3 **Explanation:** You can transform the array after two operations to [4,2,5,5,3], then the deviation will be 5 - 2 = 3. ``` **Example 3:** ``` **Input:** nums = [2,10,8] **Output:** 3 ``` **Constraints:** `n == nums.length` `2 <= n <= 5 * 104` `1 <= nums[i] <= 109`",
        "test_case": [
            {
                "label": "Example 1",
                "input": "nums = [1,2,3,4]",
                "output": "1 Explanation: You can transform the array to [1,2,3, 2 ], then to [ 2 ,2,3,2], then the deviation will be 3 - 2 = 1."
            },
            {
                "label": "Example 2",
                "input": "nums = [4,1,5,20,3]",
                "output": "3 Explanation: You can transform the array after two operations to [4, 2 ,5, 5 ,3], then the deviation will be 5 - 2 = 3."
            },
            {
                "label": "Example 3",
                "input": "nums = [2,10,8]",
                "output": "3 Constraints: n == nums.length 2 <= n <= 5 * 10 4 1 <= nums[i] <= 10 9"
            }
        ],
        "elixir_template": "defmodule Solution do\n  @spec minimum_deviation(nums :: [integer]) :: integer\n  def minimum_deviation(nums) do\n    \n  end\nend",
        "erlang_template": "-spec minimum_deviation(Nums :: [integer()]) -> integer().\nminimum_deviation(Nums) ->\n  .",
        "scala_template": "object Solution {\n    def minimumDeviation(nums: Array[Int]): Int = {\n        \n    }\n}"
    },
    {
        "id": 1793,
        "name": "minimum-moves-to-make-array-complementary",
        "difficulty": "Medium",
        "link": "https://leetcode.com/problems/minimum-moves-to-make-array-complementary/",
        "task_description": "You are given an integer array `nums` of **even** length `n` and an integer `limit`. In one move, you can replace any integer from `nums` with another integer between `1` and `limit`, inclusive. The array `nums` is **complementary** if for all indices `i` (**0-indexed**), `nums[i] + nums[n - 1 - i]` equals the same number. For example, the array `[1,2,3,4]` is complementary because for all indices `i`, `nums[i] + nums[n - 1 - i] = 5`. Return the _**minimum** number of moves required to make _`nums`_ **complementary**_. **Example 1:** ``` **Input:** nums = [1,2,4,3], limit = 4 **Output:** 1 **Explanation:** In 1 move, you can change nums to [1,2,2,3] (underlined elements are changed). nums[0] + nums[3] = 1 + 3 = 4. nums[1] + nums[2] = 2 + 2 = 4. nums[2] + nums[1] = 2 + 2 = 4. nums[3] + nums[0] = 3 + 1 = 4. Therefore, nums[i] + nums[n-1-i] = 4 for every i, so nums is complementary. ``` **Example 2:** ``` **Input:** nums = [1,2,2,1], limit = 2 **Output:** 2 **Explanation:** In 2 moves, you can change nums to [2,2,2,2]. You cannot change any number to 3 since 3 > limit. ``` **Example 3:** ``` **Input:** nums = [1,2,1,2], limit = 2 **Output:** 0 **Explanation:** nums is already complementary. ``` **Constraints:** `n == nums.length` `2 <= n <= 105` `1 <= nums[i] <= limit <= 105` `n` is even.",
        "test_case": [
            {
                "label": "Example 1",
                "input": "nums = [1,2,4,3], limit = 4",
                "output": "1 Explanation: In 1 move, you can change nums to [1,2, 2 ,3] (underlined elements are changed).\nnums[0] + nums[3] = 1 + 3 = 4.\nnums[1] + nums[2] = 2 + 2 = 4.\nnums[2] + nums[1] = 2 + 2 = 4.\nnums[3] + nums[0] = 3 + 1 = 4.\nTherefore, nums[i] + nums[n-1-i] = 4 for every i, so nums is complementary."
            },
            {
                "label": "Example 2",
                "input": "nums = [1,2,2,1], limit = 2",
                "output": "2 Explanation: In 2 moves, you can change nums to [ 2 ,2,2, 2 ]. You cannot change any number to 3 since 3 > limit."
            },
            {
                "label": "Example 3",
                "input": "nums = [1,2,1,2], limit = 2",
                "output": "0 Explanation: nums is already complementary. Constraints: n == nums.length 2 <= n\u00a0<=\u00a010 5 1 <= nums[i]\u00a0<= limit <=\u00a010 5 n is even."
            }
        ],
        "elixir_template": "defmodule Solution do\n  @spec min_moves(nums :: [integer], limit :: integer) :: integer\n  def min_moves(nums, limit) do\n    \n  end\nend",
        "erlang_template": "-spec min_moves(Nums :: [integer()], Limit :: integer()) -> integer().\nmin_moves(Nums, Limit) ->\n  .",
        "scala_template": "object Solution {\n    def minMoves(nums: Array[Int], limit: Int): Int = {\n        \n    }\n}"
    },
    {
        "id": 1792,
        "name": "find-the-most-competitive-subsequence",
        "difficulty": "Medium",
        "link": "https://leetcode.com/problems/find-the-most-competitive-subsequence/",
        "task_description": "Given an integer array `nums` and a positive integer `k`, return _the most** competitive** subsequence of _`nums` _of size _`k`. An array's subsequence is a resulting sequence obtained by erasing some (possibly zero) elements from the array. We define that a subsequence `a` is more **competitive** than a subsequence `b` (of the same length) if in the first position where `a` and `b` differ, subsequence `a` has a number **less** than the corresponding number in `b`. For example, `[1,3,4]` is more competitive than `[1,3,5]` because the first position they differ is at the final number, and `4` is less than `5`. **Example 1:** ``` **Input:** nums = [3,5,2,6], k = 2 **Output:** [2,6] **Explanation:** Among the set of every possible subsequence: {[3,5], [3,2], [3,6], [5,2], [5,6], [2,6]}, [2,6] is the most competitive. ``` **Example 2:** ``` **Input:** nums = [2,4,3,3,5,4,9,6], k = 4 **Output:** [2,3,3,4] ``` **Constraints:** `1 <= nums.length <= 105` `0 <= nums[i] <= 109` `1 <= k <= nums.length`",
        "test_case": [
            {
                "label": "Example 1",
                "input": "nums = [3,5,2,6], k = 2",
                "output": "[2,6] Explanation: Among the set of every possible subsequence: {[3,5], [3,2], [3,6], [5,2], [5,6], [2,6]}, [2,6] is the most competitive."
            },
            {
                "label": "Example 2",
                "input": "nums = [2,4,3,3,5,4,9,6], k = 4",
                "output": "[2,3,3,4]"
            }
        ],
        "elixir_template": "defmodule Solution do\n  @spec most_competitive(nums :: [integer], k :: integer) :: [integer]\n  def most_competitive(nums, k) do\n    \n  end\nend",
        "erlang_template": "-spec most_competitive(Nums :: [integer()], K :: integer()) -> [integer()].\nmost_competitive(Nums, K) ->\n  .",
        "scala_template": "object Solution {\n    def mostCompetitive(nums: Array[Int], k: Int): Array[Int] = {\n        \n    }\n}"
    },
    {
        "id": 1791,
        "name": "richest-customer-wealth",
        "difficulty": "Easy",
        "link": "https://leetcode.com/problems/richest-customer-wealth/",
        "task_description": "You are given an `m x n` integer grid `accounts` where `accounts[i][j]` is the amount of money the `i\u200b\u200b\u200b\u200b\u200b\u200b\u200b\u200b\u200b\u200b\u200bth\u200b\u200b\u200b\u200b` customer has in the `j\u200b\u200b\u200b\u200b\u200b\u200b\u200b\u200b\u200b\u200b\u200bth`\u200b\u200b\u200b\u200b bank. Return_ the **wealth** that the richest customer has._ A customer's **wealth** is the amount of money they have in all their bank accounts. The richest customer is the customer that has the maximum **wealth**. **Example 1:** ``` **Input:** accounts = [[1,2,3],[3,2,1]] **Output:** 6 **Explanation****:** `1st customer has wealth = 1 + 2 + 3 = 6 ``2nd customer has wealth = 3 + 2 + 1 = 6 `Both customers are considered the richest with a wealth of 6 each, so return 6. ``` **Example 2:** ``` **Input:** accounts = [[1,5],[7,3],[3,5]] **Output:** 10 **Explanation**: 1st customer has wealth = 6 2nd customer has wealth = 10 3rd customer has wealth = 8 The 2nd customer is the richest with a wealth of 10. ``` **Example 3:** ``` **Input:** accounts = [[2,8,7],[7,1,3],[1,9,5]] **Output:** 17 ``` **Constraints:** `m == accounts.length` `n == accounts[i].length` `1 <= m, n <= 50` `1 <= accounts[i][j] <= 100`",
        "test_case": [
            {
                "label": "Example 1",
                "input": "accounts = [[1,2,3],[3,2,1]]",
                "output": "6 Explanation : 1st customer has wealth = 1 + 2 + 3 = 6 2nd customer has wealth = 3 + 2 + 1 = 6 Both customers are considered the richest with a wealth of 6 each, so return 6."
            },
            {
                "label": "Example 2",
                "input": "accounts = [[1,5],[7,3],[3,5]]",
                "output": "10 Explanation : \n1st customer has wealth = 6\n2nd customer has wealth = 10 \n3rd customer has wealth = 8\nThe 2nd customer is the richest with a wealth of 10."
            },
            {
                "label": "Example 3",
                "input": "accounts = [[2,8,7],[7,1,3],[1,9,5]]",
                "output": "17 Constraints: m ==\u00a0accounts.length n ==\u00a0accounts[i].length 1 <= m, n <= 50 1 <= accounts[i][j] <= 100"
            }
        ],
        "elixir_template": "defmodule Solution do\n  @spec maximum_wealth(accounts :: [[integer]]) :: integer\n  def maximum_wealth(accounts) do\n    \n  end\nend",
        "erlang_template": "-spec maximum_wealth(Accounts :: [[integer()]]) -> integer().\nmaximum_wealth(Accounts) ->\n  .",
        "scala_template": "object Solution {\n    def maximumWealth(accounts: Array[Array[Int]]): Int = {\n        \n    }\n}"
    },
    {
        "id": 1789,
        "name": "delivering-boxes-from-storage-to-ports",
        "difficulty": "Hard",
        "link": "https://leetcode.com/problems/delivering-boxes-from-storage-to-ports/",
        "task_description": "You have the task of delivering some boxes from storage to their ports using only one ship. However, this ship has a **limit** on the **number of boxes** and the **total weight** that it can carry. You are given an array `boxes`, where `boxes[i] = [ports\u200b\u200bi\u200b, weighti]`, and three integers `portsCount`, `maxBoxes`, and `maxWeight`. `ports\u200b\u200bi` is the port where you need to deliver the `ith` box and `weightsi` is the weight of the `ith` box. `portsCount` is the number of ports. `maxBoxes` and `maxWeight` are the respective box and weight limits of the ship. The boxes need to be delivered **in the order they are given**. The ship will follow these steps: The ship will take some number of boxes from the `boxes` queue, not violating the `maxBoxes` and `maxWeight` constraints. For each loaded box **in order**, the ship will make a **trip** to the port the box needs to be delivered to and deliver it. If the ship is already at the correct port, no **trip** is needed, and the box can immediately be delivered. The ship then makes a return **trip** to storage to take more boxes from the queue. The ship must end at storage after all the boxes have been delivered. Return _the **minimum** number of **trips** the ship needs to make to deliver all boxes to their respective ports._ **Example 1:** ``` **Input:** boxes = [[1,1],[2,1],[1,1]], portsCount = 2, maxBoxes = 3, maxWeight = 3 **Output:** 4 **Explanation:** The optimal strategy is as follows: - The ship takes all the boxes in the queue, goes to port 1, then port 2, then port 1 again, then returns to storage. 4 trips. So the total number of trips is 4. Note that the first and third boxes cannot be delivered together because the boxes need to be delivered in order (i.e. the second box needs to be delivered at port 2 before the third box). ``` **Example 2:** ``` **Input:** boxes = [[1,2],[3,3],[3,1],[3,1],[2,4]], portsCount = 3, maxBoxes = 3, maxWeight = 6 **Output:** 6 **Explanation:** The optimal strategy is as follows: - The ship takes the first box, goes to port 1, then returns to storage. 2 trips. - The ship takes the second, third and fourth boxes, goes to port 3, then returns to storage. 2 trips. - The ship takes the fifth box, goes to port 2, then returns to storage. 2 trips. So the total number of trips is 2 + 2 + 2 = 6. ``` **Example 3:** ``` **Input:** boxes = [[1,4],[1,2],[2,1],[2,1],[3,2],[3,4]], portsCount = 3, maxBoxes = 6, maxWeight = 7 **Output:** 6 **Explanation:** The optimal strategy is as follows: - The ship takes the first and second boxes, goes to port 1, then returns to storage. 2 trips. - The ship takes the third and fourth boxes, goes to port 2, then returns to storage. 2 trips. - The ship takes the fifth and sixth boxes, goes to port 3, then returns to storage. 2 trips. So the total number of trips is 2 + 2 + 2 = 6. ``` **Constraints:** `1 <= boxes.length <= 105` `1 <= portsCount, maxBoxes, maxWeight <= 105` `1 <= ports\u200b\u200bi <= portsCount` `1 <= weightsi <= maxWeight`",
        "test_case": [
            {
                "label": "Example 1",
                "input": "boxes = [[1,1],[2,1],[1,1]], portsCount = 2, maxBoxes = 3, maxWeight = 3",
                "output": "4 Explanation: The optimal strategy is as follows: \n- The ship takes all the boxes in the queue, goes to port 1, then port 2, then port 1 again, then returns to storage. 4 trips.\nSo the total number of trips is 4.\nNote that the first and third boxes cannot be delivered together because the boxes need to be delivered in order (i.e. the second box needs to be delivered at port 2 before the third box)."
            },
            {
                "label": "Example 2",
                "input": "boxes = [[1,2],[3,3],[3,1],[3,1],[2,4]], portsCount = 3, maxBoxes = 3, maxWeight = 6",
                "output": "6 Explanation: The optimal strategy is as follows: \n- The ship takes the first box, goes to port 1, then returns to storage. 2 trips.\n- The ship takes the second, third and fourth boxes, goes to port 3, then returns to storage. 2 trips.\n- The ship takes the fifth box, goes to port 2, then returns to storage. 2 trips.\nSo the total number of trips is 2 + 2 + 2 = 6."
            },
            {
                "label": "Example 3",
                "input": "boxes = [[1,4],[1,2],[2,1],[2,1],[3,2],[3,4]], portsCount = 3, maxBoxes = 6, maxWeight = 7",
                "output": "6 Explanation: The optimal strategy is as follows:\n- The ship takes the first and second boxes, goes to port 1, then returns to storage. 2 trips.\n- The ship takes the third and fourth boxes, goes to port 2, then returns to storage. 2 trips.\n- The ship takes the fifth and sixth boxes, goes to port 3, then returns to storage. 2 trips.\nSo the total number of trips is 2 + 2 + 2 = 6."
            }
        ],
        "elixir_template": "defmodule Solution do\n  @spec box_delivering(boxes :: [[integer]], ports_count :: integer, max_boxes :: integer, max_weight :: integer) :: integer\n  def box_delivering(boxes, ports_count, max_boxes, max_weight) do\n    \n  end\nend",
        "erlang_template": "-spec box_delivering(Boxes :: [[integer()]], PortsCount :: integer(), MaxBoxes :: integer(), MaxWeight :: integer()) -> integer().\nbox_delivering(Boxes, PortsCount, MaxBoxes, MaxWeight) ->\n  .",
        "scala_template": "object Solution {\n    def boxDelivering(boxes: Array[Array[Int]], portsCount: Int, maxBoxes: Int, maxWeight: Int): Int = {\n        \n    }\n}"
    },
    {
        "id": 1788,
        "name": "stone-game-vi",
        "difficulty": "Medium",
        "link": "https://leetcode.com/problems/stone-game-vi/",
        "task_description": "Alice and Bob take turns playing a game, with Alice starting first. There are `n` stones in a pile. On each player's turn, they can **remove** a stone from the pile and receive points based on the stone's value. Alice and Bob may **value the stones differently**. You are given two integer arrays of length `n`, `aliceValues` and `bobValues`. Each `aliceValues[i]` and `bobValues[i]` represents how Alice and Bob, respectively, value the `ith` stone. The winner is the person with the most points after all the stones are chosen. If both players have the same amount of points, the game results in a draw. Both players will play **optimally**. Both players know the other's values. Determine the result of the game, and: If Alice wins, return `1`. If Bob wins, return `-1`. If the game results in a draw, return `0`. **Example 1:** ``` **Input:** aliceValues = [1,3], bobValues = [2,1] **Output:** 1 **Explanation:** If Alice takes stone 1 (0-indexed) first, Alice will receive 3 points. Bob can only choose stone 0, and will only receive 2 points. Alice wins. ``` **Example 2:** ``` **Input:** aliceValues = [1,2], bobValues = [3,1] **Output:** 0 **Explanation:** If Alice takes stone 0, and Bob takes stone 1, they will both have 1 point. Draw. ``` **Example 3:** ``` **Input:** aliceValues = [2,4,3], bobValues = [1,6,7] **Output:** -1 **Explanation:** Regardless of how Alice plays, Bob will be able to have more points than Alice. For example, if Alice takes stone 1, Bob can take stone 2, and Alice takes stone 0, Alice will have 6 points to Bob's 7. Bob wins. ``` **Constraints:** `n == aliceValues.length == bobValues.length` `1 <= n <= 105` `1 <= aliceValues[i], bobValues[i] <= 100`",
        "test_case": [
            {
                "label": "Example 1",
                "input": "aliceValues = [1,3], bobValues = [2,1]",
                "output": "1 Explanation: If Alice takes stone 1 (0-indexed) first, Alice will receive 3 points.\nBob can only choose stone 0, and will only receive 2 points.\nAlice wins."
            },
            {
                "label": "Example 2",
                "input": "aliceValues = [1,2], bobValues = [3,1]",
                "output": "0 Explanation: If Alice takes stone 0, and Bob takes stone 1, they will both have 1 point.\nDraw."
            },
            {
                "label": "Example 3",
                "input": "aliceValues = [2,4,3], bobValues = [1,6,7]",
                "output": "-1 Explanation: Regardless of how Alice plays, Bob will be able to have more points than Alice.\nFor example, if Alice takes stone 1, Bob can take stone 2, and Alice takes stone 0, Alice will have 6 points to Bob's 7.\nBob wins. Constraints: n == aliceValues.length == bobValues.length 1 <= n <= 10 5 1 <= aliceValues[i], bobValues[i] <= 100"
            }
        ],
        "elixir_template": "defmodule Solution do\n  @spec stone_game_vi(alice_values :: [integer], bob_values :: [integer]) :: integer\n  def stone_game_vi(alice_values, bob_values) do\n    \n  end\nend",
        "erlang_template": "-spec stone_game_vi(AliceValues :: [integer()], BobValues :: [integer()]) -> integer().\nstone_game_vi(AliceValues, BobValues) ->\n  .",
        "scala_template": "object Solution {\n    def stoneGameVI(aliceValues: Array[Int], bobValues: Array[Int]): Int = {\n        \n    }\n}"
    },
    {
        "id": 1787,
        "name": "sum-of-absolute-differences-in-a-sorted-array",
        "difficulty": "Medium",
        "link": "https://leetcode.com/problems/sum-of-absolute-differences-in-a-sorted-array/",
        "task_description": "You are given an integer array `nums` sorted in **non-decreasing** order. Build and return _an integer array _`result`_ with the same length as _`nums`_ such that _`result[i]`_ is equal to the **summation of absolute differences** between _`nums[i]`_ and all the other elements in the array._ In other words, `result[i]` is equal to `sum(|nums[i]-nums[j]|)` where `0 <= j < nums.length` and `j != i` (**0-indexed**). **Example 1:** ``` **Input:** nums = [2,3,5] **Output:** [4,3,5] **Explanation:** Assuming the arrays are 0-indexed, then result[0] = |2-2| + |2-3| + |2-5| = 0 + 1 + 3 = 4, result[1] = |3-2| + |3-3| + |3-5| = 1 + 0 + 2 = 3, result[2] = |5-2| + |5-3| + |5-5| = 3 + 2 + 0 = 5. ``` **Example 2:** ``` **Input:** nums = [1,4,6,8,10] **Output:** [24,15,13,15,21] ``` **Constraints:** `2 <= nums.length <= 105` `1 <= nums[i] <= nums[i + 1] <= 104`",
        "test_case": [
            {
                "label": "Example 1",
                "input": "nums = [2,3,5]",
                "output": "[4,3,5] Explanation: Assuming the arrays are 0-indexed, then\nresult[0] = |2-2| + |2-3| + |2-5| = 0 + 1 + 3 = 4,\nresult[1] = |3-2| + |3-3| + |3-5| = 1 + 0 + 2 = 3,\nresult[2] = |5-2| + |5-3| + |5-5| = 3 + 2 + 0 = 5."
            },
            {
                "label": "Example 2",
                "input": "nums = [1,4,6,8,10]",
                "output": "[24,15,13,15,21]"
            }
        ],
        "elixir_template": "Elixir code template not available for this problem.",
        "erlang_template": "Elixir code template not available for this problem.",
        "scala_template": "object Solution {\n    def getSumAbsoluteDifferences(nums: Array[Int]): Array[Int] = {\n        \n    }\n}"
    },
    {
        "id": 1786,
        "name": "count-the-number-of-consistent-strings",
        "difficulty": "Easy",
        "link": "https://leetcode.com/problems/count-the-number-of-consistent-strings/",
        "task_description": "You are given a string `allowed` consisting of **distinct** characters and an array of strings `words`. A string is **consistent **if all characters in the string appear in the string `allowed`. Return_ the number of **consistent** strings in the array _`words`. **Example 1:** ``` **Input:** allowed = \"ab\", words = [\"ad\",\"bd\",\"aaab\",\"baa\",\"badab\"] **Output:** 2 **Explanation:** Strings \"aaab\" and \"baa\" are consistent since they only contain characters 'a' and 'b'. ``` **Example 2:** ``` **Input:** allowed = \"abc\", words = [\"a\",\"b\",\"c\",\"ab\",\"ac\",\"bc\",\"abc\"] **Output:** 7 **Explanation:** All strings are consistent. ``` **Example 3:** ``` **Input:** allowed = \"cad\", words = [\"cc\",\"acd\",\"b\",\"ba\",\"bac\",\"bad\",\"ac\",\"d\"] **Output:** 4 **Explanation:** Strings \"cc\", \"acd\", \"ac\", and \"d\" are consistent. ``` **Constraints:** `1 <= words.length <= 104` `1 <= allowed.length <= 26` `1 <= words[i].length <= 10` The characters in `allowed` are **distinct**. `words[i]` and `allowed` contain only lowercase English letters.",
        "test_case": [
            {
                "label": "Example 1",
                "input": "allowed = \"ab\", words = [\"ad\",\"bd\",\"aaab\",\"baa\",\"badab\"]",
                "output": "2 Explanation: Strings \"aaab\" and \"baa\" are consistent since they only contain characters 'a' and 'b'."
            },
            {
                "label": "Example 2",
                "input": "allowed = \"abc\", words = [\"a\",\"b\",\"c\",\"ab\",\"ac\",\"bc\",\"abc\"]",
                "output": "7 Explanation: All strings are consistent."
            },
            {
                "label": "Example 3",
                "input": "allowed = \"cad\", words = [\"cc\",\"acd\",\"b\",\"ba\",\"bac\",\"bad\",\"ac\",\"d\"]",
                "output": "4 Explanation: Strings \"cc\", \"acd\", \"ac\", and \"d\" are consistent."
            }
        ],
        "elixir_template": "Elixir code template not available for this problem.",
        "erlang_template": "Elixir code template not available for this problem.",
        "scala_template": "object Solution {\n    def countConsistentStrings(allowed: String, words: Array[String]): Int = {\n        \n    }\n}"
    },
    {
        "id": 1784,
        "name": "minimum-initial-energy-to-finish-tasks",
        "difficulty": "Hard",
        "link": "https://leetcode.com/problems/minimum-initial-energy-to-finish-tasks/",
        "task_description": "You are given an array `tasks` where `tasks[i] = [actuali, minimumi]`: `actuali` is the actual amount of energy you **spend to finish** the `ith` task. `minimumi` is the minimum amount of energy you **require to begin** the `ith` task. For example, if the task is `[10, 12]` and your current energy is `11`, you cannot start this task. However, if your current energy is `13`, you can complete this task, and your energy will be `3` after finishing it. You can finish the tasks in **any order** you like. Return _the **minimum** initial amount of energy you will need_ _to finish all the tasks_. **Example 1:** ``` **Input:** tasks = [[1,2],[2,4],[4,8]] **Output:** 8 **Explanation:** Starting with 8 energy, we finish the tasks in the following order: - 3rd task. Now energy = 8 - 4 = 4. - 2nd task. Now energy = 4 - 2 = 2. - 1st task. Now energy = 2 - 1 = 1. Notice that even though we have leftover energy, starting with 7 energy does not work because we cannot do the 3rd task. ``` **Example 2:** ``` **Input:** tasks = [[1,3],[2,4],[10,11],[10,12],[8,9]] **Output:** 32 **Explanation:** Starting with 32 energy, we finish the tasks in the following order: - 1st task. Now energy = 32 - 1 = 31. - 2nd task. Now energy = 31 - 2 = 29. - 3rd task. Now energy = 29 - 10 = 19. - 4th task. Now energy = 19 - 10 = 9. - 5th task. Now energy = 9 - 8 = 1. ``` **Example 3:** ``` **Input:** tasks = [[1,7],[2,8],[3,9],[4,10],[5,11],[6,12]] **Output:** 27 **Explanation:** Starting with 27 energy, we finish the tasks in the following order: - 5th task. Now energy = 27 - 5 = 22. - 2nd task. Now energy = 22 - 2 = 20. - 3rd task. Now energy = 20 - 3 = 17. - 1st task. Now energy = 17 - 1 = 16. - 4th task. Now energy = 16 - 4 = 12. - 6th task. Now energy = 12 - 6 = 6. ``` **Constraints:** `1 <= tasks.length <= 105` `1 <= actual\u200bi <= minimumi <= 104`",
        "test_case": [
            {
                "label": "Example 1",
                "input": "tasks = [[1,2],[2,4],[4,8]]",
                "output": "8 Explanation: Starting with 8 energy, we finish the tasks in the following order:\n    - 3rd task. Now energy = 8 - 4 = 4.\n    - 2nd task. Now energy = 4 - 2 = 2.\n    - 1st task. Now energy = 2 - 1 = 1.\nNotice that even though we have leftover energy, starting with 7 energy does not work because we cannot do the 3rd task."
            },
            {
                "label": "Example 2",
                "input": "tasks = [[1,3],[2,4],[10,11],[10,12],[8,9]]",
                "output": "32 Explanation: Starting with 32 energy, we finish the tasks in the following order:\n    - 1st task. Now energy = 32 - 1 = 31.\n    - 2nd task. Now energy = 31 - 2 = 29.\n    - 3rd task. Now energy = 29 - 10 = 19.\n    - 4th task. Now energy = 19 - 10 = 9.\n    - 5th task. Now energy = 9 - 8 = 1."
            },
            {
                "label": "Example 3",
                "input": "tasks = [[1,7],[2,8],[3,9],[4,10],[5,11],[6,12]]",
                "output": "27 Explanation: Starting with 27 energy, we finish the tasks in the following order:\n    - 5th task. Now energy = 27 - 5 = 22.\n    - 2nd task. Now energy = 22 - 2 = 20.\n    - 3rd task. Now energy = 20 - 3 = 17.\n    - 1st task. Now energy = 17 - 1 = 16.\n    - 4th task. Now energy = 16 - 4 = 12.\n    - 6th task. Now energy = 12 - 6 = 6."
            }
        ],
        "elixir_template": "defmodule Solution do\n  @spec minimum_effort(tasks :: [[integer]]) :: integer\n  def minimum_effort(tasks) do\n    \n  end\nend",
        "erlang_template": "-spec minimum_effort(Tasks :: [[integer()]]) -> integer().\nminimum_effort(Tasks) ->\n  .",
        "scala_template": "object Solution {\n    def minimumEffort(tasks: Array[Array[Int]]): Int = {\n        \n    }\n}"
    },
    {
        "id": 1783,
        "name": "ways-to-make-a-fair-array",
        "difficulty": "Medium",
        "link": "https://leetcode.com/problems/ways-to-make-a-fair-array/",
        "task_description": "You are given an integer array `nums`. You can choose **exactly one** index (**0-indexed**) and remove the element. Notice that the index of the elements may change after the removal. For example, if `nums = [6,1,7,4,1]`: Choosing to remove index `1` results in `nums = [6,7,4,1]`. Choosing to remove index `2` results in `nums = [6,1,4,1]`. Choosing to remove index `4` results in `nums = [6,1,7,4]`. An array is **fair** if the sum of the odd-indexed values equals the sum of the even-indexed values. Return the _**number** of indices that you could choose such that after the removal, _`nums`_ __is **fair**. _ **Example 1:** ``` **Input:** nums = [2,1,6,4] **Output:** 1 **Explanation:** Remove index 0: [1,6,4] -> Even sum: 1 + 4 = 5. Odd sum: 6. Not fair. Remove index 1: [2,6,4] -> Even sum: 2 + 4 = 6. Odd sum: 6. Fair. Remove index 2: [2,1,4] -> Even sum: 2 + 4 = 6. Odd sum: 1. Not fair. Remove index 3: [2,1,6] -> Even sum: 2 + 6 = 8. Odd sum: 1. Not fair. There is 1 index that you can remove to make nums fair. ``` **Example 2:** ``` **Input:** nums = [1,1,1] **Output:** 3 **Explanation:** You can remove any index and the remaining array is fair. ``` **Example 3:** ``` **Input:** nums = [1,2,3] **Output:** 0 **Explanation:** You cannot make a fair array after removing any index. ``` **Constraints:** `1 <= nums.length <= 105` `1 <= nums[i] <= 104`",
        "test_case": [
            {
                "label": "Example 1",
                "input": "nums = [2,1,6,4]",
                "output": "1 Explanation: Remove index 0: [1,6,4] -> Even sum: 1 + 4 = 5. Odd sum: 6. Not fair.\nRemove index 1: [2,6,4] -> Even sum: 2 + 4 = 6. Odd sum: 6. Fair.\nRemove index 2: [2,1,4] -> Even sum: 2 + 4 = 6. Odd sum: 1. Not fair.\nRemove index 3: [2,1,6] -> Even sum: 2 + 6 = 8. Odd sum: 1. Not fair.\nThere is 1 index that you can remove to make nums fair."
            },
            {
                "label": "Example 2",
                "input": "nums = [1,1,1]",
                "output": "3 Explanation: You can remove any index and the remaining array is fair."
            },
            {
                "label": "Example 3",
                "input": "nums = [1,2,3]",
                "output": "0 Explanation: You cannot make a fair array after removing any index."
            }
        ],
        "elixir_template": "defmodule Solution do\n  @spec ways_to_make_fair(nums :: [integer]) :: integer\n  def ways_to_make_fair(nums) do\n    \n  end\nend",
        "erlang_template": "-spec ways_to_make_fair(Nums :: [integer()]) -> integer().\nways_to_make_fair(Nums) ->\n  .",
        "scala_template": "object Solution {\n    def waysToMakeFair(nums: Array[Int]): Int = {\n        \n    }\n}"
    },
    {
        "id": 1782,
        "name": "smallest-string-with-a-given-numeric-value",
        "difficulty": "Medium",
        "link": "https://leetcode.com/problems/smallest-string-with-a-given-numeric-value/",
        "task_description": "The **numeric value** of a **lowercase character** is defined as its position `(1-indexed)` in the alphabet, so the numeric value of `a` is `1`, the numeric value of `b` is `2`, the numeric value of `c` is `3`, and so on. The **numeric value** of a **string** consisting of lowercase characters is defined as the sum of its characters' numeric values. For example, the numeric value of the string `\"abe\"` is equal to `1 + 2 + 5 = 8`. You are given two integers `n` and `k`. Return _the **lexicographically smallest string** with **length** equal to `n` and **numeric value** equal to `k`._ Note that a string `x` is lexicographically smaller than string `y` if `x` comes before `y` in dictionary order, that is, either `x` is a prefix of `y`, or if `i` is the first position such that `x[i] != y[i]`, then `x[i]` comes before `y[i]` in alphabetic order. **Example 1:** ``` **Input:** n = 3, k = 27 **Output:** \"aay\" **Explanation:** The numeric value of the string is 1 + 1 + 25 = 27, and it is the smallest string with such a value and length equal to 3. ``` **Example 2:** ``` **Input:** n = 5, k = 73 **Output:** \"aaszz\" ``` **Constraints:** `1 <= n <= 105` `n <= k <= 26 * n`",
        "test_case": [
            {
                "label": "Example 1",
                "input": "n = 3, k = 27",
                "output": "\"aay\" Explanation: The numeric value of the string is 1 + 1 + 25 = 27, and it is the smallest string with such a value and length equal to 3."
            },
            {
                "label": "Example 2",
                "input": "n = 5, k = 73",
                "output": "\"aaszz\""
            }
        ],
        "elixir_template": "defmodule Solution do\n  @spec get_smallest_string(n :: integer, k :: integer) :: String.t\n  def get_smallest_string(n, k) do\n    \n  end\nend",
        "erlang_template": "-spec get_smallest_string(N :: integer(), K :: integer()) -> unicode:unicode_binary().\nget_smallest_string(N, K) ->\n  .",
        "scala_template": "object Solution {\n    def getSmallestString(n: Int, k: Int): String = {\n        \n    }\n}"
    },
    {
        "id": 1781,
        "name": "check-if-two-string-arrays-are-equivalent",
        "difficulty": "Easy",
        "link": "https://leetcode.com/problems/check-if-two-string-arrays-are-equivalent/",
        "task_description": "Given two string arrays `word1` and `word2`, return_ _`true`_ if the two arrays **represent** the same string, and _`false`_ otherwise._ A string is **represented** by an array if the array elements concatenated **in order** forms the string. **Example 1:** ``` **Input:** word1 = [\"ab\", \"c\"], word2 = [\"a\", \"bc\"] **Output:** true **Explanation:** word1 represents string \"ab\" + \"c\" -> \"abc\" word2 represents string \"a\" + \"bc\" -> \"abc\" The strings are the same, so return true. ``` **Example 2:** ``` **Input:** word1 = [\"a\", \"cb\"], word2 = [\"ab\", \"c\"] **Output:** false ``` **Example 3:** ``` **Input:** word1 = [\"abc\", \"d\", \"defg\"], word2 = [\"abcddefg\"] **Output:** true ``` **Constraints:** `1 <= word1.length, word2.length <= 103` `1 <= word1[i].length, word2[i].length <= 103` `1 <= sum(word1[i].length), sum(word2[i].length) <= 103` `word1[i]` and `word2[i]` consist of lowercase letters.",
        "test_case": [
            {
                "label": "Example 1",
                "input": "word1 = [\"ab\", \"c\"], word2 = [\"a\", \"bc\"]",
                "output": "true Explanation: word1 represents string \"ab\" + \"c\" -> \"abc\"\nword2 represents string \"a\" + \"bc\" -> \"abc\"\nThe strings are the same, so return true."
            },
            {
                "label": "Example 2",
                "input": "word1 = [\"a\", \"cb\"], word2 = [\"ab\", \"c\"]",
                "output": "false"
            },
            {
                "label": "Example 3",
                "input": "word1  = [\"abc\", \"d\", \"defg\"], word2 = [\"abcddefg\"]",
                "output": "true"
            }
        ],
        "elixir_template": "defmodule Solution do\n  @spec array_strings_are_equal(word1 :: [String.t], word2 :: [String.t]) :: boolean\n  def array_strings_are_equal(word1, word2) do\n    \n  end\nend",
        "erlang_template": "-spec array_strings_are_equal(Word1 :: [unicode:unicode_binary()], Word2 :: [unicode:unicode_binary()]) -> boolean().\narray_strings_are_equal(Word1, Word2) ->\n  .",
        "scala_template": "object Solution {\n    def arrayStringsAreEqual(word1: Array[String], word2: Array[String]): Boolean = {\n        \n    }\n}"
    },
    {
        "id": 1778,
        "name": "maximize-grid-happiness",
        "difficulty": "Hard",
        "link": "https://leetcode.com/problems/maximize-grid-happiness/",
        "task_description": "You are given four integers, `m`, `n`, `introvertsCount`, and `extrovertsCount`. You have an `m x n` grid, and there are two types of people: introverts and extroverts. There are `introvertsCount` introverts and `extrovertsCount` extroverts. You should decide how many people you want to live in the grid and assign each of them one grid cell. Note that you **do not** have to have all the people living in the grid. The **happiness** of each person is calculated as follows: Introverts **start** with `120` happiness and **lose** `30` happiness for each neighbor (introvert or extrovert). Extroverts **start** with `40` happiness and **gain** `20` happiness for each neighbor (introvert or extrovert). Neighbors live in the directly adjacent cells north, east, south, and west of a person's cell. The **grid happiness** is the **sum** of each person's happiness. Return_ the **maximum possible grid happiness**._ **Example 1:** ``` **Input:** m = 2, n = 3, introvertsCount = 1, extrovertsCount = 2 **Output:** 240 **Explanation:** Assume the grid is 1-indexed with coordinates (row, column). We can put the introvert in cell (1,1) and put the extroverts in cells (1,3) and (2,3). - Introvert at (1,1) happiness: 120 (starting happiness) - (0 * 30) (0 neighbors) = 120 - Extrovert at (1,3) happiness: 40 (starting happiness) + (1 * 20) (1 neighbor) = 60 - Extrovert at (2,3) happiness: 40 (starting happiness) + (1 * 20) (1 neighbor) = 60 The grid happiness is 120 + 60 + 60 = 240. The above figure shows the grid in this example with each person's happiness. The introvert stays in the light green cell while the extroverts live on the light purple cells. ``` **Example 2:** ``` **Input:** m = 3, n = 1, introvertsCount = 2, extrovertsCount = 1 **Output:** 260 **Explanation:** Place the two introverts in (1,1) and (3,1) and the extrovert at (2,1). - Introvert at (1,1) happiness: 120 (starting happiness) - (1 * 30) (1 neighbor) = 90 - Extrovert at (2,1) happiness: 40 (starting happiness) + (2 * 20) (2 neighbors) = 80 - Introvert at (3,1) happiness: 120 (starting happiness) - (1 * 30) (1 neighbor) = 90 The grid happiness is 90 + 80 + 90 = 260. ``` **Example 3:** ``` **Input:** m = 2, n = 2, introvertsCount = 4, extrovertsCount = 0 **Output:** 240 ``` **Constraints:** `1 <= m, n <= 5` `0 <= introvertsCount, extrovertsCount <= min(m * n, 6)`",
        "test_case": [
            {
                "label": "Example 1",
                "input": "m = 2, n = 3, introvertsCount = 1, extrovertsCount = 2",
                "output": "240 Explanation: Assume the grid is 1-indexed with coordinates (row, column).\nWe can put the introvert in cell (1,1) and put the extroverts in cells (1,3) and (2,3).\n- Introvert at (1,1) happiness: 120 (starting happiness) - (0 * 30) (0 neighbors) = 120\n- Extrovert at (1,3) happiness: 40 (starting happiness) + (1 * 20) (1 neighbor) = 60\n- Extrovert at (2,3) happiness: 40 (starting happiness) + (1 * 20) (1 neighbor) = 60\nThe grid happiness is 120 + 60 + 60 = 240.\nThe above figure shows the grid in this example with each person's happiness. The introvert stays in the light green cell while the extroverts live on the light purple cells."
            },
            {
                "label": "Example 2",
                "input": "m = 3, n = 1, introvertsCount = 2, extrovertsCount = 1",
                "output": "260 Explanation: Place the two introverts in (1,1) and (3,1) and the extrovert at (2,1).\n- Introvert at (1,1) happiness: 120 (starting happiness) - (1 * 30) (1 neighbor) = 90\n- Extrovert at (2,1) happiness: 40 (starting happiness) + (2 * 20) (2 neighbors) = 80\n- Introvert at (3,1) happiness: 120 (starting happiness) - (1 * 30) (1 neighbor) = 90\nThe grid happiness is 90 + 80 + 90 = 260."
            },
            {
                "label": "Example 3",
                "input": "m = 2, n = 2, introvertsCount = 4, extrovertsCount = 0",
                "output": "240"
            }
        ],
        "elixir_template": "defmodule Solution do\n  @spec get_max_grid_happiness(m :: integer, n :: integer, introverts_count :: integer, extroverts_count :: integer) :: integer\n  def get_max_grid_happiness(m, n, introverts_count, extroverts_count) do\n    \n  end\nend",
        "erlang_template": "-spec get_max_grid_happiness(M :: integer(), N :: integer(), IntrovertsCount :: integer(), ExtrovertsCount :: integer()) -> integer().\nget_max_grid_happiness(M, N, IntrovertsCount, ExtrovertsCount) ->\n  .",
        "scala_template": "object Solution {\n    def getMaxGridHappiness(m: Int, n: Int, introvertsCount: Int, extrovertsCount: Int): Int = {\n        \n    }\n}"
    },
    {
        "id": 1777,
        "name": "determine-if-two-strings-are-close",
        "difficulty": "Medium",
        "link": "https://leetcode.com/problems/determine-if-two-strings-are-close/",
        "task_description": "Two strings are considered **close** if you can attain one from the other using the following operations: Operation 1: Swap any two **existing** characters. For example, `abcde -> aecdb` Operation 2: Transform **every** occurrence of one **existing** character into another **existing** character, and do the same with the other character. For example, `aacabb -> bbcbaa` (all `a`'s turn into `b`'s, and all `b`'s turn into `a`'s) You can use the operations on either string as many times as necessary. Given two strings, `word1` and `word2`, return `true`_ if _`word1`_ and _`word2`_ are **close**, and _`false`_ otherwise._ **Example 1:** ``` **Input:** word1 = \"abc\", word2 = \"bca\" **Output:** true **Explanation:** You can attain word2 from word1 in 2 operations. Apply Operation 1: \"abc\" -> \"acb\" Apply Operation 1: \"acb\" -> \"bca\" ``` **Example 2:** ``` **Input:** word1 = \"a\", word2 = \"aa\" **Output:** false **Explanation: **It is impossible to attain word2 from word1, or vice versa, in any number of operations. ``` **Example 3:** ``` **Input:** word1 = \"cabbba\", word2 = \"abbccc\" **Output:** true **Explanation:** You can attain word2 from word1 in 3 operations. Apply Operation 1: \"cabbba\" -> \"caabbb\" Apply Operation 2: \"caabbb\" -> \"baaccc\" Apply Operation 2: \"baaccc\" -> \"abbccc\" ``` **Constraints:** `1 <= word1.length, word2.length <= 105` `word1` and `word2` contain only lowercase English letters.",
        "test_case": [
            {
                "label": "Example 1",
                "input": "word1 = \"abc\", word2 = \"bca\"",
                "output": "true Explanation: You can attain word2 from word1 in 2 operations.\nApply Operation 1: \"a bc \" -> \"a cb \"\nApply Operation 1: \" a c b \" -> \" b c a \""
            },
            {
                "label": "Example 2",
                "input": "word1 = \"a\", word2 = \"aa\"",
                "output": "false Explanation: It is impossible to attain word2 from word1, or vice versa, in any number of operations."
            },
            {
                "label": "Example 3",
                "input": "word1 = \"cabbba\", word2 = \"abbccc\"",
                "output": "true Explanation: You can attain word2 from word1 in 3 operations.\nApply Operation 1: \"ca b bb a \" -> \"ca a bb b \"\nApply Operation 2: \" c aa bbb \" -> \" b aa ccc \"\nApply Operation 2: \" baa ccc\" -> \" abb ccc\""
            }
        ],
        "elixir_template": "defmodule Solution do\n  @spec close_strings(word1 :: String.t, word2 :: String.t) :: boolean\n  def close_strings(word1, word2) do\n    \n  end\nend",
        "erlang_template": "-spec close_strings(Word1 :: unicode:unicode_binary(), Word2 :: unicode:unicode_binary()) -> boolean().\nclose_strings(Word1, Word2) ->\n  .",
        "scala_template": "object Solution {\n    def closeStrings(word1: String, word2: String): Boolean = {\n        \n    }\n}"
    },
    {
        "id": 1776,
        "name": "minimum-operations-to-reduce-x-to-zero",
        "difficulty": "Medium",
        "link": "https://leetcode.com/problems/minimum-operations-to-reduce-x-to-zero/",
        "task_description": "You are given an integer array `nums` and an integer `x`. In one operation, you can either remove the leftmost or the rightmost element from the array `nums` and subtract its value from `x`. Note that this **modifies** the array for future operations. Return _the **minimum number** of operations to reduce _`x` _to **exactly**_ `0` _if it is possible__, otherwise, return _`-1`. **Example 1:** ``` **Input:** nums = [1,1,4,2,3], x = 5 **Output:** 2 **Explanation:** The optimal solution is to remove the last two elements to reduce x to zero. ``` **Example 2:** ``` **Input:** nums = [5,6,7,8,9], x = 4 **Output:** -1 ``` **Example 3:** ``` **Input:** nums = [3,2,20,1,1,3], x = 10 **Output:** 5 **Explanation:** The optimal solution is to remove the last three elements and the first two elements (5 operations in total) to reduce x to zero. ``` **Constraints:** `1 <= nums.length <= 105` `1 <= nums[i] <= 104` `1 <= x <= 109`",
        "test_case": [
            {
                "label": "Example 1",
                "input": "nums = [1,1,4,2,3], x = 5",
                "output": "2 Explanation: The optimal solution is to remove the last two elements to reduce x to zero."
            },
            {
                "label": "Example 2",
                "input": "nums = [5,6,7,8,9], x = 4",
                "output": "-1"
            },
            {
                "label": "Example 3",
                "input": "nums = [3,2,20,1,1,3], x = 10",
                "output": "5 Explanation: The optimal solution is to remove the last three elements and the first two elements (5 operations in total) to reduce x to zero."
            }
        ],
        "elixir_template": "defmodule Solution do\n  @spec min_operations(nums :: [integer], x :: integer) :: integer\n  def min_operations(nums, x) do\n    \n  end\nend",
        "erlang_template": "-spec min_operations(Nums :: [integer()], X :: integer()) -> integer().\nmin_operations(Nums, X) ->\n  .",
        "scala_template": "object Solution {\n    def minOperations(nums: Array[Int], x: Int): Int = {\n        \n    }\n}"
    },
    {
        "id": 1775,
        "name": "design-an-ordered-stream",
        "difficulty": "Easy",
        "link": "https://leetcode.com/problems/design-an-ordered-stream/",
        "task_description": "There is a stream of `n` `(idKey, value)` pairs arriving in an **arbitrary** order, where `idKey` is an integer between `1` and `n` and `value` is a string. No two pairs have the same `id`. Design a stream that returns the values in **increasing order of their IDs** by returning a **chunk** (list) of values after each insertion. The concatenation of all the **chunks** should result in a list of the sorted values. Implement the `OrderedStream` class: `OrderedStream(int n)` Constructs the stream to take `n` values. `String[] insert(int idKey, String value)` Inserts the pair `(idKey, value)` into the stream, then returns the **largest possible chunk** of currently inserted values that appear next in the order. **Example:** **** ``` **Input** [\"OrderedStream\", \"insert\", \"insert\", \"insert\", \"insert\", \"insert\"] [[5], [3, \"ccccc\"], [1, \"aaaaa\"], [2, \"bbbbb\"], [5, \"eeeee\"], [4, \"ddddd\"]] **Output** [null, [], [\"aaaaa\"], [\"bbbbb\", \"ccccc\"], [], [\"ddddd\", \"eeeee\"]] **Explanation** // Note that the values ordered by ID is [\"aaaaa\", \"bbbbb\", \"ccccc\", \"ddddd\", \"eeeee\"]. OrderedStream os = new OrderedStream(5); os.insert(3, \"ccccc\"); // Inserts (3, \"ccccc\"), returns []. os.insert(1, \"aaaaa\"); // Inserts (1, \"aaaaa\"), returns [\"aaaaa\"]. os.insert(2, \"bbbbb\"); // Inserts (2, \"bbbbb\"), returns [\"bbbbb\", \"ccccc\"]. os.insert(5, \"eeeee\"); // Inserts (5, \"eeeee\"), returns []. os.insert(4, \"ddddd\"); // Inserts (4, \"ddddd\"), returns [\"ddddd\", \"eeeee\"]. // Concatentating all the chunks returned: // [] + [\"aaaaa\"] + [\"bbbbb\", \"ccccc\"] + [] + [\"ddddd\", \"eeeee\"] = [\"aaaaa\", \"bbbbb\", \"ccccc\", \"ddddd\", \"eeeee\"] // The resulting order is the same as the order above. ``` **Constraints:** `1 <= n <= 1000` `1 <= id <= n` `value.length == 5` `value` consists only of lowercase letters. Each call to `insert` will have a unique `id.` Exactly `n` calls will be made to `insert`.",
        "test_case": [],
        "elixir_template": "defmodule OrderedStream do\n  @spec init_(n :: integer) :: any\n  def init_(n) do\n    \n  end\n\n  @spec insert(id_key :: integer, value :: String.t) :: [String.t]\n  def insert(id_key, value) do\n    \n  end\nend\n\n# Your functions will be called as such:\n# OrderedStream.init_(n)\n# param_1 = OrderedStream.insert(id_key, value)\n\n# OrderedStream.init_ will be called before every test case, in which you can do some necessary initializations.",
        "erlang_template": "-spec ordered_stream_init_(N :: integer()) -> any().\nordered_stream_init_(N) ->\n  .\n\n-spec ordered_stream_insert(IdKey :: integer(), Value :: unicode:unicode_binary()) -> [unicode:unicode_binary()].\nordered_stream_insert(IdKey, Value) ->\n  .\n\n\n%% Your functions will be called as such:\n%% ordered_stream_init_(N),\n%% Param_1 = ordered_stream_insert(IdKey, Value),\n\n%% ordered_stream_init_ will be called before every test case, in which you can do some necessary initializations.",
        "scala_template": "class OrderedStream(_n: Int) {\n\n    def insert(idKey: Int, value: String): List[String] = {\n        \n    }\n\n}\n\n/**\n * Your OrderedStream object will be instantiated and called as such:\n * val obj = new OrderedStream(n)\n * val param_1 = obj.insert(idKey,value)\n */"
    },
    {
        "id": 1772,
        "name": "create-sorted-array-through-instructions",
        "difficulty": "Hard",
        "link": "https://leetcode.com/problems/create-sorted-array-through-instructions/",
        "task_description": "Given an integer array `instructions`, you are asked to create a sorted array from the elements in `instructions`. You start with an empty container `nums`. For each element from **left to right** in `instructions`, insert it into `nums`. The **cost** of each insertion is the minimum of the following: The number of elements currently in `nums` that are **strictly less than** `instructions[i]`. The number of elements currently in `nums` that are **strictly greater than** `instructions[i]`. For example, if inserting element `3` into `nums = [1,2,3,5]`, the **cost** of insertion is `min(2, 1)` (elements `1` and `2` are less than `3`, element `5` is greater than `3`) and `nums` will become `[1,2,3,3,5]`. Return _the **total cost** to insert all elements from _`instructions`_ into _`nums`. Since the answer may be large, return it **modulo** `109 + 7` **Example 1:** ``` **Input:** instructions = [1,5,6,2] **Output:** 1 **Explanation:** Begin with nums = []. Insert 1 with cost min(0, 0) = 0, now nums = [1]. Insert 5 with cost min(1, 0) = 0, now nums = [1,5]. Insert 6 with cost min(2, 0) = 0, now nums = [1,5,6]. Insert 2 with cost min(1, 2) = 1, now nums = [1,2,5,6]. The total cost is 0 + 0 + 0 + 1 = 1. ``` **Example 2:** ``` **Input:** instructions = [1,2,3,6,5,4] **Output:** 3 **Explanation:** Begin with nums = []. Insert 1 with cost min(0, 0) = 0, now nums = [1]. Insert 2 with cost min(1, 0) = 0, now nums = [1,2]. Insert 3 with cost min(2, 0) = 0, now nums = [1,2,3]. Insert 6 with cost min(3, 0) = 0, now nums = [1,2,3,6]. Insert 5 with cost min(3, 1) = 1, now nums = [1,2,3,5,6]. Insert 4 with cost min(3, 2) = 2, now nums = [1,2,3,4,5,6]. The total cost is 0 + 0 + 0 + 0 + 1 + 2 = 3. ``` **Example 3:** ``` **Input:** instructions = [1,3,3,3,2,4,2,1,2] **Output:** 4 **Explanation:** Begin with nums = []. Insert 1 with cost min(0, 0) = 0, now nums = [1]. Insert 3 with cost min(1, 0) = 0, now nums = [1,3]. Insert 3 with cost min(1, 0) = 0, now nums = [1,3,3]. Insert 3 with cost min(1, 0) = 0, now nums = [1,3,3,3]. Insert 2 with cost min(1, 3) = 1, now nums = [1,2,3,3,3]. Insert 4 with cost min(5, 0) = 0, now nums = [1,2,3,3,3,4]. \u200b\u200b\u200b\u200b\u200b\u200b\u200bInsert 2 with cost min(1, 4) = 1, now nums = [1,2,2,3,3,3,4]. \u200b\u200b\u200b\u200b\u200b\u200b\u200bInsert 1 with cost min(0, 6) = 0, now nums = [1,1,2,2,3,3,3,4]. \u200b\u200b\u200b\u200b\u200b\u200b\u200bInsert 2 with cost min(2, 4) = 2, now nums = [1,1,2,2,2,3,3,3,4]. The total cost is 0 + 0 + 0 + 0 + 1 + 0 + 1 + 0 + 2 = 4. ``` **Constraints:** `1 <= instructions.length <= 105` `1 <= instructions[i] <= 105`",
        "test_case": [
            {
                "label": "Example 1",
                "input": "instructions = [1,5,6,2]",
                "output": "1 Explanation: Begin with nums = [].\r\nInsert 1 with cost min(0, 0) = 0, now nums = [1].\r\nInsert 5 with cost min(1, 0) = 0, now nums = [1,5].\r\nInsert 6 with cost min(2, 0) = 0, now nums = [1,5,6].\r\nInsert 2 with cost min(1, 2) = 1, now nums = [1,2,5,6].\r\nThe total cost is 0 + 0 + 0 + 1 = 1."
            },
            {
                "label": "Example 2",
                "input": "instructions = [1,2,3,6,5,4]",
                "output": "3 Explanation: Begin with nums = [].\r\nInsert 1 with cost min(0, 0) = 0, now nums = [1].\r\nInsert 2 with cost min(1, 0) = 0, now nums = [1,2].\r\nInsert 3 with cost min(2, 0) = 0, now nums = [1,2,3].\r\nInsert 6 with cost min(3, 0) = 0, now nums = [1,2,3,6].\r\nInsert 5 with cost min(3, 1) = 1, now nums = [1,2,3,5,6].\r\nInsert 4 with cost min(3, 2) = 2, now nums = [1,2,3,4,5,6].\r\nThe total cost is 0 + 0 + 0 + 0 + 1 + 2 = 3."
            },
            {
                "label": "Example 3",
                "input": "instructions = [1,3,3,3,2,4,2,1,2]",
                "output": "4 Explanation: Begin with nums = [].\r\nInsert 1 with cost min(0, 0) = 0, now nums = [1].\r\nInsert 3 with cost min(1, 0) = 0, now nums = [1,3].\r\nInsert 3 with cost min(1, 0) = 0, now nums = [1,3,3].\r\nInsert 3 with cost min(1, 0) = 0, now nums = [1,3,3,3].\r\nInsert 2 with cost min(1, 3) = 1, now nums = [1,2,3,3,3].\r\nInsert 4 with cost min(5, 0) = 0, now nums = [1,2,3,3,3,4].\r\n\u200b\u200b\u200b\u200b\u200b\u200b\u200bInsert 2 with cost min(1, 4) = 1, now nums = [1,2,2,3,3,3,4].\r\n\u200b\u200b\u200b\u200b\u200b\u200b\u200bInsert 1 with cost min(0, 6) = 0, now nums = [1,1,2,2,3,3,3,4].\r\n\u200b\u200b\u200b\u200b\u200b\u200b\u200bInsert 2 with cost min(2, 4) = 2, now nums = [1,1,2,2,2,3,3,3,4].\r\nThe total cost is 0 + 0 + 0 + 0 + 1 + 0 + 1 + 0 + 2 = 4."
            }
        ],
        "elixir_template": "Elixir code template not available for this problem.",
        "erlang_template": "Elixir code template not available for this problem.",
        "scala_template": "object Solution {\n    def createSortedArray(instructions: Array[Int]): Int = {\n        \n    }\n}"
    },
    {
        "id": 1771,
        "name": "sell-diminishing-valued-colored-balls",
        "difficulty": "Medium",
        "link": "https://leetcode.com/problems/sell-diminishing-valued-colored-balls/",
        "task_description": "You have an `inventory` of different colored balls, and there is a customer that wants `orders` balls of **any** color. The customer weirdly values the colored balls. Each colored ball's value is the number of balls **of that color **you currently have in your `inventory`. For example, if you own `6` yellow balls, the customer would pay `6` for the first yellow ball. After the transaction, there are only `5` yellow balls left, so the next yellow ball is then valued at `5` (i.e., the value of the balls decreases as you sell more to the customer). You are given an integer array, `inventory`, where `inventory[i]` represents the number of balls of the `ith` color that you initially own. You are also given an integer `orders`, which represents the total number of balls that the customer wants. You can sell the balls **in any order**. Return _the **maximum** total value that you can attain after selling _`orders`_ colored balls_. As the answer may be too large, return it **modulo **`109 + 7`. **Example 1:** ``` **Input:** inventory = [2,5], orders = 4 **Output:** 14 **Explanation:** Sell the 1st color 1 time (2) and the 2nd color 3 times (5 + 4 + 3). The maximum total value is 2 + 5 + 4 + 3 = 14. ``` **Example 2:** ``` **Input:** inventory = [3,5], orders = 6 **Output:** 19 **Explanation: **Sell the 1st color 2 times (3 + 2) and the 2nd color 4 times (5 + 4 + 3 + 2). The maximum total value is 3 + 2 + 5 + 4 + 3 + 2 = 19. ``` **Constraints:** `1 <= inventory.length <= 105` `1 <= inventory[i] <= 109` `1 <= orders <= min(sum(inventory[i]), 109)`",
        "test_case": [
            {
                "label": "Example 1",
                "input": "inventory = [2,5], orders = 4",
                "output": "14 Explanation: Sell the 1st color 1 time (2) and the 2nd color 3 times (5 + 4 + 3).\nThe maximum total value is 2 + 5 + 4 + 3 = 14."
            },
            {
                "label": "Example 2",
                "input": "inventory = [3,5], orders = 6",
                "output": "19 Explanation: Sell the 1st color 2 times (3 + 2) and the 2nd color 4 times (5 + 4 + 3 + 2).\nThe maximum total value is 3 + 2 + 5 + 4 + 3 + 2 = 19."
            }
        ],
        "elixir_template": "defmodule Solution do\n  @spec max_profit(inventory :: [integer], orders :: integer) :: integer\n  def max_profit(inventory, orders) do\n    \n  end\nend",
        "erlang_template": "-spec max_profit(Inventory :: [integer()], Orders :: integer()) -> integer().\nmax_profit(Inventory, Orders) ->\n  .",
        "scala_template": "object Solution {\n    def maxProfit(inventory: Array[Int], orders: Int): Int = {\n        \n    }\n}"
    },
    {
        "id": 1770,
        "name": "minimum-deletions-to-make-character-frequencies-unique",
        "difficulty": "Medium",
        "link": "https://leetcode.com/problems/minimum-deletions-to-make-character-frequencies-unique/",
        "task_description": "A string `s` is called **good** if there are no two different characters in `s` that have the same **frequency**. Given a string `s`, return_ the **minimum** number of characters you need to delete to make _`s`_ **good**._ The **frequency** of a character in a string is the number of times it appears in the string. For example, in the string `\"aab\"`, the **frequency** of `'a'` is `2`, while the **frequency** of `'b'` is `1`. **Example 1:** ``` **Input:** s = \"aab\" **Output:** 0 **Explanation:** `s` is already good. ``` **Example 2:** ``` **Input:** s = \"aaabbbcc\" **Output:** 2 **Explanation:** You can delete two 'b's resulting in the good string \"aaabcc\". Another way it to delete one 'b' and one 'c' resulting in the good string \"aaabbc\". ``` **Example 3:** ``` **Input:** s = \"ceabaacb\" **Output:** 2 **Explanation:** You can delete both 'c's resulting in the good string \"eabaab\". Note that we only care about characters that are still in the string at the end (i.e. frequency of 0 is ignored). ``` **Constraints:** `1 <= s.length <= 105` `s` contains only lowercase English letters.",
        "test_case": [
            {
                "label": "Example 1",
                "input": "s = \"aab\"",
                "output": "0 Explanation: s is already good."
            },
            {
                "label": "Example 2",
                "input": "s = \"aaabbbcc\"",
                "output": "2 Explanation: You can delete two 'b's resulting in the good string \"aaabcc\".\nAnother way it to delete one 'b' and one 'c' resulting in the good string \"aaabbc\"."
            },
            {
                "label": "Example 3",
                "input": "s = \"ceabaacb\"",
                "output": "2 Explanation: You can delete both 'c's resulting in the good string \"eabaab\".\nNote that we only care about characters that are still in the string at the end (i.e. frequency of 0 is ignored)."
            }
        ],
        "elixir_template": "defmodule Solution do\n  @spec min_deletions(s :: String.t) :: integer\n  def min_deletions(s) do\n    \n  end\nend",
        "erlang_template": "-spec min_deletions(S :: unicode:unicode_binary()) -> integer().\nmin_deletions(S) ->\n  .",
        "scala_template": "object Solution {\n    def minDeletions(s: String): Int = {\n        \n    }\n}"
    },
    {
        "id": 1769,
        "name": "get-maximum-in-generated-array",
        "difficulty": "Easy",
        "link": "https://leetcode.com/problems/get-maximum-in-generated-array/",
        "task_description": "You are given an integer `n`. A **0-indexed** integer array `nums` of length `n + 1` is generated in the following way: `nums[0] = 0` `nums[1] = 1` `nums[2 * i] = nums[i]` when `2 <= 2 * i <= n` `nums[2 * i + 1] = nums[i] + nums[i + 1]` when `2 <= 2 * i + 1 <= n` Return** **_the **maximum** integer in the array _`nums`\u200b\u200b\u200b. **Example 1:** ``` **Input:** n = 7 **Output:** 3 **Explanation:** According to the given rules: nums[0] = 0 nums[1] = 1 nums[(1 * 2) = 2] = nums[1] = 1 nums[(1 * 2) + 1 = 3] = nums[1] + nums[2] = 1 + 1 = 2 nums[(2 * 2) = 4] = nums[2] = 1 nums[(2 * 2) + 1 = 5] = nums[2] + nums[3] = 1 + 2 = 3 nums[(3 * 2) = 6] = nums[3] = 2 nums[(3 * 2) + 1 = 7] = nums[3] + nums[4] = 2 + 1 = 3 Hence, nums = [0,1,1,2,1,3,2,3], and the maximum is max(0,1,1,2,1,3,2,3) = 3. ``` **Example 2:** ``` **Input:** n = 2 **Output:** 1 **Explanation:** According to the given rules, nums = [0,1,1]. The maximum is max(0,1,1) = 1. ``` **Example 3:** ``` **Input:** n = 3 **Output:** 2 **Explanation:** According to the given rules, nums = [0,1,1,2]. The maximum is max(0,1,1,2) = 2. ``` **Constraints:** `0 <= n <= 100`",
        "test_case": [
            {
                "label": "Example 1",
                "input": "n = 7",
                "output": "3 Explanation: According to the given rules:\n  nums[0] = 0\n  nums[1] = 1\n  nums[(1 * 2) = 2] = nums[1] = 1\n  nums[(1 * 2) + 1 = 3] = nums[1] + nums[2] = 1 + 1 = 2\n  nums[(2 * 2) = 4] = nums[2] = 1\n  nums[(2 * 2) + 1 = 5] = nums[2] + nums[3] = 1 + 2 = 3\n  nums[(3 * 2) = 6] = nums[3] = 2\n  nums[(3 * 2) + 1 = 7] = nums[3] + nums[4] = 2 + 1 = 3\nHence, nums = [0,1,1,2,1,3,2,3], and the maximum is max(0,1,1,2,1,3,2,3) = 3."
            },
            {
                "label": "Example 2",
                "input": "n = 2",
                "output": "1 Explanation: According to the given rules, nums = [0,1,1]. The maximum is max(0,1,1) = 1."
            },
            {
                "label": "Example 3",
                "input": "n = 3",
                "output": "2 Explanation: According to the given rules, nums = [0,1,1,2]. The maximum is max(0,1,1,2) = 2."
            }
        ],
        "elixir_template": "defmodule Solution do\n  @spec get_maximum_generated(n :: integer) :: integer\n  def get_maximum_generated(n) do\n    \n  end\nend",
        "erlang_template": "-spec get_maximum_generated(N :: integer()) -> integer().\nget_maximum_generated(N) ->\n  .",
        "scala_template": "object Solution {\n    def getMaximumGenerated(n: Int): Int = {\n        \n    }\n}"
    },
    {
        "id": 1767,
        "name": "design-front-middle-back-queue",
        "difficulty": "Medium",
        "link": "https://leetcode.com/problems/design-front-middle-back-queue/",
        "task_description": "Design a queue that supports `push` and `pop` operations in the front, middle, and back. Implement the `FrontMiddleBack` class: `FrontMiddleBack()` Initializes the queue. `void pushFront(int val)` Adds `val` to the **front** of the queue. `void pushMiddle(int val)` Adds `val` to the **middle** of the queue. `void pushBack(int val)` Adds `val` to the **back** of the queue. `int popFront()` Removes the **front** element of the queue and returns it. If the queue is empty, return `-1`. `int popMiddle()` Removes the **middle** element of the queue and returns it. If the queue is empty, return `-1`. `int popBack()` Removes the **back** element of the queue and returns it. If the queue is empty, return `-1`. **Notice** that when there are two middle position choices, the operation is performed on the **frontmost** middle position choice. For example: Pushing `6` into the middle of `[1, 2, 3, 4, 5]` results in `[1, 2, 6, 3, 4, 5]`. Popping the middle from `[1, 2, 3, 4, 5, 6]` returns `3` and results in `[1, 2, 4, 5, 6]`. **Example 1:** ``` **Input:** [\"FrontMiddleBackQueue\", \"pushFront\", \"pushBack\", \"pushMiddle\", \"pushMiddle\", \"popFront\", \"popMiddle\", \"popMiddle\", \"popBack\", \"popFront\"] [[], [1], [2], [3], [4], [], [], [], [], []] **Output:** [null, null, null, null, null, 1, 3, 4, 2, -1] **Explanation:** FrontMiddleBackQueue q = new FrontMiddleBackQueue(); q.pushFront(1); // [1] q.pushBack(2); // [1, 2] q.pushMiddle(3); // [1, 3, 2] q.pushMiddle(4); // [1, 4, 3, 2] q.popFront(); // return 1 -> [4, 3, 2] q.popMiddle(); // return 3 -> [4, 2] q.popMiddle(); // return 4 -> [2] q.popBack(); // return 2 -> [] q.popFront(); // return -1 -> [] (The queue is empty) ``` **Constraints:** `1 <= val <= 109` At most `1000` calls will be made to `pushFront`, `pushMiddle`, `pushBack`, `popFront`, `popMiddle`, and `popBack`.",
        "test_case": [
            {
                "label": "Example 1",
                "input": "[\"FrontMiddleBackQueue\", \"pushFront\", \"pushBack\", \"pushMiddle\", \"pushMiddle\", \"popFront\", \"popMiddle\", \"popMiddle\", \"popBack\", \"popFront\"]\n[[], [1], [2], [3], [4], [], [], [], [], []]",
                "output": "[null, null, null, null, null, 1, 3, 4, 2, -1] Explanation: FrontMiddleBackQueue q = new FrontMiddleBackQueue();\nq.pushFront(1);   // [ 1 ]\nq.pushBack(2);    // [1, 2 ]\nq.pushMiddle(3);  // [1, 3 , 2]\nq.pushMiddle(4);  // [1, 4 , 3, 2]\nq.popFront();     // return 1 -> [4, 3, 2]\nq.popMiddle();    // return 3 -> [4, 2]\nq.popMiddle();    // return 4 -> [2]\nq.popBack();      // return 2 -> []\nq.popFront();     // return -1 -> [] (The queue is empty)"
            }
        ],
        "elixir_template": "defmodule FrontMiddleBackQueue do\n  @spec init_() :: any\n  def init_() do\n    \n  end\n\n  @spec push_front(val :: integer) :: any\n  def push_front(val) do\n    \n  end\n\n  @spec push_middle(val :: integer) :: any\n  def push_middle(val) do\n    \n  end\n\n  @spec push_back(val :: integer) :: any\n  def push_back(val) do\n    \n  end\n\n  @spec pop_front() :: integer\n  def pop_front() do\n    \n  end\n\n  @spec pop_middle() :: integer\n  def pop_middle() do\n    \n  end\n\n  @spec pop_back() :: integer\n  def pop_back() do\n    \n  end\nend\n\n# Your functions will be called as such:\n# FrontMiddleBackQueue.init_()\n# FrontMiddleBackQueue.push_front(val)\n# FrontMiddleBackQueue.push_middle(val)\n# FrontMiddleBackQueue.push_back(val)\n# param_4 = FrontMiddleBackQueue.pop_front()\n# param_5 = FrontMiddleBackQueue.pop_middle()\n# param_6 = FrontMiddleBackQueue.pop_back()\n\n# FrontMiddleBackQueue.init_ will be called before every test case, in which you can do some necessary initializations.",
        "erlang_template": "-spec front_middle_back_queue_init_() -> any().\nfront_middle_back_queue_init_() ->\n  .\n\n-spec front_middle_back_queue_push_front(Val :: integer()) -> any().\nfront_middle_back_queue_push_front(Val) ->\n  .\n\n-spec front_middle_back_queue_push_middle(Val :: integer()) -> any().\nfront_middle_back_queue_push_middle(Val) ->\n  .\n\n-spec front_middle_back_queue_push_back(Val :: integer()) -> any().\nfront_middle_back_queue_push_back(Val) ->\n  .\n\n-spec front_middle_back_queue_pop_front() -> integer().\nfront_middle_back_queue_pop_front() ->\n  .\n\n-spec front_middle_back_queue_pop_middle() -> integer().\nfront_middle_back_queue_pop_middle() ->\n  .\n\n-spec front_middle_back_queue_pop_back() -> integer().\nfront_middle_back_queue_pop_back() ->\n  .\n\n\n%% Your functions will be called as such:\n%% front_middle_back_queue_init_(),\n%% front_middle_back_queue_push_front(Val),\n%% front_middle_back_queue_push_middle(Val),\n%% front_middle_back_queue_push_back(Val),\n%% Param_4 = front_middle_back_queue_pop_front(),\n%% Param_5 = front_middle_back_queue_pop_middle(),\n%% Param_6 = front_middle_back_queue_pop_back(),\n\n%% front_middle_back_queue_init_ will be called before every test case, in which you can do some necessary initializations.",
        "scala_template": "class FrontMiddleBackQueue() {\n\n    def pushFront(`val`: Int): Unit = {\n        \n    }\n\n    def pushMiddle(`val`: Int): Unit = {\n        \n    }\n\n    def pushBack(`val`: Int): Unit = {\n        \n    }\n\n    def popFront(): Int = {\n        \n    }\n\n    def popMiddle(): Int = {\n        \n    }\n\n    def popBack(): Int = {\n        \n    }\n\n}\n\n/**\n * Your FrontMiddleBackQueue object will be instantiated and called as such:\n * val obj = new FrontMiddleBackQueue()\n * obj.pushFront(`val`)\n * obj.pushMiddle(`val`)\n * obj.pushBack(`val`)\n * val param_4 = obj.popFront()\n * val param_5 = obj.popMiddle()\n * val param_6 = obj.popBack()\n */"
    },
    {
        "id": 1766,
        "name": "minimum-number-of-removals-to-make-mountain-array",
        "difficulty": "Hard",
        "link": "https://leetcode.com/problems/minimum-number-of-removals-to-make-mountain-array/",
        "task_description": "You may recall that an array `arr` is a **mountain array** if and only if: `arr.length >= 3` There exists some index `i` (**0-indexed**) with `0 < i < arr.length - 1` such that: `arr[0] < arr[1] < ... < arr[i - 1] < arr[i]` `arr[i] > arr[i + 1] > ... > arr[arr.length - 1]` Given an integer array `nums`\u200b\u200b\u200b, return _the **minimum** number of elements to remove to make _`nums_\u200b\u200b\u200b_`_ __a **mountain array**._ **Example 1:** ``` **Input:** nums = [1,3,1] **Output:** 0 **Explanation:** The array itself is a mountain array so we do not need to remove any elements. ``` **Example 2:** ``` **Input:** nums = [2,1,1,5,6,2,3,1] **Output:** 3 **Explanation:** One solution is to remove the elements at indices 0, 1, and 5, making the array nums = [1,5,6,3,1]. ``` **Constraints:** `3 <= nums.length <= 1000` `1 <= nums[i] <= 109` It is guaranteed that you can make a mountain array out of `nums`.",
        "test_case": [
            {
                "label": "Example 1",
                "input": "nums = [1,3,1]",
                "output": "0 Explanation: The array itself is a mountain array so we do not need to remove any elements."
            },
            {
                "label": "Example 2",
                "input": "nums = [2,1,1,5,6,2,3,1]",
                "output": "3 Explanation: One solution is to remove the elements at indices 0, 1, and 5, making the array nums = [1,5,6,3,1]."
            }
        ],
        "elixir_template": "defmodule Solution do\n  @spec minimum_mountain_removals(nums :: [integer]) :: integer\n  def minimum_mountain_removals(nums) do\n    \n  end\nend",
        "erlang_template": "-spec minimum_mountain_removals(Nums :: [integer()]) -> integer().\nminimum_mountain_removals(Nums) ->\n  .",
        "scala_template": "object Solution {\n    def minimumMountainRemovals(nums: Array[Int]): Int = {\n        \n    }\n}"
    },
    {
        "id": 1765,
        "name": "merge-in-between-linked-lists",
        "difficulty": "Medium",
        "link": "https://leetcode.com/problems/merge-in-between-linked-lists/",
        "task_description": "You are given two linked lists: `list1` and `list2` of sizes `n` and `m` respectively. Remove `list1`'s nodes from the `ath` node to the `bth` node, and put `list2` in their place. The blue edges and nodes in the following figure indicate the result: _Build the result list and return its head._ **Example 1:** ``` **Input:** list1 = [10,1,13,6,9,5], a = 3, b = 4, list2 = [1000000,1000001,1000002] **Output:** [10,1,13,1000000,1000001,1000002,5] **Explanation:** We remove the nodes 3 and 4 and put the entire list2 in their place. The blue edges and nodes in the above figure indicate the result. ``` **Example 2:** ``` **Input:** list1 = [0,1,2,3,4,5,6], a = 2, b = 5, list2 = [1000000,1000001,1000002,1000003,1000004] **Output:** [0,1,1000000,1000001,1000002,1000003,1000004,6] **Explanation:** The blue edges and nodes in the above figure indicate the result. ``` **Constraints:** `3 <= list1.length <= 104` `1 <= a <= b < list1.length - 1` `1 <= list2.length <= 104`",
        "test_case": [
            {
                "label": "Example 1",
                "input": "list1 = [10,1,13,6,9,5], a = 3, b = 4, list2 = [1000000,1000001,1000002]",
                "output": "[10,1,13,1000000,1000001,1000002,5] Explanation: We remove the nodes 3 and 4 and put the entire list2 in their place. The blue edges and nodes in the above figure indicate the result."
            },
            {
                "label": "Example 2",
                "input": "list1 = [0,1,2,3,4,5,6], a = 2, b = 5, list2 = [1000000,1000001,1000002,1000003,1000004]",
                "output": "[0,1,1000000,1000001,1000002,1000003,1000004,6] Explanation: The blue edges and nodes in the above figure indicate the result."
            }
        ],
        "elixir_template": "Elixir code template not available for this problem.",
        "erlang_template": "Elixir code template not available for this problem.",
        "scala_template": "/**\n * Definition for singly-linked list.\n * class ListNode(_x: Int = 0, _next: ListNode = null) {\n *   var next: ListNode = _next\n *   var x: Int = _x\n * }\n */\nobject Solution {\n    def mergeInBetween(list1: ListNode, a: Int, b: Int, list2: ListNode): ListNode = {\n        \n    }\n}"
    },
    {
        "id": 1764,
        "name": "maximum-repeating-substring",
        "difficulty": "Easy",
        "link": "https://leetcode.com/problems/maximum-repeating-substring/",
        "task_description": "For a string `sequence`, a string `word` is **`k`-repeating** if `word` concatenated `k` times is a substring of `sequence`. The `word`'s **maximum `k`-repeating value** is the highest value `k` where `word` is `k`-repeating in `sequence`. If `word` is not a substring of `sequence`, `word`'s maximum `k`-repeating value is `0`. Given strings `sequence` and `word`, return _the **maximum `k`-repeating value** of `word` in `sequence`_. **Example 1:** ``` **Input:** sequence = \"ababc\", word = \"ab\" **Output:** 2 **Explanation: **\"abab\" is a substring in \"ababc\". ``` **Example 2:** ``` **Input:** sequence = \"ababc\", word = \"ba\" **Output:** 1 **Explanation: **\"ba\" is a substring in \"ababc\". \"baba\" is not a substring in \"ababc\". ``` **Example 3:** ``` **Input:** sequence = \"ababc\", word = \"ac\" **Output:** 0 **Explanation: **\"ac\" is not a substring in \"ababc\". ``` **Constraints:** `1 <= sequence.length <= 100` `1 <= word.length <= 100` `sequence` and `word` contains only lowercase English letters.",
        "test_case": [
            {
                "label": "Example 1",
                "input": "sequence = \"ababc\", word = \"ab\"",
                "output": "2 Explanation: \"abab\" is a substring in \" abab c\"."
            },
            {
                "label": "Example 2",
                "input": "sequence = \"ababc\", word = \"ba\"",
                "output": "1 Explanation: \"ba\" is a substring in \"a ba bc\". \"baba\" is not a substring in \"ababc\"."
            },
            {
                "label": "Example 3",
                "input": "sequence = \"ababc\", word = \"ac\"",
                "output": "0 Explanation: \"ac\" is not a substring in \"ababc\"."
            }
        ],
        "elixir_template": "defmodule Solution do\n  @spec max_repeating(sequence :: String.t, word :: String.t) :: integer\n  def max_repeating(sequence, word) do\n    \n  end\nend",
        "erlang_template": "-spec max_repeating(Sequence :: unicode:unicode_binary(), Word :: unicode:unicode_binary()) -> integer().\nmax_repeating(Sequence, Word) ->\n  .",
        "scala_template": "object Solution {\n    def maxRepeating(sequence: String, word: String): Int = {\n        \n    }\n}"
    },
    {
        "id": 1762,
        "name": "furthest-building-you-can-reach",
        "difficulty": "Medium",
        "link": "https://leetcode.com/problems/furthest-building-you-can-reach/",
        "task_description": "You are given an integer array `heights` representing the heights of buildings, some `bricks`, and some `ladders`. You start your journey from building `0` and move to the next building by possibly using bricks or ladders. While moving from building `i` to building `i+1` (**0-indexed**), If the current building's height is **greater than or equal** to the next building's height, you do **not** need a ladder or bricks. If the current building's height is less than the next building's height, you can either use **one ladder** or `(h[i+1] - h[i])` **bricks**. _Return the furthest building index (0-indexed) you can reach if you use the given ladders and bricks optimally._ **Example 1:** ``` **Input:** heights = [4,2,7,6,9,14,12], bricks = 5, ladders = 1 **Output:** 4 **Explanation:** Starting at building 0, you can follow these steps: - Go to building 1 without using ladders nor bricks since 4 >= 2. - Go to building 2 using 5 bricks. You must use either bricks or ladders because 2 < 7. - Go to building 3 without using ladders nor bricks since 7 >= 6. - Go to building 4 using your only ladder. You must use either bricks or ladders because 6 < 9. It is impossible to go beyond building 4 because you do not have any more bricks or ladders. ``` **Example 2:** ``` **Input:** heights = [4,12,2,7,3,18,20,3,19], bricks = 10, ladders = 2 **Output:** 7 ``` **Example 3:** ``` **Input:** heights = [14,3,19,3], bricks = 17, ladders = 0 **Output:** 3 ``` **Constraints:** `1 <= heights.length <= 105` `1 <= heights[i] <= 106` `0 <= bricks <= 109` `0 <= ladders <= heights.length`",
        "test_case": [
            {
                "label": "Example 1",
                "input": "heights = [4,2,7,6,9,14,12], bricks = 5, ladders = 1",
                "output": "4 Explanation: Starting at building 0, you can follow these steps:\n- Go to building 1 without using ladders nor bricks since 4 >= 2.\n- Go to building 2 using 5 bricks. You must use either bricks or ladders because 2 < 7.\n- Go to building 3 without using ladders nor bricks since 7 >= 6.\n- Go to building 4 using your only ladder. You must use either bricks or ladders because 6 < 9.\nIt is impossible to go beyond building 4 because you do not have any more bricks or ladders."
            },
            {
                "label": "Example 2",
                "input": "heights = [4,12,2,7,3,18,20,3,19], bricks = 10, ladders = 2",
                "output": "7"
            },
            {
                "label": "Example 3",
                "input": "heights = [14,3,19,3], bricks = 17, ladders = 0",
                "output": "3"
            }
        ],
        "elixir_template": "defmodule Solution do\n  @spec furthest_building(heights :: [integer], bricks :: integer, ladders :: integer) :: integer\n  def furthest_building(heights, bricks, ladders) do\n    \n  end\nend",
        "erlang_template": "-spec furthest_building(Heights :: [integer()], Bricks :: integer(), Ladders :: integer()) -> integer().\nfurthest_building(Heights, Bricks, Ladders) ->\n  .",
        "scala_template": "object Solution {\n    def furthestBuilding(heights: Array[Int], bricks: Int, ladders: Int): Int = {\n        \n    }\n}"
    },
    {
        "id": 1761,
        "name": "count-sorted-vowel-strings",
        "difficulty": "Medium",
        "link": "https://leetcode.com/problems/count-sorted-vowel-strings/",
        "task_description": "Given an integer `n`, return _the number of strings of length _`n`_ that consist only of vowels (_`a`_, _`e`_, _`i`_, _`o`_, _`u`_) and are **lexicographically sorted**._ A string `s` is **lexicographically sorted** if for all valid `i`, `s[i]` is the same as or comes before `s[i+1]` in the alphabet. **Example 1:** ``` **Input:** n = 1 **Output:** 5 **Explanation:** The 5 sorted strings that consist of vowels only are `[\"a\",\"e\",\"i\",\"o\",\"u\"].` ``` **Example 2:** ``` **Input:** n = 2 **Output:** 15 **Explanation:** The 15 sorted strings that consist of vowels only are [\"aa\",\"ae\",\"ai\",\"ao\",\"au\",\"ee\",\"ei\",\"eo\",\"eu\",\"ii\",\"io\",\"iu\",\"oo\",\"ou\",\"uu\"]. Note that \"ea\" is not a valid string since 'e' comes after 'a' in the alphabet. ``` **Example 3:** ``` **Input:** n = 33 **Output:** 66045 ``` **Constraints:** `1 <= n <= 50`",
        "test_case": [
            {
                "label": "Example 1",
                "input": "n = 1",
                "output": "5 Explanation: The 5 sorted strings that consist of vowels only are [\"a\",\"e\",\"i\",\"o\",\"u\"]."
            },
            {
                "label": "Example 2",
                "input": "n = 2",
                "output": "15 Explanation: The 15 sorted strings that consist of vowels only are\n[\"aa\",\"ae\",\"ai\",\"ao\",\"au\",\"ee\",\"ei\",\"eo\",\"eu\",\"ii\",\"io\",\"iu\",\"oo\",\"ou\",\"uu\"].\nNote that \"ea\" is not a valid string since 'e' comes after 'a' in the alphabet."
            },
            {
                "label": "Example 3",
                "input": "n = 33",
                "output": "66045"
            }
        ],
        "elixir_template": "defmodule Solution do\n  @spec count_vowel_strings(n :: integer) :: integer\n  def count_vowel_strings(n) do\n    \n  end\nend",
        "erlang_template": "-spec count_vowel_strings(N :: integer()) -> integer().\ncount_vowel_strings(N) ->\n  .",
        "scala_template": "object Solution {\n    def countVowelStrings(n: Int): Int = {\n        \n    }\n}"
    },
    {
        "id": 1760,
        "name": "check-array-formation-through-concatenation",
        "difficulty": "Easy",
        "link": "https://leetcode.com/problems/check-array-formation-through-concatenation/",
        "task_description": "You are given an array of **distinct** integers `arr` and an array of integer arrays `pieces`, where the integers in `pieces` are **distinct**. Your goal is to form `arr` by concatenating the arrays in `pieces` **in any order**. However, you are **not** allowed to reorder the integers in each array `pieces[i]`. Return `true` _if it is possible __to form the array _`arr`_ from _`pieces`. Otherwise, return `false`. **Example 1:** ``` **Input:** arr = [15,88], pieces = [[88],[15]] **Output:** true **Explanation:** Concatenate [15] then [88] ``` **Example 2:** ``` **Input:** arr = [49,18,16], pieces = [[16,18,49]] **Output:** false **Explanation:** Even though the numbers match, we cannot reorder pieces[0]. ``` **Example 3:** ``` **Input:** arr = [91,4,64,78], pieces = [[78],[4,64],[91]] **Output:** true **Explanation:** Concatenate [91] then [4,64] then [78] ``` **Constraints:** `1 <= pieces.length <= arr.length <= 100` `sum(pieces[i].length) == arr.length` `1 <= pieces[i].length <= arr.length` `1 <= arr[i], pieces[i][j] <= 100` The integers in `arr` are **distinct**. The integers in `pieces` are **distinct** (i.e., If we flatten pieces in a 1D array, all the integers in this array are distinct).",
        "test_case": [
            {
                "label": "Example 1",
                "input": "arr = [15,88], pieces = [[88],[15]]",
                "output": "true Explanation: Concatenate [15] then [88]"
            },
            {
                "label": "Example 2",
                "input": "arr = [49,18,16], pieces = [[16,18,49]]",
                "output": "false Explanation: Even though the numbers match, we cannot reorder pieces[0]."
            },
            {
                "label": "Example 3",
                "input": "arr = [91,4,64,78], pieces = [[78],[4,64],[91]]",
                "output": "true Explanation: Concatenate [91] then [4,64] then [78]"
            }
        ],
        "elixir_template": "defmodule Solution do\n  @spec can_form_array(arr :: [integer], pieces :: [[integer]]) :: boolean\n  def can_form_array(arr, pieces) do\n    \n  end\nend",
        "erlang_template": "-spec can_form_array(Arr :: [integer()], Pieces :: [[integer()]]) -> boolean().\ncan_form_array(Arr, Pieces) ->\n  .",
        "scala_template": "object Solution {\n    def canFormArray(arr: Array[Int], pieces: Array[Array[Int]]): Boolean = {\n        \n    }\n}"
    },
    {
        "id": 1758,
        "name": "distribute-repeating-integers",
        "difficulty": "Hard",
        "link": "https://leetcode.com/problems/distribute-repeating-integers/",
        "task_description": "You are given an array of `n` integers, `nums`, where there are at most `50` unique values in the array. You are also given an array of `m` customer order quantities, `quantity`, where `quantity[i]` is the amount of integers the `ith` customer ordered. Determine if it is possible to distribute `nums` such that: The `ith` customer gets **exactly** `quantity[i]` integers, The integers the `ith` customer gets are **all equal**, and Every customer is satisfied. Return `true`_ if it is possible to distribute _`nums`_ according to the above conditions_. **Example 1:** ``` **Input:** nums = [1,2,3,4], quantity = [2] **Output:** false **Explanation:** The 0th customer cannot be given two different integers. ``` **Example 2:** ``` **Input:** nums = [1,2,3,3], quantity = [2] **Output:** true **Explanation:** The 0th customer is given [3,3]. The integers [1,2] are not used. ``` **Example 3:** ``` **Input:** nums = [1,1,2,2], quantity = [2,2] **Output:** true **Explanation:** The 0th customer is given [1,1], and the 1st customer is given [2,2]. ``` **Constraints:** `n == nums.length` `1 <= n <= 105` `1 <= nums[i] <= 1000` `m == quantity.length` `1 <= m <= 10` `1 <= quantity[i] <= 105` There are at most `50` unique values in `nums`.",
        "test_case": [
            {
                "label": "Example 1",
                "input": "nums = [1,2,3,4], quantity = [2]",
                "output": "false Explanation: The 0 th customer cannot be given two different integers."
            },
            {
                "label": "Example 2",
                "input": "nums = [1,2,3,3], quantity = [2]",
                "output": "true Explanation: The 0 th customer is given [3,3]. The integers [1,2] are not used."
            },
            {
                "label": "Example 3",
                "input": "nums = [1,1,2,2], quantity = [2,2]",
                "output": "true Explanation: The 0 th customer is given [1,1], and the 1st customer is given [2,2]. Constraints: n == nums.length 1 <= n <= 10 5 1 <= nums[i] <= 1000 m == quantity.length 1 <= m <= 10 1 <= quantity[i] <= 10 5 There are at most 50 unique values in nums ."
            }
        ],
        "elixir_template": "defmodule Solution do\n  @spec can_distribute(nums :: [integer], quantity :: [integer]) :: boolean\n  def can_distribute(nums, quantity) do\n    \n  end\nend",
        "erlang_template": "-spec can_distribute(Nums :: [integer()], Quantity :: [integer()]) -> boolean().\ncan_distribute(Nums, Quantity) ->\n  .",
        "scala_template": "object Solution {\n    def canDistribute(nums: Array[Int], quantity: Array[Int]): Boolean = {\n        \n    }\n}"
    },
    {
        "id": 1757,
        "name": "minimum-jumps-to-reach-home",
        "difficulty": "Medium",
        "link": "https://leetcode.com/problems/minimum-jumps-to-reach-home/",
        "task_description": "A certain bug's home is on the x-axis at position `x`. Help them get there from position `0`. The bug jumps according to the following rules: It can jump exactly `a` positions **forward** (to the right). It can jump exactly `b` positions **backward** (to the left). It cannot jump backward twice in a row. It cannot jump to any `forbidden` positions. The bug may jump forward **beyond** its home, but it **cannot jump** to positions numbered with **negative** integers. Given an array of integers `forbidden`, where `forbidden[i]` means that the bug cannot jump to the position `forbidden[i]`, and integers `a`, `b`, and `x`, return _the minimum number of jumps needed for the bug to reach its home_. If there is no possible sequence of jumps that lands the bug on position `x`, return `-1.` **Example 1:** ``` **Input:** forbidden = [14,4,18,1,15], a = 3, b = 15, x = 9 **Output:** 3 **Explanation:** 3 jumps forward (0 -> 3 -> 6 -> 9) will get the bug home. ``` **Example 2:** ``` **Input:** forbidden = [8,3,16,6,12,20], a = 15, b = 13, x = 11 **Output:** -1 ``` **Example 3:** ``` **Input:** forbidden = [1,6,2,14,5,17,4], a = 16, b = 9, x = 7 **Output:** 2 **Explanation:** One jump forward (0 -> 16) then one jump backward (16 -> 7) will get the bug home. ``` **Constraints:** `1 <= forbidden.length <= 1000` `1 <= a, b, forbidden[i] <= 2000` `0 <= x <= 2000` All the elements in `forbidden` are distinct. Position `x` is not forbidden.",
        "test_case": [
            {
                "label": "Example 1",
                "input": "forbidden = [14,4,18,1,15], a = 3, b = 15, x = 9",
                "output": "3 Explanation: 3 jumps forward (0 -> 3 -> 6 -> 9) will get the bug home."
            },
            {
                "label": "Example 2",
                "input": "forbidden = [8,3,16,6,12,20], a = 15, b = 13, x = 11",
                "output": "-1"
            },
            {
                "label": "Example 3",
                "input": "forbidden = [1,6,2,14,5,17,4], a = 16, b = 9, x = 7",
                "output": "2 Explanation: One jump forward (0 -> 16) then one jump backward (16 -> 7) will get the bug home."
            }
        ],
        "elixir_template": "defmodule Solution do\n  @spec minimum_jumps(forbidden :: [integer], a :: integer, b :: integer, x :: integer) :: integer\n  def minimum_jumps(forbidden, a, b, x) do\n    \n  end\nend",
        "erlang_template": "-spec minimum_jumps(Forbidden :: [integer()], A :: integer(), B :: integer(), X :: integer()) -> integer().\nminimum_jumps(Forbidden, A, B, X) ->\n  .",
        "scala_template": "object Solution {\n    def minimumJumps(forbidden: Array[Int], a: Int, b: Int, x: Int): Int = {\n        \n    }\n}"
    },
    {
        "id": 1756,
        "name": "minimum-deletions-to-make-string-balanced",
        "difficulty": "Medium",
        "link": "https://leetcode.com/problems/minimum-deletions-to-make-string-balanced/",
        "task_description": "You are given a string `s` consisting only of characters `'a'` and `'b'`\u200b\u200b\u200b\u200b. You can delete any number of characters in `s` to make `s` **balanced**. `s` is **balanced** if there is no pair of indices `(i,j)` such that `i < j` and `s[i] = 'b'` and `s[j]= 'a'`. Return _the **minimum** number of deletions needed to make _`s`_ **balanced**_. **Example 1:** ``` **Input:** s = \"aababbab\" **Output:** 2 **Explanation:** You can either: Delete the characters at 0-indexed positions 2 and 6 (\"aababbab\" -> \"aaabbb\"), or Delete the characters at 0-indexed positions 3 and 6 (\"aababbab\" -> \"aabbbb\"). ``` **Example 2:** ``` **Input:** s = \"bbaaaaabb\" **Output:** 2 **Explanation:** The only solution is to delete the first two characters. ``` **Constraints:** `1 <= s.length <= 105` `s[i]` is `'a'` or `'b'`\u200b\u200b.",
        "test_case": [
            {
                "label": "Example 1",
                "input": "s = \"aababbab\"",
                "output": "2 Explanation: You can either:\nDelete the characters at 0-indexed positions 2 and 6 (\"aa b abb a b\" -> \"aaabbb\"), or\nDelete the characters at 0-indexed positions 3 and 6 (\"aab a bb a b\" -> \"aabbbb\")."
            },
            {
                "label": "Example 2",
                "input": "s = \"bbaaaaabb\"",
                "output": "2 Explanation: The only solution is to delete the first two characters."
            }
        ],
        "elixir_template": "defmodule Solution do\n  @spec minimum_deletions(s :: String.t) :: integer\n  def minimum_deletions(s) do\n    \n  end\nend",
        "erlang_template": "-spec minimum_deletions(S :: unicode:unicode_binary()) -> integer().\nminimum_deletions(S) ->\n  .",
        "scala_template": "object Solution {\n    def minimumDeletions(s: String): Int = {\n        \n    }\n}"
    },
    {
        "id": 1755,
        "name": "defuse-the-bomb",
        "difficulty": "Easy",
        "link": "https://leetcode.com/problems/defuse-the-bomb/",
        "task_description": "You have a bomb to defuse, and your time is running out! Your informer will provide you with a **circular** array `code` of length of `n` and a key `k`. To decrypt the code, you must replace every number. All the numbers are replaced **simultaneously**. If `k > 0`, replace the `ith` number with the sum of the **next** `k` numbers. If `k < 0`, replace the `ith` number with the sum of the **previous** `k` numbers. If `k == 0`, replace the `ith` number with `0`. As `code` is circular, the next element of `code[n-1]` is `code[0]`, and the previous element of `code[0]` is `code[n-1]`. Given the **circular** array `code` and an integer key `k`, return _the decrypted code to defuse the bomb_! **Example 1:** ``` **Input:** code = [5,7,1,4], k = 3 **Output:** [12,10,16,13] **Explanation:** Each number is replaced by the sum of the next 3 numbers. The decrypted code is [7+1+4, 1+4+5, 4+5+7, 5+7+1]. Notice that the numbers wrap around. ``` **Example 2:** ``` **Input:** code = [1,2,3,4], k = 0 **Output:** [0,0,0,0] **Explanation:** When k is zero, the numbers are replaced by 0. ``` **Example 3:** ``` **Input:** code = [2,4,9,3], k = -2 **Output:** [12,5,6,13] **Explanation:** The decrypted code is [3+9, 2+3, 4+2, 9+4]. Notice that the numbers wrap around again. If k is negative, the sum is of the **previous** numbers. ``` **Constraints:** `n == code.length` `1 <= n <= 100` `1 <= code[i] <= 100` `-(n - 1) <= k <= n - 1`",
        "test_case": [
            {
                "label": "Example 1",
                "input": "code = [5,7,1,4], k = 3",
                "output": "[12,10,16,13] Explanation: Each number is replaced by the sum of the next 3 numbers. The decrypted code is [7+1+4, 1+4+5, 4+5+7, 5+7+1]. Notice that the numbers wrap around."
            },
            {
                "label": "Example 2",
                "input": "code = [1,2,3,4], k = 0",
                "output": "[0,0,0,0] Explanation: When k is zero, the numbers are replaced by 0."
            },
            {
                "label": "Example 3",
                "input": "code = [2,4,9,3], k = -2",
                "output": "[12,5,6,13] Explanation: The decrypted code is [3+9, 2+3, 4+2, 9+4]. Notice that the numbers wrap around again. If k is negative, the sum is of the previous numbers. Constraints: n == code.length 1 <= n\u00a0<= 100 1 <= code[i] <= 100 -(n - 1) <= k <= n - 1"
            }
        ],
        "elixir_template": "defmodule Solution do\n  @spec decrypt(code :: [integer], k :: integer) :: [integer]\n  def decrypt(code, k) do\n    \n  end\nend",
        "erlang_template": "-spec decrypt(Code :: [integer()], K :: integer()) -> [integer()].\ndecrypt(Code, K) ->\n  .",
        "scala_template": "object Solution {\n    def decrypt(code: Array[Int], k: Int): Array[Int] = {\n        \n    }\n}"
    },
    {
        "id": 1753,
        "name": "path-with-minimum-effort",
        "difficulty": "Medium",
        "link": "https://leetcode.com/problems/path-with-minimum-effort/",
        "task_description": "You are a hiker preparing for an upcoming hike. You are given `heights`, a 2D array of size `rows x columns`, where `heights[row][col]` represents the height of cell `(row, col)`. You are situated in the top-left cell, `(0, 0)`, and you hope to travel to the bottom-right cell, `(rows-1, columns-1)` (i.e., **0-indexed**). You can move **up**, **down**, **left**, or **right**, and you wish to find a route that requires the minimum **effort**. A route's **effort** is the **maximum absolute difference**** **in heights between two consecutive cells of the route. Return _the minimum **effort** required to travel from the top-left cell to the bottom-right cell._ **Example 1:** ``` **Input:** heights = [[1,2,2],[3,8,2],[5,3,5]] **Output:** 2 **Explanation:** The route of [1,3,5,3,5] has a maximum absolute difference of 2 in consecutive cells. This is better than the route of [1,2,2,2,5], where the maximum absolute difference is 3. ``` **Example 2:** ``` **Input:** heights = [[1,2,3],[3,8,4],[5,3,5]] **Output:** 1 **Explanation:** The route of [1,2,3,4,5] has a maximum absolute difference of 1 in consecutive cells, which is better than route [1,3,5,3,5]. ``` **Example 3:** ``` **Input:** heights = [[1,2,1,1,1],[1,2,1,2,1],[1,2,1,2,1],[1,2,1,2,1],[1,1,1,2,1]] **Output:** 0 **Explanation:** This route does not require any effort. ``` **Constraints:** `rows == heights.length` `columns == heights[i].length` `1 <= rows, columns <= 100` `1 <= heights[i][j] <= 106`",
        "test_case": [
            {
                "label": "Example 1",
                "input": "heights = [[1,2,2],[3,8,2],[5,3,5]]",
                "output": "2 Explanation: The route of [1,3,5,3,5] has a maximum absolute difference of 2 in consecutive cells.\nThis is better than the route of [1,2,2,2,5], where the maximum absolute difference is 3."
            },
            {
                "label": "Example 2",
                "input": "heights = [[1,2,3],[3,8,4],[5,3,5]]",
                "output": "1 Explanation: The route of [1,2,3,4,5] has a maximum absolute difference of 1 in consecutive cells, which is better than route [1,3,5,3,5]."
            },
            {
                "label": "Example 3",
                "input": "heights = [[1,2,1,1,1],[1,2,1,2,1],[1,2,1,2,1],[1,2,1,2,1],[1,1,1,2,1]]",
                "output": "0 Explanation: This route does not require any effort. Constraints: rows == heights.length columns == heights[i].length 1 <= rows, columns <= 100 1 <= heights[i][j] <= 10 6"
            }
        ],
        "elixir_template": "defmodule Solution do\n  @spec minimum_effort_path(heights :: [[integer]]) :: integer\n  def minimum_effort_path(heights) do\n    \n  end\nend",
        "erlang_template": "-spec minimum_effort_path(Heights :: [[integer()]]) -> integer().\nminimum_effort_path(Heights) ->\n  .",
        "scala_template": "object Solution {\n    def minimumEffortPath(heights: Array[Array[Int]]): Int = {\n        \n    }\n}"
    },
    {
        "id": 1752,
        "name": "arithmetic-subarrays",
        "difficulty": "Medium",
        "link": "https://leetcode.com/problems/arithmetic-subarrays/",
        "task_description": "A sequence of numbers is called **arithmetic** if it consists of at least two elements, and the difference between every two consecutive elements is the same. More formally, a sequence `s` is arithmetic if and only if `s[i+1] - s[i] == s[1] - s[0] `for all valid `i`. For example, these are **arithmetic** sequences: ``` 1, 3, 5, 7, 9 7, 7, 7, 7 3, -1, -5, -9 ``` The following sequence is not **arithmetic**: ``` 1, 1, 2, 5, 7 ``` You are given an array of `n` integers, `nums`, and two arrays of `m` integers each, `l` and `r`, representing the `m` range queries, where the `ith` query is the range `[l[i], r[i]]`. All the arrays are **0-indexed**. Return _a list of _`boolean` _elements_ `answer`_, where_ `answer[i]` _is_ `true` _if the subarray_ `nums[l[i]], nums[l[i]+1], ... , nums[r[i]]`_ can be **rearranged** to form an **arithmetic** sequence, and_ `false` _otherwise._ **Example 1:** ``` **Input:** nums = `[4,6,5,9,3,7]`, l = `[0,0,2]`, r = `[2,3,5]` **Output:** `[true,false,true]` **Explanation:** In the 0th query, the subarray is [4,6,5]. This can be rearranged as [6,5,4], which is an arithmetic sequence. In the 1st query, the subarray is [4,6,5,9]. This cannot be rearranged as an arithmetic sequence. In the 2nd query, the subarray is `[5,9,3,7]. This` can be rearranged as `[3,5,7,9]`, which is an arithmetic sequence. ``` **Example 2:** ``` **Input:** nums = [-12,-9,-3,-12,-6,15,20,-25,-20,-15,-10], l = [0,1,6,4,8,7], r = [4,4,9,7,9,10] **Output:** [false,true,false,false,true,true] ``` **Constraints:** `n == nums.length` `m == l.length` `m == r.length` `2 <= n <= 500` `1 <= m <= 500` `0 <= l[i] < r[i] < n` `-105 <= nums[i] <= 105`",
        "test_case": [
            {
                "label": "Example 1",
                "input": "nums = [4,6,5,9,3,7] , l = [0,0,2] , r = [2,3,5]",
                "output": "[true,false,true] Explanation: In the 0 th query, the subarray is [4,6,5]. This can be rearranged as [6,5,4], which is an arithmetic sequence.\nIn the 1 st query, the subarray is [4,6,5,9]. This cannot be rearranged as an arithmetic sequence.\nIn the 2 nd query, the subarray is [5,9,3,7]. This can be rearranged as [3,5,7,9] , which is an arithmetic sequence."
            },
            {
                "label": "Example 2",
                "input": "nums = [-12,-9,-3,-12,-6,15,20,-25,-20,-15,-10], l = [0,1,6,4,8,7], r = [4,4,9,7,9,10]",
                "output": "[false,true,false,false,true,true] Constraints: n == nums.length m == l.length m == r.length 2 <= n <= 500 1 <= m <= 500 0 <= l[i] < r[i] < n -10 5 <= nums[i] <= 10 5"
            }
        ],
        "elixir_template": "defmodule Solution do\n  @spec check_arithmetic_subarrays(nums :: [integer], l :: [integer], r :: [integer]) :: [boolean]\n  def check_arithmetic_subarrays(nums, l, r) do\n    \n  end\nend",
        "erlang_template": "-spec check_arithmetic_subarrays(Nums :: [integer()], L :: [integer()], R :: [integer()]) -> [boolean()].\ncheck_arithmetic_subarrays(Nums, L, R) ->\n  .",
        "scala_template": "object Solution {\n    def checkArithmeticSubarrays(nums: Array[Int], l: Array[Int], r: Array[Int]): List[Boolean] = {\n        \n    }\n}"
    },
    {
        "id": 1751,
        "name": "slowest-key",
        "difficulty": "Easy",
        "link": "https://leetcode.com/problems/slowest-key/",
        "task_description": "A newly designed keypad was tested, where a tester pressed a sequence of `n` keys, one at a time. You are given a string `keysPressed` of length `n`, where `keysPressed[i]` was the `ith` key pressed in the testing sequence, and a sorted list `releaseTimes`, where `releaseTimes[i]` was the time the `ith` key was released. Both arrays are **0-indexed**. The `0th` key was pressed at the time `0`, and every subsequent key was pressed at the **exact** time the previous key was released. The tester wants to know the key of the keypress that had the **longest duration**. The `ith` keypress had a **duration** of `releaseTimes[i] - releaseTimes[i - 1]`, and the `0th` keypress had a duration of `releaseTimes[0]`. Note that the same key could have been pressed multiple times during the test, and these multiple presses of the same key **may not** have had the same **duration**. _Return the key of the keypress that had the **longest duration**. If there are multiple such keypresses, return the lexicographically largest key of the keypresses._ **Example 1:** ``` **Input:** releaseTimes = [9,29,49,50], keysPressed = \"cbcd\" **Output:** \"c\" **Explanation:** The keypresses were as follows: Keypress for 'c' had a duration of 9 (pressed at time 0 and released at time 9). Keypress for 'b' had a duration of 29 - 9 = 20 (pressed at time 9 right after the release of the previous character and released at time 29). Keypress for 'c' had a duration of 49 - 29 = 20 (pressed at time 29 right after the release of the previous character and released at time 49). Keypress for 'd' had a duration of 50 - 49 = 1 (pressed at time 49 right after the release of the previous character and released at time 50). The longest of these was the keypress for 'b' and the second keypress for 'c', both with duration 20. 'c' is lexicographically larger than 'b', so the answer is 'c'. ``` **Example 2:** ``` **Input:** releaseTimes = [12,23,36,46,62], keysPressed = \"spuda\" **Output:** \"a\" **Explanation:** The keypresses were as follows: Keypress for 's' had a duration of 12. Keypress for 'p' had a duration of 23 - 12 = 11. Keypress for 'u' had a duration of 36 - 23 = 13. Keypress for 'd' had a duration of 46 - 36 = 10. Keypress for 'a' had a duration of 62 - 46 = 16. The longest of these was the keypress for 'a' with duration 16. ``` **Constraints:** `releaseTimes.length == n` `keysPressed.length == n` `2 <= n <= 1000` `1 <= releaseTimes[i] <= 109` `releaseTimes[i] < releaseTimes[i+1]` `keysPressed` contains only lowercase English letters.",
        "test_case": [
            {
                "label": "Example 1",
                "input": "releaseTimes = [9,29,49,50], keysPressed = \"cbcd\"",
                "output": "\"c\" Explanation: The keypresses were as follows:\nKeypress for 'c' had a duration of 9 (pressed at time 0 and released at time 9).\nKeypress for 'b' had a duration of 29 - 9 = 20 (pressed at time 9 right after the release of the previous character and released at time 29).\nKeypress for 'c' had a duration of 49 - 29 = 20 (pressed at time 29 right after the release of the previous character and released at time 49).\nKeypress for 'd' had a duration of 50 - 49 = 1 (pressed at time 49 right after the release of the previous character and released at time 50).\nThe longest of these was the keypress for 'b' and the second keypress for 'c', both with duration 20.\n'c' is lexicographically larger than 'b', so the answer is 'c'."
            },
            {
                "label": "Example 2",
                "input": "releaseTimes = [12,23,36,46,62], keysPressed = \"spuda\"",
                "output": "\"a\" Explanation: The keypresses were as follows:\nKeypress for 's' had a duration of 12.\nKeypress for 'p' had a duration of 23 - 12 = 11.\nKeypress for 'u' had a duration of 36 - 23 = 13.\nKeypress for 'd' had a duration of 46 - 36 = 10.\nKeypress for 'a' had a duration of 62 - 46 = 16.\nThe longest of these was the keypress for 'a' with duration 16. Constraints: releaseTimes.length == n keysPressed.length == n 2 <= n <= 1000 1 <= releaseTimes[i] <= 10 9 releaseTimes[i] < releaseTimes[i+1] keysPressed contains only lowercase English letters."
            }
        ],
        "elixir_template": "defmodule Solution do\n  @spec slowest_key(release_times :: [integer], keys_pressed :: String.t) :: char\n  def slowest_key(release_times, keys_pressed) do\n    \n  end\nend",
        "erlang_template": "-spec slowest_key(ReleaseTimes :: [integer()], KeysPressed :: unicode:unicode_binary()) -> char().\nslowest_key(ReleaseTimes, KeysPressed) ->\n  .",
        "scala_template": "object Solution {\n    def slowestKey(releaseTimes: Array[Int], keysPressed: String): Char = {\n        \n    }\n}"
    },
    {
        "id": 1748,
        "name": "best-team-with-no-conflicts",
        "difficulty": "Medium",
        "link": "https://leetcode.com/problems/best-team-with-no-conflicts/",
        "task_description": "You are the manager of a basketball team. For the upcoming tournament, you want to choose the team with the highest overall score. The score of the team is the **sum** of scores of all the players in the team. However, the basketball team is not allowed to have **conflicts**. A **conflict** exists if a younger player has a **strictly higher** score than an older player. A conflict does **not** occur between players of the same age. Given two lists, `scores` and `ages`, where each `scores[i]` and `ages[i]` represents the score and age of the `ith` player, respectively, return _the highest overall score of all possible basketball teams_. **Example 1:** ``` **Input:** scores = [1,3,5,10,15], ages = [1,2,3,4,5] **Output:** 34 **Explanation:** You can choose all the players. ``` **Example 2:** ``` **Input:** scores = [4,5,6,5], ages = [2,1,2,1] **Output:** 16 **Explanation:** It is best to choose the last 3 players. Notice that you are allowed to choose multiple people of the same age. ``` **Example 3:** ``` **Input:** scores = [1,2,3,5], ages = [8,9,10,1] **Output:** 6 **Explanation:** It is best to choose the first 3 players. ``` **Constraints:** `1 <= scores.length, ages.length <= 1000` `scores.length == ages.length` `1 <= scores[i] <= 106` `1 <= ages[i] <= 1000`",
        "test_case": [
            {
                "label": "Example 1",
                "input": "scores = [1,3,5,10,15], ages = [1,2,3,4,5]",
                "output": "34 Explanation: You can choose all the players."
            },
            {
                "label": "Example 2",
                "input": "scores = [4,5,6,5], ages = [2,1,2,1]",
                "output": "16 Explanation: It is best to choose the last 3 players. Notice that you are allowed to choose multiple people of the same age."
            },
            {
                "label": "Example 3",
                "input": "scores = [1,2,3,5], ages = [8,9,10,1]",
                "output": "6 Explanation: It is best to choose the first 3 players."
            }
        ],
        "elixir_template": "defmodule Solution do\n  @spec best_team_score(scores :: [integer], ages :: [integer]) :: integer\n  def best_team_score(scores, ages) do\n    \n  end\nend",
        "erlang_template": "-spec best_team_score(Scores :: [integer()], Ages :: [integer()]) -> integer().\nbest_team_score(Scores, Ages) ->\n  .",
        "scala_template": "object Solution {\n    def bestTeamScore(scores: Array[Int], ages: Array[Int]): Int = {\n        \n    }\n}"
    },
    {
        "id": 1747,
        "name": "lexicographically-smallest-string-after-applying-operations",
        "difficulty": "Medium",
        "link": "https://leetcode.com/problems/lexicographically-smallest-string-after-applying-operations/",
        "task_description": "You are given a string `s` of **even length** consisting of digits from `0` to `9`, and two integers `a` and `b`. You can apply either of the following two operations any number of times and in any order on `s`: Add `a` to all odd indices of `s` **(0-indexed)**. Digits post `9` are cycled back to `0`. For example, if `s = \"3456\"` and `a = 5`, `s` becomes `\"3951\"`. Rotate `s` to the right by `b` positions. For example, if `s = \"3456\"` and `b = 1`, `s` becomes `\"6345\"`. Return _the **lexicographically smallest** string you can obtain by applying the above operations any number of times on_ `s`. A string `a` is lexicographically smaller than a string `b` (of the same length) if in the first position where `a` and `b` differ, string `a` has a letter that appears earlier in the alphabet than the corresponding letter in `b`. For example, `\"0158\"` is lexicographically smaller than `\"0190\"` because the first position they differ is at the third letter, and `'5'` comes before `'9'`. **Example 1:** ``` **Input:** s = \"5525\", a = 9, b = 2 **Output:** \"2050\" **Explanation:** We can apply the following operations: Start: \"5525\" Rotate: \"2555\" Add: \"2454\" Add: \"2353\" Rotate: \"5323\" Add: \"5222\" Add: \"5121\" Rotate: \"2151\" Add: \"2050\"\u200b\u200b\u200b\u200b\u200b There is no way to obtain a string that is lexicographically smaller than \"2050\". ``` **Example 2:** ``` **Input:** s = \"74\", a = 5, b = 1 **Output:** \"24\" **Explanation:** We can apply the following operations: Start: \"74\" Rotate: \"47\" \u200b\u200b\u200b\u200b\u200b\u200b\u200bAdd: \"42\" \u200b\u200b\u200b\u200b\u200b\u200b\u200bRotate: \"24\"\u200b\u200b\u200b\u200b\u200b\u200b\u200b\u200b\u200b\u200b\u200b\u200b There is no way to obtain a string that is lexicographically smaller than \"24\". ``` **Example 3:** ``` **Input:** s = \"0011\", a = 4, b = 2 **Output:** \"0011\" **Explanation:** There are no sequence of operations that will give us a lexicographically smaller string than \"0011\". ``` **Constraints:** `2 <= s.length <= 100` `s.length` is even. `s` consists of digits from `0` to `9` only. `1 <= a <= 9` `1 <= b <= s.length - 1`",
        "test_case": [
            {
                "label": "Example 1",
                "input": "s = \"5525\", a = 9, b = 2",
                "output": "\"2050\" Explanation: We can apply the following operations:\nStart:  \"5525\"\nRotate: \"2555\"\nAdd:    \"2454\"\nAdd:    \"2353\"\nRotate: \"5323\"\nAdd:    \"5222\"\nAdd:    \"5121\"\nRotate: \"2151\"\nAdd:    \"2050\"\u200b\u200b\u200b\u200b\u200b\nThere is no way to obtain a string that is lexicographically smaller than \"2050\"."
            },
            {
                "label": "Example 2",
                "input": "s = \"74\", a = 5, b = 1",
                "output": "\"24\" Explanation: We can apply the following operations:\nStart:  \"74\"\nRotate: \"47\"\n\u200b\u200b\u200b\u200b\u200b\u200b\u200bAdd:    \"42\"\n\u200b\u200b\u200b\u200b\u200b\u200b\u200bRotate: \"24\"\u200b\u200b\u200b\u200b\u200b\u200b\u200b\u200b\u200b\u200b\u200b\u200b\nThere is no way to obtain a string that is lexicographically smaller than \"24\"."
            },
            {
                "label": "Example 3",
                "input": "s = \"0011\", a = 4, b = 2",
                "output": "\"0011\" Explanation: There are no sequence of operations that will give us a lexicographically smaller string than \"0011\"."
            }
        ],
        "elixir_template": "defmodule Solution do\n  @spec find_lex_smallest_string(s :: String.t, a :: integer, b :: integer) :: String.t\n  def find_lex_smallest_string(s, a, b) do\n    \n  end\nend",
        "erlang_template": "-spec find_lex_smallest_string(S :: unicode:unicode_binary(), A :: integer(), B :: integer()) -> unicode:unicode_binary().\nfind_lex_smallest_string(S, A, B) ->\n  .",
        "scala_template": "object Solution {\n    def findLexSmallestString(s: String, a: Int, b: Int): String = {\n        \n    }\n}"
    },
    {
        "id": 1746,
        "name": "largest-substring-between-two-equal-characters",
        "difficulty": "Easy",
        "link": "https://leetcode.com/problems/largest-substring-between-two-equal-characters/",
        "task_description": "Given a string `s`, return _the length of the longest substring between two equal characters, excluding the two characters._ If there is no such substring return `-1`. A **substring** is a contiguous sequence of characters within a string. **Example 1:** ``` **Input:** s = \"aa\" **Output:** 0 **Explanation:** The optimal substring here is an empty substring between the two `'a's`. ``` **Example 2:** ``` **Input:** s = \"abca\" **Output:** 2 **Explanation:** The optimal substring here is \"bc\". ``` **Example 3:** ``` **Input:** s = \"cbzxy\" **Output:** -1 **Explanation:** There are no characters that appear twice in s. ``` **Constraints:** `1 <= s.length <= 300` `s` contains only lowercase English letters.",
        "test_case": [
            {
                "label": "Example 1",
                "input": "s = \"aa\"",
                "output": "0 Explanation: The optimal substring here is an empty substring between the two 'a's ."
            },
            {
                "label": "Example 2",
                "input": "s = \"abca\"",
                "output": "2 Explanation: The optimal substring here is \"bc\"."
            },
            {
                "label": "Example 3",
                "input": "s = \"cbzxy\"",
                "output": "-1 Explanation: There are no characters that appear twice in s."
            }
        ],
        "elixir_template": "defmodule Solution do\n  @spec max_length_between_equal_characters(s :: String.t) :: integer\n  def max_length_between_equal_characters(s) do\n    \n  end\nend",
        "erlang_template": "-spec max_length_between_equal_characters(S :: unicode:unicode_binary()) -> integer().\nmax_length_between_equal_characters(S) ->\n  .",
        "scala_template": "object Solution {\n    def maxLengthBetweenEqualCharacters(s: String): Int = {\n        \n    }\n}"
    },
    {
        "id": 1744,
        "name": "number-of-ways-to-form-a-target-string-given-a-dictionary",
        "difficulty": "Hard",
        "link": "https://leetcode.com/problems/number-of-ways-to-form-a-target-string-given-a-dictionary/",
        "task_description": "You are given a list of strings of the **same length** `words` and a string `target`. Your task is to form `target` using the given `words` under the following rules: `target` should be formed from left to right. To form the `ith` character (**0-indexed**) of `target`, you can choose the `kth` character of the `jth` string in `words` if `target[i] = words[j][k]`. Once you use the `kth` character of the `jth` string of `words`, you **can no longer** use the `xth` character of any string in `words` where `x <= k`. In other words, all characters to the left of or at index `k` become unusuable for every string. Repeat the process until you form the string `target`. **Notice** that you can use **multiple characters** from the **same string** in `words` provided the conditions above are met. Return _the number of ways to form `target` from `words`_. Since the answer may be too large, return it **modulo** `109 + 7`. **Example 1:** ``` **Input:** words = [\"acca\",\"bbbb\",\"caca\"], target = \"aba\" **Output:** 6 **Explanation:** There are 6 ways to form target. \"aba\" -> index 0 (\"acca\"), index 1 (\"bbbb\"), index 3 (\"caca\") \"aba\" -> index 0 (\"acca\"), index 2 (\"bbbb\"), index 3 (\"caca\") \"aba\" -> index 0 (\"acca\"), index 1 (\"bbbb\"), index 3 (\"acca\") \"aba\" -> index 0 (\"acca\"), index 2 (\"bbbb\"), index 3 (\"acca\") \"aba\" -> index 1 (\"caca\"), index 2 (\"bbbb\"), index 3 (\"acca\") \"aba\" -> index 1 (\"caca\"), index 2 (\"bbbb\"), index 3 (\"caca\") ``` **Example 2:** ``` **Input:** words = [\"abba\",\"baab\"], target = \"bab\" **Output:** 4 **Explanation:** There are 4 ways to form target. \"bab\" -> index 0 (\"baab\"), index 1 (\"baab\"), index 2 (\"abba\") \"bab\" -> index 0 (\"baab\"), index 1 (\"baab\"), index 3 (\"baab\") \"bab\" -> index 0 (\"baab\"), index 2 (\"baab\"), index 3 (\"baab\") \"bab\" -> index 1 (\"abba\"), index 2 (\"baab\"), index 3 (\"baab\") ``` **Constraints:** `1 <= words.length <= 1000` `1 <= words[i].length <= 1000` All strings in `words` have the same length. `1 <= target.length <= 1000` `words[i]` and `target` contain only lowercase English letters.",
        "test_case": [
            {
                "label": "Example 1",
                "input": "words = [\"acca\",\"bbbb\",\"caca\"], target = \"aba\"",
                "output": "6 Explanation: There are 6 ways to form target.\n\"aba\" -> index 0 (\" a cca\"), index 1 (\"b b bb\"), index 3 (\"cac a \")\n\"aba\" -> index 0 (\" a cca\"), index 2 (\"bb b b\"), index 3 (\"cac a \")\n\"aba\" -> index 0 (\" a cca\"), index 1 (\"b b bb\"), index 3 (\"acc a \")\n\"aba\" -> index 0 (\" a cca\"), index 2 (\"bb b b\"), index 3 (\"acc a \")\n\"aba\" -> index 1 (\"c a ca\"), index 2 (\"bb b b\"), index 3 (\"acc a \")\n\"aba\" -> index 1 (\"c a ca\"), index 2 (\"bb b b\"), index 3 (\"cac a \")"
            },
            {
                "label": "Example 2",
                "input": "words = [\"abba\",\"baab\"], target = \"bab\"",
                "output": "4 Explanation: There are 4 ways to form target.\n\"bab\" -> index 0 (\" b aab\"), index 1 (\"b a ab\"), index 2 (\"ab b a\")\n\"bab\" -> index 0 (\" b aab\"), index 1 (\"b a ab\"), index 3 (\"baa b \")\n\"bab\" -> index 0 (\" b aab\"), index 2 (\"ba a b\"), index 3 (\"baa b \")\n\"bab\" -> index 1 (\"a b ba\"), index 2 (\"ba a b\"), index 3 (\"baa b \")"
            }
        ],
        "elixir_template": "defmodule Solution do\n  @spec num_ways(words :: [String.t], target :: String.t) :: integer\n  def num_ways(words, target) do\n    \n  end\nend",
        "erlang_template": "-spec num_ways(Words :: [unicode:unicode_binary()], Target :: unicode:unicode_binary()) -> integer().\nnum_ways(Words, Target) ->\n  .",
        "scala_template": "object Solution {\n    def numWays(words: Array[String], target: String): Int = {\n        \n    }\n}"
    },
    {
        "id": 1743,
        "name": "count-substrings-that-differ-by-one-character",
        "difficulty": "Medium",
        "link": "https://leetcode.com/problems/count-substrings-that-differ-by-one-character/",
        "task_description": "Given two strings `s` and `t`, find the number of ways you can choose a non-empty substring of `s` and replace a **single character** by a different character such that the resulting substring is a substring of `t`. In other words, find the number of substrings in `s` that differ from some substring in `t` by **exactly** one character. For example, the underlined substrings in `\"computer\"` and `\"computation\"` only differ by the `'e'`/`'a'`, so this is a valid way. Return _the number of substrings that satisfy the condition above._ A **substring** is a contiguous sequence of characters within a string. **Example 1:** ``` **Input:** s = \"aba\", t = \"baba\" **Output:** 6 **Explanation:** The following are the pairs of substrings from s and t that differ by exactly 1 character: (\"aba\", \"baba\") (\"aba\", \"baba\") (\"aba\", \"baba\") (\"aba\", \"baba\") (\"aba\", \"baba\") (\"aba\", \"baba\") The underlined portions are the substrings that are chosen from s and t. ``` \u200b\u200b**Example 2:** ``` **Input:** s = \"ab\", t = \"bb\" **Output:** 3 **Explanation:** The following are the pairs of substrings from s and t that differ by 1 character: (\"ab\", \"bb\") (\"ab\", \"bb\") (\"ab\", \"bb\") \u200b\u200b\u200b\u200bThe underlined portions are the substrings that are chosen from s and t. ``` **Constraints:** `1 <= s.length, t.length <= 100` `s` and `t` consist of lowercase English letters only.",
        "test_case": [
            {
                "label": "Example 1",
                "input": "s = \"aba\", t = \"baba\"",
                "output": "6 Explanation: The following are the pairs of substrings from s and t that differ by exactly 1 character:\n(\" a ba\", \" b aba\")\n(\" a ba\", \"ba b a\")\n(\"ab a \", \" b aba\")\n(\"ab a \", \"ba b a\")\n(\"a b a\", \"b a ba\")\n(\"a b a\", \"bab a \")\nThe underlined portions are the substrings that are chosen from s and t. \u200b\u200b"
            },
            {
                "label": "Example 2",
                "input": "s = \"ab\", t = \"bb\"",
                "output": "3 Explanation: The following are the pairs of substrings from s and t that differ by 1 character:\n(\" a b\", \" b b\")\n(\" a b\", \"b b \")\n(\" ab \", \" bb \")\n\u200b\u200b\u200b\u200bThe underlined portions are the substrings that are chosen from s and t."
            }
        ],
        "elixir_template": "defmodule Solution do\n  @spec count_substrings(s :: String.t, t :: String.t) :: integer\n  def count_substrings(s, t) do\n    \n  end\nend",
        "erlang_template": "-spec count_substrings(S :: unicode:unicode_binary(), T :: unicode:unicode_binary()) -> integer().\ncount_substrings(S, T) ->\n  .",
        "scala_template": "object Solution {\n    def countSubstrings(s: String, t: String): Int = {\n        \n    }\n}"
    },
    {
        "id": 1742,
        "name": "widest-vertical-area-between-two-points-containing-no-points",
        "difficulty": "Easy",
        "link": "https://leetcode.com/problems/widest-vertical-area-between-two-points-containing-no-points/",
        "task_description": "Given `n` `points` on a 2D plane where `points[i] = [xi, yi]`, Return_ the **widest vertical area** between two points such that no points are inside the area._ A **vertical area** is an area of fixed-width extending infinitely along the y-axis (i.e., infinite height). The **widest vertical area** is the one with the maximum width. Note that points **on the edge** of a vertical area **are not** considered included in the area. **Example 1:** \u200b ``` **Input:** points = [[8,7],[9,9],[7,4],[9,7]] **Output:** 1 **Explanation:** Both the red and the blue area are optimal. ``` **Example 2:** ``` **Input:** points = [[3,1],[9,0],[1,0],[1,4],[5,3],[8,8]] **Output:** 3 ``` **Constraints:** `n == points.length` `2 <= n <= 105` `points[i].length == 2` `0 <= xi, yi <= 109`",
        "test_case": [
            {
                "label": "Example 1",
                "input": "points = [[8,7],[9,9],[7,4],[9,7]]",
                "output": "1 Explanation: Both the red and the blue area are optimal."
            },
            {
                "label": "Example 2",
                "input": "points = [[3,1],[9,0],[1,0],[1,4],[5,3],[8,8]]",
                "output": "3 Constraints: n == points.length 2 <= n <= 10 5 points[i].length == 2 0 <= x i , y i <= 10 9"
            }
        ],
        "elixir_template": "defmodule Solution do\n  @spec max_width_of_vertical_area(points :: [[integer]]) :: integer\n  def max_width_of_vertical_area(points) do\n    \n  end\nend",
        "erlang_template": "-spec max_width_of_vertical_area(Points :: [[integer()]]) -> integer().\nmax_width_of_vertical_area(Points) ->\n  .",
        "scala_template": "object Solution {\n    def maxWidthOfVerticalArea(points: Array[Array[Int]]): Int = {\n        \n    }\n}"
    },
    {
        "id": 1741,
        "name": "sort-array-by-increasing-frequency",
        "difficulty": "Easy",
        "link": "https://leetcode.com/problems/sort-array-by-increasing-frequency/",
        "task_description": "Given an array of integers `nums`, sort the array in **increasing** order based on the frequency of the values. If multiple values have the same frequency, sort them in **decreasing** order. Return the _sorted array_. **Example 1:** ``` **Input:** nums = [1,1,2,2,2,3] **Output:** [3,1,1,2,2,2] **Explanation:** '3' has a frequency of 1, '1' has a frequency of 2, and '2' has a frequency of 3. ``` **Example 2:** ``` **Input:** nums = [2,3,1,3,2] **Output:** [1,3,3,2,2] **Explanation:** '2' and '3' both have a frequency of 2, so they are sorted in decreasing order. ``` **Example 3:** ``` **Input:** nums = [-1,1,-6,4,5,-6,1,4,1] **Output:** [5,-1,4,4,-6,-6,1,1,1] ``` **Constraints:** `1 <= nums.length <= 100` `-100 <= nums[i] <= 100`",
        "test_case": [
            {
                "label": "Example 1",
                "input": "nums = [1,1,2,2,2,3]",
                "output": "[3,1,1,2,2,2] Explanation: '3' has a frequency of 1, '1' has a frequency of 2, and '2' has a frequency of 3."
            },
            {
                "label": "Example 2",
                "input": "nums = [2,3,1,3,2]",
                "output": "[1,3,3,2,2] Explanation: '2' and '3' both have a frequency of 2, so they are sorted in decreasing order."
            },
            {
                "label": "Example 3",
                "input": "nums = [-1,1,-6,4,5,-6,1,4,1]",
                "output": "[5,-1,4,4,-6,-6,1,1,1]"
            }
        ],
        "elixir_template": "defmodule Solution do\n  @spec frequency_sort(nums :: [integer]) :: [integer]\n  def frequency_sort(nums) do\n    \n  end\nend",
        "erlang_template": "-spec frequency_sort(Nums :: [integer()]) -> [integer()].\nfrequency_sort(Nums) ->\n  .",
        "scala_template": "object Solution {\n    def frequencySort(nums: Array[Int]): Array[Int] = {\n        \n    }\n}"
    },
    {
        "id": 1740,
        "name": "count-subtrees-with-max-distance-between-cities",
        "difficulty": "Hard",
        "link": "https://leetcode.com/problems/count-subtrees-with-max-distance-between-cities/",
        "task_description": "There are `n` cities numbered from `1` to `n`. You are given an array `edges` of size `n-1`, where `edges[i] = [ui, vi]` represents a bidirectional edge between cities `ui` and `vi`. There exists a unique path between each pair of cities. In other words, the cities form a **tree**. A **subtree** is a subset of cities where every city is reachable from every other city in the subset, where the path between each pair passes through only the cities from the subset. Two subtrees are different if there is a city in one subtree that is not present in the other. For each `d` from `1` to `n-1`, find the number of subtrees in which the **maximum distance** between any two cities in the subtree is equal to `d`. Return _an array of size_ `n-1` _where the _`dth`_ __element **(1-indexed)** is the number of subtrees in which the **maximum distance** between any two cities is equal to _`d`. **Notice** that the **distance** between the two cities is the number of edges in the path between them. **Example 1:** **** ``` **Input:** n = 4, edges = [[1,2],[2,3],[2,4]] **Output:** [3,4,0] **Explanation: **The subtrees with subsets {1,2}, {2,3} and {2,4} have a max distance of 1. The subtrees with subsets {1,2,3}, {1,2,4}, {2,3,4} and {1,2,3,4} have a max distance of 2. No subtree has two nodes where the max distance between them is 3. ``` **Example 2:** ``` **Input:** n = 2, edges = [[1,2]] **Output:** [1] ``` **Example 3:** ``` **Input:** n = 3, edges = [[1,2],[2,3]] **Output:** [2,1] ``` **Constraints:** `2 <= n <= 15` `edges.length == n-1` `edges[i].length == 2` `1 <= ui, vi <= n` All pairs `(ui, vi)` are distinct.",
        "test_case": [
            {
                "label": "Example 1",
                "input": "n = 4, edges = [[1,2],[2,3],[2,4]]",
                "output": "[3,4,0] Explanation: The subtrees with subsets {1,2}, {2,3} and {2,4} have a max distance of 1.\r\nThe subtrees with subsets {1,2,3}, {1,2,4}, {2,3,4} and {1,2,3,4} have a max distance of 2.\r\nNo subtree has two nodes where the max distance between them is 3."
            },
            {
                "label": "Example 2",
                "input": "n = 2, edges = [[1,2]]",
                "output": "[1]"
            },
            {
                "label": "Example 3",
                "input": "n = 3, edges = [[1,2],[2,3]]",
                "output": "[2,1]"
            }
        ],
        "elixir_template": "Elixir code template not available for this problem.",
        "erlang_template": "Elixir code template not available for this problem.",
        "scala_template": "object Solution {\n    def countSubgraphsForEachDiameter(n: Int, edges: Array[Array[Int]]): Array[Int] = {\n        \n    }\n}"
    },
    {
        "id": 1739,
        "name": "split-two-strings-to-make-palindrome",
        "difficulty": "Medium",
        "link": "https://leetcode.com/problems/split-two-strings-to-make-palindrome/",
        "task_description": "You are given two strings `a` and `b` of the same length. Choose an index and split both strings **at the same index**, splitting `a` into two strings: `aprefix` and `asuffix` where `a = aprefix + asuffix`, and splitting `b` into two strings: `bprefix` and `bsuffix` where `b = bprefix + bsuffix`. Check if `aprefix + bsuffix` or `bprefix + asuffix` forms a palindrome. When you split a string `s` into `sprefix` and `ssuffix`, either `ssuffix` or `sprefix` is allowed to be empty. For example, if `s = \"abc\"`, then `\"\" + \"abc\"`, `\"a\" + \"bc\"`, `\"ab\" + \"c\"` , and `\"abc\" + \"\"` are valid splits. Return `true`_ if it is possible to form__ a palindrome string, otherwise return _`false`. **Notice** that `x + y` denotes the concatenation of strings `x` and `y`. **Example 1:** ``` **Input:** a = \"x\", b = \"y\" **Output:** true **Explaination:** If either a or b are palindromes the answer is true since you can split in the following way: aprefix = \"\", asuffix = \"x\" bprefix = \"\", bsuffix = \"y\" Then, aprefix + bsuffix = \"\" + \"y\" = \"y\", which is a palindrome. ``` **Example 2:** ``` **Input:** a = \"xbdef\", b = \"xecab\" **Output:** false ``` **Example 3:** ``` **Input:** a = \"ulacfd\", b = \"jizalu\" **Output:** true **Explaination:** Split them at index 3: aprefix = \"ula\", asuffix = \"cfd\" bprefix = \"jiz\", bsuffix = \"alu\" Then, aprefix + bsuffix = \"ula\" + \"alu\" = \"ulaalu\", which is a palindrome. ``` **Constraints:** `1 <= a.length, b.length <= 105` `a.length == b.length` `a` and `b` consist of lowercase English letters",
        "test_case": [
            {
                "label": "Example 1",
                "input": "a = \"x\", b = \"y\"",
                "output": "true Explaination: If either a or b are palindromes the answer is true since you can split in the following way:\na prefix = \"\", a suffix = \"x\"\nb prefix = \"\", b suffix = \"y\"\nThen, a prefix + b suffix = \"\" + \"y\" = \"y\", which is a palindrome."
            },
            {
                "label": "Example 2",
                "input": "a = \"xbdef\", b = \"xecab\"",
                "output": "false"
            },
            {
                "label": "Example 3",
                "input": "a = \"ulacfd\", b = \"jizalu\"",
                "output": "true Explaination: Split them at index 3:\na prefix = \"ula\", a suffix = \"cfd\"\nb prefix = \"jiz\", b suffix = \"alu\"\nThen, a prefix + b suffix = \"ula\" + \"alu\" = \"ulaalu\", which is a palindrome."
            }
        ],
        "elixir_template": "defmodule Solution do\n  @spec check_palindrome_formation(a :: String.t, b :: String.t) :: boolean\n  def check_palindrome_formation(a, b) do\n    \n  end\nend",
        "erlang_template": "-spec check_palindrome_formation(A :: unicode:unicode_binary(), B :: unicode:unicode_binary()) -> boolean().\ncheck_palindrome_formation(A, B) ->\n  .",
        "scala_template": "object Solution {\n    def checkPalindromeFormation(a: String, b: String): Boolean = {\n        \n    }\n}"
    },
    {
        "id": 1738,
        "name": "maximal-network-rank",
        "difficulty": "Medium",
        "link": "https://leetcode.com/problems/maximal-network-rank/",
        "task_description": "There is an infrastructure of `n` cities with some number of `roads` connecting these cities. Each `roads[i] = [ai, bi]` indicates that there is a bidirectional road between cities `ai` and `bi`. The **network rank**_ _of **two different cities** is defined as the total number of **directly** connected roads to **either** city. If a road is directly connected to both cities, it is only counted **once**. The **maximal network rank **of the infrastructure is the **maximum network rank** of all pairs of different cities. Given the integer `n` and the array `roads`, return _the **maximal network rank** of the entire infrastructure_. **Example 1:** **** ``` **Input:** n = 4, roads = [[0,1],[0,3],[1,2],[1,3]] **Output:** 4 **Explanation:** The network rank of cities 0 and 1 is 4 as there are 4 roads that are connected to either 0 or 1. The road between 0 and 1 is only counted once. ``` **Example 2:** **** ``` **Input:** n = 5, roads = [[0,1],[0,3],[1,2],[1,3],[2,3],[2,4]] **Output:** 5 **Explanation:** There are 5 roads that are connected to cities 1 or 2. ``` **Example 3:** ``` **Input:** n = 8, roads = [[0,1],[1,2],[2,3],[2,4],[5,6],[5,7]] **Output:** 5 **Explanation:** The network rank of 2 and 5 is 5. Notice that all the cities do not have to be connected. ``` **Constraints:** `2 <= n <= 100` `0 <= roads.length <= n * (n - 1) / 2` `roads[i].length == 2` `0 <= ai, bi <= n-1` `ai != bi` Each pair of cities has **at most one** road connecting them.",
        "test_case": [
            {
                "label": "Example 1",
                "input": "n = 4, roads = [[0,1],[0,3],[1,2],[1,3]]",
                "output": "4 Explanation: The network rank of cities 0 and 1 is 4 as there are 4 roads that are connected to either 0 or 1. The road between 0 and 1 is only counted once."
            },
            {
                "label": "Example 2",
                "input": "n = 5, roads = [[0,1],[0,3],[1,2],[1,3],[2,3],[2,4]]",
                "output": "5 Explanation: There are 5 roads that are connected to cities 1 or 2."
            },
            {
                "label": "Example 3",
                "input": "n = 8, roads = [[0,1],[1,2],[2,3],[2,4],[5,6],[5,7]]",
                "output": "5 Explanation: The network rank of 2 and 5 is 5. Notice that all the cities do not have to be connected."
            }
        ],
        "elixir_template": "defmodule Solution do\n  @spec maximal_network_rank(n :: integer, roads :: [[integer]]) :: integer\n  def maximal_network_rank(n, roads) do\n    \n  end\nend",
        "erlang_template": "-spec maximal_network_rank(N :: integer(), Roads :: [[integer()]]) -> integer().\nmaximal_network_rank(N, Roads) ->\n  .",
        "scala_template": "object Solution {\n    def maximalNetworkRank(n: Int, roads: Array[Array[Int]]): Int = {\n        \n    }\n}"
    },
    {
        "id": 1737,
        "name": "maximum-nesting-depth-of-the-parentheses",
        "difficulty": "Easy",
        "link": "https://leetcode.com/problems/maximum-nesting-depth-of-the-parentheses/",
        "task_description": "Given a **valid parentheses string** `s`, return the **nesting depth** of_ _`s`. The nesting depth is the **maximum** number of nested parentheses. **Example 1:** **Input:** s = \"(1+(2*3)+((8)/4))+1\" **Output:** 3 **Explanation:** Digit 8 is inside of 3 nested parentheses in the string. **Example 2:** **Input:** s = \"(1)+((2))+(((3)))\" **Output:** 3 **Explanation:** Digit 3 is inside of 3 nested parentheses in the string. **Example 3:** **Input:** s = \"()(())((()()))\" **Output:** 3 **Constraints:** `1 <= s.length <= 100` `s` consists of digits `0-9` and characters `'+'`, `'-'`, `'*'`, `'/'`, `'('`, and `')'`. It is guaranteed that parentheses expression `s` is a VPS.",
        "test_case": [
            {
                "label": "Example 1",
                "input": "s = \"(1+(2*3)+((8)/4))+1\"",
                "output": "3 Explanation: Digit 8 is inside of 3 nested parentheses in the string."
            },
            {
                "label": "Example 2",
                "input": "s = \"(1)+((2))+(((3)))\"",
                "output": "3 Explanation: Digit 3 is inside of 3 nested parentheses in the string."
            },
            {
                "label": "Example 3",
                "input": "s = \"()(())((()()))\"",
                "output": "3"
            }
        ],
        "elixir_template": "defmodule Solution do\n  @spec max_depth(s :: String.t) :: integer\n  def max_depth(s) do\n    \n  end\nend",
        "erlang_template": "-spec max_depth(S :: unicode:unicode_binary()) -> integer().\nmax_depth(S) ->\n  .",
        "scala_template": "object Solution {\n    def maxDepth(s: String): Int = {\n        \n    }\n}"
    },
    {
        "id": 1733,
        "name": "maximum-number-of-visible-points",
        "difficulty": "Hard",
        "link": "https://leetcode.com/problems/maximum-number-of-visible-points/",
        "task_description": "You are given an array `points`, an integer `angle`, and your `location`, where `location = [posx, posy]` and `points[i] = [xi, yi]` both denote **integral coordinates** on the X-Y plane. Initially, you are facing directly east from your position. You **cannot move** from your position, but you can **rotate**. In other words, `posx` and `posy` cannot be changed. Your field of view in **degrees** is represented by `angle`, determining how wide you can see from any given view direction. Let `d` be the amount in degrees that you rotate counterclockwise. Then, your field of view is the **inclusive** range of angles `[d - angle/2, d + angle/2]`. Your browser does not support the video tag or this video format. You can **see** some set of points if, for each point, the **angle** formed by the point, your position, and the immediate east direction from your position is **in your field of view**. There can be multiple points at one coordinate. There may be points at your location, and you can always see these points regardless of your rotation. Points do not obstruct your vision to other points. Return _the maximum number of points you can see_. **Example 1:** ``` **Input:** points = [[2,1],[2,2],[3,3]], angle = 90, location = [1,1] **Output:** 3 **Explanation:** The shaded region represents your field of view. All points can be made visible in your field of view, including [3,3] even though [2,2] is in front and in the same line of sight. ``` **Example 2:** ``` **Input:** points = [[2,1],[2,2],[3,4],[1,1]], angle = 90, location = [1,1] **Output:** 4 **Explanation:** All points can be made visible in your field of view, including the one at your location. ``` **Example 3:** ``` **Input:** points = [[1,0],[2,1]], angle = 13, location = [1,1] **Output:** 1 **Explanation:** You can only see one of the two points, as shown above. ``` **Constraints:** `1 <= points.length <= 105` `points[i].length == 2` `location.length == 2` `0 <= angle < 360` `0 <= posx, posy, xi, yi <= 100`",
        "test_case": [
            {
                "label": "Example 1",
                "input": "points = [[2,1],[2,2],[3,3]], angle = 90, location = [1,1]",
                "output": "3 Explanation: The shaded region represents your field of view. All points can be made visible in your field of view, including [3,3] even though [2,2] is in front and in the same line of sight."
            },
            {
                "label": "Example 2",
                "input": "points = [[2,1],[2,2],[3,4],[1,1]], angle = 90, location = [1,1]",
                "output": "4 Explanation: All points can be made visible in your field of view, including the one at your location."
            },
            {
                "label": "Example 3",
                "input": "points = [[1,0],[2,1]], angle = 13, location = [1,1]",
                "output": "1 Explanation: You can only see one of the two points, as shown above."
            }
        ],
        "elixir_template": "defmodule Solution do\n  @spec visible_points(points :: [[integer]], angle :: integer, location :: [integer]) :: integer\n  def visible_points(points, angle, location) do\n    \n  end\nend",
        "erlang_template": "-spec visible_points(Points :: [[integer()]], Angle :: integer(), Location :: [integer()]) -> integer().\nvisible_points(Points, Angle, Location) ->\n  .",
        "scala_template": "object Solution {\n    def visiblePoints(points: List[List[Int]], angle: Int, location: List[Int]): Int = {\n        \n    }\n}"
    },
    {
        "id": 1732,
        "name": "minimum-one-bit-operations-to-make-integers-zero",
        "difficulty": "Hard",
        "link": "https://leetcode.com/problems/minimum-one-bit-operations-to-make-integers-zero/",
        "task_description": "Given an integer `n`, you must transform it into `0` using the following operations any number of times: Change the rightmost (`0th`) bit in the binary representation of `n`. Change the `ith` bit in the binary representation of `n` if the `(i-1)th` bit is set to `1` and the `(i-2)th` through `0th` bits are set to `0`. Return _the minimum number of operations to transform _`n`_ into _`0`_._ **Example 1:** ``` **Input:** n = 3 **Output:** 2 **Explanation:** The binary representation of 3 is \"11\". \"11\" -> \"01\" with the 2nd operation since the 0th bit is 1. \"01\" -> \"00\" with the 1st operation. ``` **Example 2:** ``` **Input:** n = 6 **Output:** 4 **Explanation:** The binary representation of 6 is \"110\". \"110\" -> \"010\" with the 2nd operation since the 1st bit is 1 and 0th through 0th bits are 0. \"010\" -> \"011\" with the 1st operation. \"011\" -> \"001\" with the 2nd operation since the 0th bit is 1. \"001\" -> \"000\" with the 1st operation. ``` **Constraints:** `0 <= n <= 109`",
        "test_case": [
            {
                "label": "Example 1",
                "input": "n = 3",
                "output": "2 Explanation: The binary representation of 3 is \"11\".\n\" 1 1\" -> \" 0 1\" with the 2 nd operation since the 0 th bit is 1.\n\"0 1 \" -> \"0 0 \" with the 1 st operation."
            },
            {
                "label": "Example 2",
                "input": "n = 6",
                "output": "4 Explanation: The binary representation of 6 is \"110\".\n\" 1 10\" -> \" 0 10\" with the 2 nd operation since the 1 st bit is 1 and 0 th through 0 th bits are 0.\n\"01 0 \" -> \"01 1 \" with the 1 st operation.\n\"0 1 1\" -> \"0 0 1\" with the 2 nd operation since the 0 th bit is 1.\n\"00 1 \" -> \"00 0 \" with the 1 st operation."
            }
        ],
        "elixir_template": "defmodule Solution do\n  @spec minimum_one_bit_operations(n :: integer) :: integer\n  def minimum_one_bit_operations(n) do\n    \n  end\nend",
        "erlang_template": "-spec minimum_one_bit_operations(N :: integer()) -> integer().\nminimum_one_bit_operations(N) ->\n  .",
        "scala_template": "object Solution {\n    def minimumOneBitOperations(n: Int): Int = {\n        \n    }\n}"
    },
    {
        "id": 1731,
        "name": "even-odd-tree",
        "difficulty": "Medium",
        "link": "https://leetcode.com/problems/even-odd-tree/",
        "task_description": "A binary tree is named **Even-Odd** if it meets the following conditions: The root of the binary tree is at level index `0`, its children are at level index `1`, their children are at level index `2`, etc. For every **even-indexed** level, all nodes at the level have **odd** integer values in **strictly increasing** order (from left to right). For every odd-indexed level, all nodes at the level have even integer values in **strictly decreasing** order (from left to right). Given the `root` of a binary tree, _return _`true`_ if the binary tree is **Even-Odd**, otherwise return _`false`_._ **Example 1:** ``` **Input:** root = [1,10,4,3,null,7,9,12,8,6,null,null,2] **Output:** true **Explanation:** The node values on each level are: Level 0: [1] Level 1: [10,4] Level 2: [3,7,9] Level 3: [12,8,6,2] Since levels 0 and 2 are all odd and increasing and levels 1 and 3 are all even and decreasing, the tree is Even-Odd. ``` **Example 2:** ``` **Input:** root = [5,4,2,3,3,7] **Output:** false **Explanation:** The node values on each level are: Level 0: [5] Level 1: [4,2] Level 2: [3,3,7] Node values in level 2 must be in strictly increasing order, so the tree is not Even-Odd. ``` **Example 3:** ``` **Input:** root = [5,9,1,3,5,7] **Output:** false **Explanation:** Node values in the level 1 should be even integers. ``` **Constraints:** The number of nodes in the tree is in the range `[1, 105]`. `1 <= Node.val <= 106`",
        "test_case": [
            {
                "label": "Example 1",
                "input": "root = [1,10,4,3,null,7,9,12,8,6,null,null,2]",
                "output": "true Explanation: The node values on each level are:\nLevel 0: [1]\nLevel 1: [10,4]\nLevel 2: [3,7,9]\nLevel 3: [12,8,6,2]\nSince levels 0 and 2 are all odd and increasing and levels 1 and 3 are all even and decreasing, the tree is Even-Odd."
            },
            {
                "label": "Example 2",
                "input": "root = [5,4,2,3,3,7]",
                "output": "false Explanation: The node values on each level are:\nLevel 0: [5]\nLevel 1: [4,2]\nLevel 2: [3,3,7]\nNode values in level 2 must be in strictly increasing order, so the tree is not Even-Odd."
            },
            {
                "label": "Example 3",
                "input": "root = [5,9,1,3,5,7]",
                "output": "false Explanation: Node values in the level 1 should be even integers. Constraints: The number of nodes in the tree is in the range [1, 10 5 ] . 1 <= Node.val <= 10 6"
            }
        ],
        "elixir_template": "# Definition for a binary tree node.\n#\n# defmodule TreeNode do\n#   @type t :: %__MODULE__{\n#           val: integer,\n#           left: TreeNode.t() | nil,\n#           right: TreeNode.t() | nil\n#         }\n#   defstruct val: 0, left: nil, right: nil\n# end\n\ndefmodule Solution do\n  @spec is_even_odd_tree(root :: TreeNode.t | nil) :: boolean\n  def is_even_odd_tree(root) do\n    \n  end\nend",
        "erlang_template": "%% Definition for a binary tree node.\n%%\n%% -record(tree_node, {val = 0 :: integer(),\n%%                     left = null  :: 'null' | #tree_node{},\n%%                     right = null :: 'null' | #tree_node{}}).\n\n-spec is_even_odd_tree(Root :: #tree_node{} | null) -> boolean().\nis_even_odd_tree(Root) ->\n  .",
        "scala_template": "/**\n * Definition for a binary tree node.\n * class TreeNode(_value: Int = 0, _left: TreeNode = null, _right: TreeNode = null) {\n *   var value: Int = _value\n *   var left: TreeNode = _left\n *   var right: TreeNode = _right\n * }\n */\nobject Solution {\n    def isEvenOddTree(root: TreeNode): Boolean = {\n        \n    }\n}"
    },
    {
        "id": 1730,
        "name": "special-array-with-x-elements-greater-than-or-equal-x",
        "difficulty": "Easy",
        "link": "https://leetcode.com/problems/special-array-with-x-elements-greater-than-or-equal-x/",
        "task_description": "You are given an array `nums` of non-negative integers. `nums` is considered **special** if there exists a number `x` such that there are **exactly** `x` numbers in `nums` that are **greater than or equal to** `x`. Notice that `x` **does not** have to be an element in `nums`. Return `x` _if the array is **special**, otherwise, return _`-1`. It can be proven that if `nums` is special, the value for `x` is **unique**. **Example 1:** ``` **Input:** nums = [3,5] **Output:** 2 **Explanation:** There are 2 values (3 and 5) that are greater than or equal to 2. ``` **Example 2:** ``` **Input:** nums = [0,0] **Output:** -1 **Explanation:** No numbers fit the criteria for x. If x = 0, there should be 0 numbers >= x, but there are 2. If x = 1, there should be 1 number >= x, but there are 0. If x = 2, there should be 2 numbers >= x, but there are 0. x cannot be greater since there are only 2 numbers in nums. ``` **Example 3:** ``` **Input:** nums = [0,4,3,0,4] **Output:** 3 **Explanation:** There are 3 values that are greater than or equal to 3. ``` **Constraints:** `1 <= nums.length <= 100` `0 <= nums[i] <= 1000`",
        "test_case": [
            {
                "label": "Example 1",
                "input": "nums = [3,5]",
                "output": "2 Explanation: There are 2 values (3 and 5) that are greater than or equal to 2."
            },
            {
                "label": "Example 2",
                "input": "nums = [0,0]",
                "output": "-1 Explanation: No numbers fit the criteria for x.\nIf x = 0, there should be 0 numbers >= x, but there are 2.\nIf x = 1, there should be 1 number >= x, but there are 0.\nIf x = 2, there should be 2 numbers >= x, but there are 0.\nx cannot be greater since there are only 2 numbers in nums."
            },
            {
                "label": "Example 3",
                "input": "nums = [0,4,3,0,4]",
                "output": "3 Explanation: There are 3 values that are greater than or equal to 3."
            }
        ],
        "elixir_template": "defmodule Solution do\n  @spec special_array(nums :: [integer]) :: integer\n  def special_array(nums) do\n    \n  end\nend",
        "erlang_template": "-spec special_array(Nums :: [integer()]) -> integer().\nspecial_array(Nums) ->\n  .",
        "scala_template": "object Solution {\n    def specialArray(nums: Array[Int]): Int = {\n        \n    }\n}"
    },
    {
        "id": 1728,
        "name": "fancy-sequence",
        "difficulty": "Hard",
        "link": "https://leetcode.com/problems/fancy-sequence/",
        "task_description": "Write an API that generates fancy sequences using the `append`, `addAll`, and `multAll` operations. Implement the `Fancy` class: `Fancy()` Initializes the object with an empty sequence. `void append(val)` Appends an integer `val` to the end of the sequence. `void addAll(inc)` Increments all existing values in the sequence by an integer `inc`. `void multAll(m)` Multiplies all existing values in the sequence by an integer `m`. `int getIndex(idx)` Gets the current value at index `idx` (0-indexed) of the sequence **modulo** `109 + 7`. If the index is greater or equal than the length of the sequence, return `-1`. **Example 1:** ``` **Input** [\"Fancy\", \"append\", \"addAll\", \"append\", \"multAll\", \"getIndex\", \"addAll\", \"append\", \"multAll\", \"getIndex\", \"getIndex\", \"getIndex\"] [[], [2], [3], [7], [2], [0], [3], [10], [2], [0], [1], [2]] **Output** [null, null, null, null, null, 10, null, null, null, 26, 34, 20] **Explanation** Fancy fancy = new Fancy(); fancy.append(2); // fancy sequence: [2] fancy.addAll(3); // fancy sequence: [2+3] -> [5] fancy.append(7); // fancy sequence: [5, 7] fancy.multAll(2); // fancy sequence: [5*2, 7*2] -> [10, 14] fancy.getIndex(0); // return 10 fancy.addAll(3); // fancy sequence: [10+3, 14+3] -> [13, 17] fancy.append(10); // fancy sequence: [13, 17, 10] fancy.multAll(2); // fancy sequence: [13*2, 17*2, 10*2] -> [26, 34, 20] fancy.getIndex(0); // return 26 fancy.getIndex(1); // return 34 fancy.getIndex(2); // return 20 ``` **Constraints:** `1 <= val, inc, m <= 100` `0 <= idx <= 105` At most `105` calls total will be made to `append`, `addAll`, `multAll`, and `getIndex`.",
        "test_case": [],
        "elixir_template": "defmodule Fancy do\n  @spec init_() :: any\n  def init_() do\n    \n  end\n\n  @spec append(val :: integer) :: any\n  def append(val) do\n    \n  end\n\n  @spec add_all(inc :: integer) :: any\n  def add_all(inc) do\n    \n  end\n\n  @spec mult_all(m :: integer) :: any\n  def mult_all(m) do\n    \n  end\n\n  @spec get_index(idx :: integer) :: integer\n  def get_index(idx) do\n    \n  end\nend\n\n# Your functions will be called as such:\n# Fancy.init_()\n# Fancy.append(val)\n# Fancy.add_all(inc)\n# Fancy.mult_all(m)\n# param_4 = Fancy.get_index(idx)\n\n# Fancy.init_ will be called before every test case, in which you can do some necessary initializations.",
        "erlang_template": "-spec fancy_init_() -> any().\nfancy_init_() ->\n  .\n\n-spec fancy_append(Val :: integer()) -> any().\nfancy_append(Val) ->\n  .\n\n-spec fancy_add_all(Inc :: integer()) -> any().\nfancy_add_all(Inc) ->\n  .\n\n-spec fancy_mult_all(M :: integer()) -> any().\nfancy_mult_all(M) ->\n  .\n\n-spec fancy_get_index(Idx :: integer()) -> integer().\nfancy_get_index(Idx) ->\n  .\n\n\n%% Your functions will be called as such:\n%% fancy_init_(),\n%% fancy_append(Val),\n%% fancy_add_all(Inc),\n%% fancy_mult_all(M),\n%% Param_4 = fancy_get_index(Idx),\n\n%% fancy_init_ will be called before every test case, in which you can do some necessary initializations.",
        "scala_template": "class Fancy() {\n\n    def append(`val`: Int): Unit = {\n        \n    }\n\n    def addAll(inc: Int): Unit = {\n        \n    }\n\n    def multAll(m: Int): Unit = {\n        \n    }\n\n    def getIndex(idx: Int): Int = {\n        \n    }\n\n}\n\n/**\n * Your Fancy object will be instantiated and called as such:\n * val obj = new Fancy()\n * obj.append(`val`)\n * obj.addAll(inc)\n * obj.multAll(m)\n * val param_4 = obj.getIndex(idx)\n */"
    },
    {
        "id": 1727,
        "name": "cat-and-mouse-ii",
        "difficulty": "Hard",
        "link": "https://leetcode.com/problems/cat-and-mouse-ii/",
        "task_description": "A game is played by a cat and a mouse named Cat and Mouse. The environment is represented by a `grid` of size `rows x cols`, where each element is a wall, floor, player (Cat, Mouse), or food. Players are represented by the characters `'C'`(Cat)`,'M'`(Mouse). Floors are represented by the character `'.'` and can be walked on. Walls are represented by the character `'#'` and cannot be walked on. Food is represented by the character `'F'` and can be walked on. There is only one of each character `'C'`, `'M'`, and `'F'` in `grid`. Mouse and Cat play according to the following rules: Mouse **moves first**, then they take turns to move. During each turn, Cat and Mouse can jump in one of the four directions (left, right, up, down). They cannot jump over the wall nor outside of the `grid`. `catJump, mouseJump` are the maximum lengths Cat and Mouse can jump at a time, respectively. Cat and Mouse can jump less than the maximum length. Staying in the same position is allowed. Mouse can jump over Cat. The game can end in 4 ways: If Cat occupies the same position as Mouse, Cat wins. If Cat reaches the food first, Cat wins. If Mouse reaches the food first, Mouse wins. If Mouse cannot get to the food within 1000 turns, Cat wins. Given a `rows x cols` matrix `grid` and two integers `catJump` and `mouseJump`, return `true`_ if Mouse can win the game if both Cat and Mouse play optimally, otherwise return _`false`. **Example 1:** ``` **Input:** grid = [\"####F\",\"#C...\",\"M....\"], catJump = 1, mouseJump = 2 **Output:** true **Explanation:** Cat cannot catch Mouse on its turn nor can it get the food before Mouse. ``` **Example 2:** ``` **Input:** grid = [\"M.C...F\"], catJump = 1, mouseJump = 4 **Output:** true ``` **Example 3:** ``` **Input:** grid = [\"M.C...F\"], catJump = 1, mouseJump = 3 **Output:** false ``` **Constraints:** `rows == grid.length` `cols = grid[i].length` `1 <= rows, cols <= 8` `grid[i][j]` consist only of characters `'C'`, `'M'`, `'F'`, `'.'`, and `'#'`. There is only one of each character `'C'`, `'M'`, and `'F'` in `grid`. `1 <= catJump, mouseJump <= 8`",
        "test_case": [
            {
                "label": "Example 1",
                "input": "grid = [\"####F\",\"#C...\",\"M....\"], catJump = 1, mouseJump = 2",
                "output": "true Explanation: Cat cannot catch Mouse on its turn nor can it get the food before Mouse."
            },
            {
                "label": "Example 2",
                "input": "grid = [\"M.C...F\"], catJump = 1, mouseJump = 4",
                "output": "true"
            },
            {
                "label": "Example 3",
                "input": "grid = [\"M.C...F\"], catJump = 1, mouseJump = 3",
                "output": "false Constraints: rows == grid.length cols = grid[i].length 1 <= rows, cols <= 8 grid[i][j] consist only of characters 'C' , 'M' , 'F' , '.' , and '#' . There is only one of each character 'C' , 'M' , and 'F' in grid . 1 <= catJump, mouseJump <= 8"
            }
        ],
        "elixir_template": "defmodule Solution do\n  @spec can_mouse_win(grid :: [String.t], cat_jump :: integer, mouse_jump :: integer) :: boolean\n  def can_mouse_win(grid, cat_jump, mouse_jump) do\n    \n  end\nend",
        "erlang_template": "-spec can_mouse_win(Grid :: [unicode:unicode_binary()], CatJump :: integer(), MouseJump :: integer()) -> boolean().\ncan_mouse_win(Grid, CatJump, MouseJump) ->\n  .",
        "scala_template": "object Solution {\n    def canMouseWin(grid: Array[String], catJump: Int, mouseJump: Int): Boolean = {\n        \n    }\n}"
    },
    {
        "id": 1726,
        "name": "coordinate-with-maximum-network-quality",
        "difficulty": "Medium",
        "link": "https://leetcode.com/problems/coordinate-with-maximum-network-quality/",
        "task_description": "You are given an array of network towers `towers`, where `towers[i] = [xi, yi, qi]` denotes the `ith` network tower with location `(xi, yi)` and quality factor `qi`. All the coordinates are **integral coordinates** on the X-Y plane, and the distance between the two coordinates is the **Euclidean distance**. You are also given an integer `radius` where a tower is **reachable** if the distance is **less than or equal to** `radius`. Outside that distance, the signal becomes garbled, and the tower is **not reachable**. The signal quality of the `ith` tower at a coordinate `(x, y)` is calculated with the formula `\u230aqi / (1 + d)\u230b`, where `d` is the distance between the tower and the coordinate. The **network quality** at a coordinate is the sum of the signal qualities from all the **reachable** towers. Return _the array _`[cx, cy]`_ representing the **integral** coordinate _`(cx, cy)`_ where the **network quality** is maximum. If there are multiple coordinates with the same **network quality**, return the lexicographically minimum **non-negative** coordinate._ **Note:** A coordinate `(x1, y1)` is lexicographically smaller than `(x2, y2)` if either: `x1 < x2`, or `x1 == x2` and `y1 < y2`. `\u230aval\u230b` is the greatest integer less than or equal to `val` (the floor function). **Example 1:** ``` **Input:** towers = [[1,2,5],[2,1,7],[3,1,9]], radius = 2 **Output:** [2,1] **Explanation:** At coordinate (2, 1) the total quality is 13. - Quality of 7 from (2, 1) results in \u230a7 / (1 + sqrt(0)\u230b = \u230a7\u230b = 7 - Quality of 5 from (1, 2) results in \u230a5 / (1 + sqrt(2)\u230b = \u230a2.07\u230b = 2 - Quality of 9 from (3, 1) results in \u230a9 / (1 + sqrt(1)\u230b = \u230a4.5\u230b = 4 No other coordinate has a higher network quality. ``` **Example 2:** ``` **Input:** towers = [[23,11,21]], radius = 9 **Output:** [23,11] **Explanation:** Since there is only one tower, the network quality is highest right at the tower's location. ``` **Example 3:** ``` **Input:** towers = [[1,2,13],[2,1,7],[0,1,9]], radius = 2 **Output:** [1,2] **Explanation:** Coordinate (1, 2) has the highest network quality. ``` **Constraints:** `1 <= towers.length <= 50` `towers[i].length == 3` `0 <= xi, yi, qi <= 50` `1 <= radius <= 50`",
        "test_case": [
            {
                "label": "Example 1",
                "input": "towers = [[1,2,5],[2,1,7],[3,1,9]], radius = 2",
                "output": "[2,1] Explanation: At coordinate (2, 1) the total quality is 13.\n- Quality of 7 from (2, 1) results in \u230a7 / (1 + sqrt(0)\u230b = \u230a7\u230b = 7\n- Quality of 5 from (1, 2) results in \u230a5 / (1 + sqrt(2)\u230b = \u230a2.07\u230b = 2\n- Quality of 9 from (3, 1) results in \u230a9 / (1 + sqrt(1)\u230b = \u230a4.5\u230b = 4\nNo other coordinate has a higher network quality."
            },
            {
                "label": "Example 2",
                "input": "towers = [[23,11,21]], radius = 9",
                "output": "[23,11] Explanation: Since there is only one tower, the network quality is highest right at the tower's location."
            },
            {
                "label": "Example 3",
                "input": "towers = [[1,2,13],[2,1,7],[0,1,9]], radius = 2",
                "output": "[1,2] Explanation: Coordinate (1, 2) has the highest network quality."
            }
        ],
        "elixir_template": "defmodule Solution do\n  @spec best_coordinate(towers :: [[integer]], radius :: integer) :: [integer]\n  def best_coordinate(towers, radius) do\n    \n  end\nend",
        "erlang_template": "-spec best_coordinate(Towers :: [[integer()]], Radius :: integer()) -> [integer()].\nbest_coordinate(Towers, Radius) ->\n  .",
        "scala_template": "object Solution {\n    def bestCoordinate(towers: Array[Array[Int]], radius: Int): Array[Int] = {\n        \n    }\n}"
    },
    {
        "id": 1725,
        "name": "number-of-sets-of-k-non-overlapping-line-segments",
        "difficulty": "Medium",
        "link": "https://leetcode.com/problems/number-of-sets-of-k-non-overlapping-line-segments/",
        "task_description": "Given `n` points on a 1-D plane, where the `ith` point (from `0` to `n-1`) is at `x = i`, find the number of ways we can draw **exactly** `k` **non-overlapping** line segments such that each segment covers two or more points. The endpoints of each segment must have **integral coordinates**. The `k` line segments **do not** have to cover all `n` points, and they are **allowed** to share endpoints. Return _the number of ways we can draw _`k`_ non-overlapping line segments__._ Since this number can be huge, return it **modulo** `109 + 7`. **Example 1:** ``` **Input:** n = 4, k = 2 **Output:** 5 **Explanation:** The two line segments are shown in red and blue. The image above shows the 5 different ways {(0,2),(2,3)}, {(0,1),(1,3)}, {(0,1),(2,3)}, {(1,2),(2,3)}, {(0,1),(1,2)}. ``` **Example 2:** ``` **Input:** n = 3, k = 1 **Output:** 3 **Explanation:** The 3 ways are {(0,1)}, {(0,2)}, {(1,2)}. ``` **Example 3:** ``` **Input:** n = 30, k = 7 **Output:** 796297179 **Explanation:** The total number of possible ways to draw 7 line segments is 3796297200. Taking this number modulo 109 + 7 gives us 796297179. ``` **Constraints:** `2 <= n <= 1000` `1 <= k <= n-1`",
        "test_case": [
            {
                "label": "Example 1",
                "input": "n = 4, k = 2",
                "output": "5 Explanation: The two line segments are shown in red and blue.\nThe image above shows the 5 different ways {(0,2),(2,3)}, {(0,1),(1,3)}, {(0,1),(2,3)}, {(1,2),(2,3)}, {(0,1),(1,2)}."
            },
            {
                "label": "Example 2",
                "input": "n = 3, k = 1",
                "output": "3 Explanation: The 3 ways are {(0,1)}, {(0,2)}, {(1,2)}."
            },
            {
                "label": "Example 3",
                "input": "n = 30, k = 7",
                "output": "796297179 Explanation: The total number of possible ways to draw 7 line segments is 3796297200. Taking this number modulo 10 9 + 7 gives us 796297179."
            }
        ],
        "elixir_template": "defmodule Solution do\n  @spec number_of_sets(n :: integer, k :: integer) :: integer\n  def number_of_sets(n, k) do\n    \n  end\nend",
        "erlang_template": "-spec number_of_sets(N :: integer(), K :: integer()) -> integer().\nnumber_of_sets(N, K) ->\n  .",
        "scala_template": "object Solution {\n    def numberOfSets(n: Int, k: Int): Int = {\n        \n    }\n}"
    },
    {
        "id": 1723,
        "name": "maximum-number-of-achievable-transfer-requests",
        "difficulty": "Hard",
        "link": "https://leetcode.com/problems/maximum-number-of-achievable-transfer-requests/",
        "task_description": "We have `n` buildings numbered from `0` to `n - 1`. Each building has a number of employees. It's transfer season, and some employees want to change the building they reside in. You are given an array `requests` where `requests[i] = [fromi, toi]` represents an employee's request to transfer from building `fromi` to building `toi`. **All buildings are full**, so a list of requests is achievable only if for each building, the **net change in employee transfers is zero**. This means the number of employees **leaving** is **equal** to the number of employees **moving in**. For example if `n = 3` and two employees are leaving building `0`, one is leaving building `1`, and one is leaving building `2`, there should be two employees moving to building `0`, one employee moving to building `1`, and one employee moving to building `2`. Return _the maximum number of achievable requests_. **Example 1:** ``` **Input:** n = 5, requests = [[0,1],[1,0],[0,1],[1,2],[2,0],[3,4]] **Output:** 5 **Explantion:** Let's see the requests: From building 0 we have employees x and y and both want to move to building 1. From building 1 we have employees a and b and they want to move to buildings 2 and 0 respectively. From building 2 we have employee z and they want to move to building 0. From building 3 we have employee c and they want to move to building 4. From building 4 we don't have any requests. We can achieve the requests of users x and b by swapping their places. We can achieve the requests of users y, a and z by swapping the places in the 3 buildings. ``` **Example 2:** ``` **Input:** n = 3, requests = [[0,0],[1,2],[2,1]] **Output:** 3 **Explantion:** Let's see the requests: From building 0 we have employee x and they want to stay in the same building 0. From building 1 we have employee y and they want to move to building 2. From building 2 we have employee z and they want to move to building 1. We can achieve all the requests. ``` **Example 3:** ``` **Input:** n = 4, requests = [[0,3],[3,1],[1,2],[2,0]] **Output:** 4 ``` **Constraints:** `1 <= n <= 20` `1 <= requests.length <= 16` `requests[i].length == 2` `0 <= fromi, toi < n`",
        "test_case": [
            {
                "label": "Example 1",
                "input": "n = 5, requests = [[0,1],[1,0],[0,1],[1,2],[2,0],[3,4]]",
                "output": "5 Explantion: Let's see the requests:\nFrom building 0 we have employees x and y and both want to move to building 1.\nFrom building 1 we have employees a and b and they want to move to buildings 2 and 0 respectively.\nFrom building 2 we have employee z and they want to move to building 0.\nFrom building 3 we have employee c and they want to move to building 4.\nFrom building 4 we don't have any requests.\nWe can achieve the requests of users x and b by swapping their places.\nWe can achieve the requests of users y, a and z by swapping the places in the 3 buildings."
            },
            {
                "label": "Example 2",
                "input": "n = 3, requests = [[0,0],[1,2],[2,1]]",
                "output": "3 Explantion: Let's see the requests:\nFrom building 0 we have employee x and they want to stay in the same building 0.\nFrom building 1 we have employee y and they want to move to building 2.\nFrom building 2 we have employee z and they want to move to building 1.\nWe can achieve all the requests."
            },
            {
                "label": "Example 3",
                "input": "n = 4, requests = [[0,3],[3,1],[1,2],[2,0]]",
                "output": "4"
            }
        ],
        "elixir_template": "defmodule Solution do\n  @spec maximum_requests(n :: integer, requests :: [[integer]]) :: integer\n  def maximum_requests(n, requests) do\n    \n  end\nend",
        "erlang_template": "-spec maximum_requests(N :: integer(), Requests :: [[integer()]]) -> integer().\nmaximum_requests(N, Requests) ->\n  .",
        "scala_template": "object Solution {\n    def maximumRequests(n: Int, requests: Array[Array[Int]]): Int = {\n        \n    }\n}"
    },
    {
        "id": 1722,
        "name": "throne-inheritance",
        "difficulty": "Medium",
        "link": "https://leetcode.com/problems/throne-inheritance/",
        "task_description": "A kingdom consists of a king, his children, his grandchildren, and so on. Every once in a while, someone in the family dies or a child is born. The kingdom has a well-defined order of inheritance that consists of the king as the first member. Let's define the recursive function `Successor(x, curOrder)`, which given a person `x` and the inheritance order so far, returns who should be the next person after `x` in the order of inheritance. ``` Successor(x, curOrder): if x has no children or all of x's children are in curOrder: if x is the king return null else return Successor(x's parent, curOrder) else return x's oldest child who's not in curOrder ``` For example, assume we have a kingdom that consists of the king, his children Alice and Bob (Alice is older than Bob), and finally Alice's son Jack. In the beginning, `curOrder` will be `[\"king\"]`. Calling `Successor(king, curOrder)` will return Alice, so we append to `curOrder` to get `[\"king\", \"Alice\"]`. Calling `Successor(Alice, curOrder)` will return Jack, so we append to `curOrder` to get `[\"king\", \"Alice\", \"Jack\"]`. Calling `Successor(Jack, curOrder)` will return Bob, so we append to `curOrder` to get `[\"king\", \"Alice\", \"Jack\", \"Bob\"]`. Calling `Successor(Bob, curOrder)` will return `null`. Thus the order of inheritance will be `[\"king\", \"Alice\", \"Jack\", \"Bob\"]`. Using the above function, we can always obtain a unique order of inheritance. Implement the `ThroneInheritance` class: `ThroneInheritance(string kingName)` Initializes an object of the `ThroneInheritance` class. The name of the king is given as part of the constructor. `void birth(string parentName, string childName)` Indicates that `parentName` gave birth to `childName`. `void death(string name)` Indicates the death of `name`. The death of the person doesn't affect the `Successor` function nor the current inheritance order. You can treat it as just marking the person as dead. `string[] getInheritanceOrder()` Returns a list representing the current order of inheritance **excluding** dead people. **Example 1:** ``` **Input** [\"ThroneInheritance\", \"birth\", \"birth\", \"birth\", \"birth\", \"birth\", \"birth\", \"getInheritanceOrder\", \"death\", \"getInheritanceOrder\"] [[\"king\"], [\"king\", \"andy\"], [\"king\", \"bob\"], [\"king\", \"catherine\"], [\"andy\", \"matthew\"], [\"bob\", \"alex\"], [\"bob\", \"asha\"], [null], [\"bob\"], [null]] **Output** [null, null, null, null, null, null, null, [\"king\", \"andy\", \"matthew\", \"bob\", \"alex\", \"asha\", \"catherine\"], null, [\"king\", \"andy\", \"matthew\", \"alex\", \"asha\", \"catherine\"]] **Explanation** ThroneInheritance t= new ThroneInheritance(\"king\"); // order: **king** t.birth(\"king\", \"andy\"); // order: king > **andy** t.birth(\"king\", \"bob\"); // order: king > andy > **bob** t.birth(\"king\", \"catherine\"); // order: king > andy > bob > **catherine** t.birth(\"andy\", \"matthew\"); // order: king > andy > **matthew** > bob > catherine t.birth(\"bob\", \"alex\"); // order: king > andy > matthew > bob > **alex** > catherine t.birth(\"bob\", \"asha\"); // order: king > andy > matthew > bob > alex > **asha** > catherine t.getInheritanceOrder(); // return [\"king\", \"andy\", \"matthew\", \"bob\", \"alex\", \"asha\", \"catherine\"] t.death(\"bob\"); // order: king > andy > matthew > **bob** > alex > asha > catherine t.getInheritanceOrder(); // return [\"king\", \"andy\", \"matthew\", \"alex\", \"asha\", \"catherine\"] ``` **Constraints:** `1 <= kingName.length, parentName.length, childName.length, name.length <= 15` `kingName`, `parentName`, `childName`, and `name` consist of lowercase English letters only. All arguments `childName` and `kingName` are **distinct**. All `name` arguments of `death` will be passed to either the constructor or as `childName` to `birth` first. For each call to `birth(parentName, childName)`, it is guaranteed that `parentName` is alive. At most `105` calls will be made to `birth` and `death`. At most `10` calls will be made to `getInheritanceOrder`.",
        "test_case": [],
        "elixir_template": "defmodule ThroneInheritance do\n  @spec init_(king_name :: String.t) :: any\n  def init_(king_name) do\n    \n  end\n\n  @spec birth(parent_name :: String.t, child_name :: String.t) :: any\n  def birth(parent_name, child_name) do\n    \n  end\n\n  @spec death(name :: String.t) :: any\n  def death(name) do\n    \n  end\n\n  @spec get_inheritance_order() :: [String.t]\n  def get_inheritance_order() do\n    \n  end\nend\n\n# Your functions will be called as such:\n# ThroneInheritance.init_(king_name)\n# ThroneInheritance.birth(parent_name, child_name)\n# ThroneInheritance.death(name)\n# param_3 = ThroneInheritance.get_inheritance_order()\n\n# ThroneInheritance.init_ will be called before every test case, in which you can do some necessary initializations.",
        "erlang_template": "-spec throne_inheritance_init_(KingName :: unicode:unicode_binary()) -> any().\nthrone_inheritance_init_(KingName) ->\n  .\n\n-spec throne_inheritance_birth(ParentName :: unicode:unicode_binary(), ChildName :: unicode:unicode_binary()) -> any().\nthrone_inheritance_birth(ParentName, ChildName) ->\n  .\n\n-spec throne_inheritance_death(Name :: unicode:unicode_binary()) -> any().\nthrone_inheritance_death(Name) ->\n  .\n\n-spec throne_inheritance_get_inheritance_order() -> [unicode:unicode_binary()].\nthrone_inheritance_get_inheritance_order() ->\n  .\n\n\n%% Your functions will be called as such:\n%% throne_inheritance_init_(KingName),\n%% throne_inheritance_birth(ParentName, ChildName),\n%% throne_inheritance_death(Name),\n%% Param_3 = throne_inheritance_get_inheritance_order(),\n\n%% throne_inheritance_init_ will be called before every test case, in which you can do some necessary initializations.",
        "scala_template": "class ThroneInheritance(_kingName: String) {\n\n    def birth(parentName: String, childName: String): Unit = {\n        \n    }\n\n    def death(name: String): Unit = {\n        \n    }\n\n    def getInheritanceOrder(): List[String] = {\n        \n    }\n\n}\n\n/**\n * Your ThroneInheritance object will be instantiated and called as such:\n * val obj = new ThroneInheritance(kingName)\n * obj.birth(parentName,childName)\n * obj.death(name)\n * val param_3 = obj.getInheritanceOrder()\n */"
    },
    {
        "id": 1721,
        "name": "maximum-profit-of-operating-a-centennial-wheel",
        "difficulty": "Medium",
        "link": "https://leetcode.com/problems/maximum-profit-of-operating-a-centennial-wheel/",
        "task_description": "You are the operator of a Centennial Wheel that has **four gondolas**, and each gondola has room for **up** **to** **four people**. You have the ability to rotate the gondolas **counterclockwise**, which costs you `runningCost` dollars. You are given an array `customers` of length `n` where `customers[i]` is the number of new customers arriving just before the `ith` rotation (0-indexed). This means you **must rotate the wheel **`i`** times before the **`customers[i]`** customers arrive**. **You cannot make customers wait if there is room in the gondola**. Each customer pays `boardingCost` dollars when they board on the gondola closest to the ground and will exit once that gondola reaches the ground again. You can stop the wheel at any time, including **before** **serving** **all** **customers**. If you decide to stop serving customers, **all subsequent rotations are free** in order to get all the customers down safely. Note that if there are currently more than four customers waiting at the wheel, only four will board the gondola, and the rest will wait **for the next rotation**. Return_ the minimum number of rotations you need to perform to maximize your profit._ If there is **no scenario** where the profit is positive, return `-1`. **Example 1:** ``` **Input:** customers = [8,3], boardingCost = 5, runningCost = 6 **Output:** 3 **Explanation:** The numbers written on the gondolas are the number of people currently there. 1. 8 customers arrive, 4 board and 4 wait for the next gondola, the wheel rotates. Current profit is 4 * $5 - 1 * $6 = $14. 2. 3 customers arrive, the 4 waiting board the wheel and the other 3 wait, the wheel rotates. Current profit is 8 * $5 - 2 * $6 = $28. 3. The final 3 customers board the gondola, the wheel rotates. Current profit is 11 * $5 - 3 * $6 = $37. The highest profit was $37 after rotating the wheel 3 times. ``` **Example 2:** ``` **Input:** customers = [10,9,6], boardingCost = 6, runningCost = 4 **Output:** 7 **Explanation:** 1. 10 customers arrive, 4 board and 6 wait for the next gondola, the wheel rotates. Current profit is 4 * $6 - 1 * $4 = $20. 2. 9 customers arrive, 4 board and 11 wait (2 originally waiting, 9 newly waiting), the wheel rotates. Current profit is 8 * $6 - 2 * $4 = $40. 3. The final 6 customers arrive, 4 board and 13 wait, the wheel rotates. Current profit is 12 * $6 - 3 * $4 = $60. 4. 4 board and 9 wait, the wheel rotates. Current profit is 16 * $6 - 4 * $4 = $80. 5. 4 board and 5 wait, the wheel rotates. Current profit is 20 * $6 - 5 * $4 = $100. 6. 4 board and 1 waits, the wheel rotates. Current profit is 24 * $6 - 6 * $4 = $120. 7. 1 boards, the wheel rotates. Current profit is 25 * $6 - 7 * $4 = $122. The highest profit was $122 after rotating the wheel 7 times. ``` **Example 3:** ``` **Input:** customers = [3,4,0,5,1], boardingCost = 1, runningCost = 92 **Output:** -1 **Explanation:** 1. 3 customers arrive, 3 board and 0 wait, the wheel rotates. Current profit is 3 * $1 - 1 * $92 = -$89. 2. 4 customers arrive, 4 board and 0 wait, the wheel rotates. Current profit is 7 * $1 - 2 * $92 = -$177. 3. 0 customers arrive, 0 board and 0 wait, the wheel rotates. Current profit is 7 * $1 - 3 * $92 = -$269. 4. 5 customers arrive, 4 board and 1 waits, the wheel rotates. Current profit is 11 * $1 - 4 * $92 = -$357. 5. 1 customer arrives, 2 board and 0 wait, the wheel rotates. Current profit is 13 * $1 - 5 * $92 = -$447. The profit was never positive, so return -1. ``` **Constraints:** `n == customers.length` `1 <= n <= 105` `0 <= customers[i] <= 50` `1 <= boardingCost, runningCost <= 100`",
        "test_case": [
            {
                "label": "Example 1",
                "input": "customers = [8,3], boardingCost = 5, runningCost = 6",
                "output": "3 Explanation: The numbers written on the gondolas are the number of people currently there.\n1. 8 customers arrive, 4 board and 4 wait for the next gondola, the wheel rotates. Current profit is 4 * $5 - 1 * $6 = $14.\n2. 3 customers arrive, the 4 waiting board the wheel and the other 3 wait, the wheel rotates. Current profit is 8 * $5 - 2 * $6 = $28.\n3. The final 3 customers board the gondola, the wheel rotates. Current profit is 11 * $5 - 3 * $6 = $37.\nThe highest profit was $37 after rotating the wheel 3 times."
            },
            {
                "label": "Example 2",
                "input": "customers = [10,9,6], boardingCost = 6, runningCost = 4",
                "output": "7 Explanation: 1. 10 customers arrive, 4 board and 6 wait for the next gondola, the wheel rotates. Current profit is 4 * $6 - 1 * $4 = $20.\n2. 9 customers arrive, 4 board and 11 wait (2 originally waiting, 9 newly waiting), the wheel rotates. Current profit is 8 * $6 - 2 * $4 = $40.\n3. The final 6 customers arrive, 4 board and 13 wait, the wheel rotates. Current profit is 12 * $6 - 3 * $4 = $60.\n4. 4 board and 9 wait, the wheel rotates. Current profit is 16 * $6 - 4 * $4 = $80.\n5. 4 board and 5 wait, the wheel rotates. Current profit is 20 * $6 - 5 * $4 = $100.\n6. 4 board and 1 waits, the wheel rotates. Current profit is 24 * $6 - 6 * $4 = $120.\n7. 1 boards, the wheel rotates. Current profit is 25 * $6 - 7 * $4 = $122.\nThe highest profit was $122 after rotating the wheel 7 times."
            },
            {
                "label": "Example 3",
                "input": "customers = [3,4,0,5,1], boardingCost = 1, runningCost = 92",
                "output": "-1 Explanation: 1. 3 customers arrive, 3 board and 0 wait, the wheel rotates. Current profit is 3 * $1 - 1 * $92 = -$89.\n2. 4 customers arrive, 4 board and 0 wait, the wheel rotates. Current profit is 7 * $1 - 2 * $92 = -$177.\n3. 0 customers arrive, 0 board and 0 wait, the wheel rotates. Current profit is 7 * $1 - 3 * $92 = -$269.\n4. 5 customers arrive, 4 board and 1 waits, the wheel rotates. Current profit is 11 * $1 - 4 * $92 = -$357.\n5. 1 customer arrives, 2 board and 0 wait, the wheel rotates. Current profit is 13 * $1 - 5 * $92 = -$447.\nThe profit was never positive, so return -1. Constraints: n == customers.length 1 <= n <= 10 5 0 <= customers[i] <= 50 1 <= boardingCost, runningCost <= 100"
            }
        ],
        "elixir_template": "defmodule Solution do\n  @spec min_operations_max_profit(customers :: [integer], boarding_cost :: integer, running_cost :: integer) :: integer\n  def min_operations_max_profit(customers, boarding_cost, running_cost) do\n    \n  end\nend",
        "erlang_template": "-spec min_operations_max_profit(Customers :: [integer()], BoardingCost :: integer(), RunningCost :: integer()) -> integer().\nmin_operations_max_profit(Customers, BoardingCost, RunningCost) ->\n  .",
        "scala_template": "object Solution {\n    def minOperationsMaxProfit(customers: Array[Int], boardingCost: Int, runningCost: Int): Int = {\n        \n    }\n}"
    },
    {
        "id": 1720,
        "name": "crawler-log-folder",
        "difficulty": "Easy",
        "link": "https://leetcode.com/problems/crawler-log-folder/",
        "task_description": "The Leetcode file system keeps a log each time some user performs a _change folder_ operation. The operations are described below: `\"../\"` : Move to the parent folder of the current folder. (If you are already in the main folder, **remain in the same folder**). `\"./\"` : Remain in the same folder. `\"x/\"` : Move to the child folder named `x` (This folder is **guaranteed to always exist**). You are given a list of strings `logs` where `logs[i]` is the operation performed by the user at the `ith` step. The file system starts in the main folder, then the operations in `logs` are performed. Return _the minimum number of operations needed to go back to the main folder after the change folder operations._ **Example 1:** ``` **Input:** logs = [\"d1/\",\"d2/\",\"../\",\"d21/\",\"./\"] **Output:** 2 **Explanation: **Use this change folder operation \"../\" 2 times and go back to the main folder. ``` **Example 2:** ``` **Input:** logs = [\"d1/\",\"d2/\",\"./\",\"d3/\",\"../\",\"d31/\"] **Output:** 3 ``` **Example 3:** ``` **Input:** logs = [\"d1/\",\"../\",\"../\",\"../\"] **Output:** 0 ``` **Constraints:** `1 <= logs.length <= 103` `2 <= logs[i].length <= 10` `logs[i]` contains lowercase English letters, digits, `'.'`, and `'/'`. `logs[i]` follows the format described in the statement. Folder names consist of lowercase English letters and digits.",
        "test_case": [
            {
                "label": "Example 1",
                "input": "logs = [\"d1/\",\"d2/\",\"../\",\"d21/\",\"./\"]",
                "output": "2 Explanation: Use this change folder operation \"../\" 2 times and go back to the main folder."
            },
            {
                "label": "Example 2",
                "input": "logs = [\"d1/\",\"d2/\",\"./\",\"d3/\",\"../\",\"d31/\"]",
                "output": "3"
            },
            {
                "label": "Example 3",
                "input": "logs = [\"d1/\",\"../\",\"../\",\"../\"]",
                "output": "0"
            }
        ],
        "elixir_template": "defmodule Solution do\n  @spec min_operations(logs :: [String.t]) :: integer\n  def min_operations(logs) do\n    \n  end\nend",
        "erlang_template": "-spec min_operations(Logs :: [unicode:unicode_binary()]) -> integer().\nmin_operations(Logs) ->\n  .",
        "scala_template": "object Solution {\n    def minOperations(logs: Array[String]): Int = {\n        \n    }\n}"
    },
    {
        "id": 1717,
        "name": "minimum-cost-to-connect-two-groups-of-points",
        "difficulty": "Hard",
        "link": "https://leetcode.com/problems/minimum-cost-to-connect-two-groups-of-points/",
        "task_description": "You are given two groups of points where the first group has `size1` points, the second group has `size2` points, and `size1 >= size2`. The `cost` of the connection between any two points are given in an `size1 x size2` matrix where `cost[i][j]` is the cost of connecting point `i` of the first group and point `j` of the second group. The groups are connected if **each point in both groups is connected to one or more points in the opposite group**. In other words, each point in the first group must be connected to at least one point in the second group, and each point in the second group must be connected to at least one point in the first group. Return _the minimum cost it takes to connect the two groups_. **Example 1:** ``` **Input:** cost = [[15, 96], [36, 2]] **Output:** 17 **Explanation**: The optimal way of connecting the groups is: 1--A 2--B This results in a total cost of 17. ``` **Example 2:** ``` **Input:** cost = [[1, 3, 5], [4, 1, 1], [1, 5, 3]] **Output:** 4 **Explanation**: The optimal way of connecting the groups is: 1--A 2--B 2--C 3--A This results in a total cost of 4. Note that there are multiple points connected to point 2 in the first group and point A in the second group. This does not matter as there is no limit to the number of points that can be connected. We only care about the minimum total cost. ``` **Example 3:** ``` **Input:** cost = [[2, 5, 1], [3, 4, 7], [8, 1, 2], [6, 2, 4], [3, 8, 8]] **Output:** 10 ``` **Constraints:** `size1 == cost.length` `size2 == cost[i].length` `1 <= size1, size2 <= 12` `size1 >= size2` `0 <= cost[i][j] <= 100`",
        "test_case": [
            {
                "label": "Example 1",
                "input": "cost = [[15, 96], [36, 2]]",
                "output": "17 Explanation : The optimal way of connecting the groups is:\n1--A\n2--B\nThis results in a total cost of 17."
            },
            {
                "label": "Example 2",
                "input": "cost = [[1, 3, 5], [4, 1, 1], [1, 5, 3]]",
                "output": "4 Explanation : The optimal way of connecting the groups is:\n1--A\n2--B\n2--C\n3--A\nThis results in a total cost of 4.\nNote that there are multiple points connected to point 2 in the first group and point A in the second group. This does not matter as there is no limit to the number of points that can be connected. We only care about the minimum total cost."
            },
            {
                "label": "Example 3",
                "input": "cost = [[2, 5, 1], [3, 4, 7], [8, 1, 2], [6, 2, 4], [3, 8, 8]]",
                "output": "10 Constraints: size 1 == cost.length size 2 == cost[i].length 1 <= size 1 , size 2 <= 12 size 1 >= size 2 0 <= cost[i][j] <= 100"
            }
        ],
        "elixir_template": "defmodule Solution do\n  @spec connect_two_groups(cost :: [[integer]]) :: integer\n  def connect_two_groups(cost) do\n    \n  end\nend",
        "erlang_template": "-spec connect_two_groups(Cost :: [[integer()]]) -> integer().\nconnect_two_groups(Cost) ->\n  .",
        "scala_template": "object Solution {\n    def connectTwoGroups(cost: List[List[Int]]): Int = {\n        \n    }\n}"
    },
    {
        "id": 1716,
        "name": "maximum-non-negative-product-in-a-matrix",
        "difficulty": "Medium",
        "link": "https://leetcode.com/problems/maximum-non-negative-product-in-a-matrix/",
        "task_description": "You are given a `m x n` matrix `grid`. Initially, you are located at the top-left corner `(0, 0)`, and in each step, you can only **move right or down** in the matrix. Among all possible paths starting from the top-left corner `(0, 0)` and ending in the bottom-right corner `(m - 1, n - 1)`, find the path with the **maximum non-negative product**. The product of a path is the product of all integers in the grid cells visited along the path. Return the _maximum non-negative product **modulo** _`109 + 7`. _If the maximum product is **negative**, return _`-1`. Notice that the modulo is performed after getting the maximum product. **Example 1:** ``` **Input:** grid = [[-1,-2,-3],[-2,-3,-3],[-3,-3,-2]] **Output:** -1 **Explanation:** It is not possible to get non-negative product in the path from (0, 0) to (2, 2), so return -1. ``` **Example 2:** ``` **Input:** grid = [[1,-2,1],[1,-2,1],[3,-4,1]] **Output:** 8 **Explanation:** Maximum non-negative product is shown (1 * 1 * -2 * -4 * 1 = 8). ``` **Example 3:** ``` **Input:** grid = [[1,3],[0,-4]] **Output:** 0 **Explanation:** Maximum non-negative product is shown (1 * 0 * -4 = 0). ``` **Constraints:** `m == grid.length` `n == grid[i].length` `1 <= m, n <= 15` `-4 <= grid[i][j] <= 4`",
        "test_case": [
            {
                "label": "Example 1",
                "input": "grid = [[-1,-2,-3],[-2,-3,-3],[-3,-3,-2]]",
                "output": "-1 Explanation: It is not possible to get non-negative product in the path from (0, 0) to (2, 2), so return -1."
            },
            {
                "label": "Example 2",
                "input": "grid = [[1,-2,1],[1,-2,1],[3,-4,1]]",
                "output": "8 Explanation: Maximum non-negative product is shown (1 * 1 * -2 * -4 * 1 = 8)."
            },
            {
                "label": "Example 3",
                "input": "grid = [[1,3],[0,-4]]",
                "output": "0 Explanation: Maximum non-negative product is shown (1 * 0 * -4 = 0). Constraints: m == grid.length n == grid[i].length 1 <= m, n <= 15 -4 <= grid[i][j] <= 4"
            }
        ],
        "elixir_template": "defmodule Solution do\n  @spec max_product_path(grid :: [[integer]]) :: integer\n  def max_product_path(grid) do\n    \n  end\nend",
        "erlang_template": "-spec max_product_path(Grid :: [[integer()]]) -> integer().\nmax_product_path(Grid) ->\n  .",
        "scala_template": "object Solution {\n    def maxProductPath(grid: Array[Array[Int]]): Int = {\n        \n    }\n}"
    },
    {
        "id": 1715,
        "name": "split-a-string-into-the-max-number-of-unique-substrings",
        "difficulty": "Medium",
        "link": "https://leetcode.com/problems/split-a-string-into-the-max-number-of-unique-substrings/",
        "task_description": "Given a string `s`, return _the maximum number of unique substrings that the given string can be split into_. You can split string `s` into any list of **non-empty substrings**, where the concatenation of the substrings forms the original string. However, you must split the substrings such that all of them are **unique**. A **substring** is a contiguous sequence of characters within a string. **Example 1:** ``` **Input:** s = \"ababccc\" **Output:** 5 **Explanation**: One way to split maximally is ['a', 'b', 'ab', 'c', 'cc']. Splitting like ['a', 'b', 'a', 'b', 'c', 'cc'] is not valid as you have 'a' and 'b' multiple times. ``` **Example 2:** ``` **Input:** s = \"aba\" **Output:** 2 **Explanation**: One way to split maximally is ['a', 'ba']. ``` **Example 3:** ``` **Input:** s = \"aa\" **Output:** 1 **Explanation**: It is impossible to split the string any further. ``` **Constraints:** `1 <= s.length <= 16` `s` contains only lower case English letters.",
        "test_case": [
            {
                "label": "Example 1",
                "input": "s = \"ababccc\"",
                "output": "5 Explanation : One way to split maximally is ['a', 'b', 'ab', 'c', 'cc']. Splitting like ['a', 'b', 'a', 'b', 'c', 'cc'] is not valid as you have 'a' and 'b' multiple times."
            },
            {
                "label": "Example 2",
                "input": "s = \"aba\"",
                "output": "2 Explanation : One way to split maximally is ['a', 'ba']."
            },
            {
                "label": "Example 3",
                "input": "s = \"aa\"",
                "output": "1 Explanation : It is impossible to split the string any further."
            }
        ],
        "elixir_template": "defmodule Solution do\n  @spec max_unique_split(s :: String.t) :: integer\n  def max_unique_split(s) do\n    \n  end\nend",
        "erlang_template": "-spec max_unique_split(S :: unicode:unicode_binary()) -> integer().\nmax_unique_split(S) ->\n  .",
        "scala_template": "object Solution {\n    def maxUniqueSplit(s: String): Int = {\n        \n    }\n}"
    },
    {
        "id": 1714,
        "name": "rearrange-spaces-between-words",
        "difficulty": "Easy",
        "link": "https://leetcode.com/problems/rearrange-spaces-between-words/",
        "task_description": "You are given a string `text` of words that are placed among some number of spaces. Each word consists of one or more lowercase English letters and are separated by at least one space. It's guaranteed that `text` **contains at least one word**. Rearrange the spaces so that there is an **equal** number of spaces between every pair of adjacent words and that number is **maximized**. If you cannot redistribute all the spaces equally, place the **extra spaces at the end**, meaning the returned string should be the same length as `text`. Return _the string after rearranging the spaces_. **Example 1:** ``` **Input:** text = \" this is a sentence \" **Output:** \"this is a sentence\" **Explanation:** There are a total of 9 spaces and 4 words. We can evenly divide the 9 spaces between the words: 9 / (4-1) = 3 spaces. ``` **Example 2:** ``` **Input:** text = \" practice makes perfect\" **Output:** \"practice makes perfect \" **Explanation:** There are a total of 7 spaces and 3 words. 7 / (3-1) = 3 spaces plus 1 extra space. We place this extra space at the end of the string. ``` **Constraints:** `1 <= text.length <= 100` `text` consists of lowercase English letters and `' '`. `text` contains at least one word.",
        "test_case": [
            {
                "label": "Example 1",
                "input": "text = \"  this   is  a sentence \"",
                "output": "\"this   is   a   sentence\" Explanation: There are a total of 9 spaces and 4 words. We can evenly divide the 9 spaces between the words: 9 / (4-1) = 3 spaces."
            },
            {
                "label": "Example 2",
                "input": "text = \" practice   makes   perfect\"",
                "output": "\"practice   makes   perfect \" Explanation: There are a total of 7 spaces and 3 words. 7 / (3-1) = 3 spaces plus 1 extra space. We place this extra space at the end of the string."
            }
        ],
        "elixir_template": "defmodule Solution do\n  @spec reorder_spaces(text :: String.t) :: String.t\n  def reorder_spaces(text) do\n    \n  end\nend",
        "erlang_template": "-spec reorder_spaces(Text :: unicode:unicode_binary()) -> unicode:unicode_binary().\nreorder_spaces(Text) ->\n  .",
        "scala_template": "object Solution {\n    def reorderSpaces(text: String): String = {\n        \n    }\n}"
    },
    {
        "id": 1711,
        "name": "find-valid-matrix-given-row-and-column-sums",
        "difficulty": "Medium",
        "link": "https://leetcode.com/problems/find-valid-matrix-given-row-and-column-sums/",
        "task_description": "You are given two arrays `rowSum` and `colSum` of non-negative integers where `rowSum[i]` is the sum of the elements in the `ith` row and `colSum[j]` is the sum of the elements of the `jth` column of a 2D matrix. In other words, you do not know the elements of the matrix, but you do know the sums of each row and column. Find any matrix of **non-negative** integers of size `rowSum.length x colSum.length` that satisfies the `rowSum` and `colSum` requirements. Return _a 2D array representing **any** matrix that fulfills the requirements_. It's guaranteed that **at least one **matrix that fulfills the requirements exists. **Example 1:** ``` **Input:** rowSum = [3,8], colSum = [4,7] **Output:** [[3,0], [1,7]] **Explanation:** 0th row: 3 + 0 = 3 == rowSum[0] 1st row: 1 + 7 = 8 == rowSum[1] 0th column: 3 + 1 = 4 == colSum[0] 1st column: 0 + 7 = 7 == colSum[1] The row and column sums match, and all matrix elements are non-negative. Another possible matrix is: [[1,2], [3,5]] ``` **Example 2:** ``` **Input:** rowSum = [5,7,10], colSum = [8,6,8] **Output:** [[0,5,0], [6,1,0], [2,0,8]] ``` **Constraints:** `1 <= rowSum.length, colSum.length <= 500` `0 <= rowSum[i], colSum[i] <= 108` `sum(rowSum) == sum(colSum)`",
        "test_case": [
            {
                "label": "Example 1",
                "input": "rowSum = [3,8], colSum = [4,7]",
                "output": "[[3,0],\n         [1,7]] Explanation: 0 th row: 3 + 0 = 3 == rowSum[0]\n1 st row: 1 + 7 = 8 == rowSum[1]\n0 th column: 3 + 1 = 4 == colSum[0]\n1 st column: 0 + 7 = 7 == colSum[1]\nThe row and column sums match, and all matrix elements are non-negative.\nAnother possible matrix is: [[1,2],\n                             [3,5]]"
            },
            {
                "label": "Example 2",
                "input": "rowSum = [5,7,10], colSum = [8,6,8]",
                "output": "[[0,5,0],\n         [6,1,0],\n         [2,0,8]]"
            }
        ],
        "elixir_template": "defmodule Solution do\n  @spec restore_matrix(row_sum :: [integer], col_sum :: [integer]) :: [[integer]]\n  def restore_matrix(row_sum, col_sum) do\n    \n  end\nend",
        "erlang_template": "-spec restore_matrix(RowSum :: [integer()], ColSum :: [integer()]) -> [[integer()]].\nrestore_matrix(RowSum, ColSum) ->\n  .",
        "scala_template": "object Solution {\n    def restoreMatrix(rowSum: Array[Int], colSum: Array[Int]): Array[Array[Int]] = {\n        \n    }\n}"
    },
    {
        "id": 1710,
        "name": "find-servers-that-handled-most-number-of-requests",
        "difficulty": "Hard",
        "link": "https://leetcode.com/problems/find-servers-that-handled-most-number-of-requests/",
        "task_description": "You have `k` servers numbered from `0` to `k-1` that are being used to handle multiple requests simultaneously. Each server has infinite computational capacity but **cannot handle more than one request at a time**. The requests are assigned to servers according to a specific algorithm: The `ith` (0-indexed) request arrives. If all servers are busy, the request is dropped (not handled at all). If the `(i % k)th` server is available, assign the request to that server. Otherwise, assign the request to the next available server (wrapping around the list of servers and starting from 0 if necessary). For example, if the `ith` server is busy, try to assign the request to the `(i+1)th` server, then the `(i+2)th` server, and so on. You are given a **strictly increasing** array `arrival` of positive integers, where `arrival[i]` represents the arrival time of the `ith` request, and another array `load`, where `load[i]` represents the load of the `ith` request (the time it takes to complete). Your goal is to find the **busiest server(s)**. A server is considered **busiest** if it handled the most number of requests successfully among all the servers. Return _a list containing the IDs (0-indexed) of the **busiest server(s)**_. You may return the IDs in any order. **Example 1:** ``` **Input:** k = 3, arrival = [1,2,3,4,5], load = [5,2,3,3,3] **Output:** [1] **Explanation:** All of the servers start out available. The first 3 requests are handled by the first 3 servers in order. Request 3 comes in. Server 0 is busy, so it's assigned to the next available server, which is 1. Request 4 comes in. It cannot be handled since all servers are busy, so it is dropped. Servers 0 and 2 handled one request each, while server 1 handled two requests. Hence server 1 is the busiest server. ``` **Example 2:** ``` **Input:** k = 3, arrival = [1,2,3,4], load = [1,2,1,2] **Output:** [0] **Explanation:** The first 3 requests are handled by first 3 servers. Request 3 comes in. It is handled by server 0 since the server is available. Server 0 handled two requests, while servers 1 and 2 handled one request each. Hence server 0 is the busiest server. ``` **Example 3:** ``` **Input:** k = 3, arrival = [1,2,3], load = [10,12,11] **Output:** [0,1,2] **Explanation:** Each server handles a single request, so they are all considered the busiest. ``` **Constraints:** `1 <= k <= 105` `1 <= arrival.length, load.length <= 105` `arrival.length == load.length` `1 <= arrival[i], load[i] <= 109` `arrival` is **strictly increasing**.",
        "test_case": [
            {
                "label": "Example 1",
                "input": "k = 3, arrival = [1,2,3,4,5], load = [5,2,3,3,3]",
                "output": "[1] Explanation: All of the servers start out available.\nThe first 3 requests are handled by the first 3 servers in order.\nRequest 3 comes in. Server 0 is busy, so it's assigned to the next available server, which is 1.\nRequest 4 comes in. It cannot be handled since all servers are busy, so it is dropped.\nServers 0 and 2 handled one request each, while server 1 handled two requests. Hence server 1 is the busiest server."
            },
            {
                "label": "Example 2",
                "input": "k = 3, arrival = [1,2,3,4], load = [1,2,1,2]",
                "output": "[0] Explanation: The first 3 requests are handled by first 3 servers.\nRequest 3 comes in. It is handled by server 0 since the server is available.\nServer 0 handled two requests, while servers 1 and 2 handled one request each. Hence server 0 is the busiest server."
            },
            {
                "label": "Example 3",
                "input": "k = 3, arrival = [1,2,3], load = [10,12,11]",
                "output": "[0,1,2] Explanation: Each server handles a single request, so they are all considered the busiest."
            }
        ],
        "elixir_template": "defmodule Solution do\n  @spec busiest_servers(k :: integer, arrival :: [integer], load :: [integer]) :: [integer]\n  def busiest_servers(k, arrival, load) do\n    \n  end\nend",
        "erlang_template": "-spec busiest_servers(K :: integer(), Arrival :: [integer()], Load :: [integer()]) -> [integer()].\nbusiest_servers(K, Arrival, Load) ->\n  .",
        "scala_template": "object Solution {\n    def busiestServers(k: Int, arrival: Array[Int], load: Array[Int]): List[Int] = {\n        \n    }\n}"
    },
    {
        "id": 1709,
        "name": "alert-using-same-key-card-three-or-more-times-in-a-one-hour-period",
        "difficulty": "Medium",
        "link": "https://leetcode.com/problems/alert-using-same-key-card-three-or-more-times-in-a-one-hour-period/",
        "task_description": "LeetCode company workers use key-cards to unlock office doors. Each time a worker uses their key-card, the security system saves the worker's name and the time when it was used. The system emits an **alert** if any worker uses the key-card **three or more times** in a one-hour period. You are given a list of strings `keyName` and `keyTime` where `[keyName[i], keyTime[i]]` corresponds to a person's name and the time when their key-card was used **in a** **single day**. Access times are given in the **24-hour time format \"HH:MM\"**, such as `\"23:51\"` and `\"09:49\"`. Return a _list of unique worker names who received an alert for frequent keycard use_. Sort the names in **ascending order alphabetically**. Notice that `\"10:00\"` - `\"11:00\"` is considered to be within a one-hour period, while `\"22:51\"` - `\"23:52\"` is not considered to be within a one-hour period. **Example 1:** ``` **Input:** keyName = [\"daniel\",\"daniel\",\"daniel\",\"luis\",\"luis\",\"luis\",\"luis\"], keyTime = [\"10:00\",\"10:40\",\"11:00\",\"09:00\",\"11:00\",\"13:00\",\"15:00\"] **Output:** [\"daniel\"] **Explanation:** \"daniel\" used the keycard 3 times in a one-hour period (\"10:00\",\"10:40\", \"11:00\"). ``` **Example 2:** ``` **Input:** keyName = [\"alice\",\"alice\",\"alice\",\"bob\",\"bob\",\"bob\",\"bob\"], keyTime = [\"12:01\",\"12:00\",\"18:00\",\"21:00\",\"21:20\",\"21:30\",\"23:00\"] **Output:** [\"bob\"] **Explanation:** \"bob\" used the keycard 3 times in a one-hour period (\"21:00\",\"21:20\", \"21:30\"). ``` **Constraints:** `1 <= keyName.length, keyTime.length <= 105` `keyName.length == keyTime.length` `keyTime[i]` is in the format **\"HH:MM\"**. `[keyName[i], keyTime[i]]` is **unique**. `1 <= keyName[i].length <= 10` `keyName[i] contains only lowercase English letters.`",
        "test_case": [
            {
                "label": "Example 1",
                "input": "keyName = [\"daniel\",\"daniel\",\"daniel\",\"luis\",\"luis\",\"luis\",\"luis\"], keyTime = [\"10:00\",\"10:40\",\"11:00\",\"09:00\",\"11:00\",\"13:00\",\"15:00\"]",
                "output": "[\"daniel\"] Explanation: \"daniel\" used the keycard 3 times in a one-hour period (\"10:00\",\"10:40\", \"11:00\")."
            },
            {
                "label": "Example 2",
                "input": "keyName = [\"alice\",\"alice\",\"alice\",\"bob\",\"bob\",\"bob\",\"bob\"], keyTime = [\"12:01\",\"12:00\",\"18:00\",\"21:00\",\"21:20\",\"21:30\",\"23:00\"]",
                "output": "[\"bob\"] Explanation: \"bob\" used the keycard 3 times in a one-hour period (\"21:00\",\"21:20\", \"21:30\")."
            }
        ],
        "elixir_template": "defmodule Solution do\n  @spec alert_names(key_name :: [String.t], key_time :: [String.t]) :: [String.t]\n  def alert_names(key_name, key_time) do\n    \n  end\nend",
        "erlang_template": "-spec alert_names(KeyName :: [unicode:unicode_binary()], KeyTime :: [unicode:unicode_binary()]) -> [unicode:unicode_binary()].\nalert_names(KeyName, KeyTime) ->\n  .",
        "scala_template": "object Solution {\n    def alertNames(keyName: Array[String], keyTime: Array[String]): List[String] = {\n        \n    }\n}"
    },
    {
        "id": 1708,
        "name": "design-parking-system",
        "difficulty": "Easy",
        "link": "https://leetcode.com/problems/design-parking-system/",
        "task_description": "Design a parking system for a parking lot. The parking lot has three kinds of parking spaces: big, medium, and small, with a fixed number of slots for each size. Implement the `ParkingSystem` class: `ParkingSystem(int big, int medium, int small)` Initializes object of the `ParkingSystem` class. The number of slots for each parking space are given as part of the constructor. `bool addCar(int carType)` Checks whether there is a parking space of `carType` for the car that wants to get into the parking lot. `carType` can be of three kinds: big, medium, or small, which are represented by `1`, `2`, and `3` respectively. **A car can only park in a parking space of its **`carType`. If there is no space available, return `false`, else park the car in that size space and return `true`. **Example 1:** ``` **Input** [\"ParkingSystem\", \"addCar\", \"addCar\", \"addCar\", \"addCar\"] [[1, 1, 0], [1], [2], [3], [1]] **Output** [null, true, true, false, false] **Explanation** ParkingSystem parkingSystem = new ParkingSystem(1, 1, 0); parkingSystem.addCar(1); // return true because there is 1 available slot for a big car parkingSystem.addCar(2); // return true because there is 1 available slot for a medium car parkingSystem.addCar(3); // return false because there is no available slot for a small car parkingSystem.addCar(1); // return false because there is no available slot for a big car. It is already occupied. ``` **Constraints:** `0 <= big, medium, small <= 1000` `carType` is `1`, `2`, or `3` At most `1000` calls will be made to `addCar`",
        "test_case": [],
        "elixir_template": "defmodule ParkingSystem do\n  @spec init_(big :: integer, medium :: integer, small :: integer) :: any\n  def init_(big, medium, small) do\n    \n  end\n\n  @spec add_car(car_type :: integer) :: boolean\n  def add_car(car_type) do\n    \n  end\nend\n\n# Your functions will be called as such:\n# ParkingSystem.init_(big, medium, small)\n# param_1 = ParkingSystem.add_car(car_type)\n\n# ParkingSystem.init_ will be called before every test case, in which you can do some necessary initializations.",
        "erlang_template": "-spec parking_system_init_(Big :: integer(), Medium :: integer(), Small :: integer()) -> any().\nparking_system_init_(Big, Medium, Small) ->\n  .\n\n-spec parking_system_add_car(CarType :: integer()) -> boolean().\nparking_system_add_car(CarType) ->\n  .\n\n\n%% Your functions will be called as such:\n%% parking_system_init_(Big, Medium, Small),\n%% Param_1 = parking_system_add_car(CarType),\n\n%% parking_system_init_ will be called before every test case, in which you can do some necessary initializations.",
        "scala_template": "class ParkingSystem(_big: Int, _medium: Int, _small: Int) {\n\n    def addCar(carType: Int): Boolean = {\n        \n    }\n\n}\n\n/**\n * Your ParkingSystem object will be instantiated and called as such:\n * val obj = new ParkingSystem(big, medium, small)\n * val param_1 = obj.addCar(carType)\n */"
    },
    {
        "id": 1707,
        "name": "check-if-string-is-transformable-with-substring-sort-operations",
        "difficulty": "Hard",
        "link": "https://leetcode.com/problems/check-if-string-is-transformable-with-substring-sort-operations/",
        "task_description": "Given two strings `s` and `t`, transform string `s` into string `t` using the following operation any number of times: Choose a **non-empty** substring in `s` and sort it in place so the characters are in **ascending order**. For example, applying the operation on the underlined substring in `\"14234\"` results in `\"12344\"`. Return `true` if _it is possible to transform `s` into `t`_. Otherwise, return `false`. A **substring** is a contiguous sequence of characters within a string. **Example 1:** ``` **Input:** s = \"84532\", t = \"34852\" **Output:** true **Explanation:** You can transform s into t using the following sort operations: \"84532\" (from index 2 to 3) -> \"84352\" \"84352\" (from index 0 to 2) -> \"34852\" ``` **Example 2:** ``` **Input:** s = \"34521\", t = \"23415\" **Output:** true **Explanation:** You can transform s into t using the following sort operations: \"34521\" -> \"23451\" \"23451\" -> \"23415\" ``` **Example 3:** ``` **Input:** s = \"12345\", t = \"12435\" **Output:** false ``` **Constraints:** `s.length == t.length` `1 <= s.length <= 105` `s` and `t` consist of only digits.",
        "test_case": [
            {
                "label": "Example 1",
                "input": "s = \"84532\", t = \"34852\"",
                "output": "true Explanation: You can transform s into t using the following sort operations:\n\"84 53 2\" (from index 2 to 3) -> \"84 35 2\"\n\" 843 52\" (from index 0 to 2) -> \" 348 52\""
            },
            {
                "label": "Example 2",
                "input": "s = \"34521\", t = \"23415\"",
                "output": "true Explanation: You can transform s into t using the following sort operations:\n\" 3452 1\" -> \" 2345 1\"\n\"234 51 \" -> \"234 15 \""
            },
            {
                "label": "Example 3",
                "input": "s = \"12345\", t = \"12435\"",
                "output": "false Constraints: s.length == t.length 1 <= s.length <= 10 5 s and t consist of only digits."
            }
        ],
        "elixir_template": "defmodule Solution do\n  @spec is_transformable(s :: String.t, t :: String.t) :: boolean\n  def is_transformable(s, t) do\n    \n  end\nend",
        "erlang_template": "-spec is_transformable(S :: unicode:unicode_binary(), T :: unicode:unicode_binary()) -> boolean().\nis_transformable(S, T) ->\n  .",
        "scala_template": "object Solution {\n    def isTransformable(s: String, t: String): Boolean = {\n        \n    }\n}"
    },
    {
        "id": 1706,
        "name": "min-cost-to-connect-all-points",
        "difficulty": "Medium",
        "link": "https://leetcode.com/problems/min-cost-to-connect-all-points/",
        "task_description": "You are given an array `points` representing integer coordinates of some points on a 2D-plane, where `points[i] = [xi, yi]`. The cost of connecting two points `[xi, yi]` and `[xj, yj]` is the **manhattan distance** between them: `|xi - xj| + |yi - yj|`, where `|val|` denotes the absolute value of `val`. Return _the minimum cost to make all points connected._ All points are connected if there is **exactly one** simple path between any two points. **Example 1:** ``` **Input:** points = [[0,0],[2,2],[3,10],[5,2],[7,0]] **Output:** 20 **Explanation:** We can connect the points as shown above to get the minimum cost of 20. Notice that there is a unique path between every pair of points. ``` **Example 2:** ``` **Input:** points = [[3,12],[-2,5],[-4,1]] **Output:** 18 ``` **Constraints:** `1 <= points.length <= 1000` `-106 <= xi, yi <= 106` All pairs `(xi, yi)` are distinct.",
        "test_case": [
            {
                "label": "Example 1",
                "input": "points = [[0,0],[2,2],[3,10],[5,2],[7,0]]",
                "output": "20 Explanation: We can connect the points as shown above to get the minimum cost of 20.\nNotice that there is a unique path between every pair of points."
            },
            {
                "label": "Example 2",
                "input": "points = [[3,12],[-2,5],[-4,1]]",
                "output": "18"
            }
        ],
        "elixir_template": "defmodule Solution do\n  @spec min_cost_connect_points(points :: [[integer]]) :: integer\n  def min_cost_connect_points(points) do\n    \n  end\nend",
        "erlang_template": "-spec min_cost_connect_points(Points :: [[integer()]]) -> integer().\nmin_cost_connect_points(Points) ->\n  .",
        "scala_template": "object Solution {\n    def minCostConnectPoints(points: Array[Array[Int]]): Int = {\n        \n    }\n}"
    },
    {
        "id": 1705,
        "name": "count-unhappy-friends",
        "difficulty": "Medium",
        "link": "https://leetcode.com/problems/count-unhappy-friends/",
        "task_description": "You are given a list of `preferences` for `n` friends, where `n` is always **even**. For each person `i`, `preferences[i]` contains a list of friends **sorted** in the **order of preference**. In other words, a friend earlier in the list is more preferred than a friend later in the list. Friends in each list are denoted by integers from `0` to `n-1`. All the friends are divided into pairs. The pairings are given in a list `pairs`, where `pairs[i] = [xi, yi]` denotes `xi` is paired with `yi` and `yi` is paired with `xi`. However, this pairing may cause some of the friends to be unhappy. A friend `x` is unhappy if `x` is paired with `y` and there exists a friend `u` who is paired with `v` but: `x` prefers `u` over `y`, and `u` prefers `x` over `v`. Return _the number of unhappy friends_. **Example 1:** ``` **Input:** n = 4, preferences = [[1, 2, 3], [3, 2, 0], [3, 1, 0], [1, 2, 0]], pairs = [[0, 1], [2, 3]] **Output:** 2 **Explanation:** Friend 1 is unhappy because: - 1 is paired with 0 but prefers 3 over 0, and - 3 prefers 1 over 2. Friend 3 is unhappy because: - 3 is paired with 2 but prefers 1 over 2, and - 1 prefers 3 over 0. Friends 0 and 2 are happy. ``` **Example 2:** ``` **Input:** n = 2, preferences = [[1], [0]], pairs = [[1, 0]] **Output:** 0 **Explanation:** Both friends 0 and 1 are happy. ``` **Example 3:** ``` **Input:** n = 4, preferences = [[1, 3, 2], [2, 3, 0], [1, 3, 0], [0, 2, 1]], pairs = [[1, 3], [0, 2]] **Output:** 4 ``` **Constraints:** `2 <= n <= 500` `n` is even. `preferences.length == n` `preferences[i].length == n - 1` `0 <= preferences[i][j] <= n - 1` `preferences[i]` does not contain `i`. All values in `preferences[i]` are unique. `pairs.length == n/2` `pairs[i].length == 2` `xi != yi` `0 <= xi, yi <= n - 1` Each person is contained in **exactly one** pair.",
        "test_case": [
            {
                "label": "Example 1",
                "input": "n = 4, preferences = [[1, 2, 3], [3, 2, 0], [3, 1, 0], [1, 2, 0]], pairs = [[0, 1], [2, 3]]",
                "output": "2 Explanation: Friend 1 is unhappy because:\n- 1 is paired with 0 but prefers 3 over 0, and\n- 3 prefers 1 over 2.\nFriend 3 is unhappy because:\n- 3 is paired with 2 but prefers 1 over 2, and\n- 1 prefers 3 over 0.\nFriends 0 and 2 are happy."
            },
            {
                "label": "Example 2",
                "input": "n = 2, preferences = [[1], [0]], pairs = [[1, 0]]",
                "output": "0 Explanation: Both friends 0 and 1 are happy."
            },
            {
                "label": "Example 3",
                "input": "n = 4, preferences = [[1, 3, 2], [2, 3, 0], [1, 3, 0], [0, 2, 1]], pairs = [[1, 3], [0, 2]]",
                "output": "4"
            }
        ],
        "elixir_template": "defmodule Solution do\n  @spec unhappy_friends(n :: integer, preferences :: [[integer]], pairs :: [[integer]]) :: integer\n  def unhappy_friends(n, preferences, pairs) do\n    \n  end\nend",
        "erlang_template": "-spec unhappy_friends(N :: integer(), Preferences :: [[integer()]], Pairs :: [[integer()]]) -> integer().\nunhappy_friends(N, Preferences, Pairs) ->\n  .",
        "scala_template": "object Solution {\n    def unhappyFriends(n: Int, preferences: Array[Array[Int]], pairs: Array[Array[Int]]): Int = {\n        \n    }\n}"
    },
    {
        "id": 1704,
        "name": "special-positions-in-a-binary-matrix",
        "difficulty": "Easy",
        "link": "https://leetcode.com/problems/special-positions-in-a-binary-matrix/",
        "task_description": "Given an `m x n` binary matrix `mat`, return _the number of special positions in _`mat`_._ A position `(i, j)` is called **special** if `mat[i][j] == 1` and all other elements in row `i` and column `j` are `0` (rows and columns are **0-indexed**). **Example 1:** ``` **Input:** mat = [[1,0,0],[0,0,1],[1,0,0]] **Output:** 1 **Explanation:** (1, 2) is a special position because mat[1][2] == 1 and all other elements in row 1 and column 2 are 0. ``` **Example 2:** ``` **Input:** mat = [[1,0,0],[0,1,0],[0,0,1]] **Output:** 3 **Explanation:** (0, 0), (1, 1) and (2, 2) are special positions. ``` **Constraints:** `m == mat.length` `n == mat[i].length` `1 <= m, n <= 100` `mat[i][j]` is either `0` or `1`.",
        "test_case": [
            {
                "label": "Example 1",
                "input": "mat = [[1,0,0],[0,0,1],[1,0,0]]",
                "output": "1 Explanation: (1, 2) is a special position because mat[1][2] == 1 and all other elements in row 1 and column 2 are 0."
            },
            {
                "label": "Example 2",
                "input": "mat = [[1,0,0],[0,1,0],[0,0,1]]",
                "output": "3 Explanation: (0, 0), (1, 1) and (2, 2) are special positions. Constraints: m == mat.length n == mat[i].length 1 <= m, n <= 100 mat[i][j] is either 0 or 1 ."
            }
        ],
        "elixir_template": "defmodule Solution do\n  @spec num_special(mat :: [[integer]]) :: integer\n  def num_special(mat) do\n    \n  end\nend",
        "erlang_template": "-spec num_special(Mat :: [[integer()]]) -> integer().\nnum_special(Mat) ->\n  .",
        "scala_template": "object Solution {\n    def numSpecial(mat: Array[Array[Int]]): Int = {\n        \n    }\n}"
    },
    {
        "id": 1701,
        "name": "remove-max-number-of-edges-to-keep-graph-fully-traversable",
        "difficulty": "Hard",
        "link": "https://leetcode.com/problems/remove-max-number-of-edges-to-keep-graph-fully-traversable/",
        "task_description": "Alice and Bob have an undirected graph of `n` nodes and three types of edges: Type 1: Can be traversed by Alice only. Type 2: Can be traversed by Bob only. Type 3: Can be traversed by both Alice and Bob. Given an array `edges` where `edges[i] = [typei, ui, vi]` represents a bidirectional edge of type `typei` between nodes `ui` and `vi`, find the maximum number of edges you can remove so that after removing the edges, the graph can still be fully traversed by both Alice and Bob. The graph is fully traversed by Alice and Bob if starting from any node, they can reach all other nodes. Return _the maximum number of edges you can remove, or return_ `-1` _if Alice and Bob cannot fully traverse the graph._ **Example 1:** **** ``` **Input:** n = 4, edges = [[3,1,2],[3,2,3],[1,1,3],[1,2,4],[1,1,2],[2,3,4]] **Output:** 2 **Explanation: **If we remove the 2 edges [1,1,2] and [1,1,3]. The graph will still be fully traversable by Alice and Bob. Removing any additional edge will not make it so. So the maximum number of edges we can remove is 2. ``` **Example 2:** **** ``` **Input:** n = 4, edges = [[3,1,2],[3,2,3],[1,1,4],[2,1,4]] **Output:** 0 **Explanation: **Notice that removing any edge will not make the graph fully traversable by Alice and Bob. ``` **Example 3:** **** ``` **Input:** n = 4, edges = [[3,2,3],[1,1,2],[2,3,4]] **Output:** -1 Explanation: In the current graph, Alice cannot reach node 4 from the other nodes. Likewise, Bob cannot reach 1. Therefore it's impossible to make the graph fully traversable. ``` **Constraints:** `1 <= n <= 105` `1 <= edges.length <= min(105, 3 * n * (n - 1) / 2)` `edges[i].length == 3` `1 <= typei <= 3` `1 <= ui < vi <= n` All tuples `(typei, ui, vi)` are distinct.",
        "test_case": [
            {
                "label": "Example 1",
                "input": "n = 4, edges = [[3,1,2],[3,2,3],[1,1,3],[1,2,4],[1,1,2],[2,3,4]]",
                "output": "2 Explanation: If we remove the 2 edges [1,1,2] and [1,1,3]. The graph will still be fully traversable by Alice and Bob. Removing any additional edge will not make it so. So the maximum number of edges we can remove is 2."
            },
            {
                "label": "Example 2",
                "input": "n = 4, edges = [[3,1,2],[3,2,3],[1,1,4],[2,1,4]]",
                "output": "0 Explanation: Notice that removing any edge will not make the graph fully traversable by Alice and Bob."
            },
            {
                "label": "Example 3",
                "input": "n = 4, edges = [[3,2,3],[1,1,2],[2,3,4]]",
                "output": "-1 Explanation: In the current graph, Alice cannot reach node 4 from the other nodes. Likewise, Bob cannot reach 1. Therefore it's impossible to make the graph fully traversable."
            }
        ],
        "elixir_template": "defmodule Solution do\n  @spec max_num_edges_to_remove(n :: integer, edges :: [[integer]]) :: integer\n  def max_num_edges_to_remove(n, edges) do\n    \n  end\nend",
        "erlang_template": "-spec max_num_edges_to_remove(N :: integer(), Edges :: [[integer()]]) -> integer().\nmax_num_edges_to_remove(N, Edges) ->\n  .",
        "scala_template": "object Solution {\n    def maxNumEdgesToRemove(n: Int, edges: Array[Array[Int]]): Int = {\n        \n    }\n}"
    },
    {
        "id": 1700,
        "name": "minimum-time-to-make-rope-colorful",
        "difficulty": "Medium",
        "link": "https://leetcode.com/problems/minimum-time-to-make-rope-colorful/",
        "task_description": "Alice has `n` balloons arranged on a rope. You are given a **0-indexed** string `colors` where `colors[i]` is the color of the `ith` balloon. Alice wants the rope to be **colorful**. She does not want **two consecutive balloons** to be of the same color, so she asks Bob for help. Bob can remove some balloons from the rope to make it **colorful**. You are given a **0-indexed** integer array `neededTime` where `neededTime[i]` is the time (in seconds) that Bob needs to remove the `ith` balloon from the rope. Return _the **minimum time** Bob needs to make the rope **colorful**_. **Example 1:** ``` **Input:** colors = \"abaac\", neededTime = [1,2,3,4,5] **Output:** 3 **Explanation:** In the above image, 'a' is blue, 'b' is red, and 'c' is green. Bob can remove the blue balloon at index 2. This takes 3 seconds. There are no longer two consecutive balloons of the same color. Total time = 3. ``` **Example 2:** ``` **Input:** colors = \"abc\", neededTime = [1,2,3] **Output:** 0 **Explanation:** The rope is already colorful. Bob does not need to remove any balloons from the rope. ``` **Example 3:** ``` **Input:** colors = \"aabaa\", neededTime = [1,2,3,4,1] **Output:** 2 **Explanation:** Bob will remove the balloons at indices 0 and 4. Each balloons takes 1 second to remove. There are no longer two consecutive balloons of the same color. Total time = 1 + 1 = 2. ``` **Constraints:** `n == colors.length == neededTime.length` `1 <= n <= 105` `1 <= neededTime[i] <= 104` `colors` contains only lowercase English letters.",
        "test_case": [
            {
                "label": "Example 1",
                "input": "colors = \"abaac\", neededTime = [1,2,3,4,5]",
                "output": "3 Explanation: In the above image, 'a' is blue, 'b' is red, and 'c' is green.\nBob can remove the blue balloon at index 2. This takes 3 seconds.\nThere are no longer two consecutive balloons of the same color. Total time = 3."
            },
            {
                "label": "Example 2",
                "input": "colors = \"abc\", neededTime = [1,2,3]",
                "output": "0 Explanation: The rope is already colorful. Bob does not need to remove any balloons from the rope."
            },
            {
                "label": "Example 3",
                "input": "colors = \"aabaa\", neededTime = [1,2,3,4,1]",
                "output": "2 Explanation: Bob will remove the balloons at indices 0 and 4. Each balloons takes 1 second to remove.\nThere are no longer two consecutive balloons of the same color. Total time = 1 + 1 = 2. Constraints: n == colors.length == neededTime.length 1 <= n <= 10 5 1 <= neededTime[i] <= 10 4 colors contains only lowercase English letters."
            }
        ],
        "elixir_template": "defmodule Solution do\n  @spec min_cost(colors :: String.t, needed_time :: [integer]) :: integer\n  def min_cost(colors, needed_time) do\n    \n  end\nend",
        "erlang_template": "-spec min_cost(Colors :: unicode:unicode_binary(), NeededTime :: [integer()]) -> integer().\nmin_cost(Colors, NeededTime) ->\n  .",
        "scala_template": "object Solution {\n    def minCost(colors: String, neededTime: Array[Int]): Int = {\n        \n    }\n}"
    },
    {
        "id": 1699,
        "name": "number-of-ways-where-square-of-number-is-equal-to-product-of-two-numbers",
        "difficulty": "Medium",
        "link": "https://leetcode.com/problems/number-of-ways-where-square-of-number-is-equal-to-product-of-two-numbers/",
        "task_description": "Given two arrays of integers `nums1` and `nums2`, return the number of triplets formed (type 1 and type 2) under the following rules: Type 1: Triplet (i, j, k) if `nums1[i]2 == nums2[j] * nums2[k]` where `0 <= i < nums1.length` and `0 <= j < k < nums2.length`. Type 2: Triplet (i, j, k) if `nums2[i]2 == nums1[j] * nums1[k]` where `0 <= i < nums2.length` and `0 <= j < k < nums1.length`. **Example 1:** ``` **Input:** nums1 = [7,4], nums2 = [5,2,8,9] **Output:** 1 **Explanation:** Type 1: (1, 1, 2), nums1[1]2 = nums2[1] * nums2[2]. (42 = 2 * 8). ``` **Example 2:** ``` **Input:** nums1 = [1,1], nums2 = [1,1,1] **Output:** 9 **Explanation:** All Triplets are valid, because 12 = 1 * 1. Type 1: (0,0,1), (0,0,2), (0,1,2), (1,0,1), (1,0,2), (1,1,2). nums1[i]2 = nums2[j] * nums2[k]. Type 2: (0,0,1), (1,0,1), (2,0,1). nums2[i]2 = nums1[j] * nums1[k]. ``` **Example 3:** ``` **Input:** nums1 = [7,7,8,3], nums2 = [1,2,9,7] **Output:** 2 **Explanation:** There are 2 valid triplets. Type 1: (3,0,2). nums1[3]2 = nums2[0] * nums2[2]. Type 2: (3,0,1). nums2[3]2 = nums1[0] * nums1[1]. ``` **Constraints:** `1 <= nums1.length, nums2.length <= 1000` `1 <= nums1[i], nums2[i] <= 105`",
        "test_case": [
            {
                "label": "Example 1",
                "input": "nums1 = [7,4], nums2 = [5,2,8,9]",
                "output": "1 Explanation: Type 1: (1, 1, 2), nums1[1] 2 = nums2[1] * nums2[2]. (4 2 = 2 * 8)."
            },
            {
                "label": "Example 2",
                "input": "nums1 = [1,1], nums2 = [1,1,1]",
                "output": "9 Explanation: All Triplets are valid, because 1 2 = 1 * 1.\nType 1: (0,0,1), (0,0,2), (0,1,2), (1,0,1), (1,0,2), (1,1,2).  nums1[i] 2 = nums2[j] * nums2[k].\nType 2: (0,0,1), (1,0,1), (2,0,1). nums2[i] 2 = nums1[j] * nums1[k]."
            },
            {
                "label": "Example 3",
                "input": "nums1 = [7,7,8,3], nums2 = [1,2,9,7]",
                "output": "2 Explanation: There are 2 valid triplets.\nType 1: (3,0,2).  nums1[3] 2 = nums2[0] * nums2[2].\nType 2: (3,0,1).  nums2[3] 2 = nums1[0] * nums1[1]."
            }
        ],
        "elixir_template": "defmodule Solution do\n  @spec num_triplets(nums1 :: [integer], nums2 :: [integer]) :: integer\n  def num_triplets(nums1, nums2) do\n    \n  end\nend",
        "erlang_template": "-spec num_triplets(Nums1 :: [integer()], Nums2 :: [integer()]) -> integer().\nnum_triplets(Nums1, Nums2) ->\n  .",
        "scala_template": "object Solution {\n    def numTriplets(nums1: Array[Int], nums2: Array[Int]): Int = {\n        \n    }\n}"
    },
    {
        "id": 1698,
        "name": "replace-all-s-to-avoid-consecutive-repeating-characters",
        "difficulty": "Easy",
        "link": "https://leetcode.com/problems/replace-all-s-to-avoid-consecutive-repeating-characters/",
        "task_description": "Given a string `s` containing only lowercase English letters and the `'?'` character, convert **all **the `'?'` characters into lowercase letters such that the final string does not contain any **consecutive repeating **characters. You **cannot **modify the non `'?'` characters. It is **guaranteed **that there are no consecutive repeating characters in the given string **except **for `'?'`. Return _the final string after all the conversions (possibly zero) have been made_. If there is more than one solution, return **any of them**. It can be shown that an answer is always possible with the given constraints. **Example 1:** ``` **Input:** s = \"?zs\" **Output:** \"azs\" **Explanation:** There are 25 solutions for this problem. From \"azs\" to \"yzs\", all are valid. Only \"z\" is an invalid modification as the string will consist of consecutive repeating characters in \"zzs\". ``` **Example 2:** ``` **Input:** s = \"ubv?w\" **Output:** \"ubvaw\" **Explanation:** There are 24 solutions for this problem. Only \"v\" and \"w\" are invalid modifications as the strings will consist of consecutive repeating characters in \"ubvvw\" and \"ubvww\". ``` **Constraints:** `1 <= s.length <= 100` `s` consist of lowercase English letters and `'?'`.",
        "test_case": [
            {
                "label": "Example 1",
                "input": "s = \"?zs\"",
                "output": "\"azs\" Explanation: There are 25 solutions for this problem. From \"azs\" to \"yzs\", all are valid. Only \"z\" is an invalid modification as the string will consist of consecutive repeating characters in \"zzs\"."
            },
            {
                "label": "Example 2",
                "input": "s = \"ubv?w\"",
                "output": "\"ubvaw\" Explanation: There are 24 solutions for this problem. Only \"v\" and \"w\" are invalid modifications as the strings will consist of consecutive repeating characters in \"ubvvw\" and \"ubvww\"."
            }
        ],
        "elixir_template": "defmodule Solution do\n  @spec modify_string(s :: String.t) :: String.t\n  def modify_string(s) do\n    \n  end\nend",
        "erlang_template": "-spec modify_string(S :: unicode:unicode_binary()) -> unicode:unicode_binary().\nmodify_string(S) ->\n  .",
        "scala_template": "object Solution {\n    def modifyString(s: String): String = {\n        \n    }\n}"
    },
    {
        "id": 1696,
        "name": "strange-printer-ii",
        "difficulty": "Hard",
        "link": "https://leetcode.com/problems/strange-printer-ii/",
        "task_description": "There is a strange printer with the following two special requirements: On each turn, the printer will print a solid rectangular pattern of a single color on the grid. This will cover up the existing colors in the rectangle. Once the printer has used a color for the above operation, **the same color cannot be used again**. You are given a `m x n` matrix `targetGrid`, where `targetGrid[row][col]` is the color in the position `(row, col)` of the grid. Return `true`_ if it is possible to print the matrix _`targetGrid`_,__ otherwise, return _`false`. **Example 1:** ``` **Input:** targetGrid = [[1,1,1,1],[1,2,2,1],[1,2,2,1],[1,1,1,1]] **Output:** true ``` **Example 2:** ``` **Input:** targetGrid = [[1,1,1,1],[1,1,3,3],[1,1,3,4],[5,5,1,4]] **Output:** true ``` **Example 3:** ``` **Input:** targetGrid = [[1,2,1],[2,1,2],[1,2,1]] **Output:** false **Explanation:** It is impossible to form targetGrid because it is not allowed to print the same color in different turns. ``` **Constraints:** `m == targetGrid.length` `n == targetGrid[i].length` `1 <= m, n <= 60` `1 <= targetGrid[row][col] <= 60`",
        "test_case": [
            {
                "label": "Example 1",
                "input": "targetGrid = [[1,1,1,1],[1,2,2,1],[1,2,2,1],[1,1,1,1]]",
                "output": "true"
            },
            {
                "label": "Example 2",
                "input": "targetGrid = [[1,1,1,1],[1,1,3,3],[1,1,3,4],[5,5,1,4]]",
                "output": "true"
            },
            {
                "label": "Example 3",
                "input": "targetGrid = [[1,2,1],[2,1,2],[1,2,1]]",
                "output": "false Explanation: It is impossible to form targetGrid because it is not allowed to print the same color in different turns. Constraints: m == targetGrid.length n == targetGrid[i].length 1 <= m, n <= 60 1 <= targetGrid[row][col] <= 60"
            }
        ],
        "elixir_template": "defmodule Solution do\n  @spec is_printable(target_grid :: [[integer]]) :: boolean\n  def is_printable(target_grid) do\n    \n  end\nend",
        "erlang_template": "-spec is_printable(TargetGrid :: [[integer()]]) -> boolean().\nis_printable(TargetGrid) ->\n  .",
        "scala_template": "object Solution {\n    def isPrintable(targetGrid: Array[Array[Int]]): Boolean = {\n        \n    }\n}"
    },
    {
        "id": 1695,
        "name": "maximum-sum-obtained-of-any-permutation",
        "difficulty": "Medium",
        "link": "https://leetcode.com/problems/maximum-sum-obtained-of-any-permutation/",
        "task_description": "We have an array of integers, `nums`, and an array of `requests` where `requests[i] = [starti, endi]`. The `ith` request asks for the sum of `nums[starti] + nums[starti + 1] + ... + nums[endi - 1] + nums[endi]`. Both `starti` and `endi` are _0-indexed_. Return _the maximum total sum of all requests **among all permutations** of_ `nums`. Since the answer may be too large, return it **modulo** `109 + 7`. **Example 1:** ``` **Input:** nums = [1,2,3,4,5], requests = [[1,3],[0,1]] **Output:** 19 **Explanation:** One permutation of nums is [2,1,3,4,5] with the following result: requests[0] -> nums[1] + nums[2] + nums[3] = 1 + 3 + 4 = 8 requests[1] -> nums[0] + nums[1] = 2 + 1 = 3 Total sum: 8 + 3 = 11. A permutation with a higher total sum is [3,5,4,2,1] with the following result: requests[0] -> nums[1] + nums[2] + nums[3] = 5 + 4 + 2 = 11 requests[1] -> nums[0] + nums[1] = 3 + 5 = 8 Total sum: 11 + 8 = 19, which is the best that you can do. ``` **Example 2:** ``` **Input:** nums = [1,2,3,4,5,6], requests = [[0,1]] **Output:** 11 **Explanation:** A permutation with the max total sum is [6,5,4,3,2,1] with request sums [11]. ``` **Example 3:** ``` **Input:** nums = [1,2,3,4,5,10], requests = [[0,2],[1,3],[1,1]] **Output:** 47 **Explanation:** A permutation with the max total sum is [4,10,5,3,2,1] with request sums [19,18,10]. ``` **Constraints:** `n == nums.length` `1 <= n <= 105` `0 <= nums[i] <= 105` `1 <= requests.length <= 105` `requests[i].length == 2` `0 <= starti <= endi < n`",
        "test_case": [
            {
                "label": "Example 1",
                "input": "nums = [1,2,3,4,5], requests = [[1,3],[0,1]]",
                "output": "19 Explanation: One permutation of nums is [2,1,3,4,5] with the following result: \nrequests[0] -> nums[1] + nums[2] + nums[3] = 1 + 3 + 4 = 8\nrequests[1] -> nums[0] + nums[1] = 2 + 1 = 3\nTotal sum: 8 + 3 = 11.\nA permutation with a higher total sum is [3,5,4,2,1] with the following result:\nrequests[0] -> nums[1] + nums[2] + nums[3] = 5 + 4 + 2 = 11\nrequests[1] -> nums[0] + nums[1] = 3 + 5  = 8\nTotal sum: 11 + 8 = 19, which is the best that you can do."
            },
            {
                "label": "Example 2",
                "input": "nums = [1,2,3,4,5,6], requests = [[0,1]]",
                "output": "11 Explanation: A permutation with the max total sum is [6,5,4,3,2,1] with request sums [11]."
            },
            {
                "label": "Example 3",
                "input": "nums = [1,2,3,4,5,10], requests = [[0,2],[1,3],[1,1]]",
                "output": "47 Explanation: A permutation with the max total sum is [4,10,5,3,2,1] with request sums [19,18,10]. Constraints: n == nums.length 1 <= n <= 10 5 0 <= nums[i]\u00a0<= 10 5 1 <= requests.length <=\u00a010 5 requests[i].length == 2 0 <= start i <= end i <\u00a0n"
            }
        ],
        "elixir_template": "defmodule Solution do\n  @spec max_sum_range_query(nums :: [integer], requests :: [[integer]]) :: integer\n  def max_sum_range_query(nums, requests) do\n    \n  end\nend",
        "erlang_template": "-spec max_sum_range_query(Nums :: [integer()], Requests :: [[integer()]]) -> integer().\nmax_sum_range_query(Nums, Requests) ->\n  .",
        "scala_template": "object Solution {\n    def maxSumRangeQuery(nums: Array[Int], requests: Array[Array[Int]]): Int = {\n        \n    }\n}"
    },
    {
        "id": 1694,
        "name": "make-sum-divisible-by-p",
        "difficulty": "Medium",
        "link": "https://leetcode.com/problems/make-sum-divisible-by-p/",
        "task_description": "Given an array of positive integers `nums`, remove the **smallest** subarray (possibly **empty**) such that the **sum** of the remaining elements is divisible by `p`. It is **not** allowed to remove the whole array. Return _the length of the smallest subarray that you need to remove, or _`-1`_ if it's impossible_. A **subarray** is defined as a contiguous block of elements in the array. **Example 1:** ``` **Input:** nums = [3,1,4,2], p = 6 **Output:** 1 **Explanation:** The sum of the elements in nums is 10, which is not divisible by 6. We can remove the subarray [4], and the sum of the remaining elements is 6, which is divisible by 6. ``` **Example 2:** ``` **Input:** nums = [6,3,5,2], p = 9 **Output:** 2 **Explanation:** We cannot remove a single element to get a sum divisible by 9. The best way is to remove the subarray [5,2], leaving us with [6,3] with sum 9. ``` **Example 3:** ``` **Input:** nums = [1,2,3], p = 3 **Output:** 0 **Explanation:** Here the sum is 6. which is already divisible by 3. Thus we do not need to remove anything. ``` **Constraints:** `1 <= nums.length <= 105` `1 <= nums[i] <= 109` `1 <= p <= 109`",
        "test_case": [
            {
                "label": "Example 1",
                "input": "nums = [3,1,4,2], p = 6",
                "output": "1 Explanation: The sum of the elements in nums is 10, which is not divisible by 6. We can remove the subarray [4], and the sum of the remaining elements is 6, which is divisible by 6."
            },
            {
                "label": "Example 2",
                "input": "nums = [6,3,5,2], p = 9",
                "output": "2 Explanation: We cannot remove a single element to get a sum divisible by 9. The best way is to remove the subarray [5,2], leaving us with [6,3] with sum 9."
            },
            {
                "label": "Example 3",
                "input": "nums = [1,2,3], p = 3",
                "output": "0 Explanation: Here the sum is 6. which is already divisible by 3. Thus we do not need to remove anything."
            }
        ],
        "elixir_template": "defmodule Solution do\n  @spec min_subarray(nums :: [integer], p :: integer) :: integer\n  def min_subarray(nums, p) do\n    \n  end\nend",
        "erlang_template": "-spec min_subarray(Nums :: [integer()], P :: integer()) -> integer().\nmin_subarray(Nums, P) ->\n  .",
        "scala_template": "object Solution {\n    def minSubarray(nums: Array[Int], p: Int): Int = {\n        \n    }\n}"
    },
    {
        "id": 1693,
        "name": "sum-of-all-odd-length-subarrays",
        "difficulty": "Easy",
        "link": "https://leetcode.com/problems/sum-of-all-odd-length-subarrays/",
        "task_description": "Given an array of positive integers `arr`, return _the sum of all possible **odd-length subarrays** of _`arr`. A **subarray** is a contiguous subsequence of the array. **Example 1:** ``` **Input:** arr = [1,4,2,5,3] **Output:** 58 **Explanation: **The odd-length subarrays of arr and their sums are: [1] = 1 [4] = 4 [2] = 2 [5] = 5 [3] = 3 [1,4,2] = 7 [4,2,5] = 11 [2,5,3] = 10 [1,4,2,5,3] = 15 If we add all these together we get 1 + 4 + 2 + 5 + 3 + 7 + 11 + 10 + 15 = 58 ``` **Example 2:** ``` **Input:** arr = [1,2] **Output:** 3 Explanation: There are only 2 subarrays of odd length, [1] and [2]. Their sum is 3. ``` **Example 3:** ``` **Input:** arr = [10,11,12] **Output:** 66 ``` **Constraints:** `1 <= arr.length <= 100` `1 <= arr[i] <= 1000` **Follow up:** Could you solve this problem in O(n) time complexity?",
        "test_case": [
            {
                "label": "Example 1",
                "input": "arr = [1,4,2,5,3]",
                "output": "58 Explanation: The odd-length subarrays of arr and their sums are:\n[1] = 1\n[4] = 4\n[2] = 2\n[5] = 5\n[3] = 3\n[1,4,2] = 7\n[4,2,5] = 11\n[2,5,3] = 10\n[1,4,2,5,3] = 15\nIf we add all these together we get 1 + 4 + 2 + 5 + 3 + 7 + 11 + 10 + 15 = 58"
            },
            {
                "label": "Example 2",
                "input": "arr = [1,2]",
                "output": "3 Explanation: There are only 2 subarrays of odd length, [1] and [2]. Their sum is 3."
            },
            {
                "label": "Example 3",
                "input": "arr = [10,11,12]",
                "output": "66"
            }
        ],
        "elixir_template": "defmodule Solution do\n  @spec sum_odd_length_subarrays(arr :: [integer]) :: integer\n  def sum_odd_length_subarrays(arr) do\n    \n  end\nend",
        "erlang_template": "-spec sum_odd_length_subarrays(Arr :: [integer()]) -> integer().\nsum_odd_length_subarrays(Arr) ->\n  .",
        "scala_template": "object Solution {\n    def sumOddLengthSubarrays(arr: Array[Int]): Int = {\n        \n    }\n}"
    },
    {
        "id": 1692,
        "name": "number-of-ways-to-reorder-array-to-get-same-bst",
        "difficulty": "Hard",
        "link": "https://leetcode.com/problems/number-of-ways-to-reorder-array-to-get-same-bst/",
        "task_description": "Given an array `nums` that represents a permutation of integers from `1` to `n`. We are going to construct a binary search tree (BST) by inserting the elements of `nums` in order into an initially empty BST. Find the number of different ways to reorder `nums` so that the constructed BST is identical to that formed from the original array `nums`. For example, given `nums = [2,1,3]`, we will have 2 as the root, 1 as a left child, and 3 as a right child. The array `[2,3,1]` also yields the same BST but `[3,2,1]` yields a different BST. Return _the number of ways to reorder_ `nums` _such that the BST formed is identical to the original BST formed from_ `nums`. Since the answer may be very large, **return it modulo **`109 + 7`. **Example 1:** ``` **Input:** nums = [2,1,3] **Output:** 1 **Explanation:** We can reorder nums to be [2,3,1] which will yield the same BST. There are no other ways to reorder nums which will yield the same BST. ``` **Example 2:** ``` **Input:** nums = [3,4,5,1,2] **Output:** 5 **Explanation:** The following 5 arrays will yield the same BST: [3,1,2,4,5] [3,1,4,2,5] [3,1,4,5,2] [3,4,1,2,5] [3,4,1,5,2] ``` **Example 3:** ``` **Input:** nums = [1,2,3] **Output:** 0 **Explanation:** There are no other orderings of nums that will yield the same BST. ``` **Constraints:** `1 <= nums.length <= 1000` `1 <= nums[i] <= nums.length` All integers in `nums` are **distinct**.",
        "test_case": [
            {
                "label": "Example 1",
                "input": "nums = [2,1,3]",
                "output": "1 Explanation: We can reorder nums to be [2,3,1] which will yield the same BST. There are no other ways to reorder nums which will yield the same BST."
            },
            {
                "label": "Example 2",
                "input": "nums = [3,4,5,1,2]",
                "output": "5 Explanation: The following 5 arrays will yield the same BST: \n[3,1,2,4,5]\n[3,1,4,2,5]\n[3,1,4,5,2]\n[3,4,1,2,5]\n[3,4,1,5,2]"
            },
            {
                "label": "Example 3",
                "input": "nums = [1,2,3]",
                "output": "0 Explanation: There are no other orderings of nums that will yield the same BST."
            }
        ],
        "elixir_template": "defmodule Solution do\n  @spec num_of_ways(nums :: [integer]) :: integer\n  def num_of_ways(nums) do\n    \n  end\nend",
        "erlang_template": "-spec num_of_ways(Nums :: [integer()]) -> integer().\nnum_of_ways(Nums) ->\n  .",
        "scala_template": "object Solution {\n    def numOfWays(nums: Array[Int]): Int = {\n        \n    }\n}"
    },
    {
        "id": 1691,
        "name": "minimum-number-of-days-to-disconnect-island",
        "difficulty": "Hard",
        "link": "https://leetcode.com/problems/minimum-number-of-days-to-disconnect-island/",
        "task_description": "You are given an `m x n` binary grid `grid` where `1` represents land and `0` represents water. An **island** is a maximal **4-directionally** (horizontal or vertical) connected group of `1`'s. The grid is said to be **connected** if we have **exactly one island**, otherwise is said **disconnected**. In one day, we are allowed to change **any **single land cell `(1)` into a water cell `(0)`. Return _the minimum number of days to disconnect the grid_. **Example 1:** ``` **Input:** grid = [[0,1,1,0],[0,1,1,0],[0,0,0,0]] **Output:** 2 **Explanation:** We need at least 2 days to get a disconnected grid. Change land grid[1][1] and grid[0][2] to water and get 2 disconnected island. ``` **Example 2:** ``` **Input:** grid = [[1,1]] **Output:** 2 **Explanation:** Grid of full water is also disconnected ([[1,1]] -> [[0,0]]), 0 islands. ``` **Constraints:** `m == grid.length` `n == grid[i].length` `1 <= m, n <= 30` `grid[i][j]` is either `0` or `1`.",
        "test_case": [
            {
                "label": "Example 1",
                "input": "grid = [[0,1,1,0],[0,1,1,0],[0,0,0,0]]",
                "output": "2 Explanation: We need at least 2 days to get a disconnected grid.\nChange land grid[1][1] and grid[0][2] to water and get 2 disconnected island."
            },
            {
                "label": "Example 2",
                "input": "grid = [[1,1]]",
                "output": "2 Explanation: Grid of full water is also disconnected ([[1,1]] -> [[0,0]]), 0 islands. Constraints: m == grid.length n == grid[i].length 1 <= m, n <= 30 grid[i][j] is either 0 or 1 ."
            }
        ],
        "elixir_template": "defmodule Solution do\n  @spec min_days(grid :: [[integer]]) :: integer\n  def min_days(grid) do\n    \n  end\nend",
        "erlang_template": "-spec min_days(Grid :: [[integer()]]) -> integer().\nmin_days(Grid) ->\n  .",
        "scala_template": "object Solution {\n    def minDays(grid: Array[Array[Int]]): Int = {\n        \n    }\n}"
    },
    {
        "id": 1690,
        "name": "maximum-length-of-subarray-with-positive-product",
        "difficulty": "Medium",
        "link": "https://leetcode.com/problems/maximum-length-of-subarray-with-positive-product/",
        "task_description": "Given an array of integers `nums`, find the maximum length of a subarray where the product of all its elements is positive. A subarray of an array is a consecutive sequence of zero or more values taken out of that array. Return _the maximum length of a subarray with positive product_. **Example 1:** ``` **Input:** nums = [1,-2,-3,4] **Output:** 4 **Explanation:** The array nums already has a positive product of 24. ``` **Example 2:** ``` **Input:** nums = [0,1,-2,-3,-4] **Output:** 3 **Explanation:** The longest subarray with positive product is [1,-2,-3] which has a product of 6. Notice that we cannot include 0 in the subarray since that'll make the product 0 which is not positive. ``` **Example 3:** ``` **Input:** nums = [-1,-2,-3,0,1] **Output:** 2 **Explanation:** The longest subarray with positive product is [-1,-2] or [-2,-3]. ``` **Constraints:** `1 <= nums.length <= 105` `-109 <= nums[i] <= 109`",
        "test_case": [
            {
                "label": "Example 1",
                "input": "nums = [1,-2,-3,4]",
                "output": "4 Explanation: The array nums already has a positive product of 24."
            },
            {
                "label": "Example 2",
                "input": "nums = [0,1,-2,-3,-4]",
                "output": "3 Explanation: The longest subarray with positive product is [1,-2,-3] which has a product of 6.\nNotice that we cannot include 0 in the subarray since that'll make the product 0 which is not positive."
            },
            {
                "label": "Example 3",
                "input": "nums = [-1,-2,-3,0,1]",
                "output": "2 Explanation: The longest subarray with positive product is [-1,-2] or [-2,-3]."
            }
        ],
        "elixir_template": "defmodule Solution do\n  @spec get_max_len(nums :: [integer]) :: integer\n  def get_max_len(nums) do\n    \n  end\nend",
        "erlang_template": "-spec get_max_len(Nums :: [integer()]) -> integer().\nget_max_len(Nums) ->\n  .",
        "scala_template": "object Solution {\n    def getMaxLen(nums: Array[Int]): Int = {\n        \n    }\n}"
    },
    {
        "id": 1689,
        "name": "detect-pattern-of-length-m-repeated-k-or-more-times",
        "difficulty": "Easy",
        "link": "https://leetcode.com/problems/detect-pattern-of-length-m-repeated-k-or-more-times/",
        "task_description": "Given an array of positive integers `arr`, find a pattern of length `m` that is repeated `k` or more times. A **pattern** is a subarray (consecutive sub-sequence) that consists of one or more values, repeated multiple times **consecutively **without overlapping. A pattern is defined by its length and the number of repetitions. Return `true` _if there exists a pattern of length_ `m` _that is repeated_ `k` _or more times, otherwise return_ `false`. **Example 1:** ``` **Input:** arr = [1,2,4,4,4,4], m = 1, k = 3 **Output:** true **Explanation: **The pattern **(4)** of length 1 is repeated 4 consecutive times. Notice that pattern can be repeated k or more times but not less. ``` **Example 2:** ``` **Input:** arr = [1,2,1,2,1,1,1,3], m = 2, k = 2 **Output:** true **Explanation: **The pattern **(1,2)** of length 2 is repeated 2 consecutive times. Another valid pattern **(2,1) is** also repeated 2 times. ``` **Example 3:** ``` **Input:** arr = [1,2,1,2,1,3], m = 2, k = 3 **Output:** false **Explanation: **The pattern (1,2) is of length 2 but is repeated only 2 times. There is no pattern of length 2 that is repeated 3 or more times. ``` **Constraints:** `2 <= arr.length <= 100` `1 <= arr[i] <= 100` `1 <= m <= 100` `2 <= k <= 100`",
        "test_case": [
            {
                "label": "Example 1",
                "input": "arr = [1,2,4,4,4,4], m = 1, k = 3",
                "output": "true Explanation: The pattern (4) of length 1 is repeated 4 consecutive times. Notice that pattern can be repeated k or more times but not less."
            },
            {
                "label": "Example 2",
                "input": "arr = [1,2,1,2,1,1,1,3], m = 2, k = 2",
                "output": "true Explanation: The pattern (1,2) of length 2 is repeated 2 consecutive times. Another valid pattern (2,1) is also repeated 2 times."
            },
            {
                "label": "Example 3",
                "input": "arr = [1,2,1,2,1,3], m = 2, k = 3",
                "output": "false Explanation: The pattern (1,2) is of length 2 but is repeated only 2 times. There is no pattern of length 2 that is repeated 3 or more times."
            }
        ],
        "elixir_template": "defmodule Solution do\n  @spec contains_pattern(arr :: [integer], m :: integer, k :: integer) :: boolean\n  def contains_pattern(arr, m, k) do\n    \n  end\nend",
        "erlang_template": "-spec contains_pattern(Arr :: [integer()], M :: integer(), K :: integer()) -> boolean().\ncontains_pattern(Arr, M, K) ->\n  .",
        "scala_template": "object Solution {\n    def containsPattern(arr: Array[Int], m: Int, k: Int): Boolean = {\n        \n    }\n}"
    },
    {
        "id": 1685,
        "name": "stone-game-v",
        "difficulty": "Hard",
        "link": "https://leetcode.com/problems/stone-game-v/",
        "task_description": "There are several stones **arranged in a row**, and each stone has an associated value which is an integer given in the array `stoneValue`. In each round of the game, Alice divides the row into **two non-empty rows** (i.e. left row and right row), then Bob calculates the value of each row which is the sum of the values of all the stones in this row. Bob throws away the row which has the maximum value, and Alice's score increases by the value of the remaining row. If the value of the two rows are equal, Bob lets Alice decide which row will be thrown away. The next round starts with the remaining row. The game ends when there is only **one stone remaining**. Alice's is initially **zero**. Return the maximum score that Alice can obtain. **Example 1:** ``` **Input:** stoneValue = [6,2,3,4,5,5] **Output:** 18 **Explanation:** In the first round, Alice divides the row to [6,2,3], [4,5,5]. The left row has the value 11 and the right row has value 14. Bob throws away the right row and Alice's score is now 11. In the second round Alice divides the row to [6], [2,3]. This time Bob throws away the left row and Alice's score becomes 16 (11 + 5). The last round Alice has only one choice to divide the row which is [2], [3]. Bob throws away the right row and Alice's score is now 18 (16 + 2). The game ends because only one stone is remaining in the row. ``` **Example 2:** ``` **Input:** stoneValue = [7,7,7,7,7,7,7] **Output:** 28 ``` **Example 3:** ``` **Input:** stoneValue = [4] **Output:** 0 ``` **Constraints:** `1 <= stoneValue.length <= 500` `1 <= stoneValue[i] <= 106`",
        "test_case": [
            {
                "label": "Example 1",
                "input": "stoneValue = [6,2,3,4,5,5]",
                "output": "18 Explanation: In the first round, Alice divides the row to [6,2,3], [4,5,5]. The left row has the value 11 and the right row has value 14. Bob throws away the right row and Alice's score is now 11.\nIn the second round Alice divides the row to [6], [2,3]. This time Bob throws away the left row and Alice's score becomes 16 (11 + 5).\nThe last round Alice has only one choice to divide the row which is [2], [3]. Bob throws away the right row and Alice's score is now 18 (16 + 2). The game ends because only one stone is remaining in the row."
            },
            {
                "label": "Example 2",
                "input": "stoneValue = [7,7,7,7,7,7,7]",
                "output": "28"
            },
            {
                "label": "Example 3",
                "input": "stoneValue = [4]",
                "output": "0"
            }
        ],
        "elixir_template": "defmodule Solution do\n  @spec stone_game_v(stone_value :: [integer]) :: integer\n  def stone_game_v(stone_value) do\n    \n  end\nend",
        "erlang_template": "-spec stone_game_v(StoneValue :: [integer()]) -> integer().\nstone_game_v(StoneValue) ->\n  .",
        "scala_template": "object Solution {\n    def stoneGameV(stoneValue: Array[Int]): Int = {\n        \n    }\n}"
    },
    {
        "id": 1684,
        "name": "find-latest-group-of-size-m",
        "difficulty": "Medium",
        "link": "https://leetcode.com/problems/find-latest-group-of-size-m/",
        "task_description": "Given an array `arr` that represents a permutation of numbers from `1` to `n`. You have a binary string of size `n` that initially has all its bits set to zero. At each step `i` (assuming both the binary string and `arr` are 1-indexed) from `1` to `n`, the bit at position `arr[i]` is set to `1`. You are also given an integer `m`. Find the latest step at which there exists a group of ones of length `m`. A group of ones is a contiguous substring of `1`'s such that it cannot be extended in either direction. Return _the latest step at which there exists a group of ones of length **exactly**_ `m`. _If no such group exists, return_ `-1`. **Example 1:** ``` **Input:** arr = [3,5,1,2,4], m = 1 **Output:** 4 **Explanation:** Step 1: \"00100\", groups: [\"1\"] Step 2: \"00101\", groups: [\"1\", \"1\"] Step 3: \"10101\", groups: [\"1\", \"1\", \"1\"] Step 4: \"11101\", groups: [\"111\", \"1\"] Step 5: \"11111\", groups: [\"11111\"] The latest step at which there exists a group of size 1 is step 4. ``` **Example 2:** ``` **Input:** arr = [3,1,5,4,2], m = 2 **Output:** -1 **Explanation:** Step 1: \"00100\", groups: [\"1\"] Step 2: \"10100\", groups: [\"1\", \"1\"] Step 3: \"10101\", groups: [\"1\", \"1\", \"1\"] Step 4: \"10111\", groups: [\"1\", \"111\"] Step 5: \"11111\", groups: [\"11111\"] No group of size 2 exists during any step. ``` **Constraints:** `n == arr.length` `1 <= m <= n <= 105` `1 <= arr[i] <= n` All integers in `arr` are **distinct**.",
        "test_case": [
            {
                "label": "Example 1",
                "input": "arr = [3,5,1,2,4], m = 1",
                "output": "4 Explanation: Step 1: \"00 1 00\", groups: [\"1\"]\nStep 2: \"0010 1 \", groups: [\"1\", \"1\"]\nStep 3: \" 1 0101\", groups: [\"1\", \"1\", \"1\"]\nStep 4: \"1 1 101\", groups: [\"111\", \"1\"]\nStep 5: \"111 1 1\", groups: [\"11111\"]\nThe latest step at which there exists a group of size 1 is step 4."
            },
            {
                "label": "Example 2",
                "input": "arr = [3,1,5,4,2], m = 2",
                "output": "-1 Explanation: Step 1: \"00 1 00\", groups: [\"1\"]\nStep 2: \" 1 0100\", groups: [\"1\", \"1\"]\nStep 3: \"1010 1 \", groups: [\"1\", \"1\", \"1\"]\nStep 4: \"101 1 1\", groups: [\"1\", \"111\"]\nStep 5: \"1 1 111\", groups: [\"11111\"]\nNo group of size 2 exists during any step. Constraints: n == arr.length 1 <= m <= n <= 10 5 1 <= arr[i] <= n All integers in arr are distinct ."
            }
        ],
        "elixir_template": "defmodule Solution do\n  @spec find_latest_step(arr :: [integer], m :: integer) :: integer\n  def find_latest_step(arr, m) do\n    \n  end\nend",
        "erlang_template": "-spec find_latest_step(Arr :: [integer()], M :: integer()) -> integer().\nfind_latest_step(Arr, M) ->\n  .",
        "scala_template": "object Solution {\n    def findLatestStep(arr: Array[Int], m: Int): Int = {\n        \n    }\n}"
    },
    {
        "id": 1683,
        "name": "maximum-number-of-coins-you-can-get",
        "difficulty": "Medium",
        "link": "https://leetcode.com/problems/maximum-number-of-coins-you-can-get/",
        "task_description": "There are `3n` piles of coins of varying size, you and your friends will take piles of coins as follows: In each step, you will choose **any **`3` piles of coins (not necessarily consecutive). Of your choice, Alice will pick the pile with the maximum number of coins. You will pick the next pile with the maximum number of coins. Your friend Bob will pick the last pile. Repeat until there are no more piles of coins. Given an array of integers `piles` where `piles[i]` is the number of coins in the `ith` pile. Return the maximum number of coins that you can have. **Example 1:** ``` **Input:** piles = [2,4,1,2,7,8] **Output:** 9 **Explanation: **Choose the triplet (2, 7, 8), Alice Pick the pile with 8 coins, you the pile with **7** coins and Bob the last one. Choose the triplet (1, 2, 4), Alice Pick the pile with 4 coins, you the pile with **2** coins and Bob the last one. The maximum number of coins which you can have are: 7 + 2 = 9. On the other hand if we choose this arrangement (1, **2**, 8), (2, **4**, 7) you only get 2 + 4 = 6 coins which is not optimal. ``` **Example 2:** ``` **Input:** piles = [2,4,5] **Output:** 4 ``` **Example 3:** ``` **Input:** piles = [9,8,7,6,5,1,2,3,4] **Output:** 18 ``` **Constraints:** `3 <= piles.length <= 105` `piles.length % 3 == 0` `1 <= piles[i] <= 104`",
        "test_case": [
            {
                "label": "Example 1",
                "input": "piles = [2,4,1,2,7,8]",
                "output": "9 Explanation: Choose the triplet (2, 7, 8), Alice Pick the pile with 8 coins, you the pile with 7 coins and Bob the last one.\nChoose the triplet (1, 2, 4), Alice Pick the pile with 4 coins, you the pile with 2 coins and Bob the last one.\nThe maximum number of coins which you can have are: 7 + 2 = 9.\nOn the other hand if we choose this arrangement (1, 2 , 8), (2, 4 , 7) you only get 2 + 4 = 6 coins which is not optimal."
            },
            {
                "label": "Example 2",
                "input": "piles = [2,4,5]",
                "output": "4"
            },
            {
                "label": "Example 3",
                "input": "piles = [9,8,7,6,5,1,2,3,4]",
                "output": "18"
            }
        ],
        "elixir_template": "defmodule Solution do\n  @spec max_coins(piles :: [integer]) :: integer\n  def max_coins(piles) do\n    \n  end\nend",
        "erlang_template": "-spec max_coins(Piles :: [integer()]) -> integer().\nmax_coins(Piles) ->\n  .",
        "scala_template": "object Solution {\n    def maxCoins(piles: Array[Int]): Int = {\n        \n    }\n}"
    },
    {
        "id": 1682,
        "name": "most-visited-sector-in-a-circular-track",
        "difficulty": "Easy",
        "link": "https://leetcode.com/problems/most-visited-sector-in-a-circular-track/",
        "task_description": "Given an integer `n` and an integer array `rounds`. We have a circular track which consists of `n` sectors labeled from `1` to `n`. A marathon will be held on this track, the marathon consists of `m` rounds. The `ith` round starts at sector `rounds[i - 1]` and ends at sector `rounds[i]`. For example, round 1 starts at sector `rounds[0]` and ends at sector `rounds[1]` Return _an array of the most visited sectors_ sorted in **ascending** order. Notice that you circulate the track in ascending order of sector numbers in the counter-clockwise direction (See the first example). **Example 1:** ``` **Input:** n = 4, rounds = [1,3,1,2] **Output:** [1,2] **Explanation:** The marathon starts at sector 1. The order of the visited sectors is as follows: 1 --> 2 --> 3 (end of round 1) --> 4 --> 1 (end of round 2) --> 2 (end of round 3 and the marathon) We can see that both sectors 1 and 2 are visited twice and they are the most visited sectors. Sectors 3 and 4 are visited only once. ``` **Example 2:** ``` **Input:** n = 2, rounds = [2,1,2,1,2,1,2,1,2] **Output:** [2] ``` **Example 3:** ``` **Input:** n = 7, rounds = [1,3,5,7] **Output:** [1,2,3,4,5,6,7] ``` **Constraints:** `2 <= n <= 100` `1 <= m <= 100` `rounds.length == m + 1` `1 <= rounds[i] <= n` `rounds[i] != rounds[i + 1]` for `0 <= i < m`",
        "test_case": [
            {
                "label": "Example 1",
                "input": "n = 4, rounds = [1,3,1,2]",
                "output": "[1,2] Explanation: The marathon starts at sector 1. The order of the visited sectors is as follows:\n1 --> 2 --> 3 (end of round 1) --> 4 --> 1 (end of round 2) --> 2 (end of round 3 and the marathon)\nWe can see that both sectors 1 and 2 are visited twice and they are the most visited sectors. Sectors 3 and 4 are visited only once."
            },
            {
                "label": "Example 2",
                "input": "n = 2, rounds = [2,1,2,1,2,1,2,1,2]",
                "output": "[2]"
            },
            {
                "label": "Example 3",
                "input": "n = 7, rounds = [1,3,5,7]",
                "output": "[1,2,3,4,5,6,7]"
            }
        ],
        "elixir_template": "defmodule Solution do\n  @spec most_visited(n :: integer, rounds :: [integer]) :: [integer]\n  def most_visited(n, rounds) do\n    \n  end\nend",
        "erlang_template": "-spec most_visited(N :: integer(), Rounds :: [integer()]) -> [integer()].\nmost_visited(N, Rounds) ->\n  .",
        "scala_template": "object Solution {\n    def mostVisited(n: Int, rounds: Array[Int]): List[Int] = {\n        \n    }\n}"
    },
    {
        "id": 1680,
        "name": "count-all-possible-routes",
        "difficulty": "Hard",
        "link": "https://leetcode.com/problems/count-all-possible-routes/",
        "task_description": "You are given an array of **distinct** positive integers locations where `locations[i]` represents the position of city `i`. You are also given integers `start`, `finish` and `fuel` representing the starting city, ending city, and the initial amount of fuel you have, respectively. At each step, if you are at city `i`, you can pick any city `j` such that `j != i` and `0 <= j < locations.length` and move to city `j`. Moving from city `i` to city `j` reduces the amount of fuel you have by `|locations[i] - locations[j]|`. Please notice that `|x|` denotes the absolute value of `x`. Notice that `fuel` **cannot** become negative at any point in time, and that you are **allowed** to visit any city more than once (including `start` and `finish`). Return _the count of all possible routes from _`start` _to_ `finish`. Since the answer may be too large, return it modulo `109 + 7`. **Example 1:** ``` **Input:** locations = [2,3,6,8,4], start = 1, finish = 3, fuel = 5 **Output:** 4 **Explanation:** The following are all possible routes, each uses 5 units of fuel: 1 -> 3 1 -> 2 -> 3 1 -> 4 -> 3 1 -> 4 -> 2 -> 3 ``` **Example 2:** ``` **Input:** locations = [4,3,1], start = 1, finish = 0, fuel = 6 **Output:** 5 **Explanation:** The following are all possible routes: 1 -> 0, used fuel = 1 1 -> 2 -> 0, used fuel = 5 1 -> 2 -> 1 -> 0, used fuel = 5 1 -> 0 -> 1 -> 0, used fuel = 3 1 -> 0 -> 1 -> 0 -> 1 -> 0, used fuel = 5 ``` **Example 3:** ``` **Input:** locations = [5,2,1], start = 0, finish = 2, fuel = 3 **Output:** 0 **Explanation:** It is impossible to get from 0 to 2 using only 3 units of fuel since the shortest route needs 4 units of fuel. ``` **Constraints:** `2 <= locations.length <= 100` `1 <= locations[i] <= 109` All integers in `locations` are **distinct**. `0 <= start, finish < locations.length` `1 <= fuel <= 200`",
        "test_case": [
            {
                "label": "Example 1",
                "input": "locations = [2,3,6,8,4], start = 1, finish = 3, fuel = 5",
                "output": "4 Explanation: The following are all possible routes, each uses 5 units of fuel:\n1 -> 3\n1 -> 2 -> 3\n1 -> 4 -> 3\n1 -> 4 -> 2 -> 3"
            },
            {
                "label": "Example 2",
                "input": "locations = [4,3,1], start = 1, finish = 0, fuel = 6",
                "output": "5 Explanation: The following are all possible routes:\n1 -> 0, used fuel = 1\n1 -> 2 -> 0, used fuel = 5\n1 -> 2 -> 1 -> 0, used fuel = 5\n1 -> 0 -> 1 -> 0, used fuel = 3\n1 -> 0 -> 1 -> 0 -> 1 -> 0, used fuel = 5"
            },
            {
                "label": "Example 3",
                "input": "locations = [5,2,1], start = 0, finish = 2, fuel = 3",
                "output": "0 Explanation: It is impossible to get from 0 to 2 using only 3 units of fuel since the shortest route needs 4 units of fuel."
            }
        ],
        "elixir_template": "defmodule Solution do\n  @spec count_routes(locations :: [integer], start :: integer, finish :: integer, fuel :: integer) :: integer\n  def count_routes(locations, start, finish, fuel) do\n    \n  end\nend",
        "erlang_template": "-spec count_routes(Locations :: [integer()], Start :: integer(), Finish :: integer(), Fuel :: integer()) -> integer().\ncount_routes(Locations, Start, Finish, Fuel) ->\n  .",
        "scala_template": "object Solution {\n    def countRoutes(locations: Array[Int], start: Int, finish: Int, fuel: Int): Int = {\n        \n    }\n}"
    },
    {
        "id": 1679,
        "name": "shortest-subarray-to-be-removed-to-make-array-sorted",
        "difficulty": "Medium",
        "link": "https://leetcode.com/problems/shortest-subarray-to-be-removed-to-make-array-sorted/",
        "task_description": "Given an integer array `arr`, remove a subarray (can be empty) from `arr` such that the remaining elements in `arr` are **non-decreasing**. Return _the length of the shortest subarray to remove_. A **subarray** is a contiguous subsequence of the array. **Example 1:** ``` **Input:** arr = [1,2,3,10,4,2,3,5] **Output:** 3 **Explanation:** The shortest subarray we can remove is [10,4,2] of length 3. The remaining elements after that will be [1,2,3,3,5] which are sorted. Another correct solution is to remove the subarray [3,10,4]. ``` **Example 2:** ``` **Input:** arr = [5,4,3,2,1] **Output:** 4 **Explanation:** Since the array is strictly decreasing, we can only keep a single element. Therefore we need to remove a subarray of length 4, either [5,4,3,2] or [4,3,2,1]. ``` **Example 3:** ``` **Input:** arr = [1,2,3] **Output:** 0 **Explanation:** The array is already non-decreasing. We do not need to remove any elements. ``` **Constraints:** `1 <= arr.length <= 105` `0 <= arr[i] <= 109`",
        "test_case": [
            {
                "label": "Example 1",
                "input": "arr = [1,2,3,10,4,2,3,5]",
                "output": "3 Explanation: The shortest subarray we can remove is [10,4,2] of length 3. The remaining elements after that will be [1,2,3,3,5] which are sorted.\nAnother correct solution is to remove the subarray [3,10,4]."
            },
            {
                "label": "Example 2",
                "input": "arr = [5,4,3,2,1]",
                "output": "4 Explanation: Since the array is strictly decreasing, we can only keep a single element. Therefore we need to remove a subarray of length 4, either [5,4,3,2] or [4,3,2,1]."
            },
            {
                "label": "Example 3",
                "input": "arr = [1,2,3]",
                "output": "0 Explanation: The array is already non-decreasing. We do not need to remove any elements."
            }
        ],
        "elixir_template": "defmodule Solution do\n  @spec find_length_of_shortest_subarray(arr :: [integer]) :: integer\n  def find_length_of_shortest_subarray(arr) do\n    \n  end\nend",
        "erlang_template": "-spec find_length_of_shortest_subarray(Arr :: [integer()]) -> integer().\nfind_length_of_shortest_subarray(Arr) ->\n  .",
        "scala_template": "object Solution {\n    def findLengthOfShortestSubarray(arr: Array[Int]): Int = {\n        \n    }\n}"
    },
    {
        "id": 1678,
        "name": "number-of-ways-to-split-a-string",
        "difficulty": "Medium",
        "link": "https://leetcode.com/problems/number-of-ways-to-split-a-string/",
        "task_description": "Given a binary string `s`, you can split `s` into 3 **non-empty** strings `s1`, `s2`, and `s3` where `s1 + s2 + s3 = s`. Return the number of ways `s` can be split such that the number of ones is the same in `s1`, `s2`, and `s3`. Since the answer may be too large, return it **modulo** `109 + 7`. **Example 1:** ``` **Input:** s = \"10101\" **Output:** 4 **Explanation:** There are four ways to split s in 3 parts where each part contain the same number of letters '1'. \"1|010|1\" \"1|01|01\" \"10|10|1\" \"10|1|01\" ``` **Example 2:** ``` **Input:** s = \"1001\" **Output:** 0 ``` **Example 3:** ``` **Input:** s = \"0000\" **Output:** 3 **Explanation:** There are three ways to split s in 3 parts. \"0|0|00\" \"0|00|0\" \"00|0|0\" ``` **Constraints:** `3 <= s.length <= 105` `s[i]` is either `'0'` or `'1'`.",
        "test_case": [
            {
                "label": "Example 1",
                "input": "s = \"10101\"",
                "output": "4 Explanation: There are four ways to split s in 3 parts where each part contain the same number of letters '1'.\n\"1|010|1\"\n\"1|01|01\"\n\"10|10|1\"\n\"10|1|01\""
            },
            {
                "label": "Example 2",
                "input": "s = \"1001\"",
                "output": "0"
            },
            {
                "label": "Example 3",
                "input": "s = \"0000\"",
                "output": "3 Explanation: There are three ways to split s in 3 parts.\n\"0|0|00\"\n\"0|00|0\"\n\"00|0|0\""
            }
        ],
        "elixir_template": "defmodule Solution do\n  @spec num_ways(s :: String.t) :: integer\n  def num_ways(s) do\n    \n  end\nend",
        "erlang_template": "-spec num_ways(S :: unicode:unicode_binary()) -> integer().\nnum_ways(S) ->\n  .",
        "scala_template": "object Solution {\n    def numWays(s: String): Int = {\n        \n    }\n}"
    },
    {
        "id": 1677,
        "name": "matrix-diagonal-sum",
        "difficulty": "Easy",
        "link": "https://leetcode.com/problems/matrix-diagonal-sum/",
        "task_description": "Given a square matrix `mat`, return the sum of the matrix diagonals. Only include the sum of all the elements on the primary diagonal and all the elements on the secondary diagonal that are not part of the primary diagonal. **Example 1:** ``` **Input:** mat = [[**1**,2,**3**], [4,**5**,6], [**7**,8,**9**]] **Output:** 25 **Explanation: **Diagonals sum: 1 + 5 + 9 + 3 + 7 = 25 Notice that element mat[1][1] = 5 is counted only once. ``` **Example 2:** ``` **Input:** mat = [[**1**,1,1,**1**], [1,**1**,**1**,1], [1,**1**,**1**,1], [**1**,1,1,**1**]] **Output:** 8 ``` **Example 3:** ``` **Input:** mat = [[**5**]] **Output:** 5 ``` **Constraints:** `n == mat.length == mat[i].length` `1 <= n <= 100` `1 <= mat[i][j] <= 100`",
        "test_case": [
            {
                "label": "Example 1",
                "input": "mat = [[ 1 ,2, 3 ],\n\u00a0             [4, 5 ,6],\n\u00a0             [ 7 ,8, 9 ]]",
                "output": "25 Explanation: Diagonals sum: 1 + 5 + 9 + 3 + 7 = 25\nNotice that element mat[1][1] = 5 is counted only once."
            },
            {
                "label": "Example 2",
                "input": "mat = [[ 1 ,1,1, 1 ],\n\u00a0             [1, 1 , 1 ,1],\n\u00a0             [1, 1 , 1 ,1],\n\u00a0             [ 1 ,1,1, 1 ]]",
                "output": "8"
            },
            {
                "label": "Example 3",
                "input": "mat = [[ 5 ]]",
                "output": "5 Constraints: n == mat.length == mat[i].length 1 <= n <= 100 1 <= mat[i][j] <= 100"
            }
        ],
        "elixir_template": "defmodule Solution do\n  @spec diagonal_sum(mat :: [[integer]]) :: integer\n  def diagonal_sum(mat) do\n    \n  end\nend",
        "erlang_template": "-spec diagonal_sum(Mat :: [[integer()]]) -> integer().\ndiagonal_sum(Mat) ->\n  .",
        "scala_template": "object Solution {\n    def diagonalSum(mat: Array[Array[Int]]): Int = {\n        \n    }\n}"
    },
    {
        "id": 1676,
        "name": "minimum-number-of-days-to-eat-n-oranges",
        "difficulty": "Hard",
        "link": "https://leetcode.com/problems/minimum-number-of-days-to-eat-n-oranges/",
        "task_description": "There are `n` oranges in the kitchen and you decided to eat some of these oranges every day as follows: Eat one orange. If the number of remaining oranges `n` is divisible by `2` then you can eat `n / 2` oranges. If the number of remaining oranges `n` is divisible by `3` then you can eat `2 * (n / 3)` oranges. You can only choose one of the actions per day. Given the integer `n`, return _the minimum number of days to eat_ `n` _oranges_. **Example 1:** ``` **Input:** n = 10 **Output:** 4 **Explanation:** You have 10 oranges. Day 1: Eat 1 orange, 10 - 1 = 9. Day 2: Eat 6 oranges, 9 - 2*(9/3) = 9 - 6 = 3. (Since 9 is divisible by 3) Day 3: Eat 2 oranges, 3 - 2*(3/3) = 3 - 2 = 1. Day 4: Eat the last orange 1 - 1 = 0. You need at least 4 days to eat the 10 oranges. ``` **Example 2:** ``` **Input:** n = 6 **Output:** 3 **Explanation:** You have 6 oranges. Day 1: Eat 3 oranges, 6 - 6/2 = 6 - 3 = 3. (Since 6 is divisible by 2). Day 2: Eat 2 oranges, 3 - 2*(3/3) = 3 - 2 = 1. (Since 3 is divisible by 3) Day 3: Eat the last orange 1 - 1 = 0. You need at least 3 days to eat the 6 oranges. ``` **Constraints:** `1 <= n <= 2 * 109`",
        "test_case": [
            {
                "label": "Example 1",
                "input": "n = 10",
                "output": "4 Explanation: You have 10 oranges.\nDay 1: Eat 1 orange,  10 - 1 = 9.  \nDay 2: Eat 6 oranges, 9 - 2*(9/3) = 9 - 6 = 3. (Since 9 is divisible by 3)\nDay 3: Eat 2 oranges, 3 - 2*(3/3) = 3 - 2 = 1. \nDay 4: Eat the last orange  1 - 1  = 0.\nYou need at least 4 days to eat the 10 oranges."
            },
            {
                "label": "Example 2",
                "input": "n = 6",
                "output": "3 Explanation: You have 6 oranges.\nDay 1: Eat 3 oranges, 6 - 6/2 = 6 - 3 = 3. (Since 6 is divisible by 2).\nDay 2: Eat 2 oranges, 3 - 2*(3/3) = 3 - 2 = 1. (Since 3 is divisible by 3)\nDay 3: Eat the last orange  1 - 1  = 0.\nYou need at least 3 days to eat the 6 oranges."
            }
        ],
        "elixir_template": "defmodule Solution do\n  @spec min_days(n :: integer) :: integer\n  def min_days(n) do\n    \n  end\nend",
        "erlang_template": "-spec min_days(N :: integer()) -> integer().\nmin_days(N) ->\n  .",
        "scala_template": "object Solution {\n    def minDays(n: Int): Int = {\n        \n    }\n}"
    },
    {
        "id": 1675,
        "name": "magnetic-force-between-two-balls",
        "difficulty": "Medium",
        "link": "https://leetcode.com/problems/magnetic-force-between-two-balls/",
        "task_description": "In the universe Earth C-137, Rick discovered a special form of magnetic force between two balls if they are put in his new invented basket. Rick has `n` empty baskets, the `ith` basket is at `position[i]`, Morty has `m` balls and needs to distribute the balls into the baskets such that the **minimum magnetic force** between any two balls is **maximum**. Rick stated that magnetic force between two different balls at positions `x` and `y` is `|x - y|`. Given the integer array `position` and the integer `m`. Return _the required force_. **Example 1:** ``` **Input:** position = [1,2,3,4,7], m = 3 **Output:** 3 **Explanation:** Distributing the 3 balls into baskets 1, 4 and 7 will make the magnetic force between ball pairs [3, 3, 6]. The minimum magnetic force is 3. We cannot achieve a larger minimum magnetic force than 3. ``` **Example 2:** ``` **Input:** position = [5,4,3,2,1,1000000000], m = 2 **Output:** 999999999 **Explanation:** We can use baskets 1 and 1000000000. ``` **Constraints:** `n == position.length` `2 <= n <= 105` `1 <= position[i] <= 109` All integers in `position` are **distinct**. `2 <= m <= position.length`",
        "test_case": [
            {
                "label": "Example 1",
                "input": "position = [1,2,3,4,7], m = 3",
                "output": "3 Explanation: Distributing the 3 balls into baskets 1, 4 and 7 will make the magnetic force between ball pairs [3, 3, 6]. The minimum magnetic force is 3. We cannot achieve a larger minimum magnetic force than 3."
            },
            {
                "label": "Example 2",
                "input": "position = [5,4,3,2,1,1000000000], m = 2",
                "output": "999999999 Explanation: We can use baskets 1 and 1000000000. Constraints: n == position.length 2 <= n <= 10 5 1 <= position[i] <= 10 9 All integers in position are distinct . 2 <= m <= position.length"
            }
        ],
        "elixir_template": "defmodule Solution do\n  @spec max_distance(position :: [integer], m :: integer) :: integer\n  def max_distance(position, m) do\n    \n  end\nend",
        "erlang_template": "-spec max_distance(Position :: [integer()], M :: integer()) -> integer().\nmax_distance(Position, M) ->\n  .",
        "scala_template": "object Solution {\n    def maxDistance(position: Array[Int], m: Int): Int = {\n        \n    }\n}"
    },
    {
        "id": 1674,
        "name": "minimum-operations-to-make-array-equal",
        "difficulty": "Medium",
        "link": "https://leetcode.com/problems/minimum-operations-to-make-array-equal/",
        "task_description": "You have an array `arr` of length `n` where `arr[i] = (2 * i) + 1` for all valid values of `i` (i.e., `0 <= i < n`). In one operation, you can select two indices `x` and `y` where `0 <= x, y < n` and subtract `1` from `arr[x]` and add `1` to `arr[y]` (i.e., perform `arr[x] -=1 `and `arr[y] += 1`). The goal is to make all the elements of the array **equal**. It is **guaranteed** that all the elements of the array can be made equal using some operations. Given an integer `n`, the length of the array, return _the minimum number of operations_ needed to make all the elements of arr equal. **Example 1:** ``` **Input:** n = 3 **Output:** 2 **Explanation:** arr = [1, 3, 5] First operation choose x = 2 and y = 0, this leads arr to be [2, 3, 4] In the second operation choose x = 2 and y = 0 again, thus arr = [3, 3, 3]. ``` **Example 2:** ``` **Input:** n = 6 **Output:** 9 ``` **Constraints:** `1 <= n <= 104`",
        "test_case": [
            {
                "label": "Example 1",
                "input": "n = 3",
                "output": "2 Explanation: arr = [1, 3, 5]\nFirst operation choose x = 2 and y = 0, this leads arr to be [2, 3, 4]\nIn the second operation choose x = 2 and y = 0 again, thus arr = [3, 3, 3]."
            },
            {
                "label": "Example 2",
                "input": "n = 6",
                "output": "9"
            }
        ],
        "elixir_template": "defmodule Solution do\n  @spec min_operations(n :: integer) :: integer\n  def min_operations(n) do\n    \n  end\nend",
        "erlang_template": "-spec min_operations(N :: integer()) -> integer().\nmin_operations(N) ->\n  .",
        "scala_template": "object Solution {\n    def minOperations(n: Int): Int = {\n        \n    }\n}"
    },
    {
        "id": 1669,
        "name": "minimum-cost-to-cut-a-stick",
        "difficulty": "Hard",
        "link": "https://leetcode.com/problems/minimum-cost-to-cut-a-stick/",
        "task_description": "Given a wooden stick of length `n` units. The stick is labelled from `0` to `n`. For example, a stick of length **6** is labelled as follows: Given an integer array `cuts` where `cuts[i]` denotes a position you should perform a cut at. You should perform the cuts in order, you can change the order of the cuts as you wish. The cost of one cut is the length of the stick to be cut, the total cost is the sum of costs of all cuts. When you cut a stick, it will be split into two smaller sticks (i.e. the sum of their lengths is the length of the stick before the cut). Please refer to the first example for a better explanation. Return _the minimum total cost_ of the cuts. **Example 1:** ``` **Input:** n = 7, cuts = [1,3,4,5] **Output:** 16 **Explanation:** Using cuts order = [1, 3, 4, 5] as in the input leads to the following scenario: The first cut is done to a rod of length 7 so the cost is 7. The second cut is done to a rod of length 6 (i.e. the second part of the first cut), the third is done to a rod of length 4 and the last cut is to a rod of length 3. The total cost is 7 + 6 + 4 + 3 = 20. Rearranging the cuts to be [3, 5, 1, 4] for example will lead to a scenario with total cost = 16 (as shown in the example photo 7 + 4 + 3 + 2 = 16). ``` **Example 2:** ``` **Input:** n = 9, cuts = [5,6,1,4,2] **Output:** 22 **Explanation:** If you try the given cuts ordering the cost will be 25. There are much ordering with total cost <= 25, for example, the order [4, 6, 5, 2, 1] has total cost = 22 which is the minimum possible. ``` **Constraints:** `2 <= n <= 106` `1 <= cuts.length <= min(n - 1, 100)` `1 <= cuts[i] <= n - 1` All the integers in `cuts` array are **distinct**.",
        "test_case": [
            {
                "label": "Example 1",
                "input": "n = 7, cuts = [1,3,4,5]",
                "output": "16 Explanation: Using cuts order = [1, 3, 4, 5] as in the input leads to the following scenario: The first cut is done to a rod of length 7 so the cost is 7. The second cut is done to a rod of length 6 (i.e. the second part of the first cut), the third is done to a rod of length 4 and the last cut is to a rod of length 3. The total cost is 7 + 6 + 4 + 3 = 20.\nRearranging the cuts to be [3, 5, 1, 4] for example will lead to a scenario with total cost = 16 (as shown in the example photo 7 + 4 + 3 + 2 = 16)."
            },
            {
                "label": "Example 2",
                "input": "n = 9, cuts = [5,6,1,4,2]",
                "output": "22 Explanation: If you try the given cuts ordering the cost will be 25.\nThere are much ordering with total cost <= 25, for example, the order [4, 6, 5, 2, 1] has total cost = 22 which is the minimum possible."
            }
        ],
        "elixir_template": "defmodule Solution do\n  @spec min_cost(n :: integer, cuts :: [integer]) :: integer\n  def min_cost(n, cuts) do\n    \n  end\nend",
        "erlang_template": "-spec min_cost(N :: integer(), Cuts :: [integer()]) -> integer().\nmin_cost(N, Cuts) ->\n  .",
        "scala_template": "object Solution {\n    def minCost(n: Int, cuts: Array[Int]): Int = {\n        \n    }\n}"
    },
    {
        "id": 1668,
        "name": "find-longest-awesome-substring",
        "difficulty": "Hard",
        "link": "https://leetcode.com/problems/find-longest-awesome-substring/",
        "task_description": "You are given a string `s`. An **awesome** substring is a non-empty substring of `s` such that we can make any number of swaps in order to make it a palindrome. Return _the length of the maximum length **awesome substring** of_ `s`. **Example 1:** ``` **Input:** s = \"3242415\" **Output:** 5 **Explanation:** \"24241\" is the longest awesome substring, we can form the palindrome \"24142\" with some swaps. ``` **Example 2:** ``` **Input:** s = \"12345678\" **Output:** 1 ``` **Example 3:** ``` **Input:** s = \"213123\" **Output:** 6 **Explanation:** \"213123\" is the longest awesome substring, we can form the palindrome \"231132\" with some swaps. ``` **Constraints:** `1 <= s.length <= 105` `s` consists only of digits.",
        "test_case": [
            {
                "label": "Example 1",
                "input": "s = \"3242415\"",
                "output": "5 Explanation: \"24241\" is the longest awesome substring, we can form the palindrome \"24142\" with some swaps."
            },
            {
                "label": "Example 2",
                "input": "s = \"12345678\"",
                "output": "1"
            },
            {
                "label": "Example 3",
                "input": "s = \"213123\"",
                "output": "6 Explanation: \"213123\" is the longest awesome substring, we can form the palindrome \"231132\" with some swaps."
            }
        ],
        "elixir_template": "defmodule Solution do\n  @spec longest_awesome(s :: String.t) :: integer\n  def longest_awesome(s) do\n    \n  end\nend",
        "erlang_template": "-spec longest_awesome(S :: unicode:unicode_binary()) -> integer().\nlongest_awesome(S) ->\n  .",
        "scala_template": "object Solution {\n    def longestAwesome(s: String): Int = {\n        \n    }\n}"
    },
    {
        "id": 1667,
        "name": "find-kth-bit-in-nth-binary-string",
        "difficulty": "Medium",
        "link": "https://leetcode.com/problems/find-kth-bit-in-nth-binary-string/",
        "task_description": "Given two positive integers `n` and `k`, the binary string `Sn` is formed as follows: `S1 = \"0\"` `Si = Si - 1 + \"1\" + reverse(invert(Si - 1))` for `i > 1` Where `+` denotes the concatenation operation, `reverse(x)` returns the reversed string `x`, and `invert(x)` inverts all the bits in `x` (`0` changes to `1` and `1` changes to `0`). For example, the first four strings in the above sequence are: `S1 = \"0\"` `S2 = \"0**1**1\"` `S3 = \"011**1**001\"` `S4 = \"0111001**1**0110001\"` Return _the_ `kth` _bit_ _in_ `Sn`. It is guaranteed that `k` is valid for the given `n`. **Example 1:** ``` **Input:** n = 3, k = 1 **Output:** \"0\" **Explanation:** S3 is \"**0**111001\". The 1st bit is \"0\". ``` **Example 2:** ``` **Input:** n = 4, k = 11 **Output:** \"1\" **Explanation:** S4 is \"0111001101**1**0001\". The 11th bit is \"1\". ``` **Constraints:** `1 <= n <= 20` `1 <= k <= 2n - 1`",
        "test_case": [
            {
                "label": "Example 1",
                "input": "n = 3, k = 1",
                "output": "\"0\" Explanation: S 3 is \" 0 111001\".\nThe 1 st bit is \"0\"."
            },
            {
                "label": "Example 2",
                "input": "n = 4, k = 11",
                "output": "\"1\" Explanation: S 4 is \"0111001101 1 0001\".\nThe 11 th bit is \"1\"."
            }
        ],
        "elixir_template": "defmodule Solution do\n  @spec find_kth_bit(n :: integer, k :: integer) :: char\n  def find_kth_bit(n, k) do\n    \n  end\nend",
        "erlang_template": "-spec find_kth_bit(N :: integer(), K :: integer()) -> char().\nfind_kth_bit(N, K) ->\n  .",
        "scala_template": "object Solution {\n    def findKthBit(n: Int, k: Int): Char = {\n        \n    }\n}"
    },
    {
        "id": 1666,
        "name": "make-the-string-great",
        "difficulty": "Easy",
        "link": "https://leetcode.com/problems/make-the-string-great/",
        "task_description": "Given a string `s` of lower and upper case English letters. A good string is a string which doesn't have **two adjacent characters** `s[i]` and `s[i + 1]` where: `0 <= i <= s.length - 2` `s[i]` is a lower-case letter and `s[i + 1]` is the same letter but in upper-case or **vice-versa**. To make the string good, you can choose **two adjacent** characters that make the string bad and remove them. You can keep doing this until the string becomes good. Return _the string_ after making it good. The answer is guaranteed to be unique under the given constraints. **Notice** that an empty string is also good. **Example 1:** ``` **Input:** s = \"leEeetcode\" **Output:** \"leetcode\" **Explanation:** In the first step, either you choose i = 1 or i = 2, both will result \"leEeetcode\" to be reduced to \"leetcode\". ``` **Example 2:** ``` **Input:** s = \"abBAcC\" **Output:** \"\" **Explanation:** We have many possible scenarios, and all lead to the same answer. For example: \"abBAcC\" --> \"aAcC\" --> \"cC\" --> \"\" \"abBAcC\" --> \"abBA\" --> \"aA\" --> \"\" ``` **Example 3:** ``` **Input:** s = \"s\" **Output:** \"s\" ``` **Constraints:** `1 <= s.length <= 100` `s` contains only lower and upper case English letters.",
        "test_case": [
            {
                "label": "Example 1",
                "input": "s = \"leEeetcode\"",
                "output": "\"leetcode\" Explanation: In the first step, either you choose i = 1 or i = 2, both will result \"leEeetcode\" to be reduced to \"leetcode\"."
            },
            {
                "label": "Example 2",
                "input": "s = \"abBAcC\"",
                "output": "\"\" Explanation: We have many possible scenarios, and all lead to the same answer. For example:\n\"abBAcC\" --> \"aAcC\" --> \"cC\" --> \"\"\n\"abBAcC\" --> \"abBA\" --> \"aA\" --> \"\""
            },
            {
                "label": "Example 3",
                "input": "s = \"s\"",
                "output": "\"s\""
            }
        ],
        "elixir_template": "defmodule Solution do\n  @spec make_good(s :: String.t) :: String.t\n  def make_good(s) do\n    \n  end\nend",
        "erlang_template": "-spec make_good(S :: unicode:unicode_binary()) -> unicode:unicode_binary().\nmake_good(S) ->\n  .",
        "scala_template": "object Solution {\n    def makeGood(s: String): String = {\n        \n    }\n}"
    },
    {
        "id": 1663,
        "name": "detect-cycles-in-2d-grid",
        "difficulty": "Medium",
        "link": "https://leetcode.com/problems/detect-cycles-in-2d-grid/",
        "task_description": "Given a 2D array of characters `grid` of size `m x n`, you need to find if there exists any cycle consisting of the **same value** in `grid`. A cycle is a path of **length 4 or more** in the grid that starts and ends at the same cell. From a given cell, you can move to one of the cells adjacent to it - in one of the four directions (up, down, left, or right), if it has the **same value** of the current cell. Also, you cannot move to the cell that you visited in your last move. For example, the cycle `(1, 1) -> (1, 2) -> (1, 1)` is invalid because from `(1, 2)` we visited `(1, 1)` which was the last visited cell. Return `true` if any cycle of the same value exists in `grid`, otherwise, return `false`. **Example 1:** **** ``` **Input:** grid = [[\"a\",\"a\",\"a\",\"a\"],[\"a\",\"b\",\"b\",\"a\"],[\"a\",\"b\",\"b\",\"a\"],[\"a\",\"a\",\"a\",\"a\"]] **Output:** true **Explanation: **There are two valid cycles shown in different colors in the image below: ``` **Example 2:** **** ``` **Input:** grid = [[\"c\",\"c\",\"c\",\"a\"],[\"c\",\"d\",\"c\",\"c\"],[\"c\",\"c\",\"e\",\"c\"],[\"f\",\"c\",\"c\",\"c\"]] **Output:** true **Explanation: **There is only one valid cycle highlighted in the image below: ``` **Example 3:** **** ``` **Input:** grid = [[\"a\",\"b\",\"b\"],[\"b\",\"z\",\"b\"],[\"b\",\"b\",\"a\"]] **Output:** false ``` **Constraints:** `m == grid.length` `n == grid[i].length` `1 <= m, n <= 500` `grid` consists only of lowercase English letters.",
        "test_case": [
            {
                "label": "Example 1",
                "input": "grid = [[\"a\",\"a\",\"a\",\"a\"],[\"a\",\"b\",\"b\",\"a\"],[\"a\",\"b\",\"b\",\"a\"],[\"a\",\"a\",\"a\",\"a\"]]",
                "output": "true Explanation: There are two valid cycles shown in different colors in the image below:"
            },
            {
                "label": "Example 2",
                "input": "grid = [[\"c\",\"c\",\"c\",\"a\"],[\"c\",\"d\",\"c\",\"c\"],[\"c\",\"c\",\"e\",\"c\"],[\"f\",\"c\",\"c\",\"c\"]]",
                "output": "true Explanation: There is only one valid cycle highlighted in the image below:"
            },
            {
                "label": "Example 3",
                "input": "grid = [[\"a\",\"b\",\"b\"],[\"b\",\"z\",\"b\"],[\"b\",\"b\",\"a\"]]",
                "output": "false Constraints: m == grid.length n == grid[i].length 1 <= m, n <= 500 grid consists only of lowercase English letters."
            }
        ],
        "elixir_template": "defmodule Solution do\n  @spec contains_cycle(grid :: [[char]]) :: boolean\n  def contains_cycle(grid) do\n    \n  end\nend",
        "erlang_template": "-spec contains_cycle(Grid :: [[char()]]) -> boolean().\ncontains_cycle(Grid) ->\n  .",
        "scala_template": "object Solution {\n    def containsCycle(grid: Array[Array[Char]]): Boolean = {\n        \n    }\n}"
    },
    {
        "id": 1662,
        "name": "minimum-numbers-of-function-calls-to-make-target-array",
        "difficulty": "Medium",
        "link": "https://leetcode.com/problems/minimum-numbers-of-function-calls-to-make-target-array/",
        "task_description": "You are given an integer array `nums`. You have an integer array `arr` of the same length with all values set to `0` initially. You also have the following `modify` function: You want to use the modify function to convert `arr` to `nums` using the minimum number of calls. Return _the minimum number of function calls to make _`nums`_ from _`arr`. The test cases are generated so that the answer fits in a **32-bit** signed integer. **Example 1:** ``` **Input:** nums = [1,5] **Output:** 5 **Explanation:** Increment by 1 (second element): [0, 0] to get [0, 1] (1 operation). Double all the elements: [0, 1] -> [0, 2] -> [0, 4] (2 operations). Increment by 1 (both elements) [0, 4] -> [1, 4] -> **[1, 5]** (2 operations). Total of operations: 1 + 2 + 2 = 5. ``` **Example 2:** ``` **Input:** nums = [2,2] **Output:** 3 **Explanation:** Increment by 1 (both elements) [0, 0] -> [0, 1] -> [1, 1] (2 operations). Double all the elements: [1, 1] -> **[2, 2]** (1 operation). Total of operations: 2 + 1 = 3. ``` **Example 3:** ``` **Input:** nums = [4,2,5] **Output:** 6 **Explanation:** (initial)[0,0,0] -> [1,0,0] -> [1,0,1] -> [2,0,2] -> [2,1,2] -> [4,2,4] -> **[4,2,5]**(nums). ``` **Constraints:** `1 <= nums.length <= 105` `0 <= nums[i] <= 109`",
        "test_case": [
            {
                "label": "Example 1",
                "input": "nums = [1,5]",
                "output": "5 Explanation: Increment by 1 (second element): [0, 0] to get [0, 1] (1 operation).\nDouble all the elements: [0, 1] -> [0, 2] -> [0, 4] (2 operations).\nIncrement by 1 (both elements)  [0, 4] -> [1, 4] -> [1, 5] (2 operations).\nTotal of operations: 1 + 2 + 2 = 5."
            },
            {
                "label": "Example 2",
                "input": "nums = [2,2]",
                "output": "3 Explanation: Increment by 1 (both elements) [0, 0] -> [0, 1] -> [1, 1] (2 operations).\nDouble all the elements: [1, 1] -> [2, 2] (1 operation).\nTotal of operations: 2 + 1 = 3."
            },
            {
                "label": "Example 3",
                "input": "nums = [4,2,5]",
                "output": "6 Explanation: (initial)[0,0,0] -> [1,0,0] -> [1,0,1] -> [2,0,2] -> [2,1,2] -> [4,2,4] -> [4,2,5] (nums)."
            }
        ],
        "elixir_template": "defmodule Solution do\n  @spec min_operations(nums :: [integer]) :: integer\n  def min_operations(nums) do\n    \n  end\nend",
        "erlang_template": "-spec min_operations(Nums :: [integer()]) -> integer().\nmin_operations(Nums) ->\n  .",
        "scala_template": "object Solution {\n    def minOperations(nums: Array[Int]): Int = {\n        \n    }\n}"
    },
    {
        "id": 1661,
        "name": "minimum-number-of-vertices-to-reach-all-nodes",
        "difficulty": "Medium",
        "link": "https://leetcode.com/problems/minimum-number-of-vertices-to-reach-all-nodes/",
        "task_description": "Given a** directed acyclic graph**, with `n` vertices numbered from `0` to `n-1`, and an array `edges` where `edges[i] = [fromi, toi]` represents a directed edge from node `fromi` to node `toi`. Find _the smallest set of vertices from which all nodes in the graph are reachable_. It's guaranteed that a unique solution exists. Notice that you can return the vertices in any order. **Example 1:** ``` **Input:** n = 6, edges = [[0,1],[0,2],[2,5],[3,4],[4,2]] **Output:** [0,3] Explanation: It's not possible to reach all the nodes from a single vertex. From 0 we can reach [0,1,2,5]. From 3 we can reach [3,4,2,5]. So we output [0,3]. ``` **Example 2:** ``` **Input:** n = 5, edges = [[0,1],[2,1],[3,1],[1,4],[2,4]] **Output:** [0,2,3] **Explanation: **Notice that vertices 0, 3 and 2 are not reachable from any other node, so we must include them. Also any of these vertices can reach nodes 1 and 4. ``` **Constraints:** `2 <= n <= 10^5` `1 <= edges.length <= min(10^5, n * (n - 1) / 2)` `edges[i].length == 2` `0 <= fromi, toi < n` All pairs `(fromi, toi)` are distinct.",
        "test_case": [
            {
                "label": "Example 1",
                "input": "n = 6, edges = [[0,1],[0,2],[2,5],[3,4],[4,2]]",
                "output": "[0,3] Explanation: It's not possible to reach all the nodes from a single vertex. From 0 we can reach [0,1,2,5]. From 3 we can reach [3,4,2,5]. So we output [0,3]."
            },
            {
                "label": "Example 2",
                "input": "n = 5, edges = [[0,1],[2,1],[3,1],[1,4],[2,4]]",
                "output": "[0,2,3] Explanation: Notice that vertices 0, 3 and 2 are not reachable from any other node, so we must include them. Also any of these vertices can reach nodes 1 and 4."
            }
        ],
        "elixir_template": "defmodule Solution do\n  @spec find_smallest_set_of_vertices(n :: integer, edges :: [[integer]]) :: [integer]\n  def find_smallest_set_of_vertices(n, edges) do\n    \n  end\nend",
        "erlang_template": "-spec find_smallest_set_of_vertices(N :: integer(), Edges :: [[integer()]]) -> [integer()].\nfind_smallest_set_of_vertices(N, Edges) ->\n  .",
        "scala_template": "object Solution {\n    def findSmallestSetOfVertices(n: Int, edges: List[List[Int]]): List[Int] = {\n        \n    }\n}"
    },
    {
        "id": 1660,
        "name": "thousand-separator",
        "difficulty": "Easy",
        "link": "https://leetcode.com/problems/thousand-separator/",
        "task_description": "Given an integer `n`, add a dot (\".\") as the thousands separator and return it in string format. **Example 1:** ``` **Input:** n = 987 **Output:** \"987\" ``` **Example 2:** ``` **Input:** n = 1234 **Output:** \"1.234\" ``` **Constraints:** `0 <= n <= 231 - 1`",
        "test_case": [
            {
                "label": "Example 1",
                "input": "n = 987",
                "output": "\"987\""
            },
            {
                "label": "Example 2",
                "input": "n = 1234",
                "output": "\"1.234\""
            }
        ],
        "elixir_template": "defmodule Solution do\n  @spec thousand_separator(n :: integer) :: String.t\n  def thousand_separator(n) do\n    \n  end\nend",
        "erlang_template": "-spec thousand_separator(N :: integer()) -> unicode:unicode_binary().\nthousand_separator(N) ->\n  .",
        "scala_template": "object Solution {\n    def thousandSeparator(n: Int): String = {\n        \n    }\n}"
    },
    {
        "id": 1659,
        "name": "get-the-maximum-score",
        "difficulty": "Hard",
        "link": "https://leetcode.com/problems/get-the-maximum-score/",
        "task_description": "You are given two **sorted** arrays of distinct integers `nums1` and `nums2`. A **valid**_ _**path** is defined as follows: Choose array `nums1` or `nums2` to traverse (from index-0). Traverse the current array from left to right. If you are reading any value that is present in `nums1` and `nums2` you are allowed to change your path to the other array. (Only one repeated value is considered in the valid path). The **score** is defined as the sum of unique values in a valid path. Return _the maximum score you can obtain of all possible **valid paths**_. Since the answer may be too large, return it modulo `109 + 7`. **Example 1:** ``` **Input:** nums1 = [2,4,5,8,10], nums2 = [4,6,8,9] **Output:** 30 **Explanation:** Valid paths: [2,4,5,8,10], [2,4,5,8,9], [2,4,6,8,9], [2,4,6,8,10], (starting from nums1) [4,6,8,9], [4,5,8,10], [4,5,8,9], [4,6,8,10] (starting from nums2) The maximum is obtained with the path in green **[2,4,6,8,10]**. ``` **Example 2:** ``` **Input:** nums1 = [1,3,5,7,9], nums2 = [3,5,100] **Output:** 109 **Explanation:** Maximum sum is obtained with the path **[1,3,5,100]**. ``` **Example 3:** ``` **Input:** nums1 = [1,2,3,4,5], nums2 = [6,7,8,9,10] **Output:** 40 **Explanation:** There are no common elements between nums1 and nums2. Maximum sum is obtained with the path [6,7,8,9,10]. ``` **Constraints:** `1 <= nums1.length, nums2.length <= 105` `1 <= nums1[i], nums2[i] <= 107` `nums1` and `nums2` are strictly increasing.",
        "test_case": [
            {
                "label": "Example 1",
                "input": "nums1 = [2,4,5,8,10], nums2 = [4,6,8,9]",
                "output": "30 Explanation: Valid paths:\n[2,4,5,8,10], [2,4,5,8,9], [2,4,6,8,9], [2,4,6,8,10],  (starting from nums1)\n[4,6,8,9], [4,5,8,10], [4,5,8,9], [4,6,8,10]    (starting from nums2)\nThe maximum is obtained with the path in green [2,4,6,8,10] ."
            },
            {
                "label": "Example 2",
                "input": "nums1 = [1,3,5,7,9], nums2 = [3,5,100]",
                "output": "109 Explanation: Maximum sum is obtained with the path [1,3,5,100] ."
            },
            {
                "label": "Example 3",
                "input": "nums1 = [1,2,3,4,5], nums2 = [6,7,8,9,10]",
                "output": "40 Explanation: There are no common elements between nums1 and nums2.\nMaximum sum is obtained with the path [6,7,8,9,10]."
            }
        ],
        "elixir_template": "defmodule Solution do\n  @spec max_sum(nums1 :: [integer], nums2 :: [integer]) :: integer\n  def max_sum(nums1, nums2) do\n    \n  end\nend",
        "erlang_template": "-spec max_sum(Nums1 :: [integer()], Nums2 :: [integer()]) -> integer().\nmax_sum(Nums1, Nums2) ->\n  .",
        "scala_template": "object Solution {\n    def maxSum(nums1: Array[Int], nums2: Array[Int]): Int = {\n        \n    }\n}"
    },
    {
        "id": 1658,
        "name": "minimum-swaps-to-arrange-a-binary-grid",
        "difficulty": "Medium",
        "link": "https://leetcode.com/problems/minimum-swaps-to-arrange-a-binary-grid/",
        "task_description": "Given an `n x n` binary `grid`, in one step you can choose two **adjacent rows** of the grid and swap them. A grid is said to be **valid** if all the cells above the main diagonal are **zeros**. Return _the minimum number of steps_ needed to make the grid valid, or **-1** if the grid cannot be valid. The main diagonal of a grid is the diagonal that starts at cell `(1, 1)` and ends at cell `(n, n)`. **Example 1:** ``` **Input:** grid = [[0,0,1],[1,1,0],[1,0,0]] **Output:** 3 ``` **Example 2:** ``` **Input:** grid = [[0,1,1,0],[0,1,1,0],[0,1,1,0],[0,1,1,0]] **Output:** -1 **Explanation:** All rows are similar, swaps have no effect on the grid. ``` **Example 3:** ``` **Input:** grid = [[1,0,0],[1,1,0],[1,1,1]] **Output:** 0 ``` **Constraints:** `n == grid.length` `== grid[i].length` `1 <= n <= 200` `grid[i][j]` is either `0` or `1`",
        "test_case": [
            {
                "label": "Example 1",
                "input": "grid = [[0,0,1],[1,1,0],[1,0,0]]",
                "output": "3"
            },
            {
                "label": "Example 2",
                "input": "grid = [[0,1,1,0],[0,1,1,0],[0,1,1,0],[0,1,1,0]]",
                "output": "-1 Explanation: All rows are similar, swaps have no effect on the grid."
            },
            {
                "label": "Example 3",
                "input": "grid = [[1,0,0],[1,1,0],[1,1,1]]",
                "output": "0 Constraints: n == grid.length == grid[i].length 1 <= n <= 200 grid[i][j] is either 0 or 1"
            }
        ],
        "elixir_template": "defmodule Solution do\n  @spec min_swaps(grid :: [[integer]]) :: integer\n  def min_swaps(grid) do\n    \n  end\nend",
        "erlang_template": "-spec min_swaps(Grid :: [[integer()]]) -> integer().\nmin_swaps(Grid) ->\n  .",
        "scala_template": "object Solution {\n    def minSwaps(grid: Array[Array[Int]]): Int = {\n        \n    }\n}"
    },
    {
        "id": 1657,
        "name": "find-the-winner-of-an-array-game",
        "difficulty": "Medium",
        "link": "https://leetcode.com/problems/find-the-winner-of-an-array-game/",
        "task_description": "Given an integer array `arr` of **distinct** integers and an integer `k`. A game will be played between the first two elements of the array (i.e. `arr[0]` and `arr[1]`). In each round of the game, we compare `arr[0]` with `arr[1]`, the larger integer wins and remains at position `0`, and the smaller integer moves to the end of the array. The game ends when an integer wins `k` consecutive rounds. Return _the integer which will win the game_. It is **guaranteed** that there will be a winner of the game. **Example 1:** ``` **Input:** arr = [2,1,3,5,4,6,7], k = 2 **Output:** 5 **Explanation:** Let's see the rounds of the game: Round | arr | winner | win_count 1 | [2,1,3,5,4,6,7] | 2 | 1 2 | [2,3,5,4,6,7,1] | 3 | 1 3 | [3,5,4,6,7,1,2] | 5 | 1 4 | [5,4,6,7,1,2,3] | 5 | 2 So we can see that 4 rounds will be played and 5 is the winner because it wins 2 consecutive games. ``` **Example 2:** ``` **Input:** arr = [3,2,1], k = 10 **Output:** 3 **Explanation:** 3 will win the first 10 rounds consecutively. ``` **Constraints:** `2 <= arr.length <= 105` `1 <= arr[i] <= 106` `arr` contains **distinct** integers. `1 <= k <= 109`",
        "test_case": [
            {
                "label": "Example 1",
                "input": "arr = [2,1,3,5,4,6,7], k = 2",
                "output": "5 Explanation: Let's see the rounds of the game:\nRound |       arr       | winner | win_count\n  1   | [2,1,3,5,4,6,7] | 2      | 1\n  2   | [2,3,5,4,6,7,1] | 3      | 1\n  3   | [3,5,4,6,7,1,2] | 5      | 1\n  4   | [5,4,6,7,1,2,3] | 5      | 2\nSo we can see that 4 rounds will be played and 5 is the winner because it wins 2 consecutive games."
            },
            {
                "label": "Example 2",
                "input": "arr = [3,2,1], k = 10",
                "output": "3 Explanation: 3 will win the first 10 rounds consecutively."
            }
        ],
        "elixir_template": "defmodule Solution do\n  @spec get_winner(arr :: [integer], k :: integer) :: integer\n  def get_winner(arr, k) do\n    \n  end\nend",
        "erlang_template": "-spec get_winner(Arr :: [integer()], K :: integer()) -> integer().\nget_winner(Arr, K) ->\n  .",
        "scala_template": "object Solution {\n    def getWinner(arr: Array[Int], k: Int): Int = {\n        \n    }\n}"
    },
    {
        "id": 1656,
        "name": "count-good-triplets",
        "difficulty": "Easy",
        "link": "https://leetcode.com/problems/count-good-triplets/",
        "task_description": "Given an array of integers `arr`, and three integers `a`, `b` and `c`. You need to find the number of good triplets. A triplet `(arr[i], arr[j], arr[k])` is **good** if the following conditions are true: `0 <= i < j < k < arr.length` `|arr[i] - arr[j]| <= a` `|arr[j] - arr[k]| <= b` `|arr[i] - arr[k]| <= c` Where `|x|` denotes the absolute value of `x`. Return_ the number of good triplets_. **Example 1:** ``` **Input:** arr = [3,0,1,1,9,7], a = 7, b = 2, c = 3 **Output:** 4 **Explanation:** There are 4 good triplets: [(3,0,1), (3,0,1), (3,1,1), (0,1,1)]. ``` **Example 2:** ``` **Input:** arr = [1,1,2,2,3], a = 0, b = 0, c = 1 **Output:** 0 **Explanation: **No triplet satisfies all conditions. ``` **Constraints:** `3 <= arr.length <= 100` `0 <= arr[i] <= 1000` `0 <= a, b, c <= 1000`",
        "test_case": [
            {
                "label": "Example 1",
                "input": "arr = [3,0,1,1,9,7], a = 7, b = 2, c = 3",
                "output": "4 Explanation: There are 4 good triplets: [(3,0,1), (3,0,1), (3,1,1), (0,1,1)]."
            },
            {
                "label": "Example 2",
                "input": "arr = [1,1,2,2,3], a = 0, b = 0, c = 1",
                "output": "0 Explanation: No triplet satisfies all conditions."
            }
        ],
        "elixir_template": "Elixir code template not available for this problem.",
        "erlang_template": "Elixir code template not available for this problem.",
        "scala_template": "object Solution {\n    def countGoodTriplets(arr: Array[Int], a: Int, b: Int, c: Int): Int = {\n        \n    }\n}"
    },
    {
        "id": 1653,
        "name": "number-of-good-leaf-nodes-pairs",
        "difficulty": "Medium",
        "link": "https://leetcode.com/problems/number-of-good-leaf-nodes-pairs/",
        "task_description": "You are given the `root` of a binary tree and an integer `distance`. A pair of two different **leaf** nodes of a binary tree is said to be good if the length of **the shortest path** between them is less than or equal to `distance`. Return _the number of good leaf node pairs_ in the tree. **Example 1:** ``` **Input:** root = [1,2,3,null,4], distance = 3 **Output:** 1 **Explanation:** The leaf nodes of the tree are 3 and 4 and the length of the shortest path between them is 3. This is the only good pair. ``` **Example 2:** ``` **Input:** root = [1,2,3,4,5,6,7], distance = 3 **Output:** 2 **Explanation:** The good pairs are [4,5] and [6,7] with shortest path = 2. The pair [4,6] is not good because the length of ther shortest path between them is 4. ``` **Example 3:** ``` **Input:** root = [7,1,4,6,null,5,3,null,null,null,null,null,2], distance = 3 **Output:** 1 **Explanation:** The only good pair is [2,5]. ``` **Constraints:** The number of nodes in the `tree` is in the range `[1, 210].` `1 <= Node.val <= 100` `1 <= distance <= 10`",
        "test_case": [
            {
                "label": "Example 1",
                "input": "root = [1,2,3,null,4], distance = 3",
                "output": "1 Explanation: The leaf nodes of the tree are 3 and 4 and the length of the shortest path between them is 3. This is the only good pair."
            },
            {
                "label": "Example 2",
                "input": "root = [1,2,3,4,5,6,7], distance = 3",
                "output": "2 Explanation: The good pairs are [4,5] and [6,7] with shortest path = 2. The pair [4,6] is not good because the length of ther shortest path between them is 4."
            },
            {
                "label": "Example 3",
                "input": "root = [7,1,4,6,null,5,3,null,null,null,null,null,2], distance = 3",
                "output": "1 Explanation: The only good pair is [2,5]. Constraints: The number of nodes in the tree is in the range [1, 2 10 ]. 1 <= Node.val <= 100 1 <= distance <= 10"
            }
        ],
        "elixir_template": "# Definition for a binary tree node.\n#\n# defmodule TreeNode do\n#   @type t :: %__MODULE__{\n#           val: integer,\n#           left: TreeNode.t() | nil,\n#           right: TreeNode.t() | nil\n#         }\n#   defstruct val: 0, left: nil, right: nil\n# end\n\ndefmodule Solution do\n  @spec count_pairs(root :: TreeNode.t | nil, distance :: integer) :: integer\n  def count_pairs(root, distance) do\n    \n  end\nend",
        "erlang_template": "%% Definition for a binary tree node.\n%%\n%% -record(tree_node, {val = 0 :: integer(),\n%%                     left = null  :: 'null' | #tree_node{},\n%%                     right = null :: 'null' | #tree_node{}}).\n\n-spec count_pairs(Root :: #tree_node{} | null, Distance :: integer()) -> integer().\ncount_pairs(Root, Distance) ->\n  .",
        "scala_template": "/**\n * Definition for a binary tree node.\n * class TreeNode(_value: Int = 0, _left: TreeNode = null, _right: TreeNode = null) {\n *   var value: Int = _value\n *   var left: TreeNode = _left\n *   var right: TreeNode = _right\n * }\n */\nobject Solution {\n    def countPairs(root: TreeNode, distance: Int): Int = {\n        \n    }\n}"
    },
    {
        "id": 1652,
        "name": "minimum-suffix-flips",
        "difficulty": "Medium",
        "link": "https://leetcode.com/problems/minimum-suffix-flips/",
        "task_description": "You are given a **0-indexed** binary string `target` of length `n`. You have another binary string `s` of length `n` that is initially set to all zeros. You want to make `s` equal to `target`. In one operation, you can pick an index `i` where `0 <= i < n` and flip all bits in the **inclusive** range `[i, n - 1]`. Flip means changing `'0'` to `'1'` and `'1'` to `'0'`. Return _the minimum number of operations needed to make _`s`_ equal to _`target`. **Example 1:** ``` **Input:** target = \"10111\" **Output:** 3 **Explanation:** Initially, s = \"00000\". Choose index i = 2: \"00000\" -> \"00111\" Choose index i = 0: \"00111\" -> \"11000\" Choose index i = 1: \"11000\" -> \"10111\" We need at least 3 flip operations to form target. ``` **Example 2:** ``` **Input:** target = \"101\" **Output:** 3 **Explanation:** Initially, s = \"000\". Choose index i = 0: \"000\" -> \"111\" Choose index i = 1: \"111\" -> \"100\" Choose index i = 2: \"100\" -> \"101\" We need at least 3 flip operations to form target. ``` **Example 3:** ``` **Input:** target = \"00000\" **Output:** 0 **Explanation:** We do not need any operations since the initial s already equals target. ``` **Constraints:** `n == target.length` `1 <= n <= 105` `target[i]` is either `'0'` or `'1'`.",
        "test_case": [
            {
                "label": "Example 1",
                "input": "target = \"10111\"",
                "output": "3 Explanation: Initially, s = \"00000\".\nChoose index i = 2: \"00 000 \" -> \"00 111 \"\nChoose index i = 0: \" 00111 \" -> \" 11000 \"\nChoose index i = 1: \"1 1000 \" -> \"1 0111 \"\nWe need at least 3 flip operations to form target."
            },
            {
                "label": "Example 2",
                "input": "target = \"101\"",
                "output": "3 Explanation: Initially, s = \"000\".\nChoose index i = 0: \" 000 \" -> \" 111 \"\nChoose index i = 1: \"1 11 \" -> \"1 00 \"\nChoose index i = 2: \"10 0 \" -> \"10 1 \"\nWe need at least 3 flip operations to form target."
            },
            {
                "label": "Example 3",
                "input": "target = \"00000\"",
                "output": "0 Explanation: We do not need any operations since the initial s already equals target. Constraints: n == target.length 1 <= n <= 10 5 target[i] is either '0' or '1' ."
            }
        ],
        "elixir_template": "defmodule Solution do\n  @spec min_flips(target :: String.t) :: integer\n  def min_flips(target) do\n    \n  end\nend",
        "erlang_template": "-spec min_flips(Target :: unicode:unicode_binary()) -> integer().\nmin_flips(Target) ->\n  .",
        "scala_template": "object Solution {\n    def minFlips(target: String): Int = {\n        \n    }\n}"
    },
    {
        "id": 1651,
        "name": "shuffle-string",
        "difficulty": "Easy",
        "link": "https://leetcode.com/problems/shuffle-string/",
        "task_description": "You are given a string `s` and an integer array `indices` of the **same length**. The string `s` will be shuffled such that the character at the `ith` position moves to `indices[i]` in the shuffled string. Return _the shuffled string_. **Example 1:** ``` **Input:** s = \"codeleet\", `indices` = [4,5,6,7,0,2,1,3] **Output:** \"leetcode\" **Explanation:** As shown, \"codeleet\" becomes \"leetcode\" after shuffling. ``` **Example 2:** ``` **Input:** s = \"abc\", `indices` = [0,1,2] **Output:** \"abc\" **Explanation:** After shuffling, each character remains in its position. ``` **Constraints:** `s.length == indices.length == n` `1 <= n <= 100` `s` consists of only lowercase English letters. `0 <= indices[i] < n` All values of `indices` are **unique**.",
        "test_case": [
            {
                "label": "Example 1",
                "input": "s = \"codeleet\", indices = [4,5,6,7,0,2,1,3]",
                "output": "\"leetcode\" Explanation: As shown, \"codeleet\" becomes \"leetcode\" after shuffling."
            },
            {
                "label": "Example 2",
                "input": "s = \"abc\", indices = [0,1,2]",
                "output": "\"abc\" Explanation: After shuffling, each character remains in its position. Constraints: s.length == indices.length == n 1 <= n <= 100 s consists of only lowercase English letters. 0 <= indices[i] < n All values of indices are unique ."
            }
        ],
        "elixir_template": "defmodule Solution do\n  @spec restore_string(s :: String.t, indices :: [integer]) :: String.t\n  def restore_string(s, indices) do\n    \n  end\nend",
        "erlang_template": "-spec restore_string(S :: unicode:unicode_binary(), Indices :: [integer()]) -> unicode:unicode_binary().\nrestore_string(S, Indices) ->\n  .",
        "scala_template": "object Solution {\n    def restoreString(s: String, indices: Array[Int]): String = {\n        \n    }\n}"
    },
    {
        "id": 1649,
        "name": "maximum-number-of-non-overlapping-subarrays-with-sum-equals-target",
        "difficulty": "Medium",
        "link": "https://leetcode.com/problems/maximum-number-of-non-overlapping-subarrays-with-sum-equals-target/",
        "task_description": "Given an array `nums` and an integer `target`, return _the maximum number of **non-empty** **non-overlapping** subarrays such that the sum of values in each subarray is equal to_ `target`. **Example 1:** ``` **Input:** nums = [1,1,1,1,1], target = 2 **Output:** 2 **Explanation:** There are 2 non-overlapping subarrays [**1,1**,1,**1,1**] with sum equals to target(2). ``` **Example 2:** ``` **Input:** nums = [-1,3,5,1,4,2,-9], target = 6 **Output:** 2 **Explanation:** There are 3 subarrays with sum equal to 6. ([5,1], [4,2], [3,5,1,4,2,-9]) but only the first 2 are non-overlapping. ``` **Constraints:** `1 <= nums.length <= 105` `-104 <= nums[i] <= 104` `0 <= target <= 106`",
        "test_case": [
            {
                "label": "Example 1",
                "input": "nums = [1,1,1,1,1], target = 2",
                "output": "2 Explanation: There are 2 non-overlapping subarrays [ 1,1 ,1, 1,1 ] with sum equals to target(2)."
            },
            {
                "label": "Example 2",
                "input": "nums = [-1,3,5,1,4,2,-9], target = 6",
                "output": "2 Explanation: There are 3 subarrays with sum equal to 6.\n([5,1], [4,2], [3,5,1,4,2,-9]) but only the first 2 are non-overlapping."
            }
        ],
        "elixir_template": "defmodule Solution do\n  @spec max_non_overlapping(nums :: [integer], target :: integer) :: integer\n  def max_non_overlapping(nums, target) do\n    \n  end\nend",
        "erlang_template": "-spec max_non_overlapping(Nums :: [integer()], Target :: integer()) -> integer().\nmax_non_overlapping(Nums, Target) ->\n  .",
        "scala_template": "object Solution {\n    def maxNonOverlapping(nums: Array[Int], target: Int): Int = {\n        \n    }\n}"
    },
    {
        "id": 1648,
        "name": "minimum-insertions-to-balance-a-parentheses-string",
        "difficulty": "Medium",
        "link": "https://leetcode.com/problems/minimum-insertions-to-balance-a-parentheses-string/",
        "task_description": "Given a parentheses string `s` containing only the characters `'('` and `')'`. A parentheses string is **balanced** if: Any left parenthesis `'('` must have a corresponding two consecutive right parenthesis `'))'`. Left parenthesis `'('` must go before the corresponding two consecutive right parenthesis `'))'`. In other words, we treat `'('` as an opening parenthesis and `'))'` as a closing parenthesis. For example, `\"())\"`, `\"())(())))\"` and `\"(())())))\"` are balanced, `\")()\"`, `\"()))\"` and `\"(()))\"` are not balanced. You can insert the characters `'('` and `')'` at any position of the string to balance it if needed. Return _the minimum number of insertions_ needed to make `s` balanced. **Example 1:** ``` **Input:** s = \"(()))\" **Output:** 1 **Explanation:** The second '(' has two matching '))', but the first '(' has only ')' matching. We need to add one more ')' at the end of the string to be \"(())))\" which is balanced. ``` **Example 2:** ``` **Input:** s = \"())\" **Output:** 0 **Explanation:** The string is already balanced. ``` **Example 3:** ``` **Input:** s = \"))())(\" **Output:** 3 **Explanation:** Add '(' to match the first '))', Add '))' to match the last '('. ``` **Constraints:** `1 <= s.length <= 105` `s` consists of `'('` and `')'` only.",
        "test_case": [
            {
                "label": "Example 1",
                "input": "s = \"(()))\"",
                "output": "1 Explanation: The second '(' has two matching '))', but the first '(' has only ')' matching. We need to add one more ')' at the end of the string to be \"(())))\" which is balanced."
            },
            {
                "label": "Example 2",
                "input": "s = \"())\"",
                "output": "0 Explanation: The string is already balanced."
            },
            {
                "label": "Example 3",
                "input": "s = \"))())(\"",
                "output": "3 Explanation: Add '(' to match the first '))', Add '))' to match the last '('."
            }
        ],
        "elixir_template": "defmodule Solution do\n  @spec min_insertions(s :: String.t) :: integer\n  def min_insertions(s) do\n    \n  end\nend",
        "erlang_template": "-spec min_insertions(S :: unicode:unicode_binary()) -> integer().\nmin_insertions(S) ->\n  .",
        "scala_template": "object Solution {\n    def minInsertions(s: String): Int = {\n        \n    }\n}"
    },
    {
        "id": 1647,
        "name": "can-convert-string-in-k-moves",
        "difficulty": "Medium",
        "link": "https://leetcode.com/problems/can-convert-string-in-k-moves/",
        "task_description": "Given two strings `s` and `t`, your goal is to convert `s` into `t` in `k`** **moves or less. During the `ith` (`1 <= i <= k`) move you can: Choose any index `j` (1-indexed) from `s`, such that `1 <= j <= s.length` and `j` has not been chosen in any previous move, and shift the character at that index `i` times. Do nothing. Shifting a character means replacing it by the next letter in the alphabet (wrapping around so that `'z'` becomes `'a'`). Shifting a character by `i` means applying the shift operations `i` times. Remember that any index `j` can be picked at most once. Return `true` if it's possible to convert `s` into `t` in no more than `k` moves, otherwise return `false`. **Example 1:** ``` **Input:** s = \"input\", t = \"ouput\", k = 9 **Output:** true Explanation: In the 6th move, we shift 'i' 6 times to get 'o'. And in the 7th move we shift 'n' to get 'u'. ``` **Example 2:** ``` **Input:** s = \"abc\", t = \"bcd\", k = 10 **Output:** false **Explanation: **We need to shift each character in s one time to convert it into t. We can shift 'a' to 'b' during the 1st move. However, there is no way to shift the other characters in the remaining moves to obtain t from s. ``` **Example 3:** ``` **Input:** s = \"aab\", t = \"bbb\", k = 27 **Output:** true Explanation: In the 1st move, we shift the first 'a' 1 time to get 'b'. In the 27th move, we shift the second 'a' 27 times to get 'b'. ``` **Constraints:** `1 <= s.length, t.length <= 10^5` `0 <= k <= 10^9` `s`, `t` contain only lowercase English letters.",
        "test_case": [
            {
                "label": "Example 1",
                "input": "s = \"input\", t = \"ouput\", k = 9",
                "output": "true Explanation: In the 6th move, we shift 'i' 6 times to get 'o'. And in the 7th move we shift 'n' to get 'u'."
            },
            {
                "label": "Example 2",
                "input": "s = \"abc\", t = \"bcd\", k = 10",
                "output": "false Explanation: We need to shift each character in s one time to convert it into t. We can shift 'a' to 'b' during the 1st move. However, there is no way to shift the other characters in the remaining moves to obtain t from s."
            },
            {
                "label": "Example 3",
                "input": "s = \"aab\", t = \"bbb\", k = 27",
                "output": "true Explanation: In the 1st move, we shift the first 'a' 1 time to get 'b'. In the 27th move, we shift the second 'a' 27 times to get 'b'."
            }
        ],
        "elixir_template": "defmodule Solution do\n  @spec can_convert_string(s :: String.t, t :: String.t, k :: integer) :: boolean\n  def can_convert_string(s, t, k) do\n    \n  end\nend",
        "erlang_template": "-spec can_convert_string(S :: unicode:unicode_binary(), T :: unicode:unicode_binary(), K :: integer()) -> boolean().\ncan_convert_string(S, T, K) ->\n  .",
        "scala_template": "object Solution {\n    def canConvertString(s: String, t: String, k: Int): Boolean = {\n        \n    }\n}"
    },
    {
        "id": 1646,
        "name": "kth-missing-positive-number",
        "difficulty": "Easy",
        "link": "https://leetcode.com/problems/kth-missing-positive-number/",
        "task_description": "Given an array `arr` of positive integers sorted in a **strictly increasing order**, and an integer `k`. Return _the_ `kth` _**positive** integer that is **missing** from this array._ **Example 1:** ``` **Input:** arr = [2,3,4,7,11], k = 5 **Output:** 9 **Explanation: **The missing positive integers are [1,5,6,8,9,10,12,13,...]. The 5th missing positive integer is 9. ``` **Example 2:** ``` **Input:** arr = [1,2,3,4], k = 2 **Output:** 6 **Explanation: **The missing positive integers are [5,6,7,...]. The 2nd missing positive integer is 6. ``` **Constraints:** `1 <= arr.length <= 1000` `1 <= arr[i] <= 1000` `1 <= k <= 1000` `arr[i] < arr[j]` for `1 <= i < j <= arr.length` **Follow up:** Could you solve this problem in less than O(n) complexity?",
        "test_case": [
            {
                "label": "Example 1",
                "input": "arr = [2,3,4,7,11], k = 5",
                "output": "9 Explanation: The missing positive integers are [1,5,6,8,9,10,12,13,...]. The 5 th missing positive integer is 9."
            },
            {
                "label": "Example 2",
                "input": "arr = [1,2,3,4], k = 2",
                "output": "6 Explanation: The missing positive integers are [5,6,7,...]. The 2 nd missing positive integer is 6."
            }
        ],
        "elixir_template": "defmodule Solution do\n  @spec find_kth_positive(arr :: [integer], k :: integer) :: integer\n  def find_kth_positive(arr, k) do\n    \n  end\nend",
        "erlang_template": "-spec find_kth_positive(Arr :: [integer()], K :: integer()) -> integer().\nfind_kth_positive(Arr, K) ->\n  .",
        "scala_template": "object Solution {\n    def findKthPositive(arr: Array[Int], k: Int): Int = {\n        \n    }\n}"
    },
    {
        "id": 1645,
        "name": "find-a-value-of-a-mysterious-function-closest-to-target",
        "difficulty": "Hard",
        "link": "https://leetcode.com/problems/find-a-value-of-a-mysterious-function-closest-to-target/",
        "task_description": "Winston was given the above mysterious function `func`. He has an integer array `arr` and an integer `target` and he wants to find the values `l` and `r` that make the value `|func(arr, l, r) - target|` minimum possible. Return _the minimum possible value_ of `|func(arr, l, r) - target|`. Notice that `func` should be called with the values `l` and `r` where `0 <= l, r < arr.length`. **Example 1:** ``` **Input:** arr = [9,12,3,7,15], target = 5 **Output:** 2 **Explanation:** Calling func with all the pairs of [l,r] = [[0,0],[1,1],[2,2],[3,3],[4,4],[0,1],[1,2],[2,3],[3,4],[0,2],[1,3],[2,4],[0,3],[1,4],[0,4]], Winston got the following results [9,12,3,7,15,8,0,3,7,0,0,3,0,0,0]. The value closest to 5 is 7 and 3, thus the minimum difference is 2. ``` **Example 2:** ``` **Input:** arr = [1000000,1000000,1000000], target = 1 **Output:** 999999 **Explanation:** Winston called the func with all possible values of [l,r] and he always got 1000000, thus the min difference is 999999. ``` **Example 3:** ``` **Input:** arr = [1,2,4,8,16], target = 0 **Output:** 0 ``` **Constraints:** `1 <= arr.length <= 105` `1 <= arr[i] <= 106` `0 <= target <= 107`",
        "test_case": [
            {
                "label": "Example 1",
                "input": "arr = [9,12,3,7,15], target = 5",
                "output": "2 Explanation: Calling func with all the pairs of [l,r] = [[0,0],[1,1],[2,2],[3,3],[4,4],[0,1],[1,2],[2,3],[3,4],[0,2],[1,3],[2,4],[0,3],[1,4],[0,4]], Winston got the following results [9,12,3,7,15,8,0,3,7,0,0,3,0,0,0]. The value closest to 5 is 7 and 3, thus the minimum difference is 2."
            },
            {
                "label": "Example 2",
                "input": "arr = [1000000,1000000,1000000], target = 1",
                "output": "999999 Explanation: Winston called the func with all possible values of [l,r] and he always got 1000000, thus the min difference is 999999."
            },
            {
                "label": "Example 3",
                "input": "arr = [1,2,4,8,16], target = 0",
                "output": "0"
            }
        ],
        "elixir_template": "defmodule Solution do\n  @spec closest_to_target(arr :: [integer], target :: integer) :: integer\n  def closest_to_target(arr, target) do\n    \n  end\nend",
        "erlang_template": "-spec closest_to_target(Arr :: [integer()], Target :: integer()) -> integer().\nclosest_to_target(Arr, Target) ->\n  .",
        "scala_template": "object Solution {\n    def closestToTarget(arr: Array[Int], target: Int): Int = {\n        \n    }\n}"
    },
    {
        "id": 1644,
        "name": "maximum-number-of-non-overlapping-substrings",
        "difficulty": "Hard",
        "link": "https://leetcode.com/problems/maximum-number-of-non-overlapping-substrings/",
        "task_description": "Given a string `s` of lowercase letters, you need to find the maximum number of **non-empty** substrings of `s` that meet the following conditions: The substrings do not overlap, that is for any two substrings `s[i..j]` and `s[x..y]`, either `j < x` or `i > y` is true. A substring that contains a certain character `c` must also contain all occurrences of `c`. Find _the maximum number of substrings that meet the above conditions_. If there are multiple solutions with the same number of substrings, _return the one with minimum total length. _It can be shown that there exists a unique solution of minimum total length. Notice that you can return the substrings in **any** order. **Example 1:** ``` **Input:** s = \"adefaddaccc\" **Output:** [\"e\",\"f\",\"ccc\"] Explanation: The following are all the possible substrings that meet the conditions: [ \"adefaddaccc\" \"adefadda\", \"ef\", \"e\", \"f\", \"ccc\", ] If we choose the first string, we cannot choose anything else and we'd get only 1. If we choose \"adefadda\", we are left with \"ccc\" which is the only one that doesn't overlap, thus obtaining 2 substrings. Notice also, that it's not optimal to choose \"ef\" since it can be split into two. Therefore, the optimal way is to choose [\"e\",\"f\",\"ccc\"] which gives us 3 substrings. No other solution of the same number of substrings exist. ``` **Example 2:** ``` **Input:** s = \"abbaccd\" **Output:** [\"d\",\"bb\",\"cc\"] Explanation: Notice that while the set of substrings [\"d\",\"abba\",\"cc\"] also has length 3, it's considered incorrect since it has larger total length. ``` **Constraints:** `1 <= s.length <= 105` `s` contains only lowercase English letters.",
        "test_case": [
            {
                "label": "Example 1",
                "input": "s = \"adefaddaccc\"",
                "output": "[\"e\",\"f\",\"ccc\"] Explanation: The following are all the possible substrings that meet the conditions:\n[\n\u00a0 \"adefaddaccc\"\n\u00a0 \"adefadda\",\n\u00a0 \"ef\",\n\u00a0 \"e\",\n  \"f\",\n\u00a0 \"ccc\",\n]\nIf we choose the first string, we cannot choose anything else and we'd get only 1. If we choose \"adefadda\", we are left with \"ccc\" which is the only one that doesn't overlap, thus obtaining 2 substrings. Notice also, that it's not optimal to choose \"ef\" since it can be split into two. Therefore, the optimal way is to choose [\"e\",\"f\",\"ccc\"] which gives us 3 substrings. No other solution of the same number of substrings exist."
            },
            {
                "label": "Example 2",
                "input": "s = \"abbaccd\"",
                "output": "[\"d\",\"bb\",\"cc\"] Explanation: Notice that while the set of substrings [\"d\",\"abba\",\"cc\"] also has length 3, it's considered incorrect since it has larger total length."
            }
        ],
        "elixir_template": "defmodule Solution do\n  @spec max_num_of_substrings(s :: String.t) :: [String.t]\n  def max_num_of_substrings(s) do\n    \n  end\nend",
        "erlang_template": "-spec max_num_of_substrings(S :: unicode:unicode_binary()) -> [unicode:unicode_binary()].\nmax_num_of_substrings(S) ->\n  .",
        "scala_template": "object Solution {\n    def maxNumOfSubstrings(s: String): List[String] = {\n        \n    }\n}"
    },
    {
        "id": 1643,
        "name": "number-of-nodes-in-the-sub-tree-with-the-same-label",
        "difficulty": "Medium",
        "link": "https://leetcode.com/problems/number-of-nodes-in-the-sub-tree-with-the-same-label/",
        "task_description": "You are given a tree (i.e. a connected, undirected graph that has no cycles) consisting of `n` nodes numbered from `0` to `n - 1` and exactly `n - 1` `edges`. The **root** of the tree is the node `0`, and each node of the tree has **a label** which is a lower-case character given in the string `labels` (i.e. The node with the number `i` has the label `labels[i]`). The `edges` array is given on the form `edges[i] = [ai, bi]`, which means there is an edge between nodes `ai` and `bi` in the tree. Return _an array of size `n`_ where `ans[i]` is the number of nodes in the subtree of the `ith` node which have the same label as node `i`. A subtree of a tree `T` is the tree consisting of a node in `T` and all of its descendant nodes. **Example 1:** ``` **Input:** n = 7, edges = [[0,1],[0,2],[1,4],[1,5],[2,3],[2,6]], labels = \"abaedcd\" **Output:** [2,1,1,1,1,1,1] **Explanation:** Node 0 has label 'a' and its sub-tree has node 2 with label 'a' as well, thus the answer is 2. Notice that any node is part of its sub-tree. Node 1 has a label 'b'. The sub-tree of node 1 contains nodes 1,4 and 5, as nodes 4 and 5 have different labels than node 1, the answer is just 1 (the node itself). ``` **Example 2:** ``` **Input:** n = 4, edges = [[0,1],[1,2],[0,3]], labels = \"bbbb\" **Output:** [4,2,1,1] **Explanation:** The sub-tree of node 2 contains only node 2, so the answer is 1. The sub-tree of node 3 contains only node 3, so the answer is 1. The sub-tree of node 1 contains nodes 1 and 2, both have label 'b', thus the answer is 2. The sub-tree of node 0 contains nodes 0, 1, 2 and 3, all with label 'b', thus the answer is 4. ``` **Example 3:** ``` **Input:** n = 5, edges = [[0,1],[0,2],[1,3],[0,4]], labels = \"aabab\" **Output:** [3,2,1,1,1] ``` **Constraints:** `1 <= n <= 105` `edges.length == n - 1` `edges[i].length == 2` `0 <= ai, bi < n` `ai != bi` `labels.length == n` `labels` is consisting of only of lowercase English letters.",
        "test_case": [
            {
                "label": "Example 1",
                "input": "n = 7, edges = [[0,1],[0,2],[1,4],[1,5],[2,3],[2,6]], labels = \"abaedcd\"",
                "output": "[2,1,1,1,1,1,1] Explanation: Node 0 has label 'a' and its sub-tree has node 2 with label 'a' as well, thus the answer is 2. Notice that any node is part of its sub-tree.\nNode 1 has a label 'b'. The sub-tree of node 1 contains nodes 1,4 and 5, as nodes 4 and 5 have different labels than node 1, the answer is just 1 (the node itself)."
            },
            {
                "label": "Example 2",
                "input": "n = 4, edges = [[0,1],[1,2],[0,3]], labels = \"bbbb\"",
                "output": "[4,2,1,1] Explanation: The sub-tree of node 2 contains only node 2, so the answer is 1.\nThe sub-tree of node 3 contains only node 3, so the answer is 1.\nThe sub-tree of node 1 contains nodes 1 and 2, both have label 'b', thus the answer is 2.\nThe sub-tree of node 0 contains nodes 0, 1, 2 and 3, all with label 'b', thus the answer is 4."
            },
            {
                "label": "Example 3",
                "input": "n = 5, edges = [[0,1],[0,2],[1,3],[0,4]], labels = \"aabab\"",
                "output": "[3,2,1,1,1]"
            }
        ],
        "elixir_template": "defmodule Solution do\n  @spec count_sub_trees(n :: integer, edges :: [[integer]], labels :: String.t) :: [integer]\n  def count_sub_trees(n, edges, labels) do\n    \n  end\nend",
        "erlang_template": "-spec count_sub_trees(N :: integer(), Edges :: [[integer()]], Labels :: unicode:unicode_binary()) -> [integer()].\ncount_sub_trees(N, Edges, Labels) ->\n  .",
        "scala_template": "object Solution {\n    def countSubTrees(n: Int, edges: Array[Array[Int]], labels: String): Array[Int] = {\n        \n    }\n}"
    },
    {
        "id": 1642,
        "name": "water-bottles",
        "difficulty": "Easy",
        "link": "https://leetcode.com/problems/water-bottles/",
        "task_description": "There are `numBottles` water bottles that are initially full of water. You can exchange `numExchange` empty water bottles from the market with one full water bottle. The operation of drinking a full water bottle turns it into an empty bottle. Given the two integers `numBottles` and `numExchange`, return _the **maximum** number of water bottles you can drink_. **Example 1:** ``` **Input:** numBottles = 9, numExchange = 3 **Output:** 13 **Explanation:** You can exchange 3 empty bottles to get 1 full water bottle. Number of water bottles you can drink: 9 + 3 + 1 = 13. ``` **Example 2:** ``` **Input:** numBottles = 15, numExchange = 4 **Output:** 19 **Explanation:** You can exchange 4 empty bottles to get 1 full water bottle. Number of water bottles you can drink: 15 + 3 + 1 = 19. ``` **Constraints:** `1 <= numBottles <= 100` `2 <= numExchange <= 100`",
        "test_case": [
            {
                "label": "Example 1",
                "input": "numBottles = 9, numExchange = 3",
                "output": "13 Explanation: You can exchange 3 empty bottles to get 1 full water bottle.\nNumber of water bottles you can drink: 9 + 3 + 1 = 13."
            },
            {
                "label": "Example 2",
                "input": "numBottles = 15, numExchange = 4",
                "output": "19 Explanation: You can exchange 4 empty bottles to get 1 full water bottle. \nNumber of water bottles you can drink: 15 + 3 + 1 = 19."
            }
        ],
        "elixir_template": "defmodule Solution do\n  @spec num_water_bottles(num_bottles :: integer, num_exchange :: integer) :: integer\n  def num_water_bottles(num_bottles, num_exchange) do\n    \n  end\nend",
        "erlang_template": "-spec num_water_bottles(NumBottles :: integer(), NumExchange :: integer()) -> integer().\nnum_water_bottles(NumBottles, NumExchange) ->\n  .",
        "scala_template": "object Solution {\n    def numWaterBottles(numBottles: Int, numExchange: Int): Int = {\n        \n    }\n}"
    },
    {
        "id": 1638,
        "name": "best-position-for-a-service-centre",
        "difficulty": "Hard",
        "link": "https://leetcode.com/problems/best-position-for-a-service-centre/",
        "task_description": "A delivery company wants to build a new service center in a new city. The company knows the positions of all the customers in this city on a 2D-Map and wants to build the new center in a position such that **the sum of the euclidean distances to all customers is minimum**. Given an array `positions` where `positions[i] = [xi, yi]` is the position of the `ith` customer on the map, return _the minimum sum of the euclidean distances_ to all customers. In other words, you need to choose the position of the service center `[xcentre, ycentre]` such that the following formula is minimized: Answers within `10-5` of the actual value will be accepted. **Example 1:** ``` **Input:** positions = [[0,1],[1,0],[1,2],[2,1]] **Output:** 4.00000 **Explanation:** As shown, you can see that choosing [xcentre, ycentre] = [1, 1] will make the distance to each customer = 1, the sum of all distances is 4 which is the minimum possible we can achieve. ``` **Example 2:** ``` **Input:** positions = [[1,1],[3,3]] **Output:** 2.82843 **Explanation:** The minimum possible sum of distances = sqrt(2) + sqrt(2) = 2.82843 ``` **Constraints:** `1 <= positions.length <= 50` `positions[i].length == 2` `0 <= xi, yi <= 100`",
        "test_case": [
            {
                "label": "Example 1",
                "input": "positions = [[0,1],[1,0],[1,2],[2,1]]",
                "output": "4.00000 Explanation: As shown, you can see that choosing [x centre , y centre ] = [1, 1] will make the distance to each customer = 1, the sum of all distances is 4 which is the minimum possible we can achieve."
            },
            {
                "label": "Example 2",
                "input": "positions = [[1,1],[3,3]]",
                "output": "2.82843 Explanation: The minimum possible sum of distances = sqrt(2) + sqrt(2) = 2.82843"
            }
        ],
        "elixir_template": "defmodule Solution do\n  @spec get_min_dist_sum(positions :: [[integer]]) :: float\n  def get_min_dist_sum(positions) do\n    \n  end\nend",
        "erlang_template": "-spec get_min_dist_sum(Positions :: [[integer()]]) -> float().\nget_min_dist_sum(Positions) ->\n  .",
        "scala_template": "object Solution {\n    def getMinDistSum(positions: Array[Array[Int]]): Double = {\n        \n    }\n}"
    },
    {
        "id": 1637,
        "name": "string-compression-ii",
        "difficulty": "Hard",
        "link": "https://leetcode.com/problems/string-compression-ii/",
        "task_description": "Run-length encoding is a string compression method that works by replacing consecutive identical characters (repeated 2 or more times) with the concatenation of the character and the number marking the count of the characters (length of the run). For example, to compress the string `\"aabccc\"` we replace `\"aa\"` by `\"a2\"` and replace `\"ccc\"` by `\"c3\"`. Thus the compressed string becomes `\"a2bc3\"`. Notice that in this problem, we are not adding `'1'` after single characters. Given a string `s` and an integer `k`. You need to delete **at most** `k` characters from `s` such that the run-length encoded version of `s` has minimum length. Find the _minimum length of the run-length encoded version of _`s`_ after deleting at most _`k`_ characters_. **Example 1:** ``` **Input:** s = \"aaabcccd\", k = 2 **Output:** 4 Explanation: Compressing s without deleting anything will give us \"a3bc3d\" of length 6. Deleting any of the characters 'a' or 'c' would at most decrease the length of the compressed string to 5, for instance delete 2 'a' then we will have s = \"abcccd\" which compressed is abc3d. Therefore, the optimal way is to delete 'b' and 'd', then the compressed version of s will be \"a3c3\" of length 4. ``` **Example 2:** ``` **Input:** s = \"aabbaa\", k = 2 **Output:** 2 Explanation: If we delete both 'b' characters, the resulting compressed string would be \"a4\" of length 2. ``` **Example 3:** ``` **Input:** s = \"aaaaaaaaaaa\", k = 0 **Output:** 3 **Explanation: **Since k is zero, we cannot delete anything. The compressed string is \"a11\" of length 3. ``` **Constraints:** `1 <= s.length <= 100` `0 <= k <= s.length` `s` contains only lowercase English letters.",
        "test_case": [
            {
                "label": "Example 1",
                "input": "s = \"aaabcccd\", k = 2",
                "output": "4 Explanation: Compressing s without deleting anything will give us \"a3bc3d\" of length 6. Deleting any of the characters 'a' or 'c' would at most decrease the length of the compressed string to 5, for instance delete 2 'a' then we will have s = \"abcccd\" which compressed is abc3d. Therefore, the optimal way is to delete 'b' and 'd', then the compressed version of s will be \"a3c3\" of length 4."
            },
            {
                "label": "Example 2",
                "input": "s = \"aabbaa\", k = 2",
                "output": "2 Explanation: If we delete both 'b' characters, the resulting compressed string would be \"a4\" of length 2."
            },
            {
                "label": "Example 3",
                "input": "s = \"aaaaaaaaaaa\", k = 0",
                "output": "3 Explanation: Since k is zero, we cannot delete anything. The compressed string is \"a11\" of length 3."
            }
        ],
        "elixir_template": "defmodule Solution do\n  @spec get_length_of_optimal_compression(s :: String.t, k :: integer) :: integer\n  def get_length_of_optimal_compression(s, k) do\n    \n  end\nend",
        "erlang_template": "-spec get_length_of_optimal_compression(S :: unicode:unicode_binary(), K :: integer()) -> integer().\nget_length_of_optimal_compression(S, K) ->\n  .",
        "scala_template": "object Solution {\n    def getLengthOfOptimalCompression(s: String, k: Int): Int = {\n        \n    }\n}"
    },
    {
        "id": 1636,
        "name": "number-of-substrings-with-only-1s",
        "difficulty": "Medium",
        "link": "https://leetcode.com/problems/number-of-substrings-with-only-1s/",
        "task_description": "Given a binary string `s`, return _the number of substrings with all characters_ `1`_'s_. Since the answer may be too large, return it modulo `109 + 7`. **Example 1:** ``` **Input:** s = \"0110111\" **Output:** 9 **Explanation:** There are 9 substring in total with only 1's characters. \"1\" -> 5 times. \"11\" -> 3 times. \"111\" -> 1 time. ``` **Example 2:** ``` **Input:** s = \"101\" **Output:** 2 **Explanation:** Substring \"1\" is shown 2 times in s. ``` **Example 3:** ``` **Input:** s = \"111111\" **Output:** 21 **Explanation:** Each substring contains only 1's characters. ``` **Constraints:** `1 <= s.length <= 105` `s[i]` is either `'0'` or `'1'`.",
        "test_case": [
            {
                "label": "Example 1",
                "input": "s = \"0110111\"",
                "output": "9 Explanation: There are 9 substring in total with only 1's characters.\n\"1\" -> 5 times.\n\"11\" -> 3 times.\n\"111\" -> 1 time."
            },
            {
                "label": "Example 2",
                "input": "s = \"101\"",
                "output": "2 Explanation: Substring \"1\" is shown 2 times in s."
            },
            {
                "label": "Example 3",
                "input": "s = \"111111\"",
                "output": "21 Explanation: Each substring contains only 1's characters."
            }
        ],
        "elixir_template": "defmodule Solution do\n  @spec num_sub(s :: String.t) :: integer\n  def num_sub(s) do\n    \n  end\nend",
        "erlang_template": "-spec num_sub(S :: unicode:unicode_binary()) -> integer().\nnum_sub(S) ->\n  .",
        "scala_template": "object Solution {\n    def numSub(s: String): Int = {\n        \n    }\n}"
    },
    {
        "id": 1635,
        "name": "number-of-good-pairs",
        "difficulty": "Easy",
        "link": "https://leetcode.com/problems/number-of-good-pairs/",
        "task_description": "Given an array of integers `nums`, return _the number of **good pairs**_. A pair `(i, j)` is called _good_ if `nums[i] == nums[j]` and `i` < `j`. **Example 1:** ``` **Input:** nums = [1,2,3,1,1,3] **Output:** 4 **Explanation:** There are 4 good pairs (0,3), (0,4), (3,4), (2,5) 0-indexed. ``` **Example 2:** ``` **Input:** nums = [1,1,1,1] **Output:** 6 **Explanation:** Each pair in the array are _good_. ``` **Example 3:** ``` **Input:** nums = [1,2,3] **Output:** 0 ``` **Constraints:** `1 <= nums.length <= 100` `1 <= nums[i] <= 100`",
        "test_case": [
            {
                "label": "Example 1",
                "input": "nums = [1,2,3,1,1,3]",
                "output": "4 Explanation: There are 4 good pairs (0,3), (0,4), (3,4), (2,5) 0-indexed."
            },
            {
                "label": "Example 2",
                "input": "nums = [1,1,1,1]",
                "output": "6 Explanation: Each pair in the array are good ."
            },
            {
                "label": "Example 3",
                "input": "nums = [1,2,3]",
                "output": "0"
            }
        ],
        "elixir_template": "defmodule Solution do\n  @spec num_identical_pairs(nums :: [integer]) :: integer\n  def num_identical_pairs(nums) do\n    \n  end\nend",
        "erlang_template": "-spec num_identical_pairs(Nums :: [integer()]) -> integer().\nnum_identical_pairs(Nums) ->\n  .",
        "scala_template": "object Solution {\n    def numIdenticalPairs(nums: Array[Int]): Int = {\n        \n    }\n}"
    },
    {
        "id": 1633,
        "name": "minimum-number-of-increments-on-subarrays-to-form-a-target-array",
        "difficulty": "Hard",
        "link": "https://leetcode.com/problems/minimum-number-of-increments-on-subarrays-to-form-a-target-array/",
        "task_description": "You are given an integer array `target`. You have an integer array `initial` of the same size as `target` with all elements initially zeros. In one operation you can choose **any** subarray from `initial` and increment each value by one. Return _the minimum number of operations to form a _`target`_ array from _`initial`. The test cases are generated so that the answer fits in a 32-bit integer. **Example 1:** ``` **Input:** target = [1,2,3,2,1] **Output:** 3 **Explanation:** We need at least 3 operations to form the target array from the initial array. [**0,0,0,0,0**] increment 1 from index 0 to 4 (inclusive). [1,**1,1,1**,1] increment 1 from index 1 to 3 (inclusive). [1,2,**2**,2,1] increment 1 at index 2. [1,2,3,2,1] target array is formed. ``` **Example 2:** ``` **Input:** target = [3,1,1,2] **Output:** 4 **Explanation:** [**0,0,0,0**] -> [1,1,1,**1**] -> [**1**,1,1,2] -> [**2**,1,1,2] -> [3,1,1,2] ``` **Example 3:** ``` **Input:** target = [3,1,5,4,2] **Output:** 7 **Explanation:** [**0,0,0,0,0**] -> [**1**,1,1,1,1] -> [**2**,1,1,1,1] -> [3,1,**1,1,1**] -> [3,1,**2,2**,2] -> [3,1,**3,3**,2] -> [3,1,**4**,4,2] -> [3,1,5,4,2]. ``` **Constraints:** `1 <= target.length <= 105` `1 <= target[i] <= 105`",
        "test_case": [
            {
                "label": "Example 1",
                "input": "target = [1,2,3,2,1]",
                "output": "3 Explanation: We need at least 3 operations to form the target array from the initial array.\n[ 0,0,0,0,0 ] increment 1 from index 0 to 4 (inclusive).\n[1, 1,1,1 ,1] increment 1 from index 1 to 3 (inclusive).\n[1,2, 2 ,2,1] increment 1 at index 2.\n[1,2,3,2,1] target array is formed."
            },
            {
                "label": "Example 2",
                "input": "target = [3,1,1,2]",
                "output": "4 Explanation: [ 0,0,0,0 ] -> [1,1,1, 1 ] -> [ 1 ,1,1,2] -> [ 2 ,1,1,2] -> [3,1,1,2]"
            },
            {
                "label": "Example 3",
                "input": "target = [3,1,5,4,2]",
                "output": "7 Explanation: [ 0,0,0,0,0 ] -> [ 1 ,1,1,1,1] -> [ 2 ,1,1,1,1] -> [3,1, 1,1,1 ] -> [3,1, 2,2 ,2] -> [3,1, 3,3 ,2] -> [3,1, 4 ,4,2] -> [3,1,5,4,2]."
            }
        ],
        "elixir_template": "defmodule Solution do\n  @spec min_number_operations(target :: [integer]) :: integer\n  def min_number_operations(target) do\n    \n  end\nend",
        "erlang_template": "-spec min_number_operations(Target :: [integer()]) -> integer().\nmin_number_operations(Target) ->\n  .",
        "scala_template": "object Solution {\n    def minNumberOperations(target: Array[Int]): Int = {\n        \n    }\n}"
    },
    {
        "id": 1632,
        "name": "number-of-good-ways-to-split-a-string",
        "difficulty": "Medium",
        "link": "https://leetcode.com/problems/number-of-good-ways-to-split-a-string/",
        "task_description": "You are given a string `s`. A split is called **good** if you can split `s` into two non-empty strings `sleft` and `sright` where their concatenation is equal to `s` (i.e., `sleft + sright = s`) and the number of distinct letters in `sleft` and `sright` is the same. Return _the number of **good splits** you can make in `s`_. **Example 1:** ``` **Input:** s = \"aacaba\" **Output:** 2 **Explanation:** There are 5 ways to split `\"aacaba\"` and 2 of them are good. (\"a\", \"acaba\") Left string and right string contains 1 and 3 different letters respectively. (\"aa\", \"caba\") Left string and right string contains 1 and 3 different letters respectively. (\"aac\", \"aba\") Left string and right string contains 2 and 2 different letters respectively (good split). (\"aaca\", \"ba\") Left string and right string contains 2 and 2 different letters respectively (good split). (\"aacab\", \"a\") Left string and right string contains 3 and 1 different letters respectively. ``` **Example 2:** ``` **Input:** s = \"abcd\" **Output:** 1 **Explanation:** Split the string as follows (\"ab\", \"cd\"). ``` **Constraints:** `1 <= s.length <= 105` `s` consists of only lowercase English letters.",
        "test_case": [
            {
                "label": "Example 1",
                "input": "s = \"aacaba\"",
                "output": "2 Explanation: There are 5 ways to split \"aacaba\" and 2 of them are good. \n(\"a\", \"acaba\") Left string and right string contains 1 and 3 different letters respectively.\n(\"aa\", \"caba\") Left string and right string contains 1 and 3 different letters respectively.\n(\"aac\", \"aba\") Left string and right string contains 2 and 2 different letters respectively (good split).\n(\"aaca\", \"ba\") Left string and right string contains 2 and 2 different letters respectively (good split).\n(\"aacab\", \"a\") Left string and right string contains 3 and 1 different letters respectively."
            },
            {
                "label": "Example 2",
                "input": "s = \"abcd\"",
                "output": "1 Explanation: Split the string as follows (\"ab\", \"cd\")."
            }
        ],
        "elixir_template": "defmodule Solution do\n  @spec num_splits(s :: String.t) :: integer\n  def num_splits(s) do\n    \n  end\nend",
        "erlang_template": "-spec num_splits(S :: unicode:unicode_binary()) -> integer().\nnum_splits(S) ->\n  .",
        "scala_template": "object Solution {\n    def numSplits(s: String): Int = {\n        \n    }\n}"
    },
    {
        "id": 1631,
        "name": "number-of-sub-arrays-with-odd-sum",
        "difficulty": "Medium",
        "link": "https://leetcode.com/problems/number-of-sub-arrays-with-odd-sum/",
        "task_description": "Given an array of integers `arr`, return _the number of subarrays with an **odd** sum_. Since the answer can be very large, return it modulo `109 + 7`. **Example 1:** ``` **Input:** arr = [1,3,5] **Output:** 4 **Explanation:** All subarrays are [[1],[1,3],[1,3,5],[3],[3,5],[5]] All sub-arrays sum are [1,4,9,3,8,5]. Odd sums are [1,9,3,5] so the answer is 4. ``` **Example 2:** ``` **Input:** arr = [2,4,6] **Output:** 0 **Explanation:** All subarrays are [[2],[2,4],[2,4,6],[4],[4,6],[6]] All sub-arrays sum are [2,6,12,4,10,6]. All sub-arrays have even sum and the answer is 0. ``` **Example 3:** ``` **Input:** arr = [1,2,3,4,5,6,7] **Output:** 16 ``` **Constraints:** `1 <= arr.length <= 105` `1 <= arr[i] <= 100`",
        "test_case": [
            {
                "label": "Example 1",
                "input": "arr = [1,3,5]",
                "output": "4 Explanation: All subarrays are [[1],[1,3],[1,3,5],[3],[3,5],[5]]\nAll sub-arrays sum are [1,4,9,3,8,5].\nOdd sums are [1,9,3,5] so the answer is 4."
            },
            {
                "label": "Example 2",
                "input": "arr = [2,4,6]",
                "output": "0 Explanation: All subarrays are [[2],[2,4],[2,4,6],[4],[4,6],[6]]\nAll sub-arrays sum are [2,6,12,4,10,6].\nAll sub-arrays have even sum and the answer is 0."
            },
            {
                "label": "Example 3",
                "input": "arr = [1,2,3,4,5,6,7]",
                "output": "16"
            }
        ],
        "elixir_template": "defmodule Solution do\n  @spec num_of_subarrays(arr :: [integer]) :: integer\n  def num_of_subarrays(arr) do\n    \n  end\nend",
        "erlang_template": "-spec num_of_subarrays(Arr :: [integer()]) -> integer().\nnum_of_subarrays(Arr) ->\n  .",
        "scala_template": "object Solution {\n    def numOfSubarrays(arr: Array[Int]): Int = {\n        \n    }\n}"
    },
    {
        "id": 1630,
        "name": "count-odd-numbers-in-an-interval-range",
        "difficulty": "Easy",
        "link": "https://leetcode.com/problems/count-odd-numbers-in-an-interval-range/",
        "task_description": "Given two non-negative integers `low` and `high`. Return the _count of odd numbers between _`low`_ and _`high`_ (inclusive)_. **Example 1:** ``` **Input:** low = 3, high = 7 **Output:** 3 Explanation: The odd numbers between 3 and 7 are [3,5,7]. ``` **Example 2:** ``` **Input:** low = 8, high = 10 **Output:** 1 Explanation: The odd numbers between 8 and 10 are [9]. ``` **Constraints:** `0 <= low <= high <= 10^9`",
        "test_case": [
            {
                "label": "Example 1",
                "input": "low = 3, high = 7",
                "output": "3 Explanation: The odd numbers between 3 and 7 are [3,5,7]."
            },
            {
                "label": "Example 2",
                "input": "low = 8, high = 10",
                "output": "1 Explanation: The odd numbers between 8 and 10 are [9]."
            }
        ],
        "elixir_template": "Elixir code template not available for this problem.",
        "erlang_template": "Elixir code template not available for this problem.",
        "scala_template": "object Solution {\n    def countOdds(low: Int, high: Int): Int = {\n        \n    }\n}"
    },
    {
        "id": 1629,
        "name": "minimum-possible-integer-after-at-most-k-adjacent-swaps-on-digits",
        "difficulty": "Hard",
        "link": "https://leetcode.com/problems/minimum-possible-integer-after-at-most-k-adjacent-swaps-on-digits/",
        "task_description": "You are given a string `num` representing **the digits** of a very large integer and an integer `k`. You are allowed to swap any two adjacent digits of the integer **at most** `k` times. Return _the minimum integer you can obtain also as a string_. **Example 1:** ``` **Input:** num = \"4321\", k = 4 **Output:** \"1342\" **Explanation:** The steps to obtain the minimum integer from 4321 with 4 adjacent swaps are shown. ``` **Example 2:** ``` **Input:** num = \"100\", k = 1 **Output:** \"010\" **Explanation:** It's ok for the output to have leading zeros, but the input is guaranteed not to have any leading zeros. ``` **Example 3:** ``` **Input:** num = \"36789\", k = 1000 **Output:** \"36789\" **Explanation:** We can keep the number without any swaps. ``` **Constraints:** `1 <= num.length <= 3 * 104` `num` consists of only **digits** and does not contain **leading zeros**. `1 <= k <= 109`",
        "test_case": [
            {
                "label": "Example 1",
                "input": "num = \"4321\", k = 4",
                "output": "\"1342\" Explanation: The steps to obtain the minimum integer from 4321 with 4 adjacent swaps are shown."
            },
            {
                "label": "Example 2",
                "input": "num = \"100\", k = 1",
                "output": "\"010\" Explanation: It's ok for the output to have leading zeros, but the input is guaranteed not to have any leading zeros."
            },
            {
                "label": "Example 3",
                "input": "num = \"36789\", k = 1000",
                "output": "\"36789\" Explanation: We can keep the number without any swaps."
            }
        ],
        "elixir_template": "defmodule Solution do\n  @spec min_integer(num :: String.t, k :: integer) :: String.t\n  def min_integer(num, k) do\n    \n  end\nend",
        "erlang_template": "-spec min_integer(Num :: unicode:unicode_binary(), K :: integer()) -> unicode:unicode_binary().\nmin_integer(Num, K) ->\n  .",
        "scala_template": "object Solution {\n    def minInteger(num: String, k: Int): String = {\n        \n    }\n}"
    },
    {
        "id": 1628,
        "name": "count-submatrices-with-all-ones",
        "difficulty": "Medium",
        "link": "https://leetcode.com/problems/count-submatrices-with-all-ones/",
        "task_description": "Given an `m x n` binary matrix `mat`, _return the number of **submatrices** that have all ones_. **Example 1:** ``` **Input:** mat = [[1,0,1],[1,1,0],[1,1,0]] **Output:** 13 **Explanation:** There are 6 rectangles of side 1x1. There are 2 rectangles of side 1x2. There are 3 rectangles of side 2x1. There is 1 rectangle of side 2x2. There is 1 rectangle of side 3x1. Total number of rectangles = 6 + 2 + 3 + 1 + 1 = 13. ``` **Example 2:** ``` **Input:** mat = [[0,1,1,0],[0,1,1,1],[1,1,1,0]] **Output:** 24 **Explanation:** There are 8 rectangles of side 1x1. There are 5 rectangles of side 1x2. There are 2 rectangles of side 1x3. There are 4 rectangles of side 2x1. There are 2 rectangles of side 2x2. There are 2 rectangles of side 3x1. There is 1 rectangle of side 3x2. Total number of rectangles = 8 + 5 + 2 + 4 + 2 + 2 + 1 = 24. ``` **Constraints:** `1 <= m, n <= 150` `mat[i][j]` is either `0` or `1`.",
        "test_case": [
            {
                "label": "Example 1",
                "input": "mat = [[1,0,1],[1,1,0],[1,1,0]]",
                "output": "13 Explanation: There are 6 rectangles of side 1x1.\nThere are 2 rectangles of side 1x2.\nThere are 3 rectangles of side 2x1.\nThere is 1 rectangle of side 2x2. \nThere is 1 rectangle of side 3x1.\nTotal number of rectangles = 6 + 2 + 3 + 1 + 1 = 13."
            },
            {
                "label": "Example 2",
                "input": "mat = [[0,1,1,0],[0,1,1,1],[1,1,1,0]]",
                "output": "24 Explanation: There are 8 rectangles of side 1x1.\nThere are 5 rectangles of side 1x2.\nThere are 2 rectangles of side 1x3. \nThere are 4 rectangles of side 2x1.\nThere are 2 rectangles of side 2x2. \nThere are 2 rectangles of side 3x1. \nThere is 1 rectangle of side 3x2. \nTotal number of rectangles = 8 + 5 + 2 + 4 + 2 + 2 + 1 = 24."
            }
        ],
        "elixir_template": "defmodule Solution do\n  @spec num_submat(mat :: [[integer]]) :: integer\n  def num_submat(mat) do\n    \n  end\nend",
        "erlang_template": "-spec num_submat(Mat :: [[integer()]]) -> integer().\nnum_submat(Mat) ->\n  .",
        "scala_template": "object Solution {\n    def numSubmat(mat: Array[Array[Int]]): Int = {\n        \n    }\n}"
    },
    {
        "id": 1627,
        "name": "last-moment-before-all-ants-fall-out-of-a-plank",
        "difficulty": "Medium",
        "link": "https://leetcode.com/problems/last-moment-before-all-ants-fall-out-of-a-plank/",
        "task_description": "We have a wooden plank of the length `n` **units**. Some ants are walking on the plank, each ant moves with a speed of **1 unit per second**. Some of the ants move to the **left**, the other move to the **right**. When two ants moving in two **different** directions meet at some point, they change their directions and continue moving again. Assume changing directions does not take any additional time. When an ant reaches **one end** of the plank at a time `t`, it falls out of the plank immediately. Given an integer `n` and two integer arrays `left` and `right`, the positions of the ants moving to the left and the right, return _the moment when the last ant(s) fall out of the plank_. **Example 1:** ``` **Input:** n = 4, left = [4,3], right = [0,1] **Output:** 4 **Explanation:** In the image above: -The ant at index 0 is named A and going to the right. -The ant at index 1 is named B and going to the right. -The ant at index 3 is named C and going to the left. -The ant at index 4 is named D and going to the left. The last moment when an ant was on the plank is t = 4 seconds. After that, it falls immediately out of the plank. (i.e., We can say that at t = 4.0000000001, there are no ants on the plank). ``` **Example 2:** ``` **Input:** n = 7, left = [], right = [0,1,2,3,4,5,6,7] **Output:** 7 **Explanation:** All ants are going to the right, the ant at index 0 needs 7 seconds to fall. ``` **Example 3:** ``` **Input:** n = 7, left = [0,1,2,3,4,5,6,7], right = [] **Output:** 7 **Explanation:** All ants are going to the left, the ant at index 7 needs 7 seconds to fall. ``` **Constraints:** `1 <= n <= 104` `0 <= left.length <= n + 1` `0 <= left[i] <= n` `0 <= right.length <= n + 1` `0 <= right[i] <= n` `1 <= left.length + right.length <= n + 1` All values of `left` and `right` are unique, and each value can appear **only in one** of the two arrays.",
        "test_case": [
            {
                "label": "Example 1",
                "input": "n = 4, left = [4,3], right = [0,1]",
                "output": "4 Explanation: In the image above:\n-The ant at index 0 is named A and going to the right.\n-The ant at index 1 is named B and going to the right.\n-The ant at index 3 is named C and going to the left.\n-The ant at index 4 is named D and going to the left.\nThe last moment when an ant was on the plank is t = 4 seconds. After that, it falls immediately out of the plank. (i.e., We can say that at t = 4.0000000001, there are no ants on the plank)."
            },
            {
                "label": "Example 2",
                "input": "n = 7, left = [], right = [0,1,2,3,4,5,6,7]",
                "output": "7 Explanation: All ants are going to the right, the ant at index 0 needs 7 seconds to fall."
            },
            {
                "label": "Example 3",
                "input": "n = 7, left = [0,1,2,3,4,5,6,7], right = []",
                "output": "7 Explanation: All ants are going to the left, the ant at index 7 needs 7 seconds to fall."
            }
        ],
        "elixir_template": "defmodule Solution do\n  @spec get_last_moment(n :: integer, left :: [integer], right :: [integer]) :: integer\n  def get_last_moment(n, left, right) do\n    \n  end\nend",
        "erlang_template": "-spec get_last_moment(N :: integer(), Left :: [integer()], Right :: [integer()]) -> integer().\nget_last_moment(N, Left, Right) ->\n  .",
        "scala_template": "object Solution {\n    def getLastMoment(n: Int, left: Array[Int], right: Array[Int]): Int = {\n        \n    }\n}"
    },
    {
        "id": 1626,
        "name": "can-make-arithmetic-progression-from-sequence",
        "difficulty": "Easy",
        "link": "https://leetcode.com/problems/can-make-arithmetic-progression-from-sequence/",
        "task_description": "A sequence of numbers is called an **arithmetic progression** if the difference between any two consecutive elements is the same. Given an array of numbers `arr`, return `true` _if the array can be rearranged to form an **arithmetic progression**. Otherwise, return_ `false`. **Example 1:** ``` **Input:** arr = [3,5,1] **Output:** true **Explanation: **We can reorder the elements as [1,3,5] or [5,3,1] with differences 2 and -2 respectively, between each consecutive elements. ``` **Example 2:** ``` **Input:** arr = [1,2,4] **Output:** false **Explanation: **There is no way to reorder the elements to obtain an arithmetic progression. ``` **Constraints:** `2 <= arr.length <= 1000` `-106 <= arr[i] <= 106`",
        "test_case": [
            {
                "label": "Example 1",
                "input": "arr = [3,5,1]",
                "output": "true Explanation: We can reorder the elements as [1,3,5] or [5,3,1] with differences 2 and -2 respectively, between each consecutive elements."
            },
            {
                "label": "Example 2",
                "input": "arr = [1,2,4]",
                "output": "false Explanation: There is no way to reorder the elements to obtain an arithmetic progression."
            }
        ],
        "elixir_template": "defmodule Solution do\n  @spec can_make_arithmetic_progression(arr :: [integer]) :: boolean\n  def can_make_arithmetic_progression(arr) do\n    \n  end\nend",
        "erlang_template": "-spec can_make_arithmetic_progression(Arr :: [integer()]) -> boolean().\ncan_make_arithmetic_progression(Arr) ->\n  .",
        "scala_template": "object Solution {\n    def canMakeArithmeticProgression(arr: Array[Int]): Boolean = {\n        \n    }\n}"
    },
    {
        "id": 1622,
        "name": "max-value-of-equation",
        "difficulty": "Hard",
        "link": "https://leetcode.com/problems/max-value-of-equation/",
        "task_description": "You are given an array `points` containing the coordinates of points on a 2D plane, sorted by the x-values, where `points[i] = [xi, yi]` such that `xi < xj` for all `1 <= i < j <= points.length`. You are also given an integer `k`. Return _the maximum value of the equation _`yi + yj + |xi - xj|` where `|xi - xj| <= k` and `1 <= i < j <= points.length`. It is guaranteed that there exists at least one pair of points that satisfy the constraint `|xi - xj| <= k`. **Example 1:** ``` **Input:** points = [[1,3],[2,0],[5,10],[6,-10]], k = 1 **Output:** 4 **Explanation:** The first two points satisfy the condition |xi - xj| <= 1 and if we calculate the equation we get 3 + 0 + |1 - 2| = 4. Third and fourth points also satisfy the condition and give a value of 10 + -10 + |5 - 6| = 1. No other pairs satisfy the condition, so we return the max of 4 and 1. ``` **Example 2:** ``` **Input:** points = [[0,0],[3,0],[9,2]], k = 3 **Output:** 3 **Explanation: **Only the first two points have an absolute difference of 3 or less in the x-values, and give the value of 0 + 0 + |0 - 3| = 3. ``` **Constraints:** `2 <= points.length <= 105` `points[i].length == 2` `-108 <= xi, yi <= 108` `0 <= k <= 2 * 108` `xi < xj` for all `1 <= i < j <= points.length` `xi` form a strictly increasing sequence.",
        "test_case": [
            {
                "label": "Example 1",
                "input": "points = [[1,3],[2,0],[5,10],[6,-10]], k = 1",
                "output": "4 Explanation: The first two points satisfy the condition |x i - x j | <= 1 and if we calculate the equation we get 3 + 0 + |1 - 2| = 4. Third and fourth points also satisfy the condition and give a value of 10 + -10 + |5 - 6| = 1.\nNo other pairs satisfy the condition, so we return the max of 4 and 1."
            },
            {
                "label": "Example 2",
                "input": "points = [[0,0],[3,0],[9,2]], k = 3",
                "output": "3 Explanation: Only the first two points have an absolute difference of 3 or less in the x-values, and give the value of 0 + 0 + |0 - 3| = 3."
            }
        ],
        "elixir_template": "defmodule Solution do\n  @spec find_max_value_of_equation(points :: [[integer]], k :: integer) :: integer\n  def find_max_value_of_equation(points, k) do\n    \n  end\nend",
        "erlang_template": "-spec find_max_value_of_equation(Points :: [[integer()]], K :: integer()) -> integer().\nfind_max_value_of_equation(Points, K) ->\n  .",
        "scala_template": "object Solution {\n    def findMaxValueOfEquation(points: Array[Array[Int]], k: Int): Int = {\n        \n    }\n}"
    },
    {
        "id": 1621,
        "name": "number-of-subsequences-that-satisfy-the-given-sum-condition",
        "difficulty": "Medium",
        "link": "https://leetcode.com/problems/number-of-subsequences-that-satisfy-the-given-sum-condition/",
        "task_description": "You are given an array of integers `nums` and an integer `target`. Return _the number of **non-empty** subsequences of _`nums`_ such that the sum of the minimum and maximum element on it is less or equal to _`target`. Since the answer may be too large, return it **modulo** `109 + 7`. **Example 1:** ``` **Input:** nums = [3,5,6,7], target = 9 **Output:** 4 **Explanation:** There are 4 subsequences that satisfy the condition. [3] -> Min value + max value <= target (3 + 3 <= 9) [3,5] -> (3 + 5 <= 9) [3,5,6] -> (3 + 6 <= 9) [3,6] -> (3 + 6 <= 9) ``` **Example 2:** ``` **Input:** nums = [3,3,6,8], target = 10 **Output:** 6 **Explanation:** There are 6 subsequences that satisfy the condition. (nums can have repeated numbers). [3] , [3] , [3,3], [3,6] , [3,6] , [3,3,6] ``` **Example 3:** ``` **Input:** nums = [2,3,3,4,6,7], target = 12 **Output:** 61 **Explanation:** There are 63 non-empty subsequences, two of them do not satisfy the condition ([6,7], [7]). Number of valid subsequences (63 - 2 = 61). ``` **Constraints:** `1 <= nums.length <= 105` `1 <= nums[i] <= 106` `1 <= target <= 106`",
        "test_case": [
            {
                "label": "Example 1",
                "input": "nums = [3,5,6,7], target = 9",
                "output": "4 Explanation: There are 4 subsequences that satisfy the condition.\n[3] -> Min value + max value <= target (3 + 3 <= 9)\n[3,5] -> (3 + 5 <= 9)\n[3,5,6] -> (3 + 6 <= 9)\n[3,6] -> (3 + 6 <= 9)"
            },
            {
                "label": "Example 2",
                "input": "nums = [3,3,6,8], target = 10",
                "output": "6 Explanation: There are 6 subsequences that satisfy the condition. (nums can have repeated numbers).\n[3] , [3] , [3,3], [3,6] , [3,6] , [3,3,6]"
            },
            {
                "label": "Example 3",
                "input": "nums = [2,3,3,4,6,7], target = 12",
                "output": "61 Explanation: There are 63 non-empty subsequences, two of them do not satisfy the condition ([6,7], [7]).\nNumber of valid subsequences (63 - 2 = 61)."
            }
        ],
        "elixir_template": "defmodule Solution do\n  @spec num_subseq(nums :: [integer], target :: integer) :: integer\n  def num_subseq(nums, target) do\n    \n  end\nend",
        "erlang_template": "-spec num_subseq(Nums :: [integer()], Target :: integer()) -> integer().\nnum_subseq(Nums, Target) ->\n  .",
        "scala_template": "object Solution {\n    def numSubseq(nums: Array[Int], target: Int): Int = {\n        \n    }\n}"
    },
    {
        "id": 1620,
        "name": "check-if-array-pairs-are-divisible-by-k",
        "difficulty": "Medium",
        "link": "https://leetcode.com/problems/check-if-array-pairs-are-divisible-by-k/",
        "task_description": "Given an array of integers `arr` of even length `n` and an integer `k`. We want to divide the array into exactly `n / 2` pairs such that the sum of each pair is divisible by `k`. Return `true`_ If you can find a way to do that or _`false`_ otherwise_. **Example 1:** ``` **Input:** arr = [1,2,3,4,5,10,6,7,8,9], k = 5 **Output:** true **Explanation:** Pairs are (1,9),(2,8),(3,7),(4,6) and (5,10). ``` **Example 2:** ``` **Input:** arr = [1,2,3,4,5,6], k = 7 **Output:** true **Explanation:** Pairs are (1,6),(2,5) and(3,4). ``` **Example 3:** ``` **Input:** arr = [1,2,3,4,5,6], k = 10 **Output:** false **Explanation:** You can try all possible pairs to see that there is no way to divide arr into 3 pairs each with sum divisible by 10. ``` **Constraints:** `arr.length == n` `1 <= n <= 105` `n` is even. `-109 <= arr[i] <= 109` `1 <= k <= 105`",
        "test_case": [
            {
                "label": "Example 1",
                "input": "arr = [1,2,3,4,5,10,6,7,8,9], k = 5",
                "output": "true Explanation: Pairs are (1,9),(2,8),(3,7),(4,6) and (5,10)."
            },
            {
                "label": "Example 2",
                "input": "arr = [1,2,3,4,5,6], k = 7",
                "output": "true Explanation: Pairs are (1,6),(2,5) and(3,4)."
            },
            {
                "label": "Example 3",
                "input": "arr = [1,2,3,4,5,6], k = 10",
                "output": "false Explanation: You can try all possible pairs to see that there is no way to divide arr into 3 pairs each with sum divisible by 10. Constraints: arr.length == n 1 <= n <= 10 5 n is even. -10 9 <= arr[i] <= 10 9 1 <= k <= 10 5"
            }
        ],
        "elixir_template": "defmodule Solution do\n  @spec can_arrange(arr :: [integer], k :: integer) :: boolean\n  def can_arrange(arr, k) do\n    \n  end\nend",
        "erlang_template": "-spec can_arrange(Arr :: [integer()], K :: integer()) -> boolean().\ncan_arrange(Arr, K) ->\n  .",
        "scala_template": "object Solution {\n    def canArrange(arr: Array[Int], k: Int): Boolean = {\n        \n    }\n}"
    },
    {
        "id": 1619,
        "name": "path-crossing",
        "difficulty": "Easy",
        "link": "https://leetcode.com/problems/path-crossing/",
        "task_description": "Given a string `path`, where `path[i] = 'N'`, `'S'`, `'E'` or `'W'`, each representing moving one unit north, south, east, or west, respectively. You start at the origin `(0, 0)` on a 2D plane and walk on the path specified by `path`. Return `true` _if the path crosses itself at any point, that is, if at any time you are on a location you have previously visited_. Return `false` otherwise. **Example 1:** ``` **Input:** path = \"NES\" **Output:** false **Explanation:** Notice that the path doesn't cross any point more than once. ``` **Example 2:** ``` **Input:** path = \"NESWW\" **Output:** true **Explanation:** Notice that the path visits the origin twice. ``` **Constraints:** `1 <= path.length <= 104` `path[i]` is either `'N'`, `'S'`, `'E'`, or `'W'`.",
        "test_case": [
            {
                "label": "Example 1",
                "input": "path = \"NES\"",
                "output": "false Explanation: Notice that the path doesn't cross any point more than once."
            },
            {
                "label": "Example 2",
                "input": "path = \"NESWW\"",
                "output": "true Explanation: Notice that the path visits the origin twice."
            }
        ],
        "elixir_template": "defmodule Solution do\n  @spec is_path_crossing(path :: String.t) :: boolean\n  def is_path_crossing(path) do\n    \n  end\nend",
        "erlang_template": "-spec is_path_crossing(Path :: unicode:unicode_binary()) -> boolean().\nis_path_crossing(Path) ->\n  .",
        "scala_template": "object Solution {\n    def isPathCrossing(path: String): Boolean = {\n        \n    }\n}"
    },
    {
        "id": 1617,
        "name": "stone-game-iv",
        "difficulty": "Hard",
        "link": "https://leetcode.com/problems/stone-game-iv/",
        "task_description": "Alice and Bob take turns playing a game, with Alice starting first. Initially, there are `n` stones in a pile. On each player's turn, that player makes a _move_ consisting of removing **any** non-zero **square number** of stones in the pile. Also, if a player cannot make a move, he/she loses the game. Given a positive integer `n`, return `true` if and only if Alice wins the game otherwise return `false`, assuming both players play optimally. **Example 1:** ``` **Input:** n = 1 **Output:** true **Explanation: **Alice can remove 1 stone winning the game because Bob doesn't have any moves. ``` **Example 2:** ``` **Input:** n = 2 **Output:** false **Explanation: **Alice can only remove 1 stone, after that Bob removes the last one winning the game (2 -> 1 -> 0). ``` **Example 3:** ``` **Input:** n = 4 **Output:** true **Explanation:** n is already a perfect square, Alice can win with one move, removing 4 stones (4 -> 0). ``` **Constraints:** `1 <= n <= 105`",
        "test_case": [
            {
                "label": "Example 1",
                "input": "n = 1",
                "output": "true Explanation: Alice can remove 1 stone winning the game because Bob doesn't have any moves."
            },
            {
                "label": "Example 2",
                "input": "n = 2",
                "output": "false Explanation: Alice can only remove 1 stone, after that Bob removes the last one winning the game (2 -> 1 -> 0)."
            },
            {
                "label": "Example 3",
                "input": "n = 4",
                "output": "true Explanation: n is already a perfect square, Alice can win with one move, removing 4 stones (4 -> 0)."
            }
        ],
        "elixir_template": "defmodule Solution do\n  @spec winner_square_game(n :: integer) :: boolean\n  def winner_square_game(n) do\n    \n  end\nend",
        "erlang_template": "-spec winner_square_game(N :: integer()) -> boolean().\nwinner_square_game(N) ->\n  .",
        "scala_template": "object Solution {\n    def winnerSquareGame(n: Int): Boolean = {\n        \n    }\n}"
    },
    {
        "id": 1616,
        "name": "minimum-difference-between-largest-and-smallest-value-in-three-moves",
        "difficulty": "Medium",
        "link": "https://leetcode.com/problems/minimum-difference-between-largest-and-smallest-value-in-three-moves/",
        "task_description": "You are given an integer array `nums`. In one move, you can choose one element of `nums` and change it to **any value**. Return _the minimum difference between the largest and smallest value of `nums` **after performing at most three moves**_. **Example 1:** ``` **Input:** nums = [5,3,2,4] **Output:** 0 **Explanation:** We can make at most 3 moves. In the first move, change 2 to 3. nums becomes [5,3,3,4]. In the second move, change 4 to 3. nums becomes [5,3,3,3]. In the third move, change 5 to 3. nums becomes [3,3,3,3]. After performing 3 moves, the difference between the minimum and maximum is 3 - 3 = 0. ``` **Example 2:** ``` **Input:** nums = [1,5,0,10,14] **Output:** 1 **Explanation:** We can make at most 3 moves. In the first move, change 5 to 0. nums becomes [1,0,0,10,14]. In the second move, change 10 to 0. nums becomes [1,0,0,0,14]. In the third move, change 14 to 1. nums becomes [1,0,0,0,1]. After performing 3 moves, the difference between the minimum and maximum is 1 - 0 = 1. It can be shown that there is no way to make the difference 0 in 3 moves. ``` **Example 3:** ``` **Input:** nums = [3,100,20] **Output:** 0 **Explanation:** We can make at most 3 moves. In the first move, change 100 to 7. nums becomes [3,7,20]. In the second move, change 20 to 7. nums becomes [3,7,7]. In the third move, change 3 to 7. nums becomes [7,7,7]. After performing 3 moves, the difference between the minimum and maximum is 7 - 7 = 0. ``` **Constraints:** `1 <= nums.length <= 105` `-109 <= nums[i] <= 109`",
        "test_case": [
            {
                "label": "Example 1",
                "input": "nums = [5,3,2,4]",
                "output": "0 Explanation: We can make at most 3 moves.\nIn the first move, change 2 to 3. nums becomes [5,3,3,4].\nIn the second move, change 4 to 3. nums becomes [5,3,3,3].\nIn the third move, change 5 to 3. nums becomes [3,3,3,3].\nAfter performing 3 moves, the difference between the minimum and maximum is 3 - 3 = 0."
            },
            {
                "label": "Example 2",
                "input": "nums = [1,5,0,10,14]",
                "output": "1 Explanation: We can make at most 3 moves.\nIn the first move, change 5 to 0. nums becomes [1,0,0,10,14].\nIn the second move, change 10 to 0. nums becomes [1,0,0,0,14].\nIn the third move, change 14 to 1. nums becomes [1,0,0,0,1].\nAfter performing 3 moves, the difference between the minimum and maximum is 1 - 0 = 1.\nIt can be shown that there is no way to make the difference 0 in 3 moves."
            },
            {
                "label": "Example 3",
                "input": "nums = [3,100,20]",
                "output": "0 Explanation: We can make at most 3 moves.\nIn the first move, change 100 to 7. nums becomes [3,7,20].\nIn the second move, change 20 to 7. nums becomes [3,7,7].\nIn the third move, change 3 to 7. nums becomes [7,7,7].\nAfter performing 3 moves, the difference between the minimum and maximum is 7 - 7 = 0."
            }
        ],
        "elixir_template": "defmodule Solution do\n  @spec min_difference(nums :: [integer]) :: integer\n  def min_difference(nums) do\n    \n  end\nend",
        "erlang_template": "-spec min_difference(Nums :: [integer()]) -> integer().\nmin_difference(Nums) ->\n  .",
        "scala_template": "object Solution {\n    def minDifference(nums: Array[Int]): Int = {\n        \n    }\n}"
    },
    {
        "id": 1615,
        "name": "range-sum-of-sorted-subarray-sums",
        "difficulty": "Medium",
        "link": "https://leetcode.com/problems/range-sum-of-sorted-subarray-sums/",
        "task_description": "You are given the array `nums` consisting of `n` positive integers. You computed the sum of all non-empty continuous subarrays from the array and then sorted them in non-decreasing order, creating a new array of `n * (n + 1) / 2` numbers. _Return the sum of the numbers from index _`left`_ to index _`right` (**indexed from 1**)_, inclusive, in the new array. _Since the answer can be a huge number return it modulo `109 + 7`. **Example 1:** ``` **Input:** nums = [1,2,3,4], n = 4, left = 1, right = 5 **Output:** 13 **Explanation:** All subarray sums are 1, 3, 6, 10, 2, 5, 9, 3, 7, 4. After sorting them in non-decreasing order we have the new array [1, 2, 3, 3, 4, 5, 6, 7, 9, 10]. The sum of the numbers from index le = 1 to ri = 5 is 1 + 2 + 3 + 3 + 4 = 13. ``` **Example 2:** ``` **Input:** nums = [1,2,3,4], n = 4, left = 3, right = 4 **Output:** 6 **Explanation:** The given array is the same as example 1. We have the new array [1, 2, 3, 3, 4, 5, 6, 7, 9, 10]. The sum of the numbers from index le = 3 to ri = 4 is 3 + 3 = 6. ``` **Example 3:** ``` **Input:** nums = [1,2,3,4], n = 4, left = 1, right = 10 **Output:** 50 ``` **Constraints:** `n == nums.length` `1 <= nums.length <= 1000` `1 <= nums[i] <= 100` `1 <= left <= right <= n * (n + 1) / 2`",
        "test_case": [
            {
                "label": "Example 1",
                "input": "nums = [1,2,3,4], n = 4, left = 1, right = 5",
                "output": "13 Explanation: All subarray sums are 1, 3, 6, 10, 2, 5, 9, 3, 7, 4. After sorting them in non-decreasing order we have the new array [1, 2, 3, 3, 4, 5, 6, 7, 9, 10]. The sum of the numbers from index le = 1 to ri = 5 is 1 + 2 + 3 + 3 + 4 = 13."
            },
            {
                "label": "Example 2",
                "input": "nums = [1,2,3,4], n = 4, left = 3, right = 4",
                "output": "6 Explanation: The given array is the same as example 1. We have the new array [1, 2, 3, 3, 4, 5, 6, 7, 9, 10]. The sum of the numbers from index le = 3 to ri = 4 is 3 + 3 = 6."
            },
            {
                "label": "Example 3",
                "input": "nums = [1,2,3,4], n = 4, left = 1, right = 10",
                "output": "50 Constraints: n == nums.length 1 <= nums.length <= 1000 1 <= nums[i] <= 100 1 <= left <= right <= n * (n + 1) / 2"
            }
        ],
        "elixir_template": "defmodule Solution do\n  @spec range_sum(nums :: [integer], n :: integer, left :: integer, right :: integer) :: integer\n  def range_sum(nums, n, left, right) do\n    \n  end\nend",
        "erlang_template": "-spec range_sum(Nums :: [integer()], N :: integer(), Left :: integer(), Right :: integer()) -> integer().\nrange_sum(Nums, N, Left, Right) ->\n  .",
        "scala_template": "object Solution {\n    def rangeSum(nums: Array[Int], n: Int, left: Int, right: Int): Int = {\n        \n    }\n}"
    },
    {
        "id": 1613,
        "name": "find-critical-and-pseudo-critical-edges-in-minimum-spanning-tree",
        "difficulty": "Hard",
        "link": "https://leetcode.com/problems/find-critical-and-pseudo-critical-edges-in-minimum-spanning-tree/",
        "task_description": "Given a weighted undirected connected graph with `n` vertices numbered from `0` to `n - 1`, and an array `edges` where `edges[i] = [ai, bi, weighti]` represents a bidirectional and weighted edge between nodes `ai` and `bi`. A minimum spanning tree (MST) is a subset of the graph's edges that connects all vertices without cycles and with the minimum possible total edge weight. Find _all the critical and pseudo-critical edges in the given graph's minimum spanning tree (MST)_. An MST edge whose deletion from the graph would cause the MST weight to increase is called a _critical edge_. On the other hand, a pseudo-critical edge is that which can appear in some MSTs but not all. Note that you can return the indices of the edges in any order. **Example 1:** ``` **Input:** n = 5, edges = [[0,1,1],[1,2,1],[2,3,2],[0,3,2],[0,4,3],[3,4,3],[1,4,6]] **Output:** [[0,1],[2,3,4,5]] **Explanation:** The figure above describes the graph. The following figure shows all the possible MSTs: Notice that the two edges 0 and 1 appear in all MSTs, therefore they are critical edges, so we return them in the first list of the output. The edges 2, 3, 4, and 5 are only part of some MSTs, therefore they are considered pseudo-critical edges. We add them to the second list of the output. ``` **Example 2:** ``` **Input:** n = 4, edges = [[0,1,1],[1,2,1],[2,3,1],[0,3,1]] **Output:** [[],[0,1,2,3]] **Explanation:** We can observe that since all 4 edges have equal weight, choosing any 3 edges from the given 4 will yield an MST. Therefore all 4 edges are pseudo-critical. ``` **Constraints:** `2 <= n <= 100` `1 <= edges.length <= min(200, n * (n - 1) / 2)` `edges[i].length == 3` `0 <= ai < bi < n` `1 <= weighti <= 1000` All pairs `(ai, bi)` are **distinct**.",
        "test_case": [
            {
                "label": "Example 1",
                "input": "n = 5, edges = [[0,1,1],[1,2,1],[2,3,2],[0,3,2],[0,4,3],[3,4,3],[1,4,6]]",
                "output": "[[0,1],[2,3,4,5]] Explanation: The figure above describes the graph.\nThe following figure shows all the possible MSTs: Notice that the two edges 0 and 1 appear in all MSTs, therefore they are critical edges, so we return them in the first list of the output.\nThe edges 2, 3, 4, and 5 are only part of some MSTs, therefore they are considered pseudo-critical edges. We add them to the second list of the output."
            },
            {
                "label": "Example 2",
                "input": "n = 4, edges = [[0,1,1],[1,2,1],[2,3,1],[0,3,1]]",
                "output": "[[],[0,1,2,3]] Explanation: We can observe that since all 4 edges have equal weight, choosing any 3 edges from the given 4 will yield an MST. Therefore all 4 edges are pseudo-critical."
            }
        ],
        "elixir_template": "defmodule Solution do\n  @spec find_critical_and_pseudo_critical_edges(n :: integer, edges :: [[integer]]) :: [[integer]]\n  def find_critical_and_pseudo_critical_edges(n, edges) do\n    \n  end\nend",
        "erlang_template": "-spec find_critical_and_pseudo_critical_edges(N :: integer(), Edges :: [[integer()]]) -> [[integer()]].\nfind_critical_and_pseudo_critical_edges(N, Edges) ->\n  .",
        "scala_template": "object Solution {\n    def findCriticalAndPseudoCriticalEdges(n: Int, edges: Array[Array[Int]]): List[List[Int]] = {\n        \n    }\n}"
    },
    {
        "id": 1612,
        "name": "avoid-flood-in-the-city",
        "difficulty": "Medium",
        "link": "https://leetcode.com/problems/avoid-flood-in-the-city/",
        "task_description": "Your country has an infinite number of lakes. Initially, all the lakes are empty, but when it rains over the `nth` lake, the `nth` lake becomes full of water. If it rains over a lake that is **full of water**, there will be a **flood**. Your goal is to avoid floods in any lake. Given an integer array `rains` where: `rains[i] > 0` means there will be rains over the `rains[i]` lake. `rains[i] == 0` means there are no rains this day and you can choose **one lake** this day and **dry it**. Return _an array `ans`_ where: `ans.length == rains.length` `ans[i] == -1` if `rains[i] > 0`. `ans[i]` is the lake you choose to dry in the `ith` day if `rains[i] == 0`. If there are multiple valid answers return **any** of them. If it is impossible to avoid flood return **an empty array**. Notice that if you chose to dry a full lake, it becomes empty, but if you chose to dry an empty lake, nothing changes. **Example 1:** ``` **Input:** rains = [1,2,3,4] **Output:** [-1,-1,-1,-1] **Explanation:** After the first day full lakes are [1] After the second day full lakes are [1,2] After the third day full lakes are [1,2,3] After the fourth day full lakes are [1,2,3,4] There's no day to dry any lake and there is no flood in any lake. ``` **Example 2:** ``` **Input:** rains = [1,2,0,0,2,1] **Output:** [-1,-1,2,1,-1,-1] **Explanation:** After the first day full lakes are [1] After the second day full lakes are [1,2] After the third day, we dry lake 2. Full lakes are [1] After the fourth day, we dry lake 1. There is no full lakes. After the fifth day, full lakes are [2]. After the sixth day, full lakes are [1,2]. It is easy that this scenario is flood-free. [-1,-1,1,2,-1,-1] is another acceptable scenario. ``` **Example 3:** ``` **Input:** rains = [1,2,0,1,2] **Output:** [] **Explanation:** After the second day, full lakes are [1,2]. We have to dry one lake in the third day. After that, it will rain over lakes [1,2]. It's easy to prove that no matter which lake you choose to dry in the 3rd day, the other one will flood. ``` **Constraints:** `1 <= rains.length <= 105` `0 <= rains[i] <= 109`",
        "test_case": [
            {
                "label": "Example 1",
                "input": "rains = [1,2,3,4]",
                "output": "[-1,-1,-1,-1] Explanation: After the first day full lakes are [1]\nAfter the second day full lakes are [1,2]\nAfter the third day full lakes are [1,2,3]\nAfter the fourth day full lakes are [1,2,3,4]\nThere's no day to dry any lake and there is no flood in any lake."
            },
            {
                "label": "Example 2",
                "input": "rains = [1,2,0,0,2,1]",
                "output": "[-1,-1,2,1,-1,-1] Explanation: After the first day full lakes are [1]\nAfter the second day full lakes are [1,2]\nAfter the third day, we dry lake 2. Full lakes are [1]\nAfter the fourth day, we dry lake 1. There is no full lakes.\nAfter the fifth day, full lakes are [2].\nAfter the sixth day, full lakes are [1,2].\nIt is easy that this scenario is flood-free. [-1,-1,1,2,-1,-1] is another acceptable scenario."
            },
            {
                "label": "Example 3",
                "input": "rains = [1,2,0,1,2]",
                "output": "[] Explanation: After the second day, full lakes are  [1,2]. We have to dry one lake in the third day.\nAfter that, it will rain over lakes [1,2]. It's easy to prove that no matter which lake you choose to dry in the 3rd day, the other one will flood."
            }
        ],
        "elixir_template": "defmodule Solution do\n  @spec avoid_flood(rains :: [integer]) :: [integer]\n  def avoid_flood(rains) do\n    \n  end\nend",
        "erlang_template": "-spec avoid_flood(Rains :: [integer()]) -> [integer()].\navoid_flood(Rains) ->\n  .",
        "scala_template": "object Solution {\n    def avoidFlood(rains: Array[Int]): Array[Int] = {\n        \n    }\n}"
    },
    {
        "id": 1611,
        "name": "making-file-names-unique",
        "difficulty": "Medium",
        "link": "https://leetcode.com/problems/making-file-names-unique/",
        "task_description": "Given an array of strings `names` of size `n`. You will create `n` folders in your file system **such that**, at the `ith` minute, you will create a folder with the name `names[i]`. Since two files **cannot** have the same name, if you enter a folder name that was previously used, the system will have a suffix addition to its name in the form of `(k)`, where, `k` is the **smallest positive integer** such that the obtained name remains unique. Return _an array of strings of length _`n` where `ans[i]` is the actual name the system will assign to the `ith` folder when you create it. **Example 1:** ``` **Input:** names = [\"pes\",\"fifa\",\"gta\",\"pes(2019)\"] **Output:** [\"pes\",\"fifa\",\"gta\",\"pes(2019)\"] **Explanation:** Let's see how the file system creates folder names: \"pes\" --> not assigned before, remains \"pes\" \"fifa\" --> not assigned before, remains \"fifa\" \"gta\" --> not assigned before, remains \"gta\" \"pes(2019)\" --> not assigned before, remains \"pes(2019)\" ``` **Example 2:** ``` **Input:** names = [\"gta\",\"gta(1)\",\"gta\",\"avalon\"] **Output:** [\"gta\",\"gta(1)\",\"gta(2)\",\"avalon\"] **Explanation:** Let's see how the file system creates folder names: \"gta\" --> not assigned before, remains \"gta\" \"gta(1)\" --> not assigned before, remains \"gta(1)\" \"gta\" --> the name is reserved, system adds (k), since \"gta(1)\" is also reserved, systems put k = 2. it becomes \"gta(2)\" \"avalon\" --> not assigned before, remains \"avalon\" ``` **Example 3:** ``` **Input:** names = [\"onepiece\",\"onepiece(1)\",\"onepiece(2)\",\"onepiece(3)\",\"onepiece\"] **Output:** [\"onepiece\",\"onepiece(1)\",\"onepiece(2)\",\"onepiece(3)\",\"onepiece(4)\"] **Explanation:** When the last folder is created, the smallest positive valid k is 4, and it becomes \"onepiece(4)\". ``` **Constraints:** `1 <= names.length <= 5 * 104` `1 <= names[i].length <= 20` `names[i]` consists of lowercase English letters, digits, and/or round brackets.",
        "test_case": [
            {
                "label": "Example 1",
                "input": "names = [\"pes\",\"fifa\",\"gta\",\"pes(2019)\"]",
                "output": "[\"pes\",\"fifa\",\"gta\",\"pes(2019)\"] Explanation: Let's see how the file system creates folder names:\n\"pes\" --> not assigned before, remains \"pes\"\n\"fifa\" --> not assigned before, remains \"fifa\"\n\"gta\" --> not assigned before, remains \"gta\"\n\"pes(2019)\" --> not assigned before, remains \"pes(2019)\""
            },
            {
                "label": "Example 2",
                "input": "names = [\"gta\",\"gta(1)\",\"gta\",\"avalon\"]",
                "output": "[\"gta\",\"gta(1)\",\"gta(2)\",\"avalon\"] Explanation: Let's see how the file system creates folder names:\n\"gta\" --> not assigned before, remains \"gta\"\n\"gta(1)\" --> not assigned before, remains \"gta(1)\"\n\"gta\" --> the name is reserved, system adds (k), since \"gta(1)\" is also reserved, systems put k = 2. it becomes \"gta(2)\"\n\"avalon\" --> not assigned before, remains \"avalon\""
            },
            {
                "label": "Example 3",
                "input": "names = [\"onepiece\",\"onepiece(1)\",\"onepiece(2)\",\"onepiece(3)\",\"onepiece\"]",
                "output": "[\"onepiece\",\"onepiece(1)\",\"onepiece(2)\",\"onepiece(3)\",\"onepiece(4)\"] Explanation: When the last folder is created, the smallest positive valid k is 4, and it becomes \"onepiece(4)\"."
            }
        ],
        "elixir_template": "defmodule Solution do\n  @spec get_folder_names(names :: [String.t]) :: [String.t]\n  def get_folder_names(names) do\n    \n  end\nend",
        "erlang_template": "-spec get_folder_names(Names :: [unicode:unicode_binary()]) -> [unicode:unicode_binary()].\nget_folder_names(Names) ->\n  .",
        "scala_template": "object Solution {\n    def getFolderNames(names: Array[String]): Array[String] = {\n        \n    }\n}"
    },
    {
        "id": 1610,
        "name": "xor-operation-in-an-array",
        "difficulty": "Easy",
        "link": "https://leetcode.com/problems/xor-operation-in-an-array/",
        "task_description": "You are given an integer `n` and an integer `start`. Define an array `nums` where `nums[i] = start + 2 * i` (**0-indexed**) and `n == nums.length`. Return _the bitwise XOR of all elements of_ `nums`. **Example 1:** ``` **Input:** n = 5, start = 0 **Output:** 8 **Explanation:** Array nums is equal to [0, 2, 4, 6, 8] where (0 ^ 2 ^ 4 ^ 6 ^ 8) = 8. Where \"^\" corresponds to bitwise XOR operator. ``` **Example 2:** ``` **Input:** n = 4, start = 3 **Output:** 8 **Explanation:** Array nums is equal to [3, 5, 7, 9] where (3 ^ 5 ^ 7 ^ 9) = 8. ``` **Constraints:** `1 <= n <= 1000` `0 <= start <= 1000` `n == nums.length`",
        "test_case": [
            {
                "label": "Example 1",
                "input": "n = 5, start = 0",
                "output": "8 Explanation: Array nums is equal to [0, 2, 4, 6, 8] where (0 ^ 2 ^ 4 ^ 6 ^ 8) = 8.\nWhere \"^\" corresponds to bitwise XOR operator."
            },
            {
                "label": "Example 2",
                "input": "n = 4, start = 3",
                "output": "8 Explanation: Array nums is equal to [3, 5, 7, 9] where (3 ^ 5 ^ 7 ^ 9) = 8."
            }
        ],
        "elixir_template": "defmodule Solution do\n  @spec xor_operation(n :: integer, start :: integer) :: integer\n  def xor_operation(n, start) do\n    \n  end\nend",
        "erlang_template": "-spec xor_operation(N :: integer(), Start :: integer()) -> integer().\nxor_operation(N, Start) ->\n  .",
        "scala_template": "object Solution {\n    def xorOperation(n: Int, start: Int): Int = {\n        \n    }\n}"
    },
    {
        "id": 1605,
        "name": "minimum-number-of-days-to-make-m-bouquets",
        "difficulty": "Medium",
        "link": "https://leetcode.com/problems/minimum-number-of-days-to-make-m-bouquets/",
        "task_description": "You are given an integer array `bloomDay`, an integer `m` and an integer `k`. You want to make `m` bouquets. To make a bouquet, you need to use `k` **adjacent flowers** from the garden. The garden consists of `n` flowers, the `ith` flower will bloom in the `bloomDay[i]` and then can be used in **exactly one** bouquet. Return _the minimum number of days you need to wait to be able to make _`m`_ bouquets from the garden_. If it is impossible to make m bouquets return `-1`. **Example 1:** ``` **Input:** bloomDay = [1,10,3,10,2], m = 3, k = 1 **Output:** 3 **Explanation:** Let us see what happened in the first three days. x means flower bloomed and _ means flower did not bloom in the garden. We need 3 bouquets each should contain 1 flower. After day 1: [x, _, _, _, _] // we can only make one bouquet. After day 2: [x, _, _, _, x] // we can only make two bouquets. After day 3: [x, _, x, _, x] // we can make 3 bouquets. The answer is 3. ``` **Example 2:** ``` **Input:** bloomDay = [1,10,3,10,2], m = 3, k = 2 **Output:** -1 **Explanation:** We need 3 bouquets each has 2 flowers, that means we need 6 flowers. We only have 5 flowers so it is impossible to get the needed bouquets and we return -1. ``` **Example 3:** ``` **Input:** bloomDay = [7,7,7,7,12,7,7], m = 2, k = 3 **Output:** 12 **Explanation:** We need 2 bouquets each should have 3 flowers. Here is the garden after the 7 and 12 days: After day 7: [x, x, x, x, _, x, x] We can make one bouquet of the first three flowers that bloomed. We cannot make another bouquet from the last three flowers that bloomed because they are not adjacent. After day 12: [x, x, x, x, x, x, x] It is obvious that we can make two bouquets in different ways. ``` **Constraints:** `bloomDay.length == n` `1 <= n <= 105` `1 <= bloomDay[i] <= 109` `1 <= m <= 106` `1 <= k <= n`",
        "test_case": [
            {
                "label": "Example 1",
                "input": "bloomDay = [1,10,3,10,2], m = 3, k = 1",
                "output": "3 Explanation: Let us see what happened in the first three days. x means flower bloomed and _ means flower did not bloom in the garden.\nWe need 3 bouquets each should contain 1 flower.\nAfter day 1: [x, _, _, _, _]   // we can only make one bouquet.\nAfter day 2: [x, _, _, _, x]   // we can only make two bouquets.\nAfter day 3: [x, _, x, _, x]   // we can make 3 bouquets. The answer is 3."
            },
            {
                "label": "Example 2",
                "input": "bloomDay = [1,10,3,10,2], m = 3, k = 2",
                "output": "-1 Explanation: We need 3 bouquets each has 2 flowers, that means we need 6 flowers. We only have 5 flowers so it is impossible to get the needed bouquets and we return -1."
            },
            {
                "label": "Example 3",
                "input": "bloomDay = [7,7,7,7,12,7,7], m = 2, k = 3",
                "output": "12 Explanation: We need 2 bouquets each should have 3 flowers.\nHere is the garden after the 7 and 12 days:\nAfter day 7: [x, x, x, x, _, x, x]\nWe can make one bouquet of the first three flowers that bloomed. We cannot make another bouquet from the last three flowers that bloomed because they are not adjacent.\nAfter day 12: [x, x, x, x, x, x, x]\nIt is obvious that we can make two bouquets in different ways. Constraints: bloomDay.length == n 1 <= n <= 10 5 1 <= bloomDay[i] <= 10 9 1 <= m <= 10 6 1 <= k <= n"
            }
        ],
        "elixir_template": "defmodule Solution do\n  @spec min_days(bloom_day :: [integer], m :: integer, k :: integer) :: integer\n  def min_days(bloom_day, m, k) do\n    \n  end\nend",
        "erlang_template": "-spec min_days(BloomDay :: [integer()], M :: integer(), K :: integer()) -> integer().\nmin_days(BloomDay, M, K) ->\n  .",
        "scala_template": "object Solution {\n    def minDays(bloomDay: Array[Int], m: Int, k: Int): Int = {\n        \n    }\n}"
    },
    {
        "id": 1604,
        "name": "least-number-of-unique-integers-after-k-removals",
        "difficulty": "Medium",
        "link": "https://leetcode.com/problems/least-number-of-unique-integers-after-k-removals/",
        "task_description": "Given an array of integers `arr` and an integer `k`. Find the _least number of unique integers_ after removing **exactly** `k` elements. **Example 1:** ``` **Input: **arr = [5,5,4], k = 1 **Output: **1 **Explanation**: Remove the single 4, only 5 is left. ``` **Example 2:** ``` **Input: **arr = [4,3,1,1,3,3,2], k = 3 **Output: **2 **Explanation**: Remove 4, 2 and either one of the two 1s or three 3s. 1 and 3 will be left. ``` **Constraints:** `1 <= arr.length <= 10^5` `1 <= arr[i] <= 10^9` `0 <= k <= arr.length`",
        "test_case": [
            {
                "label": "Example 1",
                "input": "arr = [5,5,4], k = 1",
                "output": "1 Explanation : Remove the single 4, only 5 is left."
            },
            {
                "label": "Example 2",
                "input": "arr = [4,3,1,1,3,3,2], k = 3",
                "output": "2 Explanation : Remove 4, 2 and either one of the two 1s or three 3s. 1 and 3 will be left."
            }
        ],
        "elixir_template": "Elixir code template not available for this problem.",
        "erlang_template": "Elixir code template not available for this problem.",
        "scala_template": "object Solution {\r\n    def findLeastNumOfUniqueInts(arr: Array[Int], k: Int): Int = {\r\n        \r\n    }\r\n}"
    },
    {
        "id": 1603,
        "name": "running-sum-of-1d-array",
        "difficulty": "Easy",
        "link": "https://leetcode.com/problems/running-sum-of-1d-array/",
        "task_description": "Given an array `nums`. We define a running sum of an array as `runningSum[i] = sum(nums[0]\u2026nums[i])`. Return the running sum of `nums`. **Example 1:** ``` **Input:** nums = [1,2,3,4] **Output:** [1,3,6,10] **Explanation:** Running sum is obtained as follows: [1, 1+2, 1+2+3, 1+2+3+4]. ``` **Example 2:** ``` **Input:** nums = [1,1,1,1,1] **Output:** [1,2,3,4,5] **Explanation:** Running sum is obtained as follows: [1, 1+1, 1+1+1, 1+1+1+1, 1+1+1+1+1]. ``` **Example 3:** ``` **Input:** nums = [3,1,2,10,1] **Output:** [3,4,6,16,17] ``` **Constraints:** `1 <= nums.length <= 1000` `-10^6 <= nums[i] <= 10^6`",
        "test_case": [
            {
                "label": "Example 1",
                "input": "nums = [1,2,3,4]",
                "output": "[1,3,6,10] Explanation: Running sum is obtained as follows: [1, 1+2, 1+2+3, 1+2+3+4]."
            },
            {
                "label": "Example 2",
                "input": "nums = [1,1,1,1,1]",
                "output": "[1,2,3,4,5] Explanation: Running sum is obtained as follows: [1, 1+1, 1+1+1, 1+1+1+1, 1+1+1+1+1]."
            },
            {
                "label": "Example 3",
                "input": "nums = [3,1,2,10,1]",
                "output": "[3,4,6,16,17]"
            }
        ],
        "elixir_template": "defmodule Solution do\n  @spec running_sum(nums :: [integer]) :: [integer]\n  def running_sum(nums) do\n    \n  end\nend",
        "erlang_template": "-spec running_sum(Nums :: [integer()]) -> [integer()].\nrunning_sum(Nums) ->\n  .",
        "scala_template": "object Solution {\n    def runningSum(nums: Array[Int]): Array[Int] = {\n        \n    }\n}"
    },
    {
        "id": 1587,
        "name": "parallel-courses-ii",
        "difficulty": "Hard",
        "link": "https://leetcode.com/problems/parallel-courses-ii/",
        "task_description": "You are given an integer `n`, which indicates that there are `n` courses labeled from `1` to `n`. You are also given an array `relations` where `relations[i] = [prevCoursei, nextCoursei]`, representing a prerequisite relationship between course `prevCoursei` and course `nextCoursei`: course `prevCoursei` has to be taken before course `nextCoursei`. Also, you are given the integer `k`. In one semester, you can take **at most** `k` courses as long as you have taken all the prerequisites in the **previous** semesters for the courses you are taking. Return _the **minimum** number of semesters needed to take all courses_. The testcases will be generated such that it is possible to take every course. **Example 1:** ``` **Input:** n = 4, relations = [[2,1],[3,1],[1,4]], k = 2 **Output:** 3 **Explanation:** The figure above represents the given graph. In the first semester, you can take courses 2 and 3. In the second semester, you can take course 1. In the third semester, you can take course 4. ``` **Example 2:** ``` **Input:** n = 5, relations = [[2,1],[3,1],[4,1],[1,5]], k = 2 **Output:** 4 **Explanation:** The figure above represents the given graph. In the first semester, you can only take courses 2 and 3 since you cannot take more than two per semester. In the second semester, you can take course 4. In the third semester, you can take course 1. In the fourth semester, you can take course 5. ``` **Constraints:** `1 <= n <= 15` `1 <= k <= n` `0 <= relations.length <= n * (n-1) / 2` `relations[i].length == 2` `1 <= prevCoursei, nextCoursei <= n` `prevCoursei != nextCoursei` All the pairs `[prevCoursei, nextCoursei]` are **unique**. The given graph is a directed acyclic graph.",
        "test_case": [
            {
                "label": "Example 1",
                "input": "n = 4, relations = [[2,1],[3,1],[1,4]], k = 2",
                "output": "3 Explanation: The figure above represents the given graph.\nIn the first semester, you can take courses 2 and 3.\nIn the second semester, you can take course 1.\nIn the third semester, you can take course 4."
            },
            {
                "label": "Example 2",
                "input": "n = 5, relations = [[2,1],[3,1],[4,1],[1,5]], k = 2",
                "output": "4 Explanation: The figure above represents the given graph.\nIn the first semester, you can only take courses 2 and 3 since you cannot take more than two per semester.\nIn the second semester, you can take course 4.\nIn the third semester, you can take course 1.\nIn the fourth semester, you can take course 5."
            }
        ],
        "elixir_template": "defmodule Solution do\n  @spec min_number_of_semesters(n :: integer, relations :: [[integer]], k :: integer) :: integer\n  def min_number_of_semesters(n, relations, k) do\n    \n  end\nend",
        "erlang_template": "-spec min_number_of_semesters(N :: integer(), Relations :: [[integer()]], K :: integer()) -> integer().\nmin_number_of_semesters(N, Relations, K) ->\n  .",
        "scala_template": "object Solution {\n    def minNumberOfSemesters(n: Int, relations: Array[Array[Int]], k: Int): Int = {\n        \n    }\n}"
    },
    {
        "id": 1586,
        "name": "longest-subarray-of-1s-after-deleting-one-element",
        "difficulty": "Medium",
        "link": "https://leetcode.com/problems/longest-subarray-of-1s-after-deleting-one-element/",
        "task_description": "Given a binary array `nums`, you should delete one element from it. Return _the size of the longest non-empty subarray containing only _`1`_'s in the resulting array_. Return `0` if there is no such subarray. **Example 1:** ``` **Input:** nums = [1,1,0,1] **Output:** 3 **Explanation:** After deleting the number in position 2, [1,1,1] contains 3 numbers with value of 1's. ``` **Example 2:** ``` **Input:** nums = [0,1,1,1,0,1,1,0,1] **Output:** 5 **Explanation:** After deleting the number in position 4, [0,1,1,1,1,1,0,1] longest subarray with value of 1's is [1,1,1,1,1]. ``` **Example 3:** ``` **Input:** nums = [1,1,1] **Output:** 2 **Explanation:** You must delete one element. ``` **Constraints:** `1 <= nums.length <= 105` `nums[i]` is either `0` or `1`.",
        "test_case": [
            {
                "label": "Example 1",
                "input": "nums = [1,1,0,1]",
                "output": "3 Explanation: After deleting the number in position 2, [1,1,1] contains 3 numbers with value of 1's."
            },
            {
                "label": "Example 2",
                "input": "nums = [0,1,1,1,0,1,1,0,1]",
                "output": "5 Explanation: After deleting the number in position 4, [0,1,1,1,1,1,0,1] longest subarray with value of 1's is [1,1,1,1,1]."
            },
            {
                "label": "Example 3",
                "input": "nums = [1,1,1]",
                "output": "2 Explanation: You must delete one element."
            }
        ],
        "elixir_template": "defmodule Solution do\n  @spec longest_subarray(nums :: [integer]) :: integer\n  def longest_subarray(nums) do\n    \n  end\nend",
        "erlang_template": "-spec longest_subarray(Nums :: [integer()]) -> integer().\nlongest_subarray(Nums) ->\n  .",
        "scala_template": "object Solution {\n    def longestSubarray(nums: Array[Int]): Int = {\n        \n    }\n}"
    },
    {
        "id": 1585,
        "name": "the-kth-factor-of-n",
        "difficulty": "Medium",
        "link": "https://leetcode.com/problems/the-kth-factor-of-n/",
        "task_description": "You are given two positive integers `n` and `k`. A factor of an integer `n` is defined as an integer `i` where `n % i == 0`. Consider a list of all factors of `n` sorted in **ascending order**, return _the _`kth`_ factor_ in this list or return `-1` if `n` has less than `k` factors. **Example 1:** ``` **Input:** n = 12, k = 3 **Output:** 3 **Explanation:** Factors list is [1, 2, 3, 4, 6, 12], the 3rd factor is 3. ``` **Example 2:** ``` **Input:** n = 7, k = 2 **Output:** 7 **Explanation:** Factors list is [1, 7], the 2nd factor is 7. ``` **Example 3:** ``` **Input:** n = 4, k = 4 **Output:** -1 **Explanation:** Factors list is [1, 2, 4], there is only 3 factors. We should return -1. ``` **Constraints:** `1 <= k <= n <= 1000` **Follow up:** Could you solve this problem in less than O(n) complexity?",
        "test_case": [
            {
                "label": "Example 1",
                "input": "n = 12, k = 3",
                "output": "3 Explanation: Factors list is [1, 2, 3, 4, 6, 12], the 3 rd factor is 3."
            },
            {
                "label": "Example 2",
                "input": "n = 7, k = 2",
                "output": "7 Explanation: Factors list is [1, 7], the 2 nd factor is 7."
            },
            {
                "label": "Example 3",
                "input": "n = 4, k = 4",
                "output": "-1 Explanation: Factors list is [1, 2, 4], there is only 3 factors. We should return -1."
            }
        ],
        "elixir_template": "defmodule Solution do\n  @spec kth_factor(n :: integer, k :: integer) :: integer\n  def kth_factor(n, k) do\n    \n  end\nend",
        "erlang_template": "-spec kth_factor(N :: integer(), K :: integer()) -> integer().\nkth_factor(N, K) ->\n  .",
        "scala_template": "object Solution {\n    def kthFactor(n: Int, k: Int): Int = {\n        \n    }\n}"
    },
    {
        "id": 1584,
        "name": "average-salary-excluding-the-minimum-and-maximum-salary",
        "difficulty": "Easy",
        "link": "https://leetcode.com/problems/average-salary-excluding-the-minimum-and-maximum-salary/",
        "task_description": "You are given an array of **unique** integers `salary` where `salary[i]` is the salary of the `ith` employee. Return _the average salary of employees excluding the minimum and maximum salary_. Answers within `10-5` of the actual answer will be accepted. **Example 1:** ``` **Input:** salary = [4000,3000,1000,2000] **Output:** 2500.00000 **Explanation:** Minimum salary and maximum salary are 1000 and 4000 respectively. Average salary excluding minimum and maximum salary is (2000+3000) / 2 = 2500 ``` **Example 2:** ``` **Input:** salary = [1000,2000,3000] **Output:** 2000.00000 **Explanation:** Minimum salary and maximum salary are 1000 and 3000 respectively. Average salary excluding minimum and maximum salary is (2000) / 1 = 2000 ``` **Constraints:** `3 <= salary.length <= 100` `1000 <= salary[i] <= 106` All the integers of `salary` are **unique**.",
        "test_case": [
            {
                "label": "Example 1",
                "input": "salary = [4000,3000,1000,2000]",
                "output": "2500.00000 Explanation: Minimum salary and maximum salary are 1000 and 4000 respectively.\nAverage salary excluding minimum and maximum salary is (2000+3000) / 2 = 2500"
            },
            {
                "label": "Example 2",
                "input": "salary = [1000,2000,3000]",
                "output": "2000.00000 Explanation: Minimum salary and maximum salary are 1000 and 3000 respectively.\nAverage salary excluding minimum and maximum salary is (2000) / 1 = 2000"
            }
        ],
        "elixir_template": "defmodule Solution do\n  @spec average(salary :: [integer]) :: float\n  def average(salary) do\n    \n  end\nend",
        "erlang_template": "-spec average(Salary :: [integer()]) -> float().\naverage(Salary) ->\n  .",
        "scala_template": "object Solution {\n    def average(salary: Array[Int]): Double = {\n        \n    }\n}"
    },
    {
        "id": 1583,
        "name": "paint-house-iii",
        "difficulty": "Hard",
        "link": "https://leetcode.com/problems/paint-house-iii/",
        "task_description": "There is a row of `m` houses in a small city, each house must be painted with one of the `n` colors (labeled from `1` to `n`), some houses that have been painted last summer should not be painted again. A neighborhood is a maximal group of continuous houses that are painted with the same color. For example: `houses = [1,2,2,3,3,2,1,1]` contains `5` neighborhoods `[{1}, {2,2}, {3,3}, {2}, {1,1}]`. Given an array `houses`, an `m x n` matrix `cost` and an integer `target` where: `houses[i]`: is the color of the house `i`, and `0` if the house is not painted yet. `cost[i][j]`: is the cost of paint the house `i` with the color `j + 1`. Return _the minimum cost of painting all the remaining houses in such a way that there are exactly_ `target` _neighborhoods_. If it is not possible, return `-1`. **Example 1:** ``` **Input:** houses = [0,0,0,0,0], cost = [[1,10],[10,1],[10,1],[1,10],[5,1]], m = 5, n = 2, target = 3 **Output:** 9 **Explanation:** Paint houses of this way [1,2,2,1,1] This array contains target = 3 neighborhoods, [{1}, {2,2}, {1,1}]. Cost of paint all houses (1 + 1 + 1 + 1 + 5) = 9. ``` **Example 2:** ``` **Input:** houses = [0,2,1,2,0], cost = [[1,10],[10,1],[10,1],[1,10],[5,1]], m = 5, n = 2, target = 3 **Output:** 11 **Explanation:** Some houses are already painted, Paint the houses of this way [2,2,1,2,2] This array contains target = 3 neighborhoods, [{2,2}, {1}, {2,2}]. Cost of paint the first and last house (10 + 1) = 11. ``` **Example 3:** ``` **Input:** houses = [3,1,2,3], cost = [[1,1,1],[1,1,1],[1,1,1],[1,1,1]], m = 4, n = 3, target = 3 **Output:** -1 **Explanation:** Houses are already painted with a total of 4 neighborhoods [{3},{1},{2},{3}] different of target = 3. ``` **Constraints:** `m == houses.length == cost.length` `n == cost[i].length` `1 <= m <= 100` `1 <= n <= 20` `1 <= target <= m` `0 <= houses[i] <= n` `1 <= cost[i][j] <= 104`",
        "test_case": [
            {
                "label": "Example 1",
                "input": "houses = [0,0,0,0,0], cost = [[1,10],[10,1],[10,1],[1,10],[5,1]], m = 5, n = 2, target = 3",
                "output": "9 Explanation: Paint houses of this way [1,2,2,1,1]\nThis array contains target = 3 neighborhoods, [{1}, {2,2}, {1,1}].\nCost of paint all houses (1 + 1 + 1 + 1 + 5) = 9."
            },
            {
                "label": "Example 2",
                "input": "houses = [0,2,1,2,0], cost = [[1,10],[10,1],[10,1],[1,10],[5,1]], m = 5, n = 2, target = 3",
                "output": "11 Explanation: Some houses are already painted, Paint the houses of this way [2,2,1,2,2]\nThis array contains target = 3 neighborhoods, [{2,2}, {1}, {2,2}]. \nCost of paint the first and last house (10 + 1) = 11."
            },
            {
                "label": "Example 3",
                "input": "houses = [3,1,2,3], cost = [[1,1,1],[1,1,1],[1,1,1],[1,1,1]], m = 4, n = 3, target = 3",
                "output": "-1 Explanation: Houses are already painted with a total of 4 neighborhoods [{3},{1},{2},{3}] different of target = 3. Constraints: m == houses.length == cost.length n == cost[i].length 1 <= m <= 100 1 <= n <= 20 1 <= target <= m 0 <= houses[i] <= n 1 <= cost[i][j] <= 10 4"
            }
        ],
        "elixir_template": "defmodule Solution do\n  @spec min_cost(houses :: [integer], cost :: [[integer]], m :: integer, n :: integer, target :: integer) :: integer\n  def min_cost(houses, cost, m, n, target) do\n    \n  end\nend",
        "erlang_template": "-spec min_cost(Houses :: [integer()], Cost :: [[integer()]], M :: integer(), N :: integer(), Target :: integer()) -> integer().\nmin_cost(Houses, Cost, M, N, Target) ->\n  .",
        "scala_template": "object Solution {\n    def minCost(houses: Array[Int], cost: Array[Array[Int]], m: Int, n: Int, target: Int): Int = {\n        \n    }\n}"
    },
    {
        "id": 1582,
        "name": "design-browser-history",
        "difficulty": "Medium",
        "link": "https://leetcode.com/problems/design-browser-history/",
        "task_description": "You have a **browser** of one tab where you start on the `homepage` and you can visit another `url`, get back in the history number of `steps` or move forward in the history number of `steps`. Implement the `BrowserHistory` class: `BrowserHistory(string homepage)` Initializes the object with the `homepage` of the browser. `void visit(string url)` Visits `url` from the current page. It clears up all the forward history. `string back(int steps)` Move `steps` back in history. If you can only return `x` steps in the history and `steps > x`, you will return only `x` steps. Return the current `url` after moving back in history **at most** `steps`. `string forward(int steps)` Move `steps` forward in history. If you can only forward `x` steps in the history and `steps > x`, you will forward only `x` steps. Return the current `url` after forwarding in history **at most** `steps`. **Example:** ``` Input: [\"BrowserHistory\",\"visit\",\"visit\",\"visit\",\"back\",\"back\",\"forward\",\"visit\",\"forward\",\"back\",\"back\"] [[\"leetcode.com\"],[\"google.com\"],[\"facebook.com\"],[\"youtube.com\"],[1],[1],[1],[\"linkedin.com\"],[2],[2],[7]] Output: [null,null,null,null,\"facebook.com\",\"google.com\",\"facebook.com\",null,\"linkedin.com\",\"google.com\",\"leetcode.com\"] Explanation: BrowserHistory browserHistory = new BrowserHistory(\"leetcode.com\"); browserHistory.visit(\"google.com\"); // You are in \"leetcode.com\". Visit \"google.com\" browserHistory.visit(\"facebook.com\"); // You are in \"google.com\". Visit \"facebook.com\" browserHistory.visit(\"youtube.com\"); // You are in \"facebook.com\". Visit \"youtube.com\" browserHistory.back(1); // You are in \"youtube.com\", move back to \"facebook.com\" return \"facebook.com\" browserHistory.back(1); // You are in \"facebook.com\", move back to \"google.com\" return \"google.com\" browserHistory.forward(1); // You are in \"google.com\", move forward to \"facebook.com\" return \"facebook.com\" browserHistory.visit(\"linkedin.com\"); // You are in \"facebook.com\". Visit \"linkedin.com\" browserHistory.forward(2); // You are in \"linkedin.com\", you cannot move forward any steps. browserHistory.back(2); // You are in \"linkedin.com\", move back two steps to \"facebook.com\" then to \"google.com\". return \"google.com\" browserHistory.back(7); // You are in \"google.com\", you can move back only one step to \"leetcode.com\". return \"leetcode.com\" ``` **Constraints:** `1 <= homepage.length <= 20` `1 <= url.length <= 20` `1 <= steps <= 100` `homepage` and `url` consist of '.' or lower case English letters. At most `5000` calls will be made to `visit`, `back`, and `forward`.",
        "test_case": [],
        "elixir_template": "defmodule BrowserHistory do\n  @spec init_(homepage :: String.t) :: any\n  def init_(homepage) do\n    \n  end\n\n  @spec visit(url :: String.t) :: any\n  def visit(url) do\n    \n  end\n\n  @spec back(steps :: integer) :: String.t\n  def back(steps) do\n    \n  end\n\n  @spec forward(steps :: integer) :: String.t\n  def forward(steps) do\n    \n  end\nend\n\n# Your functions will be called as such:\n# BrowserHistory.init_(homepage)\n# BrowserHistory.visit(url)\n# param_2 = BrowserHistory.back(steps)\n# param_3 = BrowserHistory.forward(steps)\n\n# BrowserHistory.init_ will be called before every test case, in which you can do some necessary initializations.",
        "erlang_template": "-spec browser_history_init_(Homepage :: unicode:unicode_binary()) -> any().\nbrowser_history_init_(Homepage) ->\n  .\n\n-spec browser_history_visit(Url :: unicode:unicode_binary()) -> any().\nbrowser_history_visit(Url) ->\n  .\n\n-spec browser_history_back(Steps :: integer()) -> unicode:unicode_binary().\nbrowser_history_back(Steps) ->\n  .\n\n-spec browser_history_forward(Steps :: integer()) -> unicode:unicode_binary().\nbrowser_history_forward(Steps) ->\n  .\n\n\n%% Your functions will be called as such:\n%% browser_history_init_(Homepage),\n%% browser_history_visit(Url),\n%% Param_2 = browser_history_back(Steps),\n%% Param_3 = browser_history_forward(Steps),\n\n%% browser_history_init_ will be called before every test case, in which you can do some necessary initializations.",
        "scala_template": "class BrowserHistory(_homepage: String) {\n\n    def visit(url: String): Unit = {\n        \n    }\n\n    def back(steps: Int): String = {\n        \n    }\n\n    def forward(steps: Int): String = {\n        \n    }\n\n}\n\n/**\n * Your BrowserHistory object will be instantiated and called as such:\n * val obj = new BrowserHistory(homepage)\n * obj.visit(url)\n * val param_2 = obj.back(steps)\n * val param_3 = obj.forward(steps)\n */"
    },
    {
        "id": 1581,
        "name": "the-k-strongest-values-in-an-array",
        "difficulty": "Medium",
        "link": "https://leetcode.com/problems/the-k-strongest-values-in-an-array/",
        "task_description": "Given an array of integers `arr` and an integer `k`. A value `arr[i]` is said to be stronger than a value `arr[j]` if `|arr[i] - m| > |arr[j] - m|` where `m` is the **median** of the array. If `|arr[i] - m| == |arr[j] - m|`, then `arr[i]` is said to be stronger than `arr[j]` if `arr[i] > arr[j]`. Return _a list of the strongest `k`_ values in the array. return the answer **in any arbitrary order**. **Median** is the middle value in an ordered integer list. More formally, if the length of the list is n, the median is the element in position `((n - 1) / 2)` in the sorted list **(0-indexed)**. For `arr = [6, -3, 7, 2, 11]`, `n = 5` and the median is obtained by sorting the array `arr = [-3, 2, 6, 7, 11]` and the median is `arr[m]` where `m = ((5 - 1) / 2) = 2`. The median is `6`. For `arr = [-7, 22, 17, 3]`, `n = 4` and the median is obtained by sorting the array `arr = [-7, 3, 17, 22]` and the median is `arr[m]` where `m = ((4 - 1) / 2) = 1`. The median is `3`. **Example 1:** ``` **Input:** arr = [1,2,3,4,5], k = 2 **Output:** [5,1] **Explanation:** Median is 3, the elements of the array sorted by the strongest are [5,1,4,2,3]. The strongest 2 elements are [5, 1]. [1, 5] is also **accepted** answer. Please note that although |5 - 3| == |1 - 3| but 5 is stronger than 1 because 5 > 1. ``` **Example 2:** ``` **Input:** arr = [1,1,3,5,5], k = 2 **Output:** [5,5] **Explanation:** Median is 3, the elements of the array sorted by the strongest are [5,5,1,1,3]. The strongest 2 elements are [5, 5]. ``` **Example 3:** ``` **Input:** arr = [6,7,11,7,6,8], k = 5 **Output:** [11,8,6,6,7] **Explanation:** Median is 7, the elements of the array sorted by the strongest are [11,8,6,6,7,7]. Any permutation of [11,8,6,6,7] is **accepted**. ``` **Constraints:** `1 <= arr.length <= 105` `-105 <= arr[i] <= 105` `1 <= k <= arr.length`",
        "test_case": [
            {
                "label": "Example 1",
                "input": "arr = [1,2,3,4,5], k = 2",
                "output": "[5,1] Explanation: Median is 3, the elements of the array sorted by the strongest are [5,1,4,2,3]. The strongest 2 elements are [5, 1]. [1, 5] is also accepted answer.\nPlease note that although |5 - 3| == |1 - 3| but 5 is stronger than 1 because 5 > 1."
            },
            {
                "label": "Example 2",
                "input": "arr = [1,1,3,5,5], k = 2",
                "output": "[5,5] Explanation: Median is 3, the elements of the array sorted by the strongest are [5,5,1,1,3]. The strongest 2 elements are [5, 5]."
            },
            {
                "label": "Example 3",
                "input": "arr = [6,7,11,7,6,8], k = 5",
                "output": "[11,8,6,6,7] Explanation: Median is 7, the elements of the array sorted by the strongest are [11,8,6,6,7,7].\nAny permutation of [11,8,6,6,7] is accepted ."
            }
        ],
        "elixir_template": "defmodule Solution do\n  @spec get_strongest(arr :: [integer], k :: integer) :: [integer]\n  def get_strongest(arr, k) do\n    \n  end\nend",
        "erlang_template": "-spec get_strongest(Arr :: [integer()], K :: integer()) -> [integer()].\nget_strongest(Arr, K) ->\n  .",
        "scala_template": "object Solution {\n    def getStrongest(arr: Array[Int], k: Int): Array[Int] = {\n        \n    }\n}"
    },
    {
        "id": 1580,
        "name": "shuffle-the-array",
        "difficulty": "Easy",
        "link": "https://leetcode.com/problems/shuffle-the-array/",
        "task_description": "Given the array `nums` consisting of `2n` elements in the form `[x1,x2,...,xn,y1,y2,...,yn]`. _Return the array in the form_ `[x1,y1,x2,y2,...,xn,yn]`. **Example 1:** ``` **Input:** nums = [2,5,1,3,4,7], n = 3 **Output:** [2,3,5,4,1,7] **Explanation:** Since x1=2, x2=5, x3=1, y1=3, y2=4, y3=7 then the answer is [2,3,5,4,1,7]. ``` **Example 2:** ``` **Input:** nums = [1,2,3,4,4,3,2,1], n = 4 **Output:** [1,4,2,3,3,2,4,1] ``` **Example 3:** ``` **Input:** nums = [1,1,2,2], n = 2 **Output:** [1,2,1,2] ``` **Constraints:** `1 <= n <= 500` `nums.length == 2n` `1 <= nums[i] <= 10^3`",
        "test_case": [
            {
                "label": "Example 1",
                "input": "nums = [2,5,1,3,4,7], n = 3",
                "output": "[2,3,5,4,1,7] Explanation: Since x 1 =2, x 2 =5, x 3 =1, y 1 =3, y 2 =4, y 3 =7 then the answer is [2,3,5,4,1,7]."
            },
            {
                "label": "Example 2",
                "input": "nums = [1,2,3,4,4,3,2,1], n = 4",
                "output": "[1,4,2,3,3,2,4,1]"
            },
            {
                "label": "Example 3",
                "input": "nums = [1,1,2,2], n = 2",
                "output": "[1,2,1,2]"
            }
        ],
        "elixir_template": "Elixir code template not available for this problem.",
        "erlang_template": "Elixir code template not available for this problem.",
        "scala_template": "object Solution {\n    def shuffle(nums: Array[Int], n: Int): Array[Int] = {\n        \n    }\n}"
    },
    {
        "id": 1577,
        "name": "probability-of-a-two-boxes-having-the-same-number-of-distinct-balls",
        "difficulty": "Hard",
        "link": "https://leetcode.com/problems/probability-of-a-two-boxes-having-the-same-number-of-distinct-balls/",
        "task_description": "Given `2n` balls of `k` distinct colors. You will be given an integer array `balls` of size `k` where `balls[i]` is the number of balls of color `i`. All the balls will be **shuffled uniformly at random**, then we will distribute the first `n` balls to the first box and the remaining `n` balls to the other box (Please read the explanation of the second example carefully). Please note that the two boxes are considered different. For example, if we have two balls of colors `a` and `b`, and two boxes `[]` and `()`, then the distribution `[a] (b)` is considered different than the distribution `[b] (a) `(Please read the explanation of the first example carefully). Return_ the probability_ that the two boxes have the same number of distinct balls. Answers within `10-5` of the actual value will be accepted as correct. **Example 1:** ``` **Input:** balls = [1,1] **Output:** 1.00000 **Explanation:** Only 2 ways to divide the balls equally: - A ball of color 1 to box 1 and a ball of color 2 to box 2 - A ball of color 2 to box 1 and a ball of color 1 to box 2 In both ways, the number of distinct colors in each box is equal. The probability is 2/2 = 1 ``` **Example 2:** ``` **Input:** balls = [2,1,1] **Output:** 0.66667 **Explanation:** We have the set of balls [1, 1, 2, 3] This set of balls will be shuffled randomly and we may have one of the 12 distinct shuffles with equal probability (i.e. 1/12): [1,1 / 2,3], [1,1 / 3,2], [1,2 / 1,3], [1,2 / 3,1], [1,3 / 1,2], [1,3 / 2,1], [2,1 / 1,3], [2,1 / 3,1], [2,3 / 1,1], [3,1 / 1,2], [3,1 / 2,1], [3,2 / 1,1] After that, we add the first two balls to the first box and the second two balls to the second box. We can see that 8 of these 12 possible random distributions have the same number of distinct colors of balls in each box. Probability is 8/12 = 0.66667 ``` **Example 3:** ``` **Input:** balls = [1,2,1,2] **Output:** 0.60000 **Explanation:** The set of balls is [1, 2, 2, 3, 4, 4]. It is hard to display all the 180 possible random shuffles of this set but it is easy to check that 108 of them will have the same number of distinct colors in each box. Probability = 108 / 180 = 0.6 ``` **Constraints:** `1 <= balls.length <= 8` `1 <= balls[i] <= 6` `sum(balls)` is even.",
        "test_case": [
            {
                "label": "Example 1",
                "input": "balls = [1,1]",
                "output": "1.00000 Explanation: Only 2 ways to divide the balls equally:\n- A ball of color 1 to box 1 and a ball of color 2 to box 2\n- A ball of color 2 to box 1 and a ball of color 1 to box 2\nIn both ways, the number of distinct colors in each box is equal. The probability is 2/2 = 1"
            },
            {
                "label": "Example 2",
                "input": "balls = [2,1,1]",
                "output": "0.66667 Explanation: We have the set of balls [1, 1, 2, 3]\nThis set of balls will be shuffled randomly and we may have one of the 12 distinct shuffles with equal probability (i.e. 1/12):\n[1,1 / 2,3], [1,1 / 3,2], [1,2 / 1,3], [1,2 / 3,1], [1,3 / 1,2], [1,3 / 2,1], [2,1 / 1,3], [2,1 / 3,1], [2,3 / 1,1], [3,1 / 1,2], [3,1 / 2,1], [3,2 / 1,1]\nAfter that, we add the first two balls to the first box and the second two balls to the second box.\nWe can see that 8 of these 12 possible random distributions have the same number of distinct colors of balls in each box.\nProbability is 8/12 = 0.66667"
            },
            {
                "label": "Example 3",
                "input": "balls = [1,2,1,2]",
                "output": "0.60000 Explanation: The set of balls is [1, 2, 2, 3, 4, 4]. It is hard to display all the 180 possible random shuffles of this set but it is easy to check that 108 of them will have the same number of distinct colors in each box.\nProbability = 108 / 180 = 0.6"
            }
        ],
        "elixir_template": "defmodule Solution do\n  @spec get_probability(balls :: [integer]) :: float\n  def get_probability(balls) do\n    \n  end\nend",
        "erlang_template": "-spec get_probability(Balls :: [integer()]) -> float().\nget_probability(Balls) ->\n  .",
        "scala_template": "object Solution {\n    def getProbability(balls: Array[Int]): Double = {\n        \n    }\n}"
    },
    {
        "id": 1576,
        "name": "reorder-routes-to-make-all-paths-lead-to-the-city-zero",
        "difficulty": "Medium",
        "link": "https://leetcode.com/problems/reorder-routes-to-make-all-paths-lead-to-the-city-zero/",
        "task_description": "There are `n` cities numbered from `0` to `n - 1` and `n - 1` roads such that there is only one way to travel between two different cities (this network form a tree). Last year, The ministry of transport decided to orient the roads in one direction because they are too narrow. Roads are represented by `connections` where `connections[i] = [ai, bi]` represents a road from city `ai` to city `bi`. This year, there will be a big event in the capital (city `0`), and many people want to travel to this city. Your task consists of reorienting some roads such that each city can visit the city `0`. Return the **minimum** number of edges changed. It's **guaranteed** that each city can reach city `0` after reorder. **Example 1:** ``` **Input:** n = 6, connections = [[0,1],[1,3],[2,3],[4,0],[4,5]] **Output:** 3 **Explanation: **Change the direction of edges show in red such that each node can reach the node 0 (capital). ``` **Example 2:** ``` **Input:** n = 5, connections = [[1,0],[1,2],[3,2],[3,4]] **Output:** 2 **Explanation: **Change the direction of edges show in red such that each node can reach the node 0 (capital). ``` **Example 3:** ``` **Input:** n = 3, connections = [[1,0],[2,0]] **Output:** 0 ``` **Constraints:** `2 <= n <= 5 * 104` `connections.length == n - 1` `connections[i].length == 2` `0 <= ai, bi <= n - 1` `ai != bi`",
        "test_case": [
            {
                "label": "Example 1",
                "input": "n = 6, connections = [[0,1],[1,3],[2,3],[4,0],[4,5]]",
                "output": "3 Explanation: Change the direction of edges show in red such that each node can reach the node 0 (capital)."
            },
            {
                "label": "Example 2",
                "input": "n = 5, connections = [[1,0],[1,2],[3,2],[3,4]]",
                "output": "2 Explanation: Change the direction of edges show in red such that each node can reach the node 0 (capital)."
            },
            {
                "label": "Example 3",
                "input": "n = 3, connections = [[1,0],[2,0]]",
                "output": "0"
            }
        ],
        "elixir_template": "defmodule Solution do\n  @spec min_reorder(n :: integer, connections :: [[integer]]) :: integer\n  def min_reorder(n, connections) do\n    \n  end\nend",
        "erlang_template": "-spec min_reorder(N :: integer(), Connections :: [[integer()]]) -> integer().\nmin_reorder(N, Connections) ->\n  .",
        "scala_template": "object Solution {\n    def minReorder(n: Int, connections: Array[Array[Int]]): Int = {\n        \n    }\n}"
    },
    {
        "id": 1575,
        "name": "maximum-area-of-a-piece-of-cake-after-horizontal-and-vertical-cuts",
        "difficulty": "Medium",
        "link": "https://leetcode.com/problems/maximum-area-of-a-piece-of-cake-after-horizontal-and-vertical-cuts/",
        "task_description": "You are given a rectangular cake of size `h x w` and two arrays of integers `horizontalCuts` and `verticalCuts` where: `horizontalCuts[i]` is the distance from the top of the rectangular cake to the `ith` horizontal cut and similarly, and `verticalCuts[j]` is the distance from the left of the rectangular cake to the `jth` vertical cut. Return _the maximum area of a piece of cake after you cut at each horizontal and vertical position provided in the arrays_ `horizontalCuts` _and_ `verticalCuts`. Since the answer can be a large number, return this **modulo** `109 + 7`. **Example 1:** ``` **Input:** h = 5, w = 4, horizontalCuts = [1,2,4], verticalCuts = [1,3] **Output:** 4 **Explanation:** The figure above represents the given rectangular cake. Red lines are the horizontal and vertical cuts. After you cut the cake, the green piece of cake has the maximum area. ``` **Example 2:** ``` **Input:** h = 5, w = 4, horizontalCuts = [3,1], verticalCuts = [1] **Output:** 6 **Explanation:** The figure above represents the given rectangular cake. Red lines are the horizontal and vertical cuts. After you cut the cake, the green and yellow pieces of cake have the maximum area. ``` **Example 3:** ``` **Input:** h = 5, w = 4, horizontalCuts = [3], verticalCuts = [3] **Output:** 9 ``` **Constraints:** `2 <= h, w <= 109` `1 <= horizontalCuts.length <= min(h - 1, 105)` `1 <= verticalCuts.length <= min(w - 1, 105)` `1 <= horizontalCuts[i] < h` `1 <= verticalCuts[i] < w` All the elements in `horizontalCuts` are distinct. All the elements in `verticalCuts` are distinct.",
        "test_case": [
            {
                "label": "Example 1",
                "input": "h = 5, w = 4, horizontalCuts = [1,2,4], verticalCuts = [1,3]",
                "output": "4 Explanation: The figure above represents the given rectangular cake. Red lines are the horizontal and vertical cuts. After you cut the cake, the green piece of cake has the maximum area."
            },
            {
                "label": "Example 2",
                "input": "h = 5, w = 4, horizontalCuts = [3,1], verticalCuts = [1]",
                "output": "6 Explanation: The figure above represents the given rectangular cake. Red lines are the horizontal and vertical cuts. After you cut the cake, the green and yellow pieces of cake have the maximum area."
            },
            {
                "label": "Example 3",
                "input": "h = 5, w = 4, horizontalCuts = [3], verticalCuts = [3]",
                "output": "9"
            }
        ],
        "elixir_template": "defmodule Solution do\n  @spec max_area(h :: integer, w :: integer, horizontal_cuts :: [integer], vertical_cuts :: [integer]) :: integer\n  def max_area(h, w, horizontal_cuts, vertical_cuts) do\n    \n  end\nend",
        "erlang_template": "-spec max_area(H :: integer(), W :: integer(), HorizontalCuts :: [integer()], VerticalCuts :: [integer()]) -> integer().\nmax_area(H, W, HorizontalCuts, VerticalCuts) ->\n  .",
        "scala_template": "object Solution {\n    def maxArea(h: Int, w: Int, horizontalCuts: Array[Int], verticalCuts: Array[Int]): Int = {\n        \n    }\n}"
    },
    {
        "id": 1574,
        "name": "maximum-product-of-two-elements-in-an-array",
        "difficulty": "Easy",
        "link": "https://leetcode.com/problems/maximum-product-of-two-elements-in-an-array/",
        "task_description": "Given the array of integers `nums`, you will choose two different indices `i` and `j` of that array. _Return the maximum value of_ `(nums[i]-1)*(nums[j]-1)`. **Example 1:** ``` **Input:** nums = [3,4,5,2] **Output:** 12 **Explanation:** If you choose the indices i=1 and j=2 (indexed from 0), you will get the maximum value, that is, (nums[1]-1)*(nums[2]-1) = (4-1)*(5-1) = 3*4 = 12. ``` **Example 2:** ``` **Input:** nums = [1,5,4,5] **Output:** 16 **Explanation:** Choosing the indices i=1 and j=3 (indexed from 0), you will get the maximum value of (5-1)*(5-1) = 16. ``` **Example 3:** ``` **Input:** nums = [3,7] **Output:** 12 ``` **Constraints:** `2 <= nums.length <= 500` `1 <= nums[i] <= 10^3`",
        "test_case": [
            {
                "label": "Example 1",
                "input": "nums = [3,4,5,2]",
                "output": "12 Explanation: If you choose the indices i=1 and j=2 (indexed from 0), you will get the maximum value, that is, (nums[1]-1)*(nums[2]-1) = (4-1)*(5-1) = 3*4 = 12."
            },
            {
                "label": "Example 2",
                "input": "nums = [1,5,4,5]",
                "output": "16 Explanation: Choosing the indices i=1 and j=3 (indexed from 0), you will get the maximum value of (5-1)*(5-1) = 16."
            },
            {
                "label": "Example 3",
                "input": "nums = [3,7]",
                "output": "12"
            }
        ],
        "elixir_template": "defmodule Solution do\n  @spec max_product(nums :: [integer]) :: integer\n  def max_product(nums) do\n    \n  end\nend",
        "erlang_template": "-spec max_product(Nums :: [integer()]) -> integer().\nmax_product(Nums) ->\n  .",
        "scala_template": "object Solution {\n    def maxProduct(nums: Array[Int]): Int = {\n        \n    }\n}"
    },
    {
        "id": 1573,
        "name": "find-two-non-overlapping-sub-arrays-each-with-target-sum",
        "difficulty": "Medium",
        "link": "https://leetcode.com/problems/find-two-non-overlapping-sub-arrays-each-with-target-sum/",
        "task_description": "You are given an array of integers `arr` and an integer `target`. You have to find **two non-overlapping sub-arrays** of `arr` each with a sum equal `target`. There can be multiple answers so you have to find an answer where the sum of the lengths of the two sub-arrays is **minimum**. Return _the minimum sum of the lengths_ of the two required sub-arrays, or return `-1` if you cannot find such two sub-arrays. **Example 1:** ``` **Input:** arr = [3,2,2,4,3], target = 3 **Output:** 2 **Explanation:** Only two sub-arrays have sum = 3 ([3] and [3]). The sum of their lengths is 2. ``` **Example 2:** ``` **Input:** arr = [7,3,4,7], target = 7 **Output:** 2 **Explanation:** Although we have three non-overlapping sub-arrays of sum = 7 ([7], [3,4] and [7]), but we will choose the first and third sub-arrays as the sum of their lengths is 2. ``` **Example 3:** ``` **Input:** arr = [4,3,2,6,2,3,4], target = 6 **Output:** -1 **Explanation:** We have only one sub-array of sum = 6. ``` **Constraints:** `1 <= arr.length <= 105` `1 <= arr[i] <= 1000` `1 <= target <= 108`",
        "test_case": [
            {
                "label": "Example 1",
                "input": "arr = [3,2,2,4,3], target = 3",
                "output": "2 Explanation: Only two sub-arrays have sum = 3 ([3] and [3]). The sum of their lengths is 2."
            },
            {
                "label": "Example 2",
                "input": "arr = [7,3,4,7], target = 7",
                "output": "2 Explanation: Although we have three non-overlapping sub-arrays of sum = 7 ([7], [3,4] and [7]), but we will choose the first and third sub-arrays as the sum of their lengths is 2."
            },
            {
                "label": "Example 3",
                "input": "arr = [4,3,2,6,2,3,4], target = 6",
                "output": "-1 Explanation: We have only one sub-array of sum = 6."
            }
        ],
        "elixir_template": "defmodule Solution do\n  @spec min_sum_of_lengths(arr :: [integer], target :: integer) :: integer\n  def min_sum_of_lengths(arr, target) do\n    \n  end\nend",
        "erlang_template": "-spec min_sum_of_lengths(Arr :: [integer()], Target :: integer()) -> integer().\nmin_sum_of_lengths(Arr, Target) ->\n  .",
        "scala_template": "object Solution {\n    def minSumOfLengths(arr: Array[Int], target: Int): Int = {\n        \n    }\n}"
    },
    {
        "id": 1572,
        "name": "subrectangle-queries",
        "difficulty": "Medium",
        "link": "https://leetcode.com/problems/subrectangle-queries/",
        "task_description": "Implement the class `SubrectangleQueries` which receives a `rows x cols` rectangle as a matrix of integers in the constructor and supports two methods: 1.` updateSubrectangle(int row1, int col1, int row2, int col2, int newValue)` Updates all values with `newValue` in the subrectangle whose upper left coordinate is `(row1,col1)` and bottom right coordinate is `(row2,col2)`. 2.` getValue(int row, int col)` Returns the current value of the coordinate `(row,col)` from the rectangle. **Example 1:** ``` **Input** [\"SubrectangleQueries\",\"getValue\",\"updateSubrectangle\",\"getValue\",\"getValue\",\"updateSubrectangle\",\"getValue\",\"getValue\"] [[[[1,2,1],[4,3,4],[3,2,1],[1,1,1]]],[0,2],[0,0,3,2,5],[0,2],[3,1],[3,0,3,2,10],[3,1],[0,2]] **Output** [null,1,null,5,5,null,10,5] **Explanation** SubrectangleQueries subrectangleQueries = new SubrectangleQueries([[1,2,1],[4,3,4],[3,2,1],[1,1,1]]); // The initial rectangle (4x3) looks like: // 1 2 1 // 4 3 4 // 3 2 1 // 1 1 1 subrectangleQueries.getValue(0, 2); // return 1 subrectangleQueries.updateSubrectangle(0, 0, 3, 2, 5); // After this update the rectangle looks like: // 5 5 5 // 5 5 5 // 5 5 5 // 5 5 5 subrectangleQueries.getValue(0, 2); // return 5 subrectangleQueries.getValue(3, 1); // return 5 subrectangleQueries.updateSubrectangle(3, 0, 3, 2, 10); // After this update the rectangle looks like: // 5 5 5 // 5 5 5 // 5 5 5 // 10 10 10 subrectangleQueries.getValue(3, 1); // return 10 subrectangleQueries.getValue(0, 2); // return 5 ``` **Example 2:** ``` **Input** [\"SubrectangleQueries\",\"getValue\",\"updateSubrectangle\",\"getValue\",\"getValue\",\"updateSubrectangle\",\"getValue\"] [[[[1,1,1],[2,2,2],[3,3,3]]],[0,0],[0,0,2,2,100],[0,0],[2,2],[1,1,2,2,20],[2,2]] **Output** [null,1,null,100,100,null,20] **Explanation** SubrectangleQueries subrectangleQueries = new SubrectangleQueries([[1,1,1],[2,2,2],[3,3,3]]); subrectangleQueries.getValue(0, 0); // return 1 subrectangleQueries.updateSubrectangle(0, 0, 2, 2, 100); subrectangleQueries.getValue(0, 0); // return 100 subrectangleQueries.getValue(2, 2); // return 100 subrectangleQueries.updateSubrectangle(1, 1, 2, 2, 20); subrectangleQueries.getValue(2, 2); // return 20 ``` **Constraints:** There will be at most `500` operations considering both methods: `updateSubrectangle` and `getValue`. `1 <= rows, cols <= 100` `rows == rectangle.length` `cols == rectangle[i].length` `0 <= row1 <= row2 < rows` `0 <= col1 <= col2 < cols` `1 <= newValue, rectangle[i][j] <= 10^9` `0 <= row < rows` `0 <= col < cols`",
        "test_case": [],
        "elixir_template": "Elixir code template not available for this problem.",
        "erlang_template": "Elixir code template not available for this problem.",
        "scala_template": "class SubrectangleQueries(_rectangle: Array[Array[Int]]) {\n\n    def updateSubrectangle(row1: Int, col1: Int, row2: Int, col2: Int, newValue: Int) {\n        \n    }\n\n    def getValue(row: Int, col: Int): Int = {\n        \n    }\n\n}\n\n/**\n * Your SubrectangleQueries object will be instantiated and called as such:\n * var obj = new SubrectangleQueries(rectangle)\n * obj.updateSubrectangle(row1,col1,row2,col2,newValue)\n * var param_2 = obj.getValue(row,col)\n */"
    },
    {
        "id": 1571,
        "name": "allocate-mailboxes",
        "difficulty": "Hard",
        "link": "https://leetcode.com/problems/allocate-mailboxes/",
        "task_description": "Given the array `houses` where `houses[i]` is the location of the `ith` house along a street and an integer `k`, allocate `k` mailboxes in the street. Return _the **minimum** total distance between each house and its nearest mailbox_. The test cases are generated so that the answer fits in a 32-bit integer. **Example 1:** ``` **Input:** houses = [1,4,8,10,20], k = 3 **Output:** 5 **Explanation:** Allocate mailboxes in position 3, 9 and 20. Minimum total distance from each houses to nearest mailboxes is |3-1| + |4-3| + |9-8| + |10-9| + |20-20| = 5 ``` **Example 2:** ``` **Input:** houses = [2,3,5,12,18], k = 2 **Output:** 9 **Explanation:** Allocate mailboxes in position 3 and 14. Minimum total distance from each houses to nearest mailboxes is |2-3| + |3-3| + |5-3| + |12-14| + |18-14| = 9. ``` **Constraints:** `1 <= k <= houses.length <= 100` `1 <= houses[i] <= 104` All the integers of `houses` are **unique**.",
        "test_case": [
            {
                "label": "Example 1",
                "input": "houses = [1,4,8,10,20], k = 3",
                "output": "5 Explanation: Allocate mailboxes in position 3, 9 and 20.\nMinimum total distance from each houses to nearest mailboxes is |3-1| + |4-3| + |9-8| + |10-9| + |20-20| = 5"
            },
            {
                "label": "Example 2",
                "input": "houses = [2,3,5,12,18], k = 2",
                "output": "9 Explanation: Allocate mailboxes in position 3 and 14.\nMinimum total distance from each houses to nearest mailboxes is |2-3| + |3-3| + |5-3| + |12-14| + |18-14| = 9."
            }
        ],
        "elixir_template": "defmodule Solution do\n  @spec min_distance(houses :: [integer], k :: integer) :: integer\n  def min_distance(houses, k) do\n    \n  end\nend",
        "erlang_template": "-spec min_distance(Houses :: [integer()], K :: integer()) -> integer().\nmin_distance(Houses, K) ->\n  .",
        "scala_template": "object Solution {\n    def minDistance(houses: Array[Int], k: Int): Int = {\n        \n    }\n}"
    },
    {
        "id": 1570,
        "name": "final-prices-with-a-special-discount-in-a-shop",
        "difficulty": "Easy",
        "link": "https://leetcode.com/problems/final-prices-with-a-special-discount-in-a-shop/",
        "task_description": "You are given an integer array `prices` where `prices[i]` is the price of the `ith` item in a shop. There is a special discount for items in the shop. If you buy the `ith` item, then you will receive a discount equivalent to `prices[j]` where `j` is the minimum index such that `j > i` and `prices[j] <= prices[i]`. Otherwise, you will not receive any discount at all. Return an integer array `answer` where `answer[i]` is the final price you will pay for the `ith` item of the shop, considering the special discount. **Example 1:** ``` **Input:** prices = [8,4,6,2,3] **Output:** [4,2,4,2,3] **Explanation:** For item 0 with price[0]=8 you will receive a discount equivalent to prices[1]=4, therefore, the final price you will pay is 8 - 4 = 4. For item 1 with price[1]=4 you will receive a discount equivalent to prices[3]=2, therefore, the final price you will pay is 4 - 2 = 2. For item 2 with price[2]=6 you will receive a discount equivalent to prices[3]=2, therefore, the final price you will pay is 6 - 2 = 4. For items 3 and 4 you will not receive any discount at all. ``` **Example 2:** ``` **Input:** prices = [1,2,3,4,5] **Output:** [1,2,3,4,5] **Explanation:** In this case, for all items, you will not receive any discount at all. ``` **Example 3:** ``` **Input:** prices = [10,1,1,6] **Output:** [9,0,1,6] ``` **Constraints:** `1 <= prices.length <= 500` `1 <= prices[i] <= 1000`",
        "test_case": [
            {
                "label": "Example 1",
                "input": "prices = [8,4,6,2,3]",
                "output": "[4,2,4,2,3] Explanation: For item 0 with price[0]=8 you will receive a discount equivalent to prices[1]=4, therefore, the final price you will pay is 8 - 4 = 4.\nFor item 1 with price[1]=4 you will receive a discount equivalent to prices[3]=2, therefore, the final price you will pay is 4 - 2 = 2.\nFor item 2 with price[2]=6 you will receive a discount equivalent to prices[3]=2, therefore, the final price you will pay is 6 - 2 = 4.\nFor items 3 and 4 you will not receive any discount at all."
            },
            {
                "label": "Example 2",
                "input": "prices = [1,2,3,4,5]",
                "output": "[1,2,3,4,5] Explanation: In this case, for all items, you will not receive any discount at all."
            },
            {
                "label": "Example 3",
                "input": "prices = [10,1,1,6]",
                "output": "[9,0,1,6]"
            }
        ],
        "elixir_template": "defmodule Solution do\n  @spec final_prices(prices :: [integer]) :: [integer]\n  def final_prices(prices) do\n    \n  end\nend",
        "erlang_template": "-spec final_prices(Prices :: [integer()]) -> [integer()].\nfinal_prices(Prices) ->\n  .",
        "scala_template": "object Solution {\n    def finalPrices(prices: Array[Int]): Array[Int] = {\n        \n    }\n}"
    },
    {
        "id": 1569,
        "name": "max-dot-product-of-two-subsequences",
        "difficulty": "Hard",
        "link": "https://leetcode.com/problems/max-dot-product-of-two-subsequences/",
        "task_description": "Given two arrays `nums1` and `nums2`. Return the maximum dot product between **non-empty** subsequences of nums1 and nums2 with the same length. A subsequence of a array is a new array which is formed from the original array by deleting some (can be none) of the characters without disturbing the relative positions of the remaining characters. (ie, `[2,3,5]` is a subsequence of `[1,2,3,4,5]` while `[1,5,3]` is not). **Example 1:** ``` **Input:** nums1 = [2,1,-2,5], nums2 = [3,0,-6] **Output:** 18 **Explanation:** Take subsequence [2,-2] from nums1 and subsequence [3,-6] from nums2. Their dot product is (2*3 + (-2)*(-6)) = 18. ``` **Example 2:** ``` **Input:** nums1 = [3,-2], nums2 = [2,-6,7] **Output:** 21 **Explanation:** Take subsequence [3] from nums1 and subsequence [7] from nums2. Their dot product is (3*7) = 21. ``` **Example 3:** ``` **Input:** nums1 = [-1,-1], nums2 = [1,1] **Output:** -1 **Explanation: **Take subsequence [-1] from nums1 and subsequence [1] from nums2. Their dot product is -1. ``` **Constraints:** `1 <= nums1.length, nums2.length <= 500` `-1000 <= nums1[i], nums2[i] <= 1000`",
        "test_case": [
            {
                "label": "Example 1",
                "input": "nums1 = [2,1,-2,5], nums2 = [3,0,-6]",
                "output": "18 Explanation: Take subsequence [2,-2] from nums1 and subsequence [3,-6] from nums2.\nTheir dot product is (2*3 + (-2)*(-6)) = 18."
            },
            {
                "label": "Example 2",
                "input": "nums1 = [3,-2], nums2 = [2,-6,7]",
                "output": "21 Explanation: Take subsequence [3] from nums1 and subsequence [7] from nums2.\nTheir dot product is (3*7) = 21."
            },
            {
                "label": "Example 3",
                "input": "nums1 = [-1,-1], nums2 = [1,1]",
                "output": "-1 Explanation: Take subsequence [-1] from nums1 and subsequence [1] from nums2.\nTheir dot product is -1."
            }
        ],
        "elixir_template": "defmodule Solution do\n  @spec max_dot_product(nums1 :: [integer], nums2 :: [integer]) :: integer\n  def max_dot_product(nums1, nums2) do\n    \n  end\nend",
        "erlang_template": "-spec max_dot_product(Nums1 :: [integer()], Nums2 :: [integer()]) -> integer().\nmax_dot_product(Nums1, Nums2) ->\n  .",
        "scala_template": "object Solution {\n    def maxDotProduct(nums1: Array[Int], nums2: Array[Int]): Int = {\n        \n    }\n}"
    },
    {
        "id": 1568,
        "name": "pseudo-palindromic-paths-in-a-binary-tree",
        "difficulty": "Medium",
        "link": "https://leetcode.com/problems/pseudo-palindromic-paths-in-a-binary-tree/",
        "task_description": "Given a binary tree where node values are digits from 1 to 9. A path in the binary tree is said to be **pseudo-palindromic** if at least one permutation of the node values in the path is a palindrome. _Return the number of **pseudo-palindromic** paths going from the root node to leaf nodes._ **Example 1:** ``` **Input:** root = [2,3,1,3,1,null,1] **Output:** 2 **Explanation:** The figure above represents the given binary tree. There are three paths going from the root node to leaf nodes: the red path [2,3,3], the green path [2,1,1], and the path [2,3,1]. Among these paths only red path and green path are pseudo-palindromic paths since the red path [2,3,3] can be rearranged in [3,2,3] (palindrome) and the green path [2,1,1] can be rearranged in [1,2,1] (palindrome). ``` **Example 2:** **** ``` **Input:** root = [2,1,1,1,3,null,null,null,null,null,1] **Output:** 1 **Explanation:** The figure above represents the given binary tree. There are three paths going from the root node to leaf nodes: the green path [2,1,1], the path [2,1,3,1], and the path [2,1]. Among these paths only the green path is pseudo-palindromic since [2,1,1] can be rearranged in [1,2,1] (palindrome). ``` **Example 3:** ``` **Input:** root = [9] **Output:** 1 ``` **Constraints:** The number of nodes in the tree is in the range `[1, 105]`. `1 <= Node.val <= 9`",
        "test_case": [
            {
                "label": "Example 1",
                "input": "root = [2,3,1,3,1,null,1]",
                "output": "2 Explanation: The figure above represents the given binary tree. There are three paths going from the root node to leaf nodes: the red path [2,3,3], the green path [2,1,1], and the path [2,3,1]. Among these paths only red path and green path are pseudo-palindromic paths since the red path [2,3,3] can be rearranged in [3,2,3] (palindrome) and the green path [2,1,1] can be rearranged in [1,2,1] (palindrome)."
            },
            {
                "label": "Example 2",
                "input": "root = [2,1,1,1,3,null,null,null,null,null,1]",
                "output": "1 Explanation: The figure above represents the given binary tree. There are three paths going from the root node to leaf nodes: the green path [2,1,1], the path [2,1,3,1], and the path [2,1]. Among these paths only the green path is pseudo-palindromic since [2,1,1] can be rearranged in [1,2,1] (palindrome)."
            },
            {
                "label": "Example 3",
                "input": "root = [9]",
                "output": "1 Constraints: The number of nodes in the tree is in the range [1, 10 5 ] . 1 <= Node.val <= 9"
            }
        ],
        "elixir_template": "# Definition for a binary tree node.\n#\n# defmodule TreeNode do\n#   @type t :: %__MODULE__{\n#           val: integer,\n#           left: TreeNode.t() | nil,\n#           right: TreeNode.t() | nil\n#         }\n#   defstruct val: 0, left: nil, right: nil\n# end\n\ndefmodule Solution do\n  @spec pseudo_palindromic_paths (root :: TreeNode.t | nil) :: integer\n  def pseudo_palindromic_paths (root) do\n    \n  end\nend",
        "erlang_template": "%% Definition for a binary tree node.\n%%\n%% -record(tree_node, {val = 0 :: integer(),\n%%                     left = null  :: 'null' | #tree_node{},\n%%                     right = null :: 'null' | #tree_node{}}).\n\n-spec pseudo_palindromic_paths (Root :: #tree_node{} | null) -> integer().\npseudo_palindromic_paths (Root) ->\n  .",
        "scala_template": "/**\n * Definition for a binary tree node.\n * class TreeNode(_value: Int = 0, _left: TreeNode = null, _right: TreeNode = null) {\n *   var value: Int = _value\n *   var left: TreeNode = _left\n *   var right: TreeNode = _right\n * }\n */\nobject Solution {\n    def pseudoPalindromicPaths (root: TreeNode): Int = {\n        \n    }\n}"
    },
    {
        "id": 1567,
        "name": "maximum-number-of-vowels-in-a-substring-of-given-length",
        "difficulty": "Medium",
        "link": "https://leetcode.com/problems/maximum-number-of-vowels-in-a-substring-of-given-length/",
        "task_description": "Given a string `s` and an integer `k`, return _the maximum number of vowel letters in any substring of _`s`_ with length _`k`. **Vowel letters** in English are `'a'`, `'e'`, `'i'`, `'o'`, and `'u'`. **Example 1:** ``` **Input:** s = \"abciiidef\", k = 3 **Output:** 3 **Explanation:** The substring \"iii\" contains 3 vowel letters. ``` **Example 2:** ``` **Input:** s = \"aeiou\", k = 2 **Output:** 2 **Explanation:** Any substring of length 2 contains 2 vowels. ``` **Example 3:** ``` **Input:** s = \"leetcode\", k = 3 **Output:** 2 **Explanation:** \"lee\", \"eet\" and \"ode\" contain 2 vowels. ``` **Constraints:** `1 <= s.length <= 105` `s` consists of lowercase English letters. `1 <= k <= s.length`",
        "test_case": [
            {
                "label": "Example 1",
                "input": "s = \"abciiidef\", k = 3",
                "output": "3 Explanation: The substring \"iii\" contains 3 vowel letters."
            },
            {
                "label": "Example 2",
                "input": "s = \"aeiou\", k = 2",
                "output": "2 Explanation: Any substring of length 2 contains 2 vowels."
            },
            {
                "label": "Example 3",
                "input": "s = \"leetcode\", k = 3",
                "output": "2 Explanation: \"lee\", \"eet\" and \"ode\" contain 2 vowels."
            }
        ],
        "elixir_template": "defmodule Solution do\n  @spec max_vowels(s :: String.t, k :: integer) :: integer\n  def max_vowels(s, k) do\n    \n  end\nend",
        "erlang_template": "-spec max_vowels(S :: unicode:unicode_binary(), K :: integer()) -> integer().\nmax_vowels(S, K) ->\n  .",
        "scala_template": "object Solution {\n    def maxVowels(s: String, k: Int): Int = {\n        \n    }\n}"
    },
    {
        "id": 1566,
        "name": "check-if-a-word-occurs-as-a-prefix-of-any-word-in-a-sentence",
        "difficulty": "Easy",
        "link": "https://leetcode.com/problems/check-if-a-word-occurs-as-a-prefix-of-any-word-in-a-sentence/",
        "task_description": "Given a `sentence` that consists of some words separated by a **single space**, and a `searchWord`, check if `searchWord` is a prefix of any word in `sentence`. Return _the index of the word in _`sentence`_ (**1-indexed**) where _`searchWord`_ is a prefix of this word_. If `searchWord` is a prefix of more than one word, return the index of the first word **(minimum index)**. If there is no such word return `-1`. A **prefix** of a string `s` is any leading contiguous substring of `s`. **Example 1:** ``` **Input:** sentence = \"i love eating burger\", searchWord = \"burg\" **Output:** 4 **Explanation:** \"burg\" is prefix of \"burger\" which is the 4th word in the sentence. ``` **Example 2:** ``` **Input:** sentence = \"this problem is an easy problem\", searchWord = \"pro\" **Output:** 2 **Explanation:** \"pro\" is prefix of \"problem\" which is the 2nd and the 6th word in the sentence, but we return 2 as it's the minimal index. ``` **Example 3:** ``` **Input:** sentence = \"i am tired\", searchWord = \"you\" **Output:** -1 **Explanation:** \"you\" is not a prefix of any word in the sentence. ``` **Constraints:** `1 <= sentence.length <= 100` `1 <= searchWord.length <= 10` `sentence` consists of lowercase English letters and spaces. `searchWord` consists of lowercase English letters.",
        "test_case": [
            {
                "label": "Example 1",
                "input": "sentence = \"i love eating burger\", searchWord = \"burg\"",
                "output": "4 Explanation: \"burg\" is prefix of \"burger\" which is the 4th word in the sentence."
            },
            {
                "label": "Example 2",
                "input": "sentence = \"this problem is an easy problem\", searchWord = \"pro\"",
                "output": "2 Explanation: \"pro\" is prefix of \"problem\" which is the 2nd and the 6th word in the sentence, but we return 2 as it's the minimal index."
            },
            {
                "label": "Example 3",
                "input": "sentence = \"i am tired\", searchWord = \"you\"",
                "output": "-1 Explanation: \"you\" is not a prefix of any word in the sentence."
            }
        ],
        "elixir_template": "defmodule Solution do\n  @spec is_prefix_of_word(sentence :: String.t, search_word :: String.t) :: integer\n  def is_prefix_of_word(sentence, search_word) do\n    \n  end\nend",
        "erlang_template": "-spec is_prefix_of_word(Sentence :: unicode:unicode_binary(), SearchWord :: unicode:unicode_binary()) -> integer().\nis_prefix_of_word(Sentence, SearchWord) ->\n  .",
        "scala_template": "object Solution {\n    def isPrefixOfWord(sentence: String, searchWord: String): Int = {\n        \n    }\n}"
    },
    {
        "id": 1563,
        "name": "maximum-number-of-darts-inside-of-a-circular-dartboard",
        "difficulty": "Hard",
        "link": "https://leetcode.com/problems/maximum-number-of-darts-inside-of-a-circular-dartboard/",
        "task_description": "Alice is throwing `n` darts on a very large wall. You are given an array `darts` where `darts[i] = [xi, yi]` is the position of the `ith` dart that Alice threw on the wall. Bob knows the positions of the `n` darts on the wall. He wants to place a dartboard of radius `r` on the wall so that the maximum number of darts that Alice throws lie on the dartboard. Given the integer `r`, return _the maximum number of darts that can lie on the dartboard_. **Example 1:** ``` **Input:** darts = [[-2,0],[2,0],[0,2],[0,-2]], r = 2 **Output:** 4 **Explanation:** Circle dartboard with center in (0,0) and radius = 2 contain all points. ``` **Example 2:** ``` **Input:** darts = [[-3,0],[3,0],[2,6],[5,4],[0,9],[7,8]], r = 5 **Output:** 5 **Explanation:** Circle dartboard with center in (0,4) and radius = 5 contain all points except the point (7,8). ``` **Constraints:** `1 <= darts.length <= 100` `darts[i].length == 2` `-104 <= xi, yi <= 104` All the `darts` are unique `1 <= r <= 5000`",
        "test_case": [
            {
                "label": "Example 1",
                "input": "darts = [[-2,0],[2,0],[0,2],[0,-2]], r = 2",
                "output": "4 Explanation: Circle dartboard with center in (0,0) and radius = 2 contain all points."
            },
            {
                "label": "Example 2",
                "input": "darts = [[-3,0],[3,0],[2,6],[5,4],[0,9],[7,8]], r = 5",
                "output": "5 Explanation: Circle dartboard with center in (0,4) and radius = 5 contain all points except the point (7,8)."
            }
        ],
        "elixir_template": "defmodule Solution do\n  @spec num_points(darts :: [[integer]], r :: integer) :: integer\n  def num_points(darts, r) do\n    \n  end\nend",
        "erlang_template": "-spec num_points(Darts :: [[integer()]], R :: integer()) -> integer().\nnum_points(Darts, R) ->\n  .",
        "scala_template": "object Solution {\n    def numPoints(darts: Array[Array[Int]], r: Int): Int = {\n        \n    }\n}"
    },
    {
        "id": 1562,
        "name": "people-whose-list-of-favorite-companies-is-not-a-subset-of-another-list",
        "difficulty": "Medium",
        "link": "https://leetcode.com/problems/people-whose-list-of-favorite-companies-is-not-a-subset-of-another-list/",
        "task_description": "Given the array `favoriteCompanies` where `favoriteCompanies[i]` is the list of favorites companies for the `ith` person (**indexed from 0**). _Return the indices of people whose list of favorite companies is not a **subset** of any other list of favorites companies_. You must return the indices in increasing order. **Example 1:** ``` **Input:** favoriteCompanies = [[\"leetcode\",\"google\",\"facebook\"],[\"google\",\"microsoft\"],[\"google\",\"facebook\"],[\"google\"],[\"amazon\"]] **Output:** [0,1,4] **Explanation:** Person with index=2 has favoriteCompanies[2]=[\"google\",\"facebook\"] which is a subset of favoriteCompanies[0]=[\"leetcode\",\"google\",\"facebook\"] corresponding to the person with index 0. Person with index=3 has favoriteCompanies[3]=[\"google\"] which is a subset of favoriteCompanies[0]=[\"leetcode\",\"google\",\"facebook\"] and favoriteCompanies[1]=[\"google\",\"microsoft\"]. Other lists of favorite companies are not a subset of another list, therefore, the answer is [0,1,4]. ``` **Example 2:** ``` **Input:** favoriteCompanies = [[\"leetcode\",\"google\",\"facebook\"],[\"leetcode\",\"amazon\"],[\"facebook\",\"google\"]] **Output:** [0,1] **Explanation:** In this case favoriteCompanies[2]=[\"facebook\",\"google\"] is a subset of favoriteCompanies[0]=[\"leetcode\",\"google\",\"facebook\"], therefore, the answer is [0,1]. ``` **Example 3:** ``` **Input:** favoriteCompanies = [[\"leetcode\"],[\"google\"],[\"facebook\"],[\"amazon\"]] **Output:** [0,1,2,3] ``` **Constraints:** `1 <= favoriteCompanies.length <= 100` `1 <= favoriteCompanies[i].length <= 500` `1 <= favoriteCompanies[i][j].length <= 20` All strings in `favoriteCompanies[i]` are **distinct**. All lists of favorite companies are **distinct**, that is, If we sort alphabetically each list then `favoriteCompanies[i] != favoriteCompanies[j].` All strings consist of lowercase English letters only.",
        "test_case": [
            {
                "label": "Example 1",
                "input": "favoriteCompanies = [[\"leetcode\",\"google\",\"facebook\"],[\"google\",\"microsoft\"],[\"google\",\"facebook\"],[\"google\"],[\"amazon\"]]",
                "output": "[0,1,4] Explanation: Person with index=2 has favoriteCompanies[2]=[\"google\",\"facebook\"] which is a subset of favoriteCompanies[0]=[\"leetcode\",\"google\",\"facebook\"] corresponding to the person with index 0. \nPerson with index=3 has favoriteCompanies[3]=[\"google\"] which is a subset of favoriteCompanies[0]=[\"leetcode\",\"google\",\"facebook\"] and favoriteCompanies[1]=[\"google\",\"microsoft\"]. \nOther lists of favorite companies are not a subset of another list, therefore, the answer is [0,1,4]."
            },
            {
                "label": "Example 2",
                "input": "favoriteCompanies = [[\"leetcode\",\"google\",\"facebook\"],[\"leetcode\",\"amazon\"],[\"facebook\",\"google\"]]",
                "output": "[0,1] Explanation: In this case favoriteCompanies[2]=[\"facebook\",\"google\"] is a subset of favoriteCompanies[0]=[\"leetcode\",\"google\",\"facebook\"], therefore, the answer is [0,1]."
            },
            {
                "label": "Example 3",
                "input": "favoriteCompanies = [[\"leetcode\"],[\"google\"],[\"facebook\"],[\"amazon\"]]",
                "output": "[0,1,2,3]"
            }
        ],
        "elixir_template": "defmodule Solution do\n  @spec people_indexes(favorite_companies :: [[String.t]]) :: [integer]\n  def people_indexes(favorite_companies) do\n    \n  end\nend",
        "erlang_template": "-spec people_indexes(FavoriteCompanies :: [[unicode:unicode_binary()]]) -> [integer()].\npeople_indexes(FavoriteCompanies) ->\n  .",
        "scala_template": "object Solution {\n    def peopleIndexes(favoriteCompanies: List[List[String]]): List[Int] = {\n        \n    }\n}"
    },
    {
        "id": 1561,
        "name": "rearrange-words-in-a-sentence",
        "difficulty": "Medium",
        "link": "https://leetcode.com/problems/rearrange-words-in-a-sentence/",
        "task_description": "Given a sentence `text` (A _sentence_ is a string of space-separated words) in the following format: First letter is in upper case. Each word in `text` are separated by a single space. Your task is to rearrange the words in text such that all words are rearranged in an increasing order of their lengths. If two words have the same length, arrange them in their original order. Return the new text following the format shown above. **Example 1:** ``` **Input:** text = \"Leetcode is cool\" **Output:** \"Is cool leetcode\" **Explanation: **There are 3 words, \"Leetcode\" of length 8, \"is\" of length 2 and \"cool\" of length 4. Output is ordered by length and the new first word starts with capital letter. ``` **Example 2:** ``` **Input:** text = \"Keep calm and code on\" **Output:** \"On and keep calm code\" **Explanation: **Output is ordered as follows: \"On\" 2 letters. \"and\" 3 letters. \"keep\" 4 letters in case of tie order by position in original text. \"calm\" 4 letters. \"code\" 4 letters. ``` **Example 3:** ``` **Input:** text = \"To be or not to be\" **Output:** \"To be or to be not\" ``` **Constraints:** `text` begins with a capital letter and then contains lowercase letters and single space between words. `1 <= text.length <= 10^5`",
        "test_case": [
            {
                "label": "Example 1",
                "input": "text = \"Leetcode is cool\"",
                "output": "\"Is cool leetcode\" Explanation: There are 3 words, \"Leetcode\" of length 8, \"is\" of length 2 and \"cool\" of length 4.\nOutput is ordered by length and the new first word starts with capital letter."
            },
            {
                "label": "Example 2",
                "input": "text = \"Keep calm and code on\"",
                "output": "\"On and keep calm code\" Explanation: Output is ordered as follows:\n\"On\" 2 letters.\n\"and\" 3 letters.\n\"keep\" 4 letters in case of tie order by position in original text.\n\"calm\" 4 letters.\n\"code\" 4 letters."
            },
            {
                "label": "Example 3",
                "input": "text = \"To be or not to be\"",
                "output": "\"To be or to be not\" Constraints: text begins with a capital letter and then contains lowercase letters and single space between words. 1 <= text.length <= 10^5"
            }
        ],
        "elixir_template": "defmodule Solution do\n  @spec arrange_words(text :: String.t) :: String.t\n  def arrange_words(text) do\n    \n  end\nend",
        "erlang_template": "-spec arrange_words(Text :: unicode:unicode_binary()) -> unicode:unicode_binary().\narrange_words(Text) ->\n  .",
        "scala_template": "object Solution {\n    def arrangeWords(text: String): String = {\n        \n    }\n}"
    },
    {
        "id": 1560,
        "name": "number-of-students-doing-homework-at-a-given-time",
        "difficulty": "Easy",
        "link": "https://leetcode.com/problems/number-of-students-doing-homework-at-a-given-time/",
        "task_description": "Given two integer arrays `startTime` and `endTime` and given an integer `queryTime`. The `ith` student started doing their homework at the time `startTime[i]` and finished it at time `endTime[i]`. Return _the number of students_ doing their homework at time `queryTime`. More formally, return the number of students where `queryTime` lays in the interval `[startTime[i], endTime[i]]` inclusive. **Example 1:** ``` **Input:** startTime = [1,2,3], endTime = [3,2,7], queryTime = 4 **Output:** 1 **Explanation:** We have 3 students where: The first student started doing homework at time 1 and finished at time 3 and wasn't doing anything at time 4. The second student started doing homework at time 2 and finished at time 2 and also wasn't doing anything at time 4. The third student started doing homework at time 3 and finished at time 7 and was the only student doing homework at time 4. ``` **Example 2:** ``` **Input:** startTime = [4], endTime = [4], queryTime = 4 **Output:** 1 **Explanation:** The only student was doing their homework at the queryTime. ``` **Constraints:** `startTime.length == endTime.length` `1 <= startTime.length <= 100` `1 <= startTime[i] <= endTime[i] <= 1000` `1 <= queryTime <= 1000`",
        "test_case": [
            {
                "label": "Example 1",
                "input": "startTime = [1,2,3], endTime = [3,2,7], queryTime = 4",
                "output": "1 Explanation: We have 3 students where:\nThe first student started doing homework at time 1 and finished at time 3 and wasn't doing anything at time 4.\nThe second student started doing homework at time 2 and finished at time 2 and also wasn't doing anything at time 4.\nThe third student started doing homework at time 3 and finished at time 7 and was the only student doing homework at time 4."
            },
            {
                "label": "Example 2",
                "input": "startTime = [4], endTime = [4], queryTime = 4",
                "output": "1 Explanation: The only student was doing their homework at the queryTime. Constraints: startTime.length == endTime.length 1 <= startTime.length <= 100 1 <= startTime[i] <= endTime[i] <= 1000 1 <= queryTime <= 1000"
            }
        ],
        "elixir_template": "defmodule Solution do\n  @spec busy_student(start_time :: [integer], end_time :: [integer], query_time :: integer) :: integer\n  def busy_student(start_time, end_time, query_time) do\n    \n  end\nend",
        "erlang_template": "-spec busy_student(StartTime :: [integer()], EndTime :: [integer()], QueryTime :: integer()) -> integer().\nbusy_student(StartTime, EndTime, QueryTime) ->\n  .",
        "scala_template": "object Solution {\n    def busyStudent(startTime: Array[Int], endTime: Array[Int], queryTime: Int): Int = {\n        \n    }\n}"
    },
    {
        "id": 1559,
        "name": "cherry-pickup-ii",
        "difficulty": "Hard",
        "link": "https://leetcode.com/problems/cherry-pickup-ii/",
        "task_description": "You are given a `rows x cols` matrix `grid` representing a field of cherries where `grid[i][j]` represents the number of cherries that you can collect from the `(i, j)` cell. You have two robots that can collect cherries for you: **Robot #1** is located at the **top-left corner** `(0, 0)`, and **Robot #2** is located at the **top-right corner** `(0, cols - 1)`. Return _the maximum number of cherries collection using both robots by following the rules below_: From a cell `(i, j)`, robots can move to cell `(i + 1, j - 1)`, `(i + 1, j)`, or `(i + 1, j + 1)`. When any robot passes through a cell, It picks up all cherries, and the cell becomes an empty cell. When both robots stay in the same cell, only one takes the cherries. Both robots cannot move outside of the grid at any moment. Both robots should reach the bottom row in `grid`. **Example 1:** ``` **Input:** grid = [[3,1,1],[2,5,1],[1,5,5],[2,1,1]] **Output:** 24 **Explanation:** Path of robot #1 and #2 are described in color green and blue respectively. Cherries taken by Robot #1, (3 + 2 + 5 + 2) = 12. Cherries taken by Robot #2, (1 + 5 + 5 + 1) = 12. Total of cherries: 12 + 12 = 24. ``` **Example 2:** ``` **Input:** grid = [[1,0,0,0,0,0,1],[2,0,0,0,0,3,0],[2,0,9,0,0,0,0],[0,3,0,5,4,0,0],[1,0,2,3,0,0,6]] **Output:** 28 **Explanation:** Path of robot #1 and #2 are described in color green and blue respectively. Cherries taken by Robot #1, (1 + 9 + 5 + 2) = 17. Cherries taken by Robot #2, (1 + 3 + 4 + 3) = 11. Total of cherries: 17 + 11 = 28. ``` **Constraints:** `rows == grid.length` `cols == grid[i].length` `2 <= rows, cols <= 70` `0 <= grid[i][j] <= 100`",
        "test_case": [
            {
                "label": "Example 1",
                "input": "grid = [[3,1,1],[2,5,1],[1,5,5],[2,1,1]]",
                "output": "24 Explanation: Path of robot #1 and #2 are described in color green and blue respectively.\nCherries taken by Robot #1, (3 + 2 + 5 + 2) = 12.\nCherries taken by Robot #2, (1 + 5 + 5 + 1) = 12.\nTotal of cherries: 12 + 12 = 24."
            },
            {
                "label": "Example 2",
                "input": "grid = [[1,0,0,0,0,0,1],[2,0,0,0,0,3,0],[2,0,9,0,0,0,0],[0,3,0,5,4,0,0],[1,0,2,3,0,0,6]]",
                "output": "28 Explanation: Path of robot #1 and #2 are described in color green and blue respectively.\nCherries taken by Robot #1, (1 + 9 + 5 + 2) = 17.\nCherries taken by Robot #2, (1 + 3 + 4 + 3) = 11.\nTotal of cherries: 17 + 11 = 28. Constraints: rows == grid.length cols == grid[i].length 2 <= rows, cols <= 70 0 <= grid[i][j] <= 100"
            }
        ],
        "elixir_template": "defmodule Solution do\n  @spec cherry_pickup(grid :: [[integer]]) :: integer\n  def cherry_pickup(grid) do\n    \n  end\nend",
        "erlang_template": "-spec cherry_pickup(Grid :: [[integer()]]) -> integer().\ncherry_pickup(Grid) ->\n  .",
        "scala_template": "object Solution {\n    def cherryPickup(grid: Array[Array[Int]]): Int = {\n        \n    }\n}"
    },
    {
        "id": 1558,
        "name": "course-schedule-iv",
        "difficulty": "Medium",
        "link": "https://leetcode.com/problems/course-schedule-iv/",
        "task_description": "There are a total of `numCourses` courses you have to take, labeled from `0` to `numCourses - 1`. You are given an array `prerequisites` where `prerequisites[i] = [ai, bi]` indicates that you **must** take course `ai` first if you want to take course `bi`. For example, the pair `[0, 1]` indicates that you have to take course `0` before you can take course `1`. Prerequisites can also be **indirect**. If course `a` is a prerequisite of course `b`, and course `b` is a prerequisite of course `c`, then course `a` is a prerequisite of course `c`. You are also given an array `queries` where `queries[j] = [uj, vj]`. For the `jth` query, you should answer whether course `uj` is a prerequisite of course `vj` or not. Return a boolean array `answer`, where `answer[j]` is the answer to the `jth` query. **Example 1:** ``` **Input:** numCourses = 2, prerequisites = [[1,0]], queries = [[0,1],[1,0]] **Output:** [false,true] **Explanation:** The pair [1, 0] indicates that you have to take course 1 before you can take course 0. Course 0 is not a prerequisite of course 1, but the opposite is true. ``` **Example 2:** ``` **Input:** numCourses = 2, prerequisites = [], queries = [[1,0],[0,1]] **Output:** [false,false] **Explanation:** There are no prerequisites, and each course is independent. ``` **Example 3:** ``` **Input:** numCourses = 3, prerequisites = [[1,2],[1,0],[2,0]], queries = [[1,0],[1,2]] **Output:** [true,true] ``` **Constraints:** `2 <= numCourses <= 100` `0 <= prerequisites.length <= (numCourses * (numCourses - 1) / 2)` `prerequisites[i].length == 2` `0 <= ai, bi <= numCourses - 1` `ai != bi` All the pairs `[ai, bi]` are **unique**. The prerequisites graph has no cycles. `1 <= queries.length <= 104` `0 <= ui, vi <= numCourses - 1` `ui != vi`",
        "test_case": [
            {
                "label": "Example 1",
                "input": "numCourses = 2, prerequisites = [[1,0]], queries = [[0,1],[1,0]]",
                "output": "[false,true] Explanation: The pair [1, 0] indicates that you have to take course 1 before you can take course 0.\nCourse 0 is not a prerequisite of course 1, but the opposite is true."
            },
            {
                "label": "Example 2",
                "input": "numCourses = 2, prerequisites = [], queries = [[1,0],[0,1]]",
                "output": "[false,false] Explanation: There are no prerequisites, and each course is independent."
            },
            {
                "label": "Example 3",
                "input": "numCourses = 3, prerequisites = [[1,2],[1,0],[2,0]], queries = [[1,0],[1,2]]",
                "output": "[true,true]"
            }
        ],
        "elixir_template": "defmodule Solution do\n  @spec check_if_prerequisite(num_courses :: integer, prerequisites :: [[integer]], queries :: [[integer]]) :: [boolean]\n  def check_if_prerequisite(num_courses, prerequisites, queries) do\n    \n  end\nend",
        "erlang_template": "-spec check_if_prerequisite(NumCourses :: integer(), Prerequisites :: [[integer()]], Queries :: [[integer()]]) -> [boolean()].\ncheck_if_prerequisite(NumCourses, Prerequisites, Queries) ->\n  .",
        "scala_template": "object Solution {\n    def checkIfPrerequisite(numCourses: Int, prerequisites: Array[Array[Int]], queries: Array[Array[Int]]): List[Boolean] = {\n        \n    }\n}"
    },
    {
        "id": 1557,
        "name": "check-if-a-string-contains-all-binary-codes-of-size-k",
        "difficulty": "Medium",
        "link": "https://leetcode.com/problems/check-if-a-string-contains-all-binary-codes-of-size-k/",
        "task_description": "Given a binary string `s` and an integer `k`, return `true` _if every binary code of length_ `k` _is a substring of_ `s`. Otherwise, return `false`. **Example 1:** ``` **Input:** s = \"00110110\", k = 2 **Output:** true **Explanation:** The binary codes of length 2 are \"00\", \"01\", \"10\" and \"11\". They can be all found as substrings at indices 0, 1, 3 and 2 respectively. ``` **Example 2:** ``` **Input:** s = \"0110\", k = 1 **Output:** true **Explanation:** The binary codes of length 1 are \"0\" and \"1\", it is clear that both exist as a substring. ``` **Example 3:** ``` **Input:** s = \"0110\", k = 2 **Output:** false **Explanation:** The binary code \"00\" is of length 2 and does not exist in the array. ``` **Constraints:** `1 <= s.length <= 5 * 105` `s[i]` is either `'0'` or `'1'`. `1 <= k <= 20`",
        "test_case": [
            {
                "label": "Example 1",
                "input": "s = \"00110110\", k = 2",
                "output": "true Explanation: The binary codes of length 2 are \"00\", \"01\", \"10\" and \"11\". They can be all found as substrings at indices 0, 1, 3 and 2 respectively."
            },
            {
                "label": "Example 2",
                "input": "s = \"0110\", k = 1",
                "output": "true Explanation: The binary codes of length 1 are \"0\" and \"1\", it is clear that both exist as a substring."
            },
            {
                "label": "Example 3",
                "input": "s = \"0110\", k = 2",
                "output": "false Explanation: The binary code \"00\" is of length 2 and does not exist in the array."
            }
        ],
        "elixir_template": "defmodule Solution do\n  @spec has_all_codes(s :: String.t, k :: integer) :: boolean\n  def has_all_codes(s, k) do\n    \n  end\nend",
        "erlang_template": "-spec has_all_codes(S :: unicode:unicode_binary(), K :: integer()) -> boolean().\nhas_all_codes(S, K) ->\n  .",
        "scala_template": "object Solution {\n    def hasAllCodes(s: String, k: Int): Boolean = {\n        \n    }\n}"
    },
    {
        "id": 1556,
        "name": "make-two-arrays-equal-by-reversing-subarrays",
        "difficulty": "Easy",
        "link": "https://leetcode.com/problems/make-two-arrays-equal-by-reversing-subarrays/",
        "task_description": "You are given two integer arrays of equal length `target` and `arr`. In one step, you can select any **non-empty subarray** of `arr` and reverse it. You are allowed to make any number of steps. Return `true` _if you can make _`arr`_ equal to _`target`_ or _`false`_ otherwise_. **Example 1:** ``` **Input:** target = [1,2,3,4], arr = [2,4,1,3] **Output:** true **Explanation:** You can follow the next steps to convert arr to target: 1- Reverse subarray [2,4,1], arr becomes [1,4,2,3] 2- Reverse subarray [4,2], arr becomes [1,2,4,3] 3- Reverse subarray [4,3], arr becomes [1,2,3,4] There are multiple ways to convert arr to target, this is not the only way to do so. ``` **Example 2:** ``` **Input:** target = [7], arr = [7] **Output:** true **Explanation:** arr is equal to target without any reverses. ``` **Example 3:** ``` **Input:** target = [3,7,9], arr = [3,7,11] **Output:** false **Explanation:** arr does not have value 9 and it can never be converted to target. ``` **Constraints:** `target.length == arr.length` `1 <= target.length <= 1000` `1 <= target[i] <= 1000` `1 <= arr[i] <= 1000`",
        "test_case": [
            {
                "label": "Example 1",
                "input": "target = [1,2,3,4], arr = [2,4,1,3]",
                "output": "true Explanation: You can follow the next steps to convert arr to target:\n1- Reverse subarray [2,4,1], arr becomes [1,4,2,3]\n2- Reverse subarray [4,2], arr becomes [1,2,4,3]\n3- Reverse subarray [4,3], arr becomes [1,2,3,4]\nThere are multiple ways to convert arr to target, this is not the only way to do so."
            },
            {
                "label": "Example 2",
                "input": "target = [7], arr = [7]",
                "output": "true Explanation: arr is equal to target without any reverses."
            },
            {
                "label": "Example 3",
                "input": "target = [3,7,9], arr = [3,7,11]",
                "output": "false Explanation: arr does not have value 9 and it can never be converted to target. Constraints: target.length == arr.length 1 <= target.length <= 1000 1 <= target[i] <= 1000 1 <= arr[i] <= 1000"
            }
        ],
        "elixir_template": "defmodule Solution do\n  @spec can_be_equal(target :: [integer], arr :: [integer]) :: boolean\n  def can_be_equal(target, arr) do\n    \n  end\nend",
        "erlang_template": "-spec can_be_equal(Target :: [integer()], Arr :: [integer()]) -> boolean().\ncan_be_equal(Target, Arr) ->\n  .",
        "scala_template": "object Solution {\n    def canBeEqual(target: Array[Int], arr: Array[Int]): Boolean = {\n        \n    }\n}"
    },
    {
        "id": 1555,
        "name": "number-of-ways-of-cutting-a-pizza",
        "difficulty": "Hard",
        "link": "https://leetcode.com/problems/number-of-ways-of-cutting-a-pizza/",
        "task_description": "Given a rectangular pizza represented as a `rows x cols` matrix containing the following characters: `'A'` (an apple) and `'.'` (empty cell) and given the integer `k`. You have to cut the pizza into `k` pieces using `k-1` cuts. For each cut you choose the direction: vertical or horizontal, then you choose a cut position at the cell boundary and cut the pizza into two pieces. If you cut the pizza vertically, give the left part of the pizza to a person. If you cut the pizza horizontally, give the upper part of the pizza to a person. Give the last piece of pizza to the last person. _Return the number of ways of cutting the pizza such that each piece contains **at least** one apple. _Since the answer can be a huge number, return this modulo 10^9 + 7. **Example 1:** **** ``` **Input:** pizza = [\"A..\",\"AAA\",\"...\"], k = 3 **Output:** 3 **Explanation:** The figure above shows the three ways to cut the pizza. Note that pieces must contain at least one apple. ``` **Example 2:** ``` **Input:** pizza = [\"A..\",\"AA.\",\"...\"], k = 3 **Output:** 1 ``` **Example 3:** ``` **Input:** pizza = [\"A..\",\"A..\",\"...\"], k = 1 **Output:** 1 ``` **Constraints:** `1 <= rows, cols <= 50` `rows == pizza.length` `cols == pizza[i].length` `1 <= k <= 10` `pizza` consists of characters `'A'` and `'.'` only.",
        "test_case": [
            {
                "label": "Example 1",
                "input": "pizza = [\"A..\",\"AAA\",\"...\"], k = 3",
                "output": "3 Explanation: The figure above shows the three ways to cut the pizza. Note that pieces must contain at least one apple."
            },
            {
                "label": "Example 2",
                "input": "pizza = [\"A..\",\"AA.\",\"...\"], k = 3",
                "output": "1"
            },
            {
                "label": "Example 3",
                "input": "pizza = [\"A..\",\"A..\",\"...\"], k = 1",
                "output": "1"
            }
        ],
        "elixir_template": "defmodule Solution do\n  @spec ways(pizza :: [String.t], k :: integer) :: integer\n  def ways(pizza, k) do\n    \n  end\nend",
        "erlang_template": "-spec ways(Pizza :: [unicode:unicode_binary()], K :: integer()) -> integer().\nways(Pizza, K) ->\n  .",
        "scala_template": "object Solution {\n    def ways(pizza: Array[String], k: Int): Int = {\n        \n    }\n}"
    },
    {
        "id": 1554,
        "name": "minimum-time-to-collect-all-apples-in-a-tree",
        "difficulty": "Medium",
        "link": "https://leetcode.com/problems/minimum-time-to-collect-all-apples-in-a-tree/",
        "task_description": "Given an undirected tree consisting of `n` vertices numbered from `0` to `n-1`, which has some apples in their vertices. You spend 1 second to walk over one edge of the tree. _Return the minimum time in seconds you have to spend to collect all apples in the tree, starting at **vertex 0** and coming back to this vertex._ The edges of the undirected tree are given in the array `edges`, where `edges[i] = [ai, bi]` means that exists an edge connecting the vertices `ai` and `bi`. Additionally, there is a boolean array `hasApple`, where `hasApple[i] = true` means that vertex `i` has an apple; otherwise, it does not have any apple. **Example 1:** ``` **Input:** n = 7, edges = [[0,1],[0,2],[1,4],[1,5],[2,3],[2,6]], hasApple = [false,false,true,false,true,true,false] **Output:** 8 **Explanation:** The figure above represents the given tree where red vertices have an apple. One optimal path to collect all apples is shown by the green arrows. ``` **Example 2:** ``` **Input:** n = 7, edges = [[0,1],[0,2],[1,4],[1,5],[2,3],[2,6]], hasApple = [false,false,true,false,false,true,false] **Output:** 6 **Explanation:** The figure above represents the given tree where red vertices have an apple. One optimal path to collect all apples is shown by the green arrows. ``` **Example 3:** ``` **Input:** n = 7, edges = [[0,1],[0,2],[1,4],[1,5],[2,3],[2,6]], hasApple = [false,false,false,false,false,false,false] **Output:** 0 ``` **Constraints:** `1 <= n <= 105` `edges.length == n - 1` `edges[i].length == 2` `0 <= ai < bi <= n - 1` `hasApple.length == n`",
        "test_case": [
            {
                "label": "Example 1",
                "input": "n = 7, edges = [[0,1],[0,2],[1,4],[1,5],[2,3],[2,6]], hasApple = [false,false,true,false,true,true,false]",
                "output": "8 Explanation: The figure above represents the given tree where red vertices have an apple. One optimal path to collect all apples is shown by the green arrows."
            },
            {
                "label": "Example 2",
                "input": "n = 7, edges = [[0,1],[0,2],[1,4],[1,5],[2,3],[2,6]], hasApple = [false,false,true,false,false,true,false]",
                "output": "6 Explanation: The figure above represents the given tree where red vertices have an apple. One optimal path to collect all apples is shown by the green arrows."
            },
            {
                "label": "Example 3",
                "input": "n = 7, edges = [[0,1],[0,2],[1,4],[1,5],[2,3],[2,6]], hasApple = [false,false,false,false,false,false,false]",
                "output": "0"
            }
        ],
        "elixir_template": "defmodule Solution do\n  @spec min_time(n :: integer, edges :: [[integer]], has_apple :: [boolean]) :: integer\n  def min_time(n, edges, has_apple) do\n    \n  end\nend",
        "erlang_template": "-spec min_time(N :: integer(), Edges :: [[integer()]], HasApple :: [boolean()]) -> integer().\nmin_time(N, Edges, HasApple) ->\n  .",
        "scala_template": "object Solution {\n    def minTime(n: Int, edges: Array[Array[Int]], hasApple: List[Boolean]): Int = {\n        \n    }\n}"
    },
    {
        "id": 1553,
        "name": "count-triplets-that-can-form-two-arrays-of-equal-xor",
        "difficulty": "Medium",
        "link": "https://leetcode.com/problems/count-triplets-that-can-form-two-arrays-of-equal-xor/",
        "task_description": "Given an array of integers `arr`. We want to select three indices `i`, `j` and `k` where `(0 <= i < j <= k < arr.length)`. Let's define `a` and `b` as follows: `a = arr[i] ^ arr[i + 1] ^ ... ^ arr[j - 1]` `b = arr[j] ^ arr[j + 1] ^ ... ^ arr[k]` Note that **^** denotes the **bitwise-xor** operation. Return _the number of triplets_ (`i`, `j` and `k`) Where `a == b`. **Example 1:** ``` **Input:** arr = [2,3,1,6,7] **Output:** 4 **Explanation:** The triplets are (0,1,2), (0,2,2), (2,3,4) and (2,4,4) ``` **Example 2:** ``` **Input:** arr = [1,1,1,1,1] **Output:** 10 ``` **Constraints:** `1 <= arr.length <= 300` `1 <= arr[i] <= 108`",
        "test_case": [
            {
                "label": "Example 1",
                "input": "arr = [2,3,1,6,7]",
                "output": "4 Explanation: The triplets are (0,1,2), (0,2,2), (2,3,4) and (2,4,4)"
            },
            {
                "label": "Example 2",
                "input": "arr = [1,1,1,1,1]",
                "output": "10"
            }
        ],
        "elixir_template": "defmodule Solution do\n  @spec count_triplets(arr :: [integer]) :: integer\n  def count_triplets(arr) do\n    \n  end\nend",
        "erlang_template": "-spec count_triplets(Arr :: [integer()]) -> integer().\ncount_triplets(Arr) ->\n  .",
        "scala_template": "object Solution {\n    def countTriplets(arr: Array[Int]): Int = {\n        \n    }\n}"
    },
    {
        "id": 1552,
        "name": "build-an-array-with-stack-operations",
        "difficulty": "Medium",
        "link": "https://leetcode.com/problems/build-an-array-with-stack-operations/",
        "task_description": "You are given an integer array `target` and an integer `n`. You have an empty stack with the two following operations: **`\"Push\"`**: pushes an integer to the top of the stack. **`\"Pop\"`**: removes the integer on the top of the stack. You also have a stream of the integers in the range `[1, n]`. Use the two stack operations to make the numbers in the stack (from the bottom to the top) equal to `target`. You should follow the following rules: If the stream of the integers is not empty, pick the next integer from the stream and push it to the top of the stack. If the stack is not empty, pop the integer at the top of the stack. If, at any moment, the elements in the stack (from the bottom to the top) are equal to `target`, do not read new integers from the stream and do not do more operations on the stack. Return _the stack operations needed to build _`target` following the mentioned rules. If there are multiple valid answers, return **any of them**. **Example 1:** ``` **Input:** target = [1,3], n = 3 **Output:** [\"Push\",\"Push\",\"Pop\",\"Push\"] **Explanation:** Initially the stack s is empty. The last element is the top of the stack. Read 1 from the stream and push it to the stack. s = [1]. Read 2 from the stream and push it to the stack. s = [1,2]. Pop the integer on the top of the stack. s = [1]. Read 3 from the stream and push it to the stack. s = [1,3]. ``` **Example 2:** ``` **Input:** target = [1,2,3], n = 3 **Output:** [\"Push\",\"Push\",\"Push\"] **Explanation:** Initially the stack s is empty. The last element is the top of the stack. Read 1 from the stream and push it to the stack. s = [1]. Read 2 from the stream and push it to the stack. s = [1,2]. Read 3 from the stream and push it to the stack. s = [1,2,3]. ``` **Example 3:** ``` **Input:** target = [1,2], n = 4 **Output:** [\"Push\",\"Push\"] **Explanation:** Initially the stack s is empty. The last element is the top of the stack. Read 1 from the stream and push it to the stack. s = [1]. Read 2 from the stream and push it to the stack. s = [1,2]. Since the stack (from the bottom to the top) is equal to target, we stop the stack operations. The answers that read integer 3 from the stream are not accepted. ``` **Constraints:** `1 <= target.length <= 100` `1 <= n <= 100` `1 <= target[i] <= n` `target` is strictly increasing.",
        "test_case": [
            {
                "label": "Example 1",
                "input": "target = [1,3], n = 3",
                "output": "[\"Push\",\"Push\",\"Pop\",\"Push\"] Explanation: Initially the stack s is empty. The last element is the top of the stack.\nRead 1 from the stream and push it to the stack. s = [1].\nRead 2 from the stream and push it to the stack. s = [1,2].\nPop the integer on the top of the stack. s = [1].\nRead 3 from the stream and push it to the stack. s = [1,3]."
            },
            {
                "label": "Example 2",
                "input": "target = [1,2,3], n = 3",
                "output": "[\"Push\",\"Push\",\"Push\"] Explanation: Initially the stack s is empty. The last element is the top of the stack.\nRead 1 from the stream and push it to the stack. s = [1].\nRead 2 from the stream and push it to the stack. s = [1,2].\nRead 3 from the stream and push it to the stack. s = [1,2,3]."
            },
            {
                "label": "Example 3",
                "input": "target = [1,2], n = 4",
                "output": "[\"Push\",\"Push\"] Explanation: Initially the stack s is empty. The last element is the top of the stack.\nRead 1 from the stream and push it to the stack. s = [1].\nRead 2 from the stream and push it to the stack. s = [1,2].\nSince the stack (from the bottom to the top) is equal to target, we stop the stack operations.\nThe answers that read integer 3 from the stream are not accepted."
            }
        ],
        "elixir_template": "defmodule Solution do\n  @spec build_array(target :: [integer], n :: integer) :: [String.t]\n  def build_array(target, n) do\n    \n  end\nend",
        "erlang_template": "-spec build_array(Target :: [integer()], N :: integer()) -> [unicode:unicode_binary()].\nbuild_array(Target, N) ->\n  .",
        "scala_template": "object Solution {\n    def buildArray(target: Array[Int], n: Int): List[String] = {\n        \n    }\n}"
    },
    {
        "id": 1550,
        "name": "find-the-kth-smallest-sum-of-a-matrix-with-sorted-rows",
        "difficulty": "Hard",
        "link": "https://leetcode.com/problems/find-the-kth-smallest-sum-of-a-matrix-with-sorted-rows/",
        "task_description": "You are given an `m x n` matrix `mat` that has its rows sorted in non-decreasing order and an integer `k`. You are allowed to choose **exactly one element** from each row to form an array. Return _the _`kth`_ smallest array sum among all possible arrays_. **Example 1:** ``` **Input:** mat = [[1,3,11],[2,4,6]], k = 5 **Output:** 7 **Explanation:** Choosing one element from each row, the first k smallest sum are: [1,2], [1,4], [3,2], [3,4], [1,6]. Where the 5th sum is 7. ``` **Example 2:** ``` **Input:** mat = [[1,3,11],[2,4,6]], k = 9 **Output:** 17 ``` **Example 3:** ``` **Input:** mat = [[1,10,10],[1,4,5],[2,3,6]], k = 7 **Output:** 9 **Explanation:** Choosing one element from each row, the first k smallest sum are: [1,1,2], [1,1,3], [1,4,2], [1,4,3], [1,1,6], [1,5,2], [1,5,3]. Where the 7th sum is 9. ``` **Constraints:** `m == mat.length` `n == mat.length[i]` `1 <= m, n <= 40` `1 <= mat[i][j] <= 5000` `1 <= k <= min(200, nm)` `mat[i]` is a non-decreasing array.",
        "test_case": [
            {
                "label": "Example 1",
                "input": "mat = [[1,3,11],[2,4,6]], k = 5",
                "output": "7 Explanation: Choosing one element from each row, the first k smallest sum are:\n[1,2], [1,4], [3,2], [3,4], [1,6]. Where the 5th sum is 7."
            },
            {
                "label": "Example 2",
                "input": "mat = [[1,3,11],[2,4,6]], k = 9",
                "output": "17"
            },
            {
                "label": "Example 3",
                "input": "mat = [[1,10,10],[1,4,5],[2,3,6]], k = 7",
                "output": "9 Explanation: Choosing one element from each row, the first k smallest sum are:\n[1,1,2], [1,1,3], [1,4,2], [1,4,3], [1,1,6], [1,5,2], [1,5,3]. Where the 7th sum is 9. Constraints: m == mat.length n == mat.length[i] 1 <= m, n <= 40 1 <= mat[i][j] <= 5000 1 <= k <= min(200, n m ) mat[i] is a non-decreasing array."
            }
        ],
        "elixir_template": "defmodule Solution do\n  @spec kth_smallest(mat :: [[integer]], k :: integer) :: integer\n  def kth_smallest(mat, k) do\n    \n  end\nend",
        "erlang_template": "-spec kth_smallest(Mat :: [[integer()]], K :: integer()) -> integer().\nkth_smallest(Mat, K) ->\n  .",
        "scala_template": "object Solution {\n    def kthSmallest(mat: Array[Array[Int]], k: Int): Int = {\n        \n    }\n}"
    },
    {
        "id": 1549,
        "name": "longest-continuous-subarray-with-absolute-diff-less-than-or-equal-to-limit",
        "difficulty": "Medium",
        "link": "https://leetcode.com/problems/longest-continuous-subarray-with-absolute-diff-less-than-or-equal-to-limit/",
        "task_description": "Given an array of integers `nums` and an integer `limit`, return the size of the longest **non-empty** subarray such that the absolute difference between any two elements of this subarray is less than or equal to `limit`_._ **Example 1:** ``` **Input:** nums = [8,2,4,7], limit = 4 **Output:** 2 **Explanation:** All subarrays are: [8] with maximum absolute diff |8-8| = 0 <= 4. [8,2] with maximum absolute diff |8-2| = 6 > 4. [8,2,4] with maximum absolute diff |8-2| = 6 > 4. [8,2,4,7] with maximum absolute diff |8-2| = 6 > 4. [2] with maximum absolute diff |2-2| = 0 <= 4. [2,4] with maximum absolute diff |2-4| = 2 <= 4. [2,4,7] with maximum absolute diff |2-7| = 5 > 4. [4] with maximum absolute diff |4-4| = 0 <= 4. [4,7] with maximum absolute diff |4-7| = 3 <= 4. [7] with maximum absolute diff |7-7| = 0 <= 4. Therefore, the size of the longest subarray is 2. ``` **Example 2:** ``` **Input:** nums = [10,1,2,4,7,2], limit = 5 **Output:** 4 **Explanation:** The subarray [2,4,7,2] is the longest since the maximum absolute diff is |2-7| = 5 <= 5. ``` **Example 3:** ``` **Input:** nums = [4,2,2,2,4,4,2,2], limit = 0 **Output:** 3 ``` **Constraints:** `1 <= nums.length <= 105` `1 <= nums[i] <= 109` `0 <= limit <= 109`",
        "test_case": [
            {
                "label": "Example 1",
                "input": "nums = [8,2,4,7], limit = 4",
                "output": "2 Explanation: All subarrays are: \n[8] with maximum absolute diff |8-8| = 0 <= 4.\n[8,2] with maximum absolute diff |8-2| = 6 > 4. \n[8,2,4] with maximum absolute diff |8-2| = 6 > 4.\n[8,2,4,7] with maximum absolute diff |8-2| = 6 > 4.\n[2] with maximum absolute diff |2-2| = 0 <= 4.\n[2,4] with maximum absolute diff |2-4| = 2 <= 4.\n[2,4,7] with maximum absolute diff |2-7| = 5 > 4.\n[4] with maximum absolute diff |4-4| = 0 <= 4.\n[4,7] with maximum absolute diff |4-7| = 3 <= 4.\n[7] with maximum absolute diff |7-7| = 0 <= 4. \nTherefore, the size of the longest subarray is 2."
            },
            {
                "label": "Example 2",
                "input": "nums = [10,1,2,4,7,2], limit = 5",
                "output": "4 Explanation: The subarray [2,4,7,2] is the longest since the maximum absolute diff is |2-7| = 5 <= 5."
            },
            {
                "label": "Example 3",
                "input": "nums = [4,2,2,2,4,4,2,2], limit = 0",
                "output": "3"
            }
        ],
        "elixir_template": "defmodule Solution do\n  @spec longest_subarray(nums :: [integer], limit :: integer) :: integer\n  def longest_subarray(nums, limit) do\n    \n  end\nend",
        "erlang_template": "-spec longest_subarray(Nums :: [integer()], Limit :: integer()) -> integer().\nlongest_subarray(Nums, Limit) ->\n  .",
        "scala_template": "object Solution {\n    def longestSubarray(nums: Array[Int], limit: Int): Int = {\n        \n    }\n}"
    },
    {
        "id": 1548,
        "name": "check-if-all-1s-are-at-least-length-k-places-away",
        "difficulty": "Easy",
        "link": "https://leetcode.com/problems/check-if-all-1s-are-at-least-length-k-places-away/",
        "task_description": "Given an binary array `nums` and an integer `k`, return `true`_ if all _`1`_'s are at least _`k`_ places away from each other, otherwise return _`false`. **Example 1:** ``` **Input:** nums = [1,0,0,0,1,0,0,1], k = 2 **Output:** true **Explanation:** Each of the 1s are at least 2 places away from each other. ``` **Example 2:** ``` **Input:** nums = [1,0,0,1,0,1], k = 2 **Output:** false **Explanation:** The second 1 and third 1 are only one apart from each other. ``` **Constraints:** `1 <= nums.length <= 105` `0 <= k <= nums.length` `nums[i]` is `0` or `1`",
        "test_case": [
            {
                "label": "Example 1",
                "input": "nums = [1,0,0,0,1,0,0,1], k = 2",
                "output": "true Explanation: Each of the 1s are at least 2 places away from each other."
            },
            {
                "label": "Example 2",
                "input": "nums = [1,0,0,1,0,1], k = 2",
                "output": "false Explanation: The second 1 and third 1 are only one apart from each other."
            }
        ],
        "elixir_template": "defmodule Solution do\n  @spec k_length_apart(nums :: [integer], k :: integer) :: boolean\n  def k_length_apart(nums, k) do\n    \n  end\nend",
        "erlang_template": "-spec k_length_apart(Nums :: [integer()], K :: integer()) -> boolean().\nk_length_apart(Nums, K) ->\n  .",
        "scala_template": "object Solution {\n    def kLengthApart(nums: Array[Int], k: Int): Boolean = {\n        \n    }\n}"
    },
    {
        "id": 1547,
        "name": "destination-city",
        "difficulty": "Easy",
        "link": "https://leetcode.com/problems/destination-city/",
        "task_description": "You are given the array `paths`, where `paths[i] = [cityAi, cityBi]` means there exists a direct path going from `cityAi` to `cityBi`. _Return the destination city, that is, the city without any path outgoing to another city._ It is guaranteed that the graph of paths forms a line without any loop, therefore, there will be exactly one destination city. **Example 1:** ``` **Input:** paths = [[\"London\",\"New York\"],[\"New York\",\"Lima\"],[\"Lima\",\"Sao Paulo\"]] **Output:** \"Sao Paulo\" **Explanation:** Starting at \"London\" city you will reach \"Sao Paulo\" city which is the destination city. Your trip consist of: \"London\" -> \"New York\" -> \"Lima\" -> \"Sao Paulo\". ``` **Example 2:** ``` **Input:** paths = [[\"B\",\"C\"],[\"D\",\"B\"],[\"C\",\"A\"]] **Output:** \"A\" **Explanation:** All possible trips are: \"D\" -> \"B\" -> \"C\" -> \"A\". \"B\" -> \"C\" -> \"A\". \"C\" -> \"A\". \"A\". Clearly the destination city is \"A\". ``` **Example 3:** ``` **Input:** paths = [[\"A\",\"Z\"]] **Output:** \"Z\" ``` **Constraints:** `1 <= paths.length <= 100` `paths[i].length == 2` `1 <= cityAi.length, cityBi.length <= 10` `cityAi != cityBi` All strings consist of lowercase and uppercase English letters and the space character.",
        "test_case": [
            {
                "label": "Example 1",
                "input": "paths = [[\"London\",\"New York\"],[\"New York\",\"Lima\"],[\"Lima\",\"Sao Paulo\"]]",
                "output": "\"Sao Paulo\" Explanation: Starting at \"London\" city you will reach \"Sao Paulo\" city which is the destination city. Your trip consist of: \"London\" -> \"New York\" -> \"Lima\" -> \"Sao Paulo\"."
            },
            {
                "label": "Example 2",
                "input": "paths = [[\"B\",\"C\"],[\"D\",\"B\"],[\"C\",\"A\"]]",
                "output": "\"A\" Explanation: All possible trips are:\u00a0\n\"D\" -> \"B\" -> \"C\" -> \"A\".\u00a0\n\"B\" -> \"C\" -> \"A\".\u00a0\n\"C\" -> \"A\".\u00a0\n\"A\".\u00a0\nClearly the destination city is \"A\"."
            },
            {
                "label": "Example 3",
                "input": "paths = [[\"A\",\"Z\"]]",
                "output": "\"Z\""
            }
        ],
        "elixir_template": "defmodule Solution do\n  @spec dest_city(paths :: [[String.t]]) :: String.t\n  def dest_city(paths) do\n    \n  end\nend",
        "erlang_template": "-spec dest_city(Paths :: [[unicode:unicode_binary()]]) -> unicode:unicode_binary().\ndest_city(Paths) ->\n  .",
        "scala_template": "object Solution {\n    def destCity(paths: List[List[String]]): String = {\n        \n    }\n}"
    },
    {
        "id": 1545,
        "name": "form-largest-integer-with-digits-that-add-up-to-target",
        "difficulty": "Hard",
        "link": "https://leetcode.com/problems/form-largest-integer-with-digits-that-add-up-to-target/",
        "task_description": "Given an array of integers `cost` and an integer `target`, return _the **maximum** integer you can paint under the following rules_: The cost of painting a digit `(i + 1)` is given by `cost[i]` (**0-indexed**). The total cost used must be equal to `target`. The integer does not have `0` digits. Since the answer may be very large, return it as a string. If there is no way to paint any integer given the condition, return `\"0\"`. **Example 1:** ``` **Input:** cost = [4,3,2,5,6,7,2,5,5], target = 9 **Output:** \"7772\" **Explanation:** The cost to paint the digit '7' is 2, and the digit '2' is 3. Then cost(\"7772\") = 2*3+ 3*1 = 9. You could also paint \"977\", but \"7772\" is the largest number. **Digit cost** 1 -> 4 2 -> 3 3 -> 2 4 -> 5 5 -> 6 6 -> 7 7 -> 2 8 -> 5 9 -> 5 ``` **Example 2:** ``` **Input:** cost = [7,6,5,5,5,6,8,7,8], target = 12 **Output:** \"85\" **Explanation:** The cost to paint the digit '8' is 7, and the digit '5' is 5. Then cost(\"85\") = 7 + 5 = 12. ``` **Example 3:** ``` **Input:** cost = [2,4,6,2,4,6,4,4,4], target = 5 **Output:** \"0\" **Explanation:** It is impossible to paint any integer with total cost equal to target. ``` **Constraints:** `cost.length == 9` `1 <= cost[i], target <= 5000`",
        "test_case": [
            {
                "label": "Example 1",
                "input": "cost = [4,3,2,5,6,7,2,5,5], target = 9",
                "output": "\"7772\" Explanation: The cost to paint the digit '7' is 2, and the digit '2' is 3. Then cost(\"7772\") = 2*3+ 3*1 = 9. You could also paint \"977\", but \"7772\" is the largest number. Digit    cost 1  ->   4\n  2  ->   3\n  3  ->   2\n  4  ->   5\n  5  ->   6\n  6  ->   7\n  7  ->   2\n  8  ->   5\n  9  ->   5"
            },
            {
                "label": "Example 2",
                "input": "cost = [7,6,5,5,5,6,8,7,8], target = 12",
                "output": "\"85\" Explanation: The cost to paint the digit '8' is 7, and the digit '5' is 5. Then cost(\"85\") = 7 + 5 = 12."
            },
            {
                "label": "Example 3",
                "input": "cost = [2,4,6,2,4,6,4,4,4], target = 5",
                "output": "\"0\" Explanation: It is impossible to paint any integer with total cost equal to target. Constraints: cost.length == 9 1 <= cost[i], target <= 5000"
            }
        ],
        "elixir_template": "defmodule Solution do\n  @spec largest_number(cost :: [integer], target :: integer) :: String.t\n  def largest_number(cost, target) do\n    \n  end\nend",
        "erlang_template": "-spec largest_number(Cost :: [integer()], Target :: integer()) -> unicode:unicode_binary().\nlargest_number(Cost, Target) ->\n  .",
        "scala_template": "object Solution {\n    def largestNumber(cost: Array[Int], target: Int): String = {\n        \n    }\n}"
    },
    {
        "id": 1544,
        "name": "count-good-nodes-in-binary-tree",
        "difficulty": "Medium",
        "link": "https://leetcode.com/problems/count-good-nodes-in-binary-tree/",
        "task_description": "Given a binary tree `root`, a node _X_ in the tree is named **good** if in the path from root to _X_ there are no nodes with a value _greater than_ X. Return the number of **good** nodes in the binary tree. **Example 1:** **** ``` **Input:** root = [3,1,4,3,null,1,5] **Output:** 4 **Explanation:** Nodes in blue are **good**. Root Node (3) is always a good node. Node 4 -> (3,4) is the maximum value in the path starting from the root. Node 5 -> (3,4,5) is the maximum value in the path Node 3 -> (3,1,3) is the maximum value in the path. ``` **Example 2:** **** ``` **Input:** root = [3,3,null,4,2] **Output:** 3 **Explanation:** Node 2 -> (3, 3, 2) is not good, because \"3\" is higher than it. ``` **Example 3:** ``` **Input:** root = [1] **Output:** 1 **Explanation:** Root is considered as **good**. ``` **Constraints:** The number of nodes in the binary tree is in the range `[1, 10^5]`. Each node's value is between `[-10^4, 10^4]`.",
        "test_case": [
            {
                "label": "Example 1",
                "input": "root = [3,1,4,3,null,1,5]",
                "output": "4 Explanation: Nodes in blue are good .\r\nRoot Node (3) is always a good node.\r\nNode 4 -> (3,4) is the maximum value in the path starting from the root.\r\nNode 5 -> (3,4,5) is the maximum value in the path\r\nNode 3 -> (3,1,3) is the maximum value in the path."
            },
            {
                "label": "Example 2",
                "input": "root = [3,3,null,4,2]",
                "output": "3 Explanation: Node 2 -> (3, 3, 2) is not good, because \"3\" is higher than it."
            },
            {
                "label": "Example 3",
                "input": "root = [1]",
                "output": "1 Explanation: Root is considered as good . Constraints: The number of nodes in the binary tree is in the range [1, 10^5] . Each node's value is between [-10^4, 10^4] ."
            }
        ],
        "elixir_template": "Elixir code template not available for this problem.",
        "erlang_template": "Elixir code template not available for this problem.",
        "scala_template": "/**\n * Definition for a binary tree node.\n * class TreeNode(_value: Int = 0, _left: TreeNode = null, _right: TreeNode = null) {\n *   var value: Int = _value\n *   var left: TreeNode = _left\n *   var right: TreeNode = _right\n * }\n */\nobject Solution {\n    def goodNodes(root: TreeNode): Int = {\n        \n    }\n}"
    },
    {
        "id": 1543,
        "name": "simplified-fractions",
        "difficulty": "Medium",
        "link": "https://leetcode.com/problems/simplified-fractions/",
        "task_description": "Given an integer `n`, return _a list of all **simplified** fractions between _`0`_ and _`1`_ (exclusive) such that the denominator is less-than-or-equal-to _`n`. You can return the answer in **any order**. **Example 1:** ``` **Input:** n = 2 **Output:** [\"1/2\"] **Explanation:** \"1/2\" is the only unique fraction with a denominator less-than-or-equal-to 2. ``` **Example 2:** ``` **Input:** n = 3 **Output:** [\"1/2\",\"1/3\",\"2/3\"] ``` **Example 3:** ``` **Input:** n = 4 **Output:** [\"1/2\",\"1/3\",\"1/4\",\"2/3\",\"3/4\"] **Explanation:** \"2/4\" is not a simplified fraction because it can be simplified to \"1/2\". ``` **Constraints:** `1 <= n <= 100`",
        "test_case": [
            {
                "label": "Example 1",
                "input": "n = 2",
                "output": "[\"1/2\"] Explanation: \"1/2\" is the only unique fraction with a denominator less-than-or-equal-to 2."
            },
            {
                "label": "Example 2",
                "input": "n = 3",
                "output": "[\"1/2\",\"1/3\",\"2/3\"]"
            },
            {
                "label": "Example 3",
                "input": "n = 4",
                "output": "[\"1/2\",\"1/3\",\"1/4\",\"2/3\",\"3/4\"] Explanation: \"2/4\" is not a simplified fraction because it can be simplified to \"1/2\"."
            }
        ],
        "elixir_template": "defmodule Solution do\n  @spec simplified_fractions(n :: integer) :: [String.t]\n  def simplified_fractions(n) do\n    \n  end\nend",
        "erlang_template": "-spec simplified_fractions(N :: integer()) -> [unicode:unicode_binary()].\nsimplified_fractions(N) ->\n  .",
        "scala_template": "object Solution {\n    def simplifiedFractions(n: Int): List[String] = {\n        \n    }\n}"
    },
    {
        "id": 1542,
        "name": "consecutive-characters",
        "difficulty": "Easy",
        "link": "https://leetcode.com/problems/consecutive-characters/",
        "task_description": "The **power** of the string is the maximum length of a non-empty substring that contains only one unique character. Given a string `s`, return _the **power** of_ `s`. **Example 1:** ``` **Input:** s = \"leetcode\" **Output:** 2 **Explanation:** The substring \"ee\" is of length 2 with the character 'e' only. ``` **Example 2:** ``` **Input:** s = \"abbcccddddeeeeedcba\" **Output:** 5 **Explanation:** The substring \"eeeee\" is of length 5 with the character 'e' only. ``` **Constraints:** `1 <= s.length <= 500` `s` consists of only lowercase English letters.",
        "test_case": [
            {
                "label": "Example 1",
                "input": "s = \"leetcode\"",
                "output": "2 Explanation: The substring \"ee\" is of length 2 with the character 'e' only."
            },
            {
                "label": "Example 2",
                "input": "s = \"abbcccddddeeeeedcba\"",
                "output": "5 Explanation: The substring \"eeeee\" is of length 5 with the character 'e' only."
            }
        ],
        "elixir_template": "defmodule Solution do\n  @spec max_power(s :: String.t) :: integer\n  def max_power(s) do\n    \n  end\nend",
        "erlang_template": "-spec max_power(S :: unicode:unicode_binary()) -> integer().\nmax_power(S) ->\n  .",
        "scala_template": "object Solution {\n    def maxPower(s: String): Int = {\n        \n    }\n}"
    },
    {
        "id": 1539,
        "name": "diagonal-traverse-ii",
        "difficulty": "Medium",
        "link": "https://leetcode.com/problems/diagonal-traverse-ii/",
        "task_description": "Given a 2D integer array `nums`, return _all elements of _`nums`_ in diagonal order as shown in the below images_. **Example 1:** ``` **Input:** nums = [[1,2,3],[4,5,6],[7,8,9]] **Output:** [1,4,2,7,5,3,8,6,9] ``` **Example 2:** ``` **Input:** nums = [[1,2,3,4,5],[6,7],[8],[9,10,11],[12,13,14,15,16]] **Output:** [1,6,2,8,7,3,9,4,12,10,5,13,11,14,15,16] ``` **Constraints:** `1 <= nums.length <= 105` `1 <= nums[i].length <= 105` `1 <= sum(nums[i].length) <= 105` `1 <= nums[i][j] <= 105`",
        "test_case": [
            {
                "label": "Example 1",
                "input": "nums = [[1,2,3],[4,5,6],[7,8,9]]",
                "output": "[1,4,2,7,5,3,8,6,9]"
            },
            {
                "label": "Example 2",
                "input": "nums = [[1,2,3,4,5],[6,7],[8],[9,10,11],[12,13,14,15,16]]",
                "output": "[1,6,2,8,7,3,9,4,12,10,5,13,11,14,15,16]"
            }
        ],
        "elixir_template": "defmodule Solution do\n  @spec find_diagonal_order(nums :: [[integer]]) :: [integer]\n  def find_diagonal_order(nums) do\n    \n  end\nend",
        "erlang_template": "-spec find_diagonal_order(Nums :: [[integer()]]) -> [integer()].\nfind_diagonal_order(Nums) ->\n  .",
        "scala_template": "object Solution {\n    def findDiagonalOrder(nums: List[List[Int]]): Array[Int] = {\n        \n    }\n}"
    },
    {
        "id": 1538,
        "name": "maximum-points-you-can-obtain-from-cards",
        "difficulty": "Medium",
        "link": "https://leetcode.com/problems/maximum-points-you-can-obtain-from-cards/",
        "task_description": "There are several cards **arranged in a row**, and each card has an associated number of points. The points are given in the integer array `cardPoints`. In one step, you can take one card from the beginning or from the end of the row. You have to take exactly `k` cards. Your score is the sum of the points of the cards you have taken. Given the integer array `cardPoints` and the integer `k`, return the _maximum score_ you can obtain. **Example 1:** ``` **Input:** cardPoints = [1,2,3,4,5,6,1], k = 3 **Output:** 12 **Explanation:** After the first step, your score will always be 1. However, choosing the rightmost card first will maximize your total score. The optimal strategy is to take the three cards on the right, giving a final score of 1 + 6 + 5 = 12. ``` **Example 2:** ``` **Input:** cardPoints = [2,2,2], k = 2 **Output:** 4 **Explanation:** Regardless of which two cards you take, your score will always be 4. ``` **Example 3:** ``` **Input:** cardPoints = [9,7,7,9,7,7,9], k = 7 **Output:** 55 **Explanation:** You have to take all the cards. Your score is the sum of points of all cards. ``` **Constraints:** `1 <= cardPoints.length <= 105` `1 <= cardPoints[i] <= 104` `1 <= k <= cardPoints.length`",
        "test_case": [
            {
                "label": "Example 1",
                "input": "cardPoints = [1,2,3,4,5,6,1], k = 3",
                "output": "12 Explanation: After the first step, your score will always be 1. However, choosing the rightmost card first will maximize your total score. The optimal strategy is to take the three cards on the right, giving a final score of 1 + 6 + 5 = 12."
            },
            {
                "label": "Example 2",
                "input": "cardPoints = [2,2,2], k = 2",
                "output": "4 Explanation: Regardless of which two cards you take, your score will always be 4."
            },
            {
                "label": "Example 3",
                "input": "cardPoints = [9,7,7,9,7,7,9], k = 7",
                "output": "55 Explanation: You have to take all the cards. Your score is the sum of points of all cards."
            }
        ],
        "elixir_template": "defmodule Solution do\n  @spec max_score(card_points :: [integer], k :: integer) :: integer\n  def max_score(card_points, k) do\n    \n  end\nend",
        "erlang_template": "-spec max_score(CardPoints :: [integer()], K :: integer()) -> integer().\nmax_score(CardPoints, K) ->\n  .",
        "scala_template": "object Solution {\n    def maxScore(cardPoints: Array[Int], k: Int): Int = {\n        \n    }\n}"
    },
    {
        "id": 1537,
        "name": "maximum-score-after-splitting-a-string",
        "difficulty": "Easy",
        "link": "https://leetcode.com/problems/maximum-score-after-splitting-a-string/",
        "task_description": "Given a string `s` of zeros and ones, _return the maximum score after splitting the string into two **non-empty** substrings_ (i.e. **left** substring and **right** substring). The score after splitting a string is the number of **zeros** in the **left** substring plus the number of **ones** in the **right** substring. **Example 1:** ``` **Input:** s = \"011101\" **Output:** 5 **Explanation:** All possible ways of splitting s into two non-empty substrings are: left = \"0\" and right = \"11101\", score = 1 + 4 = 5 left = \"01\" and right = \"1101\", score = 1 + 3 = 4 left = \"011\" and right = \"101\", score = 1 + 2 = 3 left = \"0111\" and right = \"01\", score = 1 + 1 = 2 left = \"01110\" and right = \"1\", score = 2 + 1 = 3 ``` **Example 2:** ``` **Input:** s = \"00111\" **Output:** 5 **Explanation:** When left = \"00\" and right = \"111\", we get the maximum score = 2 + 3 = 5 ``` **Example 3:** ``` **Input:** s = \"1111\" **Output:** 3 ``` **Constraints:** `2 <= s.length <= 500` The string `s` consists of characters `'0'` and `'1'` only.",
        "test_case": [
            {
                "label": "Example 1",
                "input": "s = \"011101\"",
                "output": "5 Explanation: All possible ways of splitting s into two non-empty substrings are:\nleft = \"0\" and right = \"11101\", score = 1 + 4 = 5 \nleft = \"01\" and right = \"1101\", score = 1 + 3 = 4 \nleft = \"011\" and right = \"101\", score = 1 + 2 = 3 \nleft = \"0111\" and right = \"01\", score = 1 + 1 = 2 \nleft = \"01110\" and right = \"1\", score = 2 + 1 = 3"
            },
            {
                "label": "Example 2",
                "input": "s = \"00111\"",
                "output": "5 Explanation: When left = \"00\" and right = \"111\", we get the maximum score = 2 + 3 = 5"
            },
            {
                "label": "Example 3",
                "input": "s = \"1111\"",
                "output": "3"
            }
        ],
        "elixir_template": "defmodule Solution do\n  @spec max_score(s :: String.t) :: integer\n  def max_score(s) do\n    \n  end\nend",
        "erlang_template": "-spec max_score(S :: unicode:unicode_binary()) -> integer().\nmax_score(S) ->\n  .",
        "scala_template": "object Solution {\n    def maxScore(s: String): Int = {\n        \n    }\n}"
    },
    {
        "id": 1535,
        "name": "build-array-where-you-can-find-the-maximum-exactly-k-comparisons",
        "difficulty": "Hard",
        "link": "https://leetcode.com/problems/build-array-where-you-can-find-the-maximum-exactly-k-comparisons/",
        "task_description": "You are given three integers `n`, `m` and `k`. Consider the following algorithm to find the maximum element of an array of positive integers: You should build the array arr which has the following properties: `arr` has exactly `n` integers. `1 <= arr[i] <= m` where `(0 <= i < n)`. After applying the mentioned algorithm to `arr`, the value `search_cost` is equal to `k`. Return _the number of ways_ to build the array `arr` under the mentioned conditions. As the answer may grow large, the answer **must be** computed modulo `109 + 7`. **Example 1:** ``` **Input:** n = 2, m = 3, k = 1 **Output:** 6 **Explanation:** The possible arrays are [1, 1], [2, 1], [2, 2], [3, 1], [3, 2] [3, 3] ``` **Example 2:** ``` **Input:** n = 5, m = 2, k = 3 **Output:** 0 **Explanation:** There are no possible arrays that satisfy the mentioned conditions. ``` **Example 3:** ``` **Input:** n = 9, m = 1, k = 1 **Output:** 1 **Explanation:** The only possible array is [1, 1, 1, 1, 1, 1, 1, 1, 1] ``` **Constraints:** `1 <= n <= 50` `1 <= m <= 100` `0 <= k <= n`",
        "test_case": [
            {
                "label": "Example 1",
                "input": "n = 2, m = 3, k = 1",
                "output": "6 Explanation: The possible arrays are [1, 1], [2, 1], [2, 2], [3, 1], [3, 2] [3, 3]"
            },
            {
                "label": "Example 2",
                "input": "n = 5, m = 2, k = 3",
                "output": "0 Explanation: There are no possible arrays that satisfy the mentioned conditions."
            },
            {
                "label": "Example 3",
                "input": "n = 9, m = 1, k = 1",
                "output": "1 Explanation: The only possible array is [1, 1, 1, 1, 1, 1, 1, 1, 1]"
            }
        ],
        "elixir_template": "defmodule Solution do\n  @spec num_of_arrays(n :: integer, m :: integer, k :: integer) :: integer\n  def num_of_arrays(n, m, k) do\n    \n  end\nend",
        "erlang_template": "-spec num_of_arrays(N :: integer(), M :: integer(), K :: integer()) -> integer().\nnum_of_arrays(N, M, K) ->\n  .",
        "scala_template": "object Solution {\n    def numOfArrays(n: Int, m: Int, k: Int): Int = {\n        \n    }\n}"
    },
    {
        "id": 1534,
        "name": "minimum-number-of-frogs-croaking",
        "difficulty": "Medium",
        "link": "https://leetcode.com/problems/minimum-number-of-frogs-croaking/",
        "task_description": "You are given the string `croakOfFrogs`, which represents a combination of the string `\"croak\"` from different frogs, that is, multiple frogs can croak at the same time, so multiple `\"croak\"` are mixed. _Return the minimum number of _different_ frogs to finish all the croaks in the given string._ A valid `\"croak\"` means a frog is printing five letters `'c'`, `'r'`, `'o'`, `'a'`, and `'k'` **sequentially**. The frogs have to print all five letters to finish a croak. If the given string is not a combination of a valid `\"croak\"` return `-1`. **Example 1:** ``` **Input:** croakOfFrogs = \"croakcroak\" **Output:** 1 **Explanation:** One frog yelling \"croak**\"** twice. ``` **Example 2:** ``` **Input:** croakOfFrogs = \"crcoakroak\" **Output:** 2 **Explanation:** The minimum number of frogs is two. The first frog could yell \"**cr**c**oak**roak\". The second frog could yell later \"cr**c**oak**roak**\". ``` **Example 3:** ``` **Input:** croakOfFrogs = \"croakcrook\" **Output:** -1 **Explanation:** The given string is an invalid combination of \"croak**\"** from different frogs. ``` **Constraints:** `1 <= croakOfFrogs.length <= 105` `croakOfFrogs` is either `'c'`, `'r'`, `'o'`, `'a'`, or `'k'`.",
        "test_case": [
            {
                "label": "Example 1",
                "input": "croakOfFrogs = \"croakcroak\"",
                "output": "1 Explanation: One frog yelling \"croak \" twice."
            },
            {
                "label": "Example 2",
                "input": "croakOfFrogs = \"crcoakroak\"",
                "output": "2 Explanation: The minimum number of frogs is two. \nThe first frog could yell \" cr c oak roak\".\nThe second frog could yell later \"cr c oak roak \"."
            },
            {
                "label": "Example 3",
                "input": "croakOfFrogs = \"croakcrook\"",
                "output": "-1 Explanation: The given string is an invalid combination of \"croak \" from different frogs."
            }
        ],
        "elixir_template": "defmodule Solution do\n  @spec min_number_of_frogs(croak_of_frogs :: String.t) :: integer\n  def min_number_of_frogs(croak_of_frogs) do\n    \n  end\nend",
        "erlang_template": "-spec min_number_of_frogs(CroakOfFrogs :: unicode:unicode_binary()) -> integer().\nmin_number_of_frogs(CroakOfFrogs) ->\n  .",
        "scala_template": "object Solution {\n    def minNumberOfFrogs(croakOfFrogs: String): Int = {\n        \n    }\n}"
    },
    {
        "id": 1533,
        "name": "display-table-of-food-orders-in-a-restaurant",
        "difficulty": "Medium",
        "link": "https://leetcode.com/problems/display-table-of-food-orders-in-a-restaurant/",
        "task_description": "Given the array `orders`, which represents the orders that customers have done in a restaurant. More specifically `orders[i]=[customerNamei,tableNumberi,foodItemi]` where `customerNamei` is the name of the customer, `tableNumberi` is the table customer sit at, and `foodItemi` is the item customer orders. _Return the restaurant's \u201c**display table**\u201d_. The \u201c**display table**\u201d is a table whose row entries denote how many of each food item each table ordered. The first column is the table number and the remaining columns correspond to each food item in alphabetical order. The first row should be a header whose first column is \u201cTable\u201d, followed by the names of the food items. Note that the customer names are not part of the table. Additionally, the rows should be sorted in numerically increasing order. **Example 1:** ``` **Input:** orders = [[\"David\",\"3\",\"Ceviche\"],[\"Corina\",\"10\",\"Beef Burrito\"],[\"David\",\"3\",\"Fried Chicken\"],[\"Carla\",\"5\",\"Water\"],[\"Carla\",\"5\",\"Ceviche\"],[\"Rous\",\"3\",\"Ceviche\"]] **Output:** [[\"Table\",\"Beef Burrito\",\"Ceviche\",\"Fried Chicken\",\"Water\"],[\"3\",\"0\",\"2\",\"1\",\"0\"],[\"5\",\"0\",\"1\",\"0\",\"1\"],[\"10\",\"1\",\"0\",\"0\",\"0\"]] **Explanation: **The displaying table looks like: **Table,Beef Burrito,Ceviche,Fried Chicken,Water** 3 ,0 ,2 ,1 ,0 5 ,0 ,1 ,0 ,1 10 ,1 ,0 ,0 ,0 For the table 3: David orders \"Ceviche\" and \"Fried Chicken\", and Rous orders \"Ceviche\". For the table 5: Carla orders \"Water\" and \"Ceviche\". For the table 10: Corina orders \"Beef Burrito\". ``` **Example 2:** ``` **Input:** orders = [[\"James\",\"12\",\"Fried Chicken\"],[\"Ratesh\",\"12\",\"Fried Chicken\"],[\"Amadeus\",\"12\",\"Fried Chicken\"],[\"Adam\",\"1\",\"Canadian Waffles\"],[\"Brianna\",\"1\",\"Canadian Waffles\"]] **Output:** [[\"Table\",\"Canadian Waffles\",\"Fried Chicken\"],[\"1\",\"2\",\"0\"],[\"12\",\"0\",\"3\"]] **Explanation:** For the table 1: Adam and Brianna order \"Canadian Waffles\". For the table 12: James, Ratesh and Amadeus order \"Fried Chicken\". ``` **Example 3:** ``` **Input:** orders = [[\"Laura\",\"2\",\"Bean Burrito\"],[\"Jhon\",\"2\",\"Beef Burrito\"],[\"Melissa\",\"2\",\"Soda\"]] **Output:** [[\"Table\",\"Bean Burrito\",\"Beef Burrito\",\"Soda\"],[\"2\",\"1\",\"1\",\"1\"]] ``` **Constraints:** `1 <= orders.length <= 5 * 10^4` `orders[i].length == 3` `1 <= customerNamei.length, foodItemi.length <= 20` `customerNamei` and `foodItemi` consist of lowercase and uppercase English letters and the space character. `tableNumberi `is a valid integer between `1` and `500`.",
        "test_case": [
            {
                "label": "Example 1",
                "input": "orders = [[\"David\",\"3\",\"Ceviche\"],[\"Corina\",\"10\",\"Beef Burrito\"],[\"David\",\"3\",\"Fried Chicken\"],[\"Carla\",\"5\",\"Water\"],[\"Carla\",\"5\",\"Ceviche\"],[\"Rous\",\"3\",\"Ceviche\"]]",
                "output": "[[\"Table\",\"Beef Burrito\",\"Ceviche\",\"Fried Chicken\",\"Water\"],[\"3\",\"0\",\"2\",\"1\",\"0\"],[\"5\",\"0\",\"1\",\"0\",\"1\"],[\"10\",\"1\",\"0\",\"0\",\"0\"]] Explanation: The displaying table looks like: Table,Beef Burrito,Ceviche,Fried Chicken,Water 3    ,0           ,2      ,1            ,0\r\n5    ,0           ,1      ,0            ,1\r\n10   ,1           ,0      ,0            ,0\r\nFor the table 3: David orders \"Ceviche\" and \"Fried Chicken\", and Rous orders \"Ceviche\".\r\nFor the table 5: Carla orders \"Water\" and \"Ceviche\".\r\nFor the table 10: Corina orders \"Beef Burrito\"."
            },
            {
                "label": "Example 2",
                "input": "orders = [[\"James\",\"12\",\"Fried Chicken\"],[\"Ratesh\",\"12\",\"Fried Chicken\"],[\"Amadeus\",\"12\",\"Fried Chicken\"],[\"Adam\",\"1\",\"Canadian Waffles\"],[\"Brianna\",\"1\",\"Canadian Waffles\"]]",
                "output": "[[\"Table\",\"Canadian Waffles\",\"Fried Chicken\"],[\"1\",\"2\",\"0\"],[\"12\",\"0\",\"3\"]] Explanation: For the table 1: Adam and Brianna order \"Canadian Waffles\".\r\nFor the table 12: James, Ratesh and Amadeus order \"Fried Chicken\"."
            },
            {
                "label": "Example 3",
                "input": "orders = [[\"Laura\",\"2\",\"Bean Burrito\"],[\"Jhon\",\"2\",\"Beef Burrito\"],[\"Melissa\",\"2\",\"Soda\"]]",
                "output": "[[\"Table\",\"Bean Burrito\",\"Beef Burrito\",\"Soda\"],[\"2\",\"1\",\"1\",\"1\"]]"
            }
        ],
        "elixir_template": "Elixir code template not available for this problem.",
        "erlang_template": "Elixir code template not available for this problem.",
        "scala_template": "object Solution {\r\n    def displayTable(orders: List[List[String]]): List[List[String]] = {\r\n        \r\n    }\r\n}"
    },
    {
        "id": 1532,
        "name": "reformat-the-string",
        "difficulty": "Easy",
        "link": "https://leetcode.com/problems/reformat-the-string/",
        "task_description": "You are given an alphanumeric string `s`. (**Alphanumeric string** is a string consisting of lowercase English letters and digits). You have to find a permutation of the string where no letter is followed by another letter and no digit is followed by another digit. That is, no two adjacent characters have the same type. Return _the reformatted string_ or return **an empty string** if it is impossible to reformat the string. **Example 1:** ``` **Input:** s = \"a0b1c2\" **Output:** \"0a1b2c\" **Explanation:** No two adjacent characters have the same type in \"0a1b2c\". \"a0b1c2\", \"0a1b2c\", \"0c2a1b\" are also valid permutations. ``` **Example 2:** ``` **Input:** s = \"leetcode\" **Output:** \"\" **Explanation:** \"leetcode\" has only characters so we cannot separate them by digits. ``` **Example 3:** ``` **Input:** s = \"1229857369\" **Output:** \"\" **Explanation:** \"1229857369\" has only digits so we cannot separate them by characters. ``` **Constraints:** `1 <= s.length <= 500` `s` consists of only lowercase English letters and/or digits.",
        "test_case": [
            {
                "label": "Example 1",
                "input": "s = \"a0b1c2\"",
                "output": "\"0a1b2c\" Explanation: No two adjacent characters have the same type in \"0a1b2c\". \"a0b1c2\", \"0a1b2c\", \"0c2a1b\" are also valid permutations."
            },
            {
                "label": "Example 2",
                "input": "s = \"leetcode\"",
                "output": "\"\" Explanation: \"leetcode\" has only characters so we cannot separate them by digits."
            },
            {
                "label": "Example 3",
                "input": "s = \"1229857369\"",
                "output": "\"\" Explanation: \"1229857369\" has only digits so we cannot separate them by characters."
            }
        ],
        "elixir_template": "defmodule Solution do\n  @spec reformat(s :: String.t) :: String.t\n  def reformat(s) do\n    \n  end\nend",
        "erlang_template": "-spec reformat(S :: unicode:unicode_binary()) -> unicode:unicode_binary().\nreformat(S) ->\n  .",
        "scala_template": "object Solution {\n    def reformat(s: String): String = {\n        \n    }\n}"
    },
    {
        "id": 1531,
        "name": "number-of-ways-to-wear-different-hats-to-each-other",
        "difficulty": "Hard",
        "link": "https://leetcode.com/problems/number-of-ways-to-wear-different-hats-to-each-other/",
        "task_description": "There are `n` people and `40` types of hats labeled from `1` to `40`. Given a 2D integer array `hats`, where `hats[i]` is a list of all hats preferred by the `ith` person. Return _the number of ways that the `n` people wear different hats to each other_. Since the answer may be too large, return it modulo `109 + 7`. **Example 1:** ``` **Input:** hats = [[3,4],[4,5],[5]] **Output:** 1 **Explanation:** There is only one way to choose hats given the conditions. First person choose hat 3, Second person choose hat 4 and last one hat 5. ``` **Example 2:** ``` **Input:** hats = [[3,5,1],[3,5]] **Output:** 4 **Explanation:** There are 4 ways to choose hats: (3,5), (5,3), (1,3) and (1,5) ``` **Example 3:** ``` **Input:** hats = [[1,2,3,4],[1,2,3,4],[1,2,3,4],[1,2,3,4]] **Output:** 24 **Explanation:** Each person can choose hats labeled from 1 to 4. Number of Permutations of (1,2,3,4) = 24. ``` **Constraints:** `n == hats.length` `1 <= n <= 10` `1 <= hats[i].length <= 40` `1 <= hats[i][j] <= 40` `hats[i]` contains a list of **unique** integers.",
        "test_case": [
            {
                "label": "Example 1",
                "input": "hats = [[3,4],[4,5],[5]]",
                "output": "1 Explanation: There is only one way to choose hats given the conditions. \nFirst person choose hat 3, Second person choose hat 4 and last one hat 5."
            },
            {
                "label": "Example 2",
                "input": "hats = [[3,5,1],[3,5]]",
                "output": "4 Explanation: There are 4 ways to choose hats:\n(3,5), (5,3), (1,3) and (1,5)"
            },
            {
                "label": "Example 3",
                "input": "hats = [[1,2,3,4],[1,2,3,4],[1,2,3,4],[1,2,3,4]]",
                "output": "24 Explanation: Each person can choose hats labeled from 1 to 4.\nNumber of Permutations of (1,2,3,4) = 24. Constraints: n == hats.length 1 <= n <= 10 1 <= hats[i].length <= 40 1 <= hats[i][j] <= 40 hats[i] contains a list of unique integers."
            }
        ],
        "elixir_template": "defmodule Solution do\n  @spec number_ways(hats :: [[integer]]) :: integer\n  def number_ways(hats) do\n    \n  end\nend",
        "erlang_template": "-spec number_ways(Hats :: [[integer()]]) -> integer().\nnumber_ways(Hats) ->\n  .",
        "scala_template": "object Solution {\n    def numberWays(hats: List[List[Int]]): Int = {\n        \n    }\n}"
    },
    {
        "id": 1530,
        "name": "check-if-a-string-can-break-another-string",
        "difficulty": "Medium",
        "link": "https://leetcode.com/problems/check-if-a-string-can-break-another-string/",
        "task_description": "Given two strings: `s1` and `s2` with the same size, check if some permutation of string `s1` can break some permutation of string `s2` or vice-versa. In other words `s2` can break `s1` or vice-versa. A string `x` can break string `y` (both of size `n`) if `x[i] >= y[i]` (in alphabetical order) for all `i` between `0` and `n-1`. **Example 1:** ``` **Input:** s1 = \"abc\", s2 = \"xya\" **Output:** true **Explanation:** \"ayx\" is a permutation of s2=\"xya\" which can break to string \"abc\" which is a permutation of s1=\"abc\". ``` **Example 2:** ``` **Input:** s1 = \"abe\", s2 = \"acd\" **Output:** false **Explanation:** All permutations for s1=\"abe\" are: \"abe\", \"aeb\", \"bae\", \"bea\", \"eab\" and \"eba\" and all permutation for s2=\"acd\" are: \"acd\", \"adc\", \"cad\", \"cda\", \"dac\" and \"dca\". However, there is not any permutation from s1 which can break some permutation from s2 and vice-versa. ``` **Example 3:** ``` **Input:** s1 = \"leetcodee\", s2 = \"interview\" **Output:** true ``` **Constraints:** `s1.length == n` `s2.length == n` `1 <= n <= 10^5` All strings consist of lowercase English letters.",
        "test_case": [
            {
                "label": "Example 1",
                "input": "s1 = \"abc\", s2 = \"xya\"",
                "output": "true Explanation: \"ayx\" is a permutation of s2=\"xya\" which can break to string \"abc\" which is a permutation of s1=\"abc\"."
            },
            {
                "label": "Example 2",
                "input": "s1 = \"abe\", s2 = \"acd\"",
                "output": "false Explanation: All permutations for s1=\"abe\" are: \"abe\", \"aeb\", \"bae\", \"bea\", \"eab\" and \"eba\" and all permutation for s2=\"acd\" are: \"acd\", \"adc\", \"cad\", \"cda\", \"dac\" and \"dca\". However, there is not any permutation from s1 which can break some permutation from s2 and vice-versa."
            },
            {
                "label": "Example 3",
                "input": "s1 = \"leetcodee\", s2 = \"interview\"",
                "output": "true Constraints: s1.length == n s2.length == n 1 <= n <= 10^5 All strings consist of lowercase English letters."
            }
        ],
        "elixir_template": "defmodule Solution do\n  @spec check_if_can_break(s1 :: String.t, s2 :: String.t) :: boolean\n  def check_if_can_break(s1, s2) do\n    \n  end\nend",
        "erlang_template": "-spec check_if_can_break(S1 :: unicode:unicode_binary(), S2 :: unicode:unicode_binary()) -> boolean().\ncheck_if_can_break(S1, S2) ->\n  .",
        "scala_template": "object Solution {\n    def checkIfCanBreak(s1: String, s2: String): Boolean = {\n        \n    }\n}"
    },
    {
        "id": 1529,
        "name": "max-difference-you-can-get-from-changing-an-integer",
        "difficulty": "Medium",
        "link": "https://leetcode.com/problems/max-difference-you-can-get-from-changing-an-integer/",
        "task_description": "You are given an integer `num`. You will apply the following steps exactly **two** times: Pick a digit `x (0 <= x <= 9)`. Pick another digit `y (0 <= y <= 9)`. The digit `y` can be equal to `x`. Replace all the occurrences of `x` in the decimal representation of `num` by `y`. The new integer **cannot** have any leading zeros, also the new integer **cannot** be 0. Let `a` and `b` be the results of applying the operations to `num` the first and second times, respectively. Return _the max difference_ between `a` and `b`. **Example 1:** ``` **Input:** num = 555 **Output:** 888 **Explanation:** The first time pick x = 5 and y = 9 and store the new integer in a. The second time pick x = 5 and y = 1 and store the new integer in b. We have now a = 999 and b = 111 and max difference = 888 ``` **Example 2:** ``` **Input:** num = 9 **Output:** 8 **Explanation:** The first time pick x = 9 and y = 9 and store the new integer in a. The second time pick x = 9 and y = 1 and store the new integer in b. We have now a = 9 and b = 1 and max difference = 8 ``` **Constraints:** `1 <= num <= 108`",
        "test_case": [
            {
                "label": "Example 1",
                "input": "num = 555",
                "output": "888 Explanation: The first time pick x = 5 and y = 9 and store the new integer in a.\nThe second time pick x = 5 and y = 1 and store the new integer in b.\nWe have now a = 999 and b = 111 and max difference = 888"
            },
            {
                "label": "Example 2",
                "input": "num = 9",
                "output": "8 Explanation: The first time pick x = 9 and y = 9 and store the new integer in a.\nThe second time pick x = 9 and y = 1 and store the new integer in b.\nWe have now a = 9 and b = 1 and max difference = 8"
            }
        ],
        "elixir_template": "defmodule Solution do\n  @spec max_diff(num :: integer) :: integer\n  def max_diff(num) do\n    \n  end\nend",
        "erlang_template": "-spec max_diff(Num :: integer()) -> integer().\nmax_diff(Num) ->\n  .",
        "scala_template": "object Solution {\n    def maxDiff(num: Int): Int = {\n        \n    }\n}"
    },
    {
        "id": 1528,
        "name": "kids-with-the-greatest-number-of-candies",
        "difficulty": "Easy",
        "link": "https://leetcode.com/problems/kids-with-the-greatest-number-of-candies/",
        "task_description": "There are `n` kids with candies. You are given an integer array `candies`, where each `candies[i]` represents the number of candies the `ith` kid has, and an integer `extraCandies`, denoting the number of extra candies that you have. Return _a boolean array _`result`_ of length _`n`_, where _`result[i]`_ is _`true`_ if, after giving the _`ith`_ kid all the _`extraCandies`_, they will have the **greatest** number of candies among all the kids__, or _`false`_ otherwise_. Note that **multiple** kids can have the **greatest** number of candies. **Example 1:** ``` **Input:** candies = [2,3,5,1,3], extraCandies = 3 **Output:** [true,true,true,false,true] **Explanation:** If you give all extraCandies to: - Kid 1, they will have 2 + 3 = 5 candies, which is the greatest among the kids. - Kid 2, they will have 3 + 3 = 6 candies, which is the greatest among the kids. - Kid 3, they will have 5 + 3 = 8 candies, which is the greatest among the kids. - Kid 4, they will have 1 + 3 = 4 candies, which is not the greatest among the kids. - Kid 5, they will have 3 + 3 = 6 candies, which is the greatest among the kids. ``` **Example 2:** ``` **Input:** candies = [4,2,1,1,2], extraCandies = 1 **Output:** [true,false,false,false,false] **Explanation:** There is only 1 extra candy. Kid 1 will always have the greatest number of candies, even if a different kid is given the extra candy. ``` **Example 3:** ``` **Input:** candies = [12,1,12], extraCandies = 10 **Output:** [true,false,true] ``` **Constraints:** `n == candies.length` `2 <= n <= 100` `1 <= candies[i] <= 100` `1 <= extraCandies <= 50`",
        "test_case": [
            {
                "label": "Example 1",
                "input": "candies = [2,3,5,1,3], extraCandies = 3",
                "output": "[true,true,true,false,true] Explanation: If you give all extraCandies to:\n- Kid 1, they will have 2 + 3 = 5 candies, which is the greatest among the kids.\n- Kid 2, they will have 3 + 3 = 6 candies, which is the greatest among the kids.\n- Kid 3, they will have 5 + 3 = 8 candies, which is the greatest among the kids.\n- Kid 4, they will have 1 + 3 = 4 candies, which is not the greatest among the kids.\n- Kid 5, they will have 3 + 3 = 6 candies, which is the greatest among the kids."
            },
            {
                "label": "Example 2",
                "input": "candies = [4,2,1,1,2], extraCandies = 1",
                "output": "[true,false,false,false,false] Explanation: There is only 1 extra candy.\nKid 1 will always have the greatest number of candies, even if a different kid is given the extra candy."
            },
            {
                "label": "Example 3",
                "input": "candies = [12,1,12], extraCandies = 10",
                "output": "[true,false,true] Constraints: n == candies.length 2 <= n <= 100 1 <= candies[i] <= 100 1 <= extraCandies <= 50"
            }
        ],
        "elixir_template": "defmodule Solution do\n  @spec kids_with_candies(candies :: [integer], extra_candies :: integer) :: [boolean]\n  def kids_with_candies(candies, extra_candies) do\n    \n  end\nend",
        "erlang_template": "-spec kids_with_candies(Candies :: [integer()], ExtraCandies :: integer()) -> [boolean()].\nkids_with_candies(Candies, ExtraCandies) ->\n  .",
        "scala_template": "object Solution {\n    def kidsWithCandies(candies: Array[Int], extraCandies: Int): List[Boolean] = {\n        \n    }\n}"
    },
    {
        "id": 1527,
        "name": "number-of-ways-to-paint-n-3-grid",
        "difficulty": "Hard",
        "link": "https://leetcode.com/problems/number-of-ways-to-paint-n-3-grid/",
        "task_description": "You have a `grid` of size `n x 3` and you want to paint each cell of the grid with exactly one of the three colors: **Red**, **Yellow,** or **Green** while making sure that no two adjacent cells have the same color (i.e., no two cells that share vertical or horizontal sides have the same color). Given `n` the number of rows of the grid, return _the number of ways_ you can paint this `grid`. As the answer may grow large, the answer **must be** computed modulo `109 + 7`. **Example 1:** ``` **Input:** n = 1 **Output:** 12 **Explanation:** There are 12 possible way to paint the grid as shown. ``` **Example 2:** ``` **Input:** n = 5000 **Output:** 30228214 ``` **Constraints:** `n == grid.length` `1 <= n <= 5000`",
        "test_case": [
            {
                "label": "Example 1",
                "input": "n = 1",
                "output": "12 Explanation: There are 12 possible way to paint the grid as shown."
            },
            {
                "label": "Example 2",
                "input": "n = 5000",
                "output": "30228214 Constraints: n == grid.length 1 <= n <= 5000"
            }
        ],
        "elixir_template": "defmodule Solution do\n  @spec num_of_ways(n :: integer) :: integer\n  def num_of_ways(n) do\n    \n  end\nend",
        "erlang_template": "-spec num_of_ways(N :: integer()) -> integer().\nnum_of_ways(N) ->\n  .",
        "scala_template": "object Solution {\n    def numOfWays(n: Int): Int = {\n        \n    }\n}"
    },
    {
        "id": 1526,
        "name": "html-entity-parser",
        "difficulty": "Medium",
        "link": "https://leetcode.com/problems/html-entity-parser/",
        "task_description": "**HTML entity parser** is the parser that takes HTML code as input and replace all the entities of the special characters by the characters itself. The special characters and their entities for HTML are: **Quotation Mark:** the entity is `&quot;` and symbol character is `\"`. **Single Quote Mark:** the entity is `&apos;` and symbol character is `'`. **Ampersand:** the entity is `&amp;` and symbol character is `&`. **Greater Than Sign:** the entity is `&gt;` and symbol character is `>`. **Less Than Sign:** the entity is `&lt;` and symbol character is `<`. **Slash:** the entity is `&frasl;` and symbol character is `/`. Given the input `text` string to the HTML parser, you have to implement the entity parser. Return _the text after replacing the entities by the special characters_. **Example 1:** ``` **Input:** text = \"&amp; is an HTML entity but &ambassador; is not.\" **Output:** \"& is an HTML entity but &ambassador; is not.\" **Explanation:** The parser will replace the &amp; entity by & ``` **Example 2:** ``` **Input:** text = \"and I quote: &quot;...&quot;\" **Output:** \"and I quote: \\\"...\\\"\" ``` **Constraints:** `1 <= text.length <= 105` The string may contain any possible characters out of all the 256 ASCII characters.",
        "test_case": [
            {
                "label": "Example 1",
                "input": "text = \"&amp; is an HTML entity but &ambassador; is not.\"",
                "output": "\"& is an HTML entity but &ambassador; is not.\" Explanation: The parser will replace the &amp; entity by &"
            },
            {
                "label": "Example 2",
                "input": "text = \"and I quote: &quot;...&quot;\"",
                "output": "\"and I quote: \\\"...\\\"\""
            }
        ],
        "elixir_template": "defmodule Solution do\n  @spec entity_parser(text :: String.t) :: String.t\n  def entity_parser(text) do\n    \n  end\nend",
        "erlang_template": "-spec entity_parser(Text :: unicode:unicode_binary()) -> unicode:unicode_binary().\nentity_parser(Text) ->\n  .",
        "scala_template": "object Solution {\n    def entityParser(text: String): String = {\n        \n    }\n}"
    },
    {
        "id": 1525,
        "name": "queries-on-a-permutation-with-key",
        "difficulty": "Medium",
        "link": "https://leetcode.com/problems/queries-on-a-permutation-with-key/",
        "task_description": "Given the array `queries` of positive integers between `1` and `m`, you have to process all `queries[i]` (from `i=0` to `i=queries.length-1`) according to the following rules: In the beginning, you have the permutation `P=[1,2,3,...,m]`. For the current `i`, find the position of `queries[i]` in the permutation `P` (**indexing from 0**) and then move this at the beginning of the permutation `P`. Notice that the position of `queries[i]` in `P` is the result for `queries[i]`. Return an array containing the result for the given `queries`. **Example 1:** ``` **Input:** queries = [3,1,2,1], m = 5 **Output:** [2,1,2,1] **Explanation:** The queries are processed as follow: For i=0: queries[i]=3, P=[1,2,3,4,5], position of 3 in P is **2**, then we move 3 to the beginning of P resulting in P=[3,1,2,4,5]. For i=1: queries[i]=1, P=[3,1,2,4,5], position of 1 in P is **1**, then we move 1 to the beginning of P resulting in P=[1,3,2,4,5]. For i=2: queries[i]=2, P=[1,3,2,4,5], position of 2 in P is **2**, then we move 2 to the beginning of P resulting in P=[2,1,3,4,5]. For i=3: queries[i]=1, P=[2,1,3,4,5], position of 1 in P is **1**, then we move 1 to the beginning of P resulting in P=[1,2,3,4,5]. Therefore, the array containing the result is [2,1,2,1]. ``` **Example 2:** ``` **Input:** queries = [4,1,2,2], m = 4 **Output:** [3,1,2,0] ``` **Example 3:** ``` **Input:** queries = [7,5,5,8,3], m = 8 **Output:** [6,5,0,7,5] ``` **Constraints:** `1 <= m <= 10^3` `1 <= queries.length <= m` `1 <= queries[i] <= m`",
        "test_case": [
            {
                "label": "Example 1",
                "input": "queries = [3,1,2,1], m = 5",
                "output": "[2,1,2,1] Explanation: The queries are processed as follow: \nFor i=0: queries[i]=3, P=[1,2,3,4,5], position of 3 in P is 2 , then we move 3 to the beginning of P resulting in P=[3,1,2,4,5]. \nFor i=1: queries[i]=1, P=[3,1,2,4,5], position of 1 in P is 1 , then we move 1 to the beginning of P resulting in P=[1,3,2,4,5]. \nFor i=2: queries[i]=2, P=[1,3,2,4,5], position of 2 in P is 2 , then we move 2 to the beginning of P resulting in P=[2,1,3,4,5]. \nFor i=3: queries[i]=1, P=[2,1,3,4,5], position of 1 in P is 1 , then we move 1 to the beginning of P resulting in P=[1,2,3,4,5]. \nTherefore, the array containing the result is [2,1,2,1]."
            },
            {
                "label": "Example 2",
                "input": "queries = [4,1,2,2], m = 4",
                "output": "[3,1,2,0]"
            },
            {
                "label": "Example 3",
                "input": "queries = [7,5,5,8,3], m = 8",
                "output": "[6,5,0,7,5]"
            }
        ],
        "elixir_template": "defmodule Solution do\n  @spec process_queries(queries :: [integer], m :: integer) :: [integer]\n  def process_queries(queries, m) do\n    \n  end\nend",
        "erlang_template": "-spec process_queries(Queries :: [integer()], M :: integer()) -> [integer()].\nprocess_queries(Queries, M) ->\n  .",
        "scala_template": "object Solution {\n    def processQueries(queries: Array[Int], m: Int): Array[Int] = {\n        \n    }\n}"
    },
    {
        "id": 1524,
        "name": "string-matching-in-an-array",
        "difficulty": "Easy",
        "link": "https://leetcode.com/problems/string-matching-in-an-array/",
        "task_description": "Given an array of string `words`, return _all strings in _`words`_ that is a **substring** of another word_. You can return the answer in **any order**. A **substring** is a contiguous sequence of characters within a string **Example 1:** ``` **Input:** words = [\"mass\",\"as\",\"hero\",\"superhero\"] **Output:** [\"as\",\"hero\"] **Explanation:** \"as\" is substring of \"mass\" and \"hero\" is substring of \"superhero\". [\"hero\",\"as\"] is also a valid answer. ``` **Example 2:** ``` **Input:** words = [\"leetcode\",\"et\",\"code\"] **Output:** [\"et\",\"code\"] **Explanation:** \"et\", \"code\" are substring of \"leetcode\". ``` **Example 3:** ``` **Input:** words = [\"blue\",\"green\",\"bu\"] **Output:** [] **Explanation:** No string of words is substring of another string. ``` **Constraints:** `1 <= words.length <= 100` `1 <= words[i].length <= 30` `words[i]` contains only lowercase English letters. All the strings of `words` are **unique**.",
        "test_case": [
            {
                "label": "Example 1",
                "input": "words = [\"mass\",\"as\",\"hero\",\"superhero\"]",
                "output": "[\"as\",\"hero\"] Explanation: \"as\" is substring of \"mass\" and \"hero\" is substring of \"superhero\".\n[\"hero\",\"as\"] is also a valid answer."
            },
            {
                "label": "Example 2",
                "input": "words = [\"leetcode\",\"et\",\"code\"]",
                "output": "[\"et\",\"code\"] Explanation: \"et\", \"code\" are substring of \"leetcode\"."
            },
            {
                "label": "Example 3",
                "input": "words = [\"blue\",\"green\",\"bu\"]",
                "output": "[] Explanation: No string of words is substring of another string."
            }
        ],
        "elixir_template": "defmodule Solution do\n  @spec string_matching(words :: [String.t]) :: [String.t]\n  def string_matching(words) do\n    \n  end\nend",
        "erlang_template": "-spec string_matching(Words :: [unicode:unicode_binary()]) -> [unicode:unicode_binary()].\nstring_matching(Words) ->\n  .",
        "scala_template": "object Solution {\n    def stringMatching(words: Array[String]): List[String] = {\n        \n    }\n}"
    },
    {
        "id": 1522,
        "name": "stone-game-iii",
        "difficulty": "Hard",
        "link": "https://leetcode.com/problems/stone-game-iii/",
        "task_description": "Alice and Bob continue their games with piles of stones. There are several stones **arranged in a row**, and each stone has an associated value which is an integer given in the array `stoneValue`. Alice and Bob take turns, with Alice starting first. On each player's turn, that player can take `1`, `2`, or `3` stones from the **first** remaining stones in the row. The score of each player is the sum of the values of the stones taken. The score of each player is `0` initially. The objective of the game is to end with the highest score, and the winner is the player with the highest score and there could be a tie. The game continues until all the stones have been taken. Assume Alice and Bob **play optimally**. Return `\"Alice\"`_ if Alice will win, _`\"Bob\"`_ if Bob will win, or _`\"Tie\"`_ if they will end the game with the same score_. **Example 1:** ``` **Input:** stoneValue = [1,2,3,7] **Output:** \"Bob\" **Explanation:** Alice will always lose. Her best move will be to take three piles and the score become 6. Now the score of Bob is 7 and Bob wins. ``` **Example 2:** ``` **Input:** stoneValue = [1,2,3,-9] **Output:** \"Alice\" **Explanation:** Alice must choose all the three piles at the first move to win and leave Bob with negative score. If Alice chooses one pile her score will be 1 and the next move Bob's score becomes 5. In the next move, Alice will take the pile with value = -9 and lose. If Alice chooses two piles her score will be 3 and the next move Bob's score becomes 3. In the next move, Alice will take the pile with value = -9 and also lose. Remember that both play optimally so here Alice will choose the scenario that makes her win. ``` **Example 3:** ``` **Input:** stoneValue = [1,2,3,6] **Output:** \"Tie\" **Explanation:** Alice cannot win this game. She can end the game in a draw if she decided to choose all the first three piles, otherwise she will lose. ``` **Constraints:** `1 <= stoneValue.length <= 5 * 104` `-1000 <= stoneValue[i] <= 1000`",
        "test_case": [
            {
                "label": "Example 1",
                "input": "stoneValue = [1,2,3,7]",
                "output": "\"Bob\" Explanation: Alice will always lose. Her best move will be to take three piles and the score become 6. Now the score of Bob is 7 and Bob wins."
            },
            {
                "label": "Example 2",
                "input": "stoneValue = [1,2,3,-9]",
                "output": "\"Alice\" Explanation: Alice must choose all the three piles at the first move to win and leave Bob with negative score.\nIf Alice chooses one pile her score will be 1 and the next move Bob's score becomes 5. In the next move, Alice will take the pile with value = -9 and lose.\nIf Alice chooses two piles her score will be 3 and the next move Bob's score becomes 3. In the next move, Alice will take the pile with value = -9 and also lose.\nRemember that both play optimally so here Alice will choose the scenario that makes her win."
            },
            {
                "label": "Example 3",
                "input": "stoneValue = [1,2,3,6]",
                "output": "\"Tie\" Explanation: Alice cannot win this game. She can end the game in a draw if she decided to choose all the first three piles, otherwise she will lose."
            }
        ],
        "elixir_template": "defmodule Solution do\n  @spec stone_game_iii(stone_value :: [integer]) :: String.t\n  def stone_game_iii(stone_value) do\n    \n  end\nend",
        "erlang_template": "-spec stone_game_iii(StoneValue :: [integer()]) -> unicode:unicode_binary().\nstone_game_iii(StoneValue) ->\n  .",
        "scala_template": "object Solution {\n    def stoneGameIII(stoneValue: Array[Int]): String = {\n        \n    }\n}"
    },
    {
        "id": 1520,
        "name": "number-of-steps-to-reduce-a-number-in-binary-representation-to-one",
        "difficulty": "Medium",
        "link": "https://leetcode.com/problems/number-of-steps-to-reduce-a-number-in-binary-representation-to-one/",
        "task_description": "Given the binary representation of an integer as a string `s`, return _the number of steps to reduce it to _`1`_ under the following rules_: If the current number is even, you have to divide it by `2`. If the current number is odd, you have to add `1` to it. It is guaranteed that you can always reach one for all test cases. **Example 1:** ``` **Input:** s = \"1101\" **Output:** 6 **Explanation:** \"1101\" corressponds to number 13 in their decimal representation. Step 1) 13 is odd, add 1 and obtain 14. Step 2) 14 is even, divide by 2 and obtain 7. Step 3) 7 is odd, add 1 and obtain 8. Step 4) 8 is even, divide by 2 and obtain 4. Step 5) 4 is even, divide by 2 and obtain 2. Step 6) 2 is even, divide by 2 and obtain 1. ``` **Example 2:** ``` **Input:** s = \"10\" **Output:** 1 **Explanation:** \"10\" corresponds to number 2 in their decimal representation. Step 1) 2 is even, divide by 2 and obtain 1. ``` **Example 3:** ``` **Input:** s = \"1\" **Output:** 0 ``` **Constraints:** `1 <= s.length <= 500` `s` consists of characters '0' or '1' `s[0] == '1'`",
        "test_case": [
            {
                "label": "Example 1",
                "input": "s = \"1101\"",
                "output": "6 Explanation: \"1101\" corressponds to number 13 in their decimal representation.\nStep 1) 13 is odd, add 1 and obtain 14.\u00a0\nStep 2) 14 is even, divide by 2 and obtain 7.\nStep 3) 7 is odd, add 1 and obtain 8.\nStep 4) 8 is even, divide by 2 and obtain 4.\u00a0 \nStep 5) 4 is even, divide by 2 and obtain 2.\u00a0\nStep 6) 2 is even, divide by 2 and obtain 1."
            },
            {
                "label": "Example 2",
                "input": "s = \"10\"",
                "output": "1 Explanation: \"10\" corresponds to number 2 in their decimal representation.\nStep 1) 2 is even, divide by 2 and obtain 1."
            },
            {
                "label": "Example 3",
                "input": "s = \"1\"",
                "output": "0"
            }
        ],
        "elixir_template": "defmodule Solution do\n  @spec num_steps(s :: String.t) :: integer\n  def num_steps(s) do\n    \n  end\nend",
        "erlang_template": "-spec num_steps(S :: unicode:unicode_binary()) -> integer().\nnum_steps(S) ->\n  .",
        "scala_template": "object Solution {\n    def numSteps(s: String): Int = {\n        \n    }\n}"
    },
    {
        "id": 1519,
        "name": "minimum-subsequence-in-non-increasing-order",
        "difficulty": "Easy",
        "link": "https://leetcode.com/problems/minimum-subsequence-in-non-increasing-order/",
        "task_description": "Given the array `nums`, obtain a subsequence of the array whose sum of elements is **strictly greater** than the sum of the non included elements in such subsequence. If there are multiple solutions, return the subsequence with **minimum size** and if there still exist multiple solutions, return the subsequence with the **maximum total sum** of all its elements. A subsequence of an array can be obtained by erasing some (possibly zero) elements from the array. Note that the solution with the given constraints is guaranteed to be **unique**. Also return the answer sorted in **non-increasing** order. **Example 1:** ``` **Input:** nums = [4,3,10,9,8] **Output:** [10,9] **Explanation:** The subsequences [10,9] and [10,8] are minimal such that the sum of their elements is strictly greater than the sum of elements not included. However, the subsequence [10,9] has the maximum total sum of its elements. ``` **Example 2:** ``` **Input:** nums = [4,4,7,6,7] **Output:** [7,7,6] **Explanation:** The subsequence [7,7] has the sum of its elements equal to 14 which is not strictly greater than the sum of elements not included (14 = 4 + 4 + 6). Therefore, the subsequence [7,6,7] is the minimal satisfying the conditions. Note the subsequence has to be returned in non-increasing order. ``` **Constraints:** `1 <= nums.length <= 500` `1 <= nums[i] <= 100`",
        "test_case": [
            {
                "label": "Example 1",
                "input": "nums = [4,3,10,9,8]",
                "output": "[10,9] Explanation: The subsequences [10,9] and [10,8] are minimal such that the sum of their elements is strictly greater than the sum of elements not included. However, the subsequence [10,9] has the maximum total sum of its elements."
            },
            {
                "label": "Example 2",
                "input": "nums = [4,4,7,6,7]",
                "output": "[7,7,6] Explanation: The subsequence [7,7] has the sum of its elements equal to 14 which is not strictly greater than the sum of elements not included (14 = 4 + 4 + 6). Therefore, the subsequence [7,6,7] is the minimal satisfying the conditions. Note the subsequence has to be returned in non-increasing order."
            }
        ],
        "elixir_template": "defmodule Solution do\n  @spec min_subsequence(nums :: [integer]) :: [integer]\n  def min_subsequence(nums) do\n    \n  end\nend",
        "erlang_template": "-spec min_subsequence(Nums :: [integer()]) -> [integer()].\nmin_subsequence(Nums) ->\n  .",
        "scala_template": "object Solution {\n    def minSubsequence(nums: Array[Int]): List[Int] = {\n        \n    }\n}"
    },
    {
        "id": 1517,
        "name": "restore-the-array",
        "difficulty": "Hard",
        "link": "https://leetcode.com/problems/restore-the-array/",
        "task_description": "A program was supposed to print an array of integers. The program forgot to print whitespaces and the array is printed as a string of digits `s` and all we know is that all integers in the array were in the range `[1, k]` and there are no leading zeros in the array. Given the string `s` and the integer `k`, return _the number of the possible arrays that can be printed as _`s`_ using the mentioned program_. Since the answer may be very large, return it **modulo** `109 + 7`. **Example 1:** ``` **Input:** s = \"1000\", k = 10000 **Output:** 1 **Explanation:** The only possible array is [1000] ``` **Example 2:** ``` **Input:** s = \"1000\", k = 10 **Output:** 0 **Explanation:** There cannot be an array that was printed this way and has all integer >= 1 and <= 10. ``` **Example 3:** ``` **Input:** s = \"1317\", k = 2000 **Output:** 8 **Explanation:** Possible arrays are [1317],[131,7],[13,17],[1,317],[13,1,7],[1,31,7],[1,3,17],[1,3,1,7] ``` **Constraints:** `1 <= s.length <= 105` `s` consists of only digits and does not contain leading zeros. `1 <= k <= 109`",
        "test_case": [
            {
                "label": "Example 1",
                "input": "s = \"1000\", k = 10000",
                "output": "1 Explanation: The only possible array is [1000]"
            },
            {
                "label": "Example 2",
                "input": "s = \"1000\", k = 10",
                "output": "0 Explanation: There cannot be an array that was printed this way and has all integer >= 1 and <= 10."
            },
            {
                "label": "Example 3",
                "input": "s = \"1317\", k = 2000",
                "output": "8 Explanation: Possible arrays are [1317],[131,7],[13,17],[1,317],[13,1,7],[1,31,7],[1,3,17],[1,3,1,7]"
            }
        ],
        "elixir_template": "defmodule Solution do\n  @spec number_of_arrays(s :: String.t, k :: integer) :: integer\n  def number_of_arrays(s, k) do\n    \n  end\nend",
        "erlang_template": "-spec number_of_arrays(S :: unicode:unicode_binary(), K :: integer()) -> integer().\nnumber_of_arrays(S, K) ->\n  .",
        "scala_template": "object Solution {\n    def numberOfArrays(s: String, k: Int): Int = {\n        \n    }\n}"
    },
    {
        "id": 1516,
        "name": "the-k-th-lexicographical-string-of-all-happy-strings-of-length-n",
        "difficulty": "Medium",
        "link": "https://leetcode.com/problems/the-k-th-lexicographical-string-of-all-happy-strings-of-length-n/",
        "task_description": "A **happy string** is a string that: consists only of letters of the set `['a', 'b', 'c']`. `s[i] != s[i + 1]` for all values of `i` from `1` to `s.length - 1` (string is 1-indexed). For example, strings **\"abc\", \"ac\", \"b\"** and **\"abcbabcbcb\"** are all happy strings and strings **\"aa\", \"baa\"** and **\"ababbc\"** are not happy strings. Given two integers `n` and `k`, consider a list of all happy strings of length `n` sorted in lexicographical order. Return _the kth string_ of this list or return an **empty string** if there are less than `k` happy strings of length `n`. **Example 1:** ``` **Input:** n = 1, k = 3 **Output:** \"c\" **Explanation:** The list [\"a\", \"b\", \"c\"] contains all happy strings of length 1. The third string is \"c\". ``` **Example 2:** ``` **Input:** n = 1, k = 4 **Output:** \"\" **Explanation:** There are only 3 happy strings of length 1. ``` **Example 3:** ``` **Input:** n = 3, k = 9 **Output:** \"cab\" **Explanation:** There are 12 different happy string of length 3 [\"aba\", \"abc\", \"aca\", \"acb\", \"bab\", \"bac\", \"bca\", \"bcb\", \"cab\", \"cac\", \"cba\", \"cbc\"]. You will find the 9th string = \"cab\" ``` **Constraints:** `1 <= n <= 10` `1 <= k <= 100`",
        "test_case": [
            {
                "label": "Example 1",
                "input": "n = 1, k = 3",
                "output": "\"c\" Explanation: The list [\"a\", \"b\", \"c\"] contains all happy strings of length 1. The third string is \"c\"."
            },
            {
                "label": "Example 2",
                "input": "n = 1, k = 4",
                "output": "\"\" Explanation: There are only 3 happy strings of length 1."
            },
            {
                "label": "Example 3",
                "input": "n = 3, k = 9",
                "output": "\"cab\" Explanation: There are 12 different happy string of length 3 [\"aba\", \"abc\", \"aca\", \"acb\", \"bab\", \"bac\", \"bca\", \"bcb\", \"cab\", \"cac\", \"cba\", \"cbc\"]. You will find the 9 th string = \"cab\""
            }
        ],
        "elixir_template": "defmodule Solution do\n  @spec get_happy_string(n :: integer, k :: integer) :: String.t\n  def get_happy_string(n, k) do\n    \n  end\nend",
        "erlang_template": "-spec get_happy_string(N :: integer(), K :: integer()) -> unicode:unicode_binary().\nget_happy_string(N, K) ->\n  .",
        "scala_template": "object Solution {\n    def getHappyString(n: Int, k: Int): String = {\n        \n    }\n}"
    },
    {
        "id": 1515,
        "name": "find-the-minimum-number-of-fibonacci-numbers-whose-sum-is-k",
        "difficulty": "Medium",
        "link": "https://leetcode.com/problems/find-the-minimum-number-of-fibonacci-numbers-whose-sum-is-k/",
        "task_description": "Given an integer `k`, _return the minimum number of Fibonacci numbers whose sum is equal to _`k`. The same Fibonacci number can be used multiple times. The Fibonacci numbers are defined as: `F1 = 1` `F2 = 1` `Fn = Fn-1 + Fn-2` for `n > 2.` It is guaranteed that for the given constraints we can always find such Fibonacci numbers that sum up to `k`. **Example 1:** ``` **Input:** k = 7 **Output:** 2 **Explanation:** The Fibonacci numbers are: 1, 1, 2, 3, 5, 8, 13, ... For k = 7 we can use 2 + 5 = 7. ``` **Example 2:** ``` **Input:** k = 10 **Output:** 2 **Explanation:** For k = 10 we can use 2 + 8 = 10. ``` **Example 3:** ``` **Input:** k = 19 **Output:** 3 **Explanation:** For k = 19 we can use 1 + 5 + 13 = 19. ``` **Constraints:** `1 <= k <= 109`",
        "test_case": [
            {
                "label": "Example 1",
                "input": "k = 7",
                "output": "2 Explanation: The Fibonacci numbers are: 1, 1, 2, 3, 5, 8, 13, ... \nFor k = 7 we can use 2 + 5 = 7."
            },
            {
                "label": "Example 2",
                "input": "k = 10",
                "output": "2 Explanation: For k = 10 we can use 2 + 8 = 10."
            },
            {
                "label": "Example 3",
                "input": "k = 19",
                "output": "3 Explanation: For k = 19 we can use 1 + 5 + 13 = 19."
            }
        ],
        "elixir_template": "defmodule Solution do\n  @spec find_min_fibonacci_numbers(k :: integer) :: integer\n  def find_min_fibonacci_numbers(k) do\n    \n  end\nend",
        "erlang_template": "-spec find_min_fibonacci_numbers(K :: integer()) -> integer().\nfind_min_fibonacci_numbers(K) ->\n  .",
        "scala_template": "object Solution {\n    def findMinFibonacciNumbers(k: Int): Int = {\n        \n    }\n}"
    },
    {
        "id": 1514,
        "name": "minimum-value-to-get-positive-step-by-step-sum",
        "difficulty": "Easy",
        "link": "https://leetcode.com/problems/minimum-value-to-get-positive-step-by-step-sum/",
        "task_description": "Given an array of integers `nums`, you start with an initial **positive** value _startValue__._ In each iteration, you calculate the step by step sum of _startValue_ plus elements in `nums` (from left to right). Return the minimum **positive** value of _startValue_ such that the step by step sum is never less than 1. **Example 1:** ``` **Input:** nums = [-3,2,-3,4,2] **Output:** 5 **Explanation: **If you choose startValue = 4, in the third iteration your step by step sum is less than 1. **step by step sum** **startValue = 4 | startValue = 5 | nums** (4 **-3** ) = 1 | (5 **-3** ) = 2 | -3 (1 **+2** ) = 3 | (2 **+2** ) = 4 | 2 (3 **-3** ) = 0 | (4 **-3** ) = 1 | -3 (0 **+4** ) = 4 | (1 **+4** ) = 5 | 4 (4 **+2** ) = 6 | (5 **+2** ) = 7 | 2 ``` **Example 2:** ``` **Input:** nums = [1,2] **Output:** 1 **Explanation:** Minimum start value should be positive. ``` **Example 3:** ``` **Input:** nums = [1,-2,-3] **Output:** 5 ``` **Constraints:** `1 <= nums.length <= 100` `-100 <= nums[i] <= 100`",
        "test_case": [
            {
                "label": "Example 1",
                "input": "nums = [-3,2,-3,4,2]",
                "output": "5 Explanation: If you choose startValue = 4, in the third iteration your step by step sum is less than 1. step by step sum startValue = 4 | startValue = 5 | nums (4 -3 ) = 1  | (5 -3 ) = 2    |  -3\n  (1 +2 ) = 3  | (2 +2 ) = 4    |   2\n  (3 -3 ) = 0  | (4 -3 ) = 1    |  -3\n  (0 +4 ) = 4  | (1 +4 ) = 5    |   4\n  (4 +2 ) = 6  | (5 +2 ) = 7    |   2"
            },
            {
                "label": "Example 2",
                "input": "nums = [1,2]",
                "output": "1 Explanation: Minimum start value should be positive."
            },
            {
                "label": "Example 3",
                "input": "nums = [1,-2,-3]",
                "output": "5"
            }
        ],
        "elixir_template": "defmodule Solution do\n  @spec min_start_value(nums :: [integer]) :: integer\n  def min_start_value(nums) do\n    \n  end\nend",
        "erlang_template": "-spec min_start_value(Nums :: [integer()]) -> integer().\nmin_start_value(Nums) ->\n  .",
        "scala_template": "object Solution {\n    def minStartValue(nums: Array[Int]): Int = {\n        \n    }\n}"
    },
    {
        "id": 1513,
        "name": "find-all-good-strings",
        "difficulty": "Hard",
        "link": "https://leetcode.com/problems/find-all-good-strings/",
        "task_description": "Given the strings `s1` and `s2` of size `n` and the string `evil`, return _the number of **good** strings_. A **good** string has size `n`, it is alphabetically greater than or equal to `s1`, it is alphabetically smaller than or equal to `s2`, and it does not contain the string `evil` as a substring. Since the answer can be a huge number, return this **modulo** `109 + 7`. **Example 1:** ``` **Input:** n = 2, s1 = \"aa\", s2 = \"da\", evil = \"b\" **Output:** 51 **Explanation:** There are 25 good strings starting with 'a': \"aa\",\"ac\",\"ad\",...,\"az\". Then there are 25 good strings starting with 'c': \"ca\",\"cc\",\"cd\",...,\"cz\" and finally there is one good string starting with 'd': \"da\". ``` **Example 2:** ``` **Input:** n = 8, s1 = \"leetcode\", s2 = \"leetgoes\", evil = \"leet\" **Output:** 0 **Explanation:** All strings greater than or equal to s1 and smaller than or equal to s2 start with the prefix \"leet\", therefore, there is not any good string. ``` **Example 3:** ``` **Input:** n = 2, s1 = \"gx\", s2 = \"gz\", evil = \"x\" **Output:** 2 ``` **Constraints:** `s1.length == n` `s2.length == n` `s1 <= s2` `1 <= n <= 500` `1 <= evil.length <= 50` All strings consist of lowercase English letters.",
        "test_case": [
            {
                "label": "Example 1",
                "input": "n = 2, s1 = \"aa\", s2 = \"da\", evil = \"b\"",
                "output": "51 Explanation: There are 25 good strings starting with 'a': \"aa\",\"ac\",\"ad\",...,\"az\". Then there are 25 good strings starting with 'c': \"ca\",\"cc\",\"cd\",...,\"cz\" and finally there is one good string starting with 'd': \"da\"."
            },
            {
                "label": "Example 2",
                "input": "n = 8, s1 = \"leetcode\", s2 = \"leetgoes\", evil = \"leet\"",
                "output": "0 Explanation: All strings greater than or equal to s1 and smaller than or equal to s2 start with the prefix \"leet\", therefore, there is not any good string."
            },
            {
                "label": "Example 3",
                "input": "n = 2, s1 = \"gx\", s2 = \"gz\", evil = \"x\"",
                "output": "2 Constraints: s1.length == n s2.length == n s1 <= s2 1 <= n <= 500 1 <= evil.length <= 50 All strings consist of lowercase English letters."
            }
        ],
        "elixir_template": "defmodule Solution do\n  @spec find_good_strings(n :: integer, s1 :: String.t, s2 :: String.t, evil :: String.t) :: integer\n  def find_good_strings(n, s1, s2, evil) do\n    \n  end\nend",
        "erlang_template": "-spec find_good_strings(N :: integer(), S1 :: unicode:unicode_binary(), S2 :: unicode:unicode_binary(), Evil :: unicode:unicode_binary()) -> integer().\nfind_good_strings(N, S1, S2, Evil) ->\n  .",
        "scala_template": "object Solution {\n    def findGoodStrings(n: Int, s1: String, s2: String, evil: String): Int = {\n        \n    }\n}"
    },
    {
        "id": 1512,
        "name": "design-underground-system",
        "difficulty": "Medium",
        "link": "https://leetcode.com/problems/design-underground-system/",
        "task_description": "An underground railway system is keeping track of customer travel times between different stations. They are using this data to calculate the average time it takes to travel from one station to another. Implement the `UndergroundSystem` class: `void checkIn(int id, string stationName, int t)` A customer with a card ID equal to `id`, checks in at the station `stationName` at time `t`. A customer can only be checked into one place at a time. `void checkOut(int id, string stationName, int t)` A customer with a card ID equal to `id`, checks out from the station `stationName` at time `t`. `double getAverageTime(string startStation, string endStation)` Returns the average time it takes to travel from `startStation` to `endStation`. The average time is computed from all the previous traveling times from `startStation` to `endStation` that happened **directly**, meaning a check in at `startStation` followed by a check out from `endStation`. The time it takes to travel from `startStation` to `endStation` **may be different** from the time it takes to travel from `endStation` to `startStation`. There will be at least one customer that has traveled from `startStation` to `endStation` before `getAverageTime` is called. You may assume all calls to the `checkIn` and `checkOut` methods are consistent. If a customer checks in at time `t1` then checks out at time `t2`, then `t1 < t2`. All events happen in chronological order. **Example 1:** ``` **Input** [\"UndergroundSystem\",\"checkIn\",\"checkIn\",\"checkIn\",\"checkOut\",\"checkOut\",\"checkOut\",\"getAverageTime\",\"getAverageTime\",\"checkIn\",\"getAverageTime\",\"checkOut\",\"getAverageTime\"] [[],[45,\"Leyton\",3],[32,\"Paradise\",8],[27,\"Leyton\",10],[45,\"Waterloo\",15],[27,\"Waterloo\",20],[32,\"Cambridge\",22],[\"Paradise\",\"Cambridge\"],[\"Leyton\",\"Waterloo\"],[10,\"Leyton\",24],[\"Leyton\",\"Waterloo\"],[10,\"Waterloo\",38],[\"Leyton\",\"Waterloo\"]] **Output** [null,null,null,null,null,null,null,14.00000,11.00000,null,11.00000,null,12.00000] **Explanation** UndergroundSystem undergroundSystem = new UndergroundSystem(); undergroundSystem.checkIn(45, \"Leyton\", 3); undergroundSystem.checkIn(32, \"Paradise\", 8); undergroundSystem.checkIn(27, \"Leyton\", 10); undergroundSystem.checkOut(45, \"Waterloo\", 15); // Customer 45 \"Leyton\" -> \"Waterloo\" in 15-3 = 12 undergroundSystem.checkOut(27, \"Waterloo\", 20); // Customer 27 \"Leyton\" -> \"Waterloo\" in 20-10 = 10 undergroundSystem.checkOut(32, \"Cambridge\", 22); // Customer 32 \"Paradise\" -> \"Cambridge\" in 22-8 = 14 undergroundSystem.getAverageTime(\"Paradise\", \"Cambridge\"); // return 14.00000. One trip \"Paradise\" -> \"Cambridge\", (14) / 1 = 14 undergroundSystem.getAverageTime(\"Leyton\", \"Waterloo\"); // return 11.00000. Two trips \"Leyton\" -> \"Waterloo\", (10 + 12) / 2 = 11 undergroundSystem.checkIn(10, \"Leyton\", 24); undergroundSystem.getAverageTime(\"Leyton\", \"Waterloo\"); // return 11.00000 undergroundSystem.checkOut(10, \"Waterloo\", 38); // Customer 10 \"Leyton\" -> \"Waterloo\" in 38-24 = 14 undergroundSystem.getAverageTime(\"Leyton\", \"Waterloo\"); // return 12.00000. Three trips \"Leyton\" -> \"Waterloo\", (10 + 12 + 14) / 3 = 12 ``` **Example 2:** ``` **Input** [\"UndergroundSystem\",\"checkIn\",\"checkOut\",\"getAverageTime\",\"checkIn\",\"checkOut\",\"getAverageTime\",\"checkIn\",\"checkOut\",\"getAverageTime\"] [[],[10,\"Leyton\",3],[10,\"Paradise\",8],[\"Leyton\",\"Paradise\"],[5,\"Leyton\",10],[5,\"Paradise\",16],[\"Leyton\",\"Paradise\"],[2,\"Leyton\",21],[2,\"Paradise\",30],[\"Leyton\",\"Paradise\"]] **Output** [null,null,null,5.00000,null,null,5.50000,null,null,6.66667] **Explanation** UndergroundSystem undergroundSystem = new UndergroundSystem(); undergroundSystem.checkIn(10, \"Leyton\", 3); undergroundSystem.checkOut(10, \"Paradise\", 8); // Customer 10 \"Leyton\" -> \"Paradise\" in 8-3 = 5 undergroundSystem.getAverageTime(\"Leyton\", \"Paradise\"); // return 5.00000, (5) / 1 = 5 undergroundSystem.checkIn(5, \"Leyton\", 10); undergroundSystem.checkOut(5, \"Paradise\", 16); // Customer 5 \"Leyton\" -> \"Paradise\" in 16-10 = 6 undergroundSystem.getAverageTime(\"Leyton\", \"Paradise\"); // return 5.50000, (5 + 6) / 2 = 5.5 undergroundSystem.checkIn(2, \"Leyton\", 21); undergroundSystem.checkOut(2, \"Paradise\", 30); // Customer 2 \"Leyton\" -> \"Paradise\" in 30-21 = 9 undergroundSystem.getAverageTime(\"Leyton\", \"Paradise\"); // return 6.66667, (5 + 6 + 9) / 3 = 6.66667 ``` **Constraints:** `1 <= id, t <= 106` `1 <= stationName.length, startStation.length, endStation.length <= 10` All strings consist of uppercase and lowercase English letters and digits. There will be at most `2 * 104` calls **in total** to `checkIn`, `checkOut`, and `getAverageTime`. Answers within `10-5` of the actual value will be accepted.",
        "test_case": [],
        "elixir_template": "defmodule UndergroundSystem do\n  @spec init_() :: any\n  def init_() do\n    \n  end\n\n  @spec check_in(id :: integer, station_name :: String.t, t :: integer) :: any\n  def check_in(id, station_name, t) do\n    \n  end\n\n  @spec check_out(id :: integer, station_name :: String.t, t :: integer) :: any\n  def check_out(id, station_name, t) do\n    \n  end\n\n  @spec get_average_time(start_station :: String.t, end_station :: String.t) :: float\n  def get_average_time(start_station, end_station) do\n    \n  end\nend\n\n# Your functions will be called as such:\n# UndergroundSystem.init_()\n# UndergroundSystem.check_in(id, station_name, t)\n# UndergroundSystem.check_out(id, station_name, t)\n# param_3 = UndergroundSystem.get_average_time(start_station, end_station)\n\n# UndergroundSystem.init_ will be called before every test case, in which you can do some necessary initializations.",
        "erlang_template": "-spec underground_system_init_() -> any().\nunderground_system_init_() ->\n  .\n\n-spec underground_system_check_in(Id :: integer(), StationName :: unicode:unicode_binary(), T :: integer()) -> any().\nunderground_system_check_in(Id, StationName, T) ->\n  .\n\n-spec underground_system_check_out(Id :: integer(), StationName :: unicode:unicode_binary(), T :: integer()) -> any().\nunderground_system_check_out(Id, StationName, T) ->\n  .\n\n-spec underground_system_get_average_time(StartStation :: unicode:unicode_binary(), EndStation :: unicode:unicode_binary()) -> float().\nunderground_system_get_average_time(StartStation, EndStation) ->\n  .\n\n\n%% Your functions will be called as such:\n%% underground_system_init_(),\n%% underground_system_check_in(Id, StationName, T),\n%% underground_system_check_out(Id, StationName, T),\n%% Param_3 = underground_system_get_average_time(StartStation, EndStation),\n\n%% underground_system_init_ will be called before every test case, in which you can do some necessary initializations.",
        "scala_template": "class UndergroundSystem() {\n\n    def checkIn(id: Int, stationName: String, t: Int): Unit = {\n        \n    }\n\n    def checkOut(id: Int, stationName: String, t: Int): Unit = {\n        \n    }\n\n    def getAverageTime(startStation: String, endStation: String): Double = {\n        \n    }\n\n}\n\n/**\n * Your UndergroundSystem object will be instantiated and called as such:\n * val obj = new UndergroundSystem()\n * obj.checkIn(id,stationName,t)\n * obj.checkOut(id,stationName,t)\n * val param_3 = obj.getAverageTime(startStation,endStation)\n */"
    }
]
